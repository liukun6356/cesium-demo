/*!
 * 云端地球平台
 * 版本信息：v2.2.2, hash值: c7447cb82a12dea981e8
 * 编译日期：2023-4-24 14:41:53
 * 版权所有：Copyright by 大势智慧 https://www.daspatial.com
 *
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("cesium/Cesium"), require("@turf/turf"));
	else if(typeof define === 'function' && define.amd)
		define(["cesium/Cesium", "@turf/turf"], factory);
	else if(typeof exports === 'object')
		exports["das3d"] = factory(require("cesium/Cesium"), require("@turf/turf"));
	else
		root["das3d"] = factory(root["Cesium"], root["turf"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__33__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 92);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DasClass = exports.DasClass = function () {
  //========== 构造方法 ==========
  function DasClass(options) {
    _classCallCheck(this, DasClass);

    // this.options = options;

    // 别名,但不建议使用。
    this.addEventListener = this.on;
    this.removeEventListener = this.clearAllEventListeners = this.off;
    this.addOneTimeEventListener = this.once;
    this.fireEvent = this.fire;
    this.hasEventListeners = this.listens;
  }

  _createClass(DasClass, [{
    key: "destroy",
    value: function destroy() {
      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }

    //========== 方法 ==========

  }, {
    key: "hasEvent",
    value: function hasEvent(type) {
      if (!this._events) {
        return false;
      }

      if (this._events[type]) return true;else return false;
    }
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */

  }, {
    key: "on",
    value: function on(types, fn, context) {
      // types can be a map of types/handlers
      if (isArray(types)) {
        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      } else if (isObject(types)) {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var _i = 0, _len = types.length; _i < _len; _i++) {
          this._on(types[_i], fn, context);
        }
      }

      return this;
    }

    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object.
     */

  }, {
    key: "off",
    value: function off(types, fn, context) {
      if (!types) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (isArray(types)) {
        for (var i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      } else if (isObject(types)) {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (var _i2 = 0, _len2 = types.length; _i2 < _len2; _i2++) {
          this._off(types[_i2], fn, context);
        }
      }

      return this;
    }

    // attach listener (without syntactic sugar now)

  }, {
    key: "_on",
    value: function _on(type, fn, context) {
      this._events = this._events || {};

      /* get/init listeners for type */
      var typeListeners = this._events[type];
      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }
      var newListener = { fn: fn, ctx: context },
          listeners = typeListeners;

      // check if fn already there
      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return;
        }
      }

      listeners.push(newListener);
    }
  }, {
    key: "_off",
    value: function _off(type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];

      if (!listeners) {
        return;
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        }
        // clear all listeners for a type if function isn't specified
        delete this._events[type];
        return;
      }

      if (context === this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];
          if (l.ctx !== context) {
            continue;
          }
          if (l.fn === fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(i, 1);

            return;
          }
        }
      }
    }

    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide an data
    // object — the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.

  }, {
    key: "fire",
    value: function fire(type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });

      if (this._events) {
        var listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;
          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    }

    // @method listens(type: String): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.

  }, {
    key: "listens",
    value: function listens(type, propagate) {
      var listeners = this._events && this._events[type];
      if (listeners && listeners.length) {
        return true;
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true;
          }
        }
      }
      return false;
    }

    // @method once(…): this
    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.

  }, {
    key: "once",
    value: function once(types, fn, context) {
      if (isObject(types)) {
        for (var type in types) {
          this.once(type, types[type], fn);
        }
        return this;
      }

      var handler = bind(function () {
        this.off(types, fn, context).off(types, handler, context);
      }, this);

      // add a listener that's executed once and removed after that
      return this.on(types, fn, context).on(types, handler, context);
    }

    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events

  }, {
    key: "addEventParent",
    value: function addEventParent(obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    }

    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events

  }, {
    key: "removeEventParent",
    value: function removeEventParent(obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }
      return this;
    }
  }, {
    key: "_propagateEvent",
    value: function _propagateEvent(e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  }]);

  return DasClass;
}();

//事件类型枚举[统一的定义，避免命名混乱]


var eventType = exports.eventType = {
  add: "add",
  remove: "remove", //移除对象
  delete: "delete", //删除对象
  update: "update",

  start: "start",
  change: "change",
  endItem: "endItem", //多个数据异步分析时，完成其中一个时的回调事件
  end: "end",
  stop: "stop",

  loadBefore: "loadBefore", //加载完成 未做任何其他处理前
  load: "load", //加载完成，执行所有内部处理后
  error: "error",

  click: "click",
  clickMap: "clickMap", //单击地图空白（未单击到矢量或模型数据）时
  mouseMove: "mouseMove",
  mouseOver: "mouseOver", //鼠标移入
  mouseOut: "mouseOut", //鼠标移出
  rightClick: "rightClick",
  dblClick: "dblClick",

  //标绘事件
  drawStart: "draw-start", //开始绘制
  drawMouseMove: "draw-mouse-move", //正在移动鼠标中，绘制过程中鼠标移动了点
  drawAddPoint: "draw-add-point", //绘制过程中增加了点
  drawRemovePoint: "draw-remove-lastpoint", //绘制过程中删除了last点
  drawCreated: "draw-created", //创建完成
  editStart: "edit-start", //开始编辑
  editMouseDown: "edit-mouse-movestart", //移动鼠标按下左键					  LEFT_DOWN
  editMouseMove: "edit-mouse-move", //正在移动鼠标中，正在编辑拖拽修改点中	MOUSE_MOVE
  editMovePoint: "edit-move-point", //编辑修改了点 						  LEFT_UP
  editRemovePoint: "edit-remove-point", //编辑删除了点
  editStyle: "edit-style", //图上编辑修改了相关style属性
  editStop: "edit-stop", //停止编辑

  //3dtiles模型
  initialTilesLoaded: "initialTilesLoaded",
  allTilesLoaded: "allTilesLoaded",

  //瓦片底图
  loadTileStart: "loadTileStart",
  loadTileEnd: "loadTileEnd",
  loadTileError: "loadTileError",

  //widget
  beforeCreate: "beforeCreate", //在实例初始化之后、创建之前执行
  created: "created", //实例创建后执行
  beforeActivate: "beforeActivate", //在activat挂载开始之前调用
  activated: "activated", //activate方法调用后
  openView: "openView", //view弹窗构造完成后后调用
  beforeDisable: "beforeDisable", //实例销毁之前调用
  disabled: "disabled" //实例销毁完成调用
};

function extend(dest) {
  var i, j, len, src;

  for (j = 1, len = arguments.length; j < len; j++) {
    src = arguments[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}

function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
  if (!str) {
    // eslint-disable-next-line no-console
    console.error("传入了空event事件名称，请检查代码");
    return str;
  }
  return trim(str).split(/\s+/);
}

function falseFn() {
  return false;
}

function bind(fn, obj) {
  var slice = Array.prototype.slice;

  if (fn.bind) {
    return fn.bind.apply(fn, slice.call(arguments, 1));
  }

  var args = slice.call(arguments, 2);

  return function () {
    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  };
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
  obj._das3d_id = obj._das3d_id || ++lastId;
  return obj._das3d_id;
}

function isObject(obj) {
  return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object" && obj.constructor == Object;
}

var isArray = Array.isArray || function (obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aroundPoint = exports.windingPoint = undefined;
exports.formatNum = formatNum;
exports.formatPosition = formatPosition;
exports.getPositionValue = getPositionValue;
exports.formatRectangle = formatRectangle;
exports.getRectangle = getRectangle;
exports.getMaxHeight = getMaxHeight;
exports.addPositionsHeight = addPositionsHeight;
exports.setPositionsHeight = setPositionsHeight;
exports.getSurfaceHeight = getSurfaceHeight;
exports.getSurface3DTilesHeight = getSurface3DTilesHeight;
exports.getSurfaceTerrainHeight = getSurfaceTerrainHeight;
exports.setPositionSurfaceHeight = setPositionSurfaceHeight;
exports.getCurrentMousePosition = getCurrentMousePosition;
exports.getCenter = getCenter;
exports.pickCenterPoint = pickCenterPoint;
exports.getExtent = getExtent;
exports.getCameraView = getCameraView;
exports.centerOfMass = centerOfMass;
exports.isInPoly = isInPoly;
exports.getPositionByGeoJSON = getPositionByGeoJSON;
exports.sliceByMaxDistance = sliceByMaxDistance;
exports.BouncePosition = BouncePosition;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _index = __webpack_require__(22);

var drawAttr = _interopRequireWildcard(_index);

var _Attr = __webpack_require__(21);

var polygonAttr = _interopRequireWildcard(_Attr);

var _tileset = __webpack_require__(32);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util = __webpack_require__(3);

var _matrix = __webpack_require__(16);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _layer = __webpack_require__(24);

var _turf = __webpack_require__(33);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//格式化 数字 小数位数
function formatNum(num, digits) {
  return Number(Number(num).toFixed(digits || 0));
}

//格式化坐标点为可显示的可理解格式（如：经度x:123.345345、纬度y:31.324324、高度z:123.1）。
function formatPosition(position) {
  if (!position) return null;
  var carto = Cesium.Cartographic.fromCartesian(position);
  var result = {};
  result.x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
  result.y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
  result.z = formatNum(carto.height, 2);
  return result;
}

//获取position的最终value值，因为cesium经常属性或绑定一层，通过该方法可以内部去判断是否有getValue或_value进行取最终value值。
function getPositionValue(position, time) {
  if (!position) return position;

  var _position;
  if (position instanceof Cesium.Cartesian3) {
    _position = position;
  } else if (position._value && position._value instanceof Cesium.Cartesian3) {
    _position = position._value;
  } else if (typeof position.getValue == "function") {
    _position = position.getValue(time || (0, _util.currentTime)());
  }

  return _position;
}

//格式化Rectangle
function formatRectangle(rectangle) {
  var west = formatNum(Cesium.Math.toDegrees(rectangle.west), 6);
  var east = formatNum(Cesium.Math.toDegrees(rectangle.east), 6);
  var north = formatNum(Cesium.Math.toDegrees(rectangle.north), 6);
  var south = formatNum(Cesium.Math.toDegrees(rectangle.south), 6);

  return {
    xmin: west,
    xmax: east,
    ymin: south,
    ymax: north
  };
}

//获取坐标的边界
function getRectangle(positions, isFormat) {
  //剔除null值的数据
  for (var i = positions.length - 1; i >= 0; i--) {
    if (!Cesium.defined(positions[i])) {
      positions.splice(i, 1);
    }
  }

  var rectangle = Cesium.Rectangle.fromCartesianArray(positions);
  if (isFormat) return formatRectangle(rectangle);else return rectangle;
}

/**
 * 获取坐标数组中最高高程值
 * @param {Array} positions Array<Cartesian3> 笛卡尔坐标数组
 * @param {Number} defaultVal 默认高程值
 */
function getMaxHeight(positions, defaultVal) {
  if (defaultVal == null) defaultVal = 0;

  var maxHeight = defaultVal;
  if (positions == null || positions.length == 0) return maxHeight;

  for (var i = 0; i < positions.length; i++) {
    var tempCarto = Cesium.Cartographic.fromCartesian(positions[i]);
    if (tempCarto.height > maxHeight) {
      maxHeight = tempCarto.height;
    }
  }
  return formatNum(maxHeight, 2);
}

/**
 * 在坐标基础海拔上增加指定的海拔高度值
 * @param {Array} positions Cartesian3类型的数组
 * @param {Number} height 高度值
 * @return {Array} Cartesian3类型的数组
 */
function addPositionsHeight(positions, addHeight) {
  addHeight = Number(addHeight) || 0;

  if (isNaN(addHeight) || addHeight == 0) return positions;

  if (positions instanceof Array) {
    var arr = [];
    for (var i = 0, len = positions.length; i < len; i++) {
      var car = Cesium.Cartographic.fromCartesian(positions[i]);
      var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
      arr.push(point);
    }
    return arr;
  } else {
    var _car = Cesium.Cartographic.fromCartesian(positions);
    return Cesium.Cartesian3.fromRadians(_car.longitude, _car.latitude, _car.height + addHeight);
  }
}

/**
 * 设置坐标中海拔高度为指定的高度值
 * @param {Array} positions Cartesian3类型的数组
 * @param {Number} height 高度值
 * @return {Array} Cartesian3类型的数组
 */
function setPositionsHeight(positions, height) {
  height = Number(height) || 0;

  if (positions instanceof Array) {
    var arr = [];
    for (var i = 0, len = positions.length; i < len; i++) {
      var car = Cesium.Cartographic.fromCartesian(positions[i]);
      var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
      arr.push(point);
    }
    return arr;
  } else {
    var _car2 = Cesium.Cartographic.fromCartesian(positions);
    return Cesium.Cartesian3.fromRadians(_car2.longitude, _car2.latitude, height);
  }
}

/**
 * 获取坐标的贴地(或贴模型)高度
 * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法callback
 */
function getSurfaceHeight(scene, position, opts) {
  if (!position) return position;
  if (scene instanceof Cesium.Viewer)
    //兼容传入viewer
    scene = scene.scene;
  opts = opts || {};

  //是否在3ditiles上面
  var _has3dtiles = Cesium.defaultValue(opts.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(scene, position)));

  if (opts.inSurface) {
    // 淹没分析等应用场景中需要判断
    if (_has3dtiles) {
      //求贴模型的高度
      return getSurface3DTilesHeight(scene, position, opts);
    } else {
      //求贴地形高度
      return getSurfaceTerrainHeight(scene, position, opts);
    }
  } else {
    return getSurface3DTilesHeight(scene, position, opts);
  }
}

/**
 * 获取坐标的 贴模型高度
 * opts支持:   是否异步 asyn:true  异步回调方法callback返回“新高度”和“原始的Cartographic坐标”
 */
function getSurface3DTilesHeight(scene, position, opts) {
  opts = opts || {};

  //原始的Cartographic坐标
  opts.cartesian = opts.cartesian || Cesium.Cartographic.fromCartesian(position);
  var carto = opts.cartesian;
  var callback = opts.callback || opts.calback; //兼容不同参数名

  //是否异步求精确高度
  if (opts.asyn) {
    scene.clampToHeightMostDetailed([position], opts.objectsToExclude, 0.2).then(function (clampedPositions) {
      var clampedPt = clampedPositions[0];
      if (Cesium.defined(clampedPt)) {
        var cartiles = Cesium.Cartographic.fromCartesian(clampedPt);
        var heightTiles = cartiles.height;
        if (Cesium.defined(heightTiles) && heightTiles > -1000) {
          if (callback) callback(heightTiles, cartiles);
          return;
        }
      }
      //说明没在模型上，继续求地形上的高度
      getSurfaceTerrainHeight(scene, position, opts);
    });
  } else {
    //取贴模型高度
    var heightTiles = scene.sampleHeight(carto, opts.objectsToExclude, 0.2);
    if (Cesium.defined(heightTiles) && heightTiles > -1000) {
      if (callback) callback(heightTiles, carto);
      return heightTiles;
    }
  }

  return 0; //表示取值失败
}

/**
 * 获取坐标的 贴地高度
 * opts支持:   是否异步 asyn:true  异步回调方法callback
 */
function getSurfaceTerrainHeight(scene, position, opts) {
  opts = opts || {};

  //原始的Cartographic坐标
  var carto = opts.cartesian || Cesium.Cartographic.fromCartesian(position);
  var callback = opts.callback || opts.calback; //兼容不同参数名

  var _hasTerrain = (0, _layer.hasTerrain)(scene); //是否有地形
  if (!_hasTerrain) {
    //不存在地形，直接返回
    if (callback) callback(carto.height, carto);
    return carto.height;
  }

  //是否异步求精确高度
  if (opts.asyn) {
    Cesium.when(Cesium.sampleTerrainMostDetailed(scene.terrainProvider, [carto]), function (samples) {
      var clampedCart = samples[0];
      var heightTerrain;
      if (Cesium.defined(clampedCart) && Cesium.defined(clampedCart.height)) {
        heightTerrain = clampedCart.height;
      } else {
        heightTerrain = scene.globe.getHeight(carto);
      }
      if (callback) callback(heightTerrain, carto);
    });
  } else {
    var heightTerrain = scene.globe.getHeight(carto);
    if (Cesium.defined(heightTerrain) && heightTerrain > -1000) {
      if (callback) callback(heightTerrain, carto);
      return heightTerrain;
    }
  }
  return 0; //表示取值失败
}

/**
 * 设置坐标中海拔高度为贴地或贴模型的高度
 * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法callback
 */
function setPositionSurfaceHeight(scene, position, opts) {
  if (!position) return position;

  opts = opts || {};
  var carto = Cesium.Cartographic.fromCartesian(position);

  var height = getSurfaceHeight(scene, position, opts);
  if (height != 0 || Cesium.defined(opts.maxHeight) && height <= opts.maxHeight) {
    if (opts.relativeHeight) height += carto.height; //Cesium.HeightReference.RELATIVE_TO_GROUND时
    var positionNew = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
    return positionNew;
  }
  return position;
}

function hasPickedModel(pickedObject, noPickEntity) {
  if (Cesium.defined(pickedObject.id)) {
    //entity
    var entity = pickedObject.id;
    if (entity._noMousePosition) return entity; //排除标识不拾取的对象
    if (noPickEntity && entity == noPickEntity) return entity;
  }

  if (Cesium.defined(pickedObject.primitive)) {
    //primitive
    var primitive = pickedObject.primitive;
    if (primitive._noMousePosition) return primitive; //排除标识不拾取的对象
    if (noPickEntity && primitive == noPickEntity) return primitive;
  }

  if (Cesium.defined(pickedObject.tileset)) {
    //tileset
    var tileset = pickedObject.tileset;
    if (tileset._noMousePosition) return tileset; //排除标识不拾取的对象
    if (noPickEntity && tileset == noPickEntity) return tileset;
  }

  return null;
}

/**
 * 获取鼠标当前的屏幕坐标位置的三维Cesium坐标
 * @param {Cesium.Scene} scene
 * @param {Cesium.Cartesian2} position 二维屏幕坐标位置
 * @param {Cesium.Entity} noPickEntity 排除的对象（主要用于绘制中，排除对自己本身的拾取）
 */
function getCurrentMousePosition(scene, position, noPickEntity) {
  var cartesian;

  //在模型上提取坐标
  var pickedObject;
  try {
    pickedObject = scene.pick(position, 5, 5);
  } catch (e) {
    daslog.log("scene.pick 拾取时异常", e);
  }

  if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {
    //pickPositionSupported :判断是否支持深度拾取,不支持时无法进行鼠标交互绘制

    var pcEntity = hasPickedModel(pickedObject, noPickEntity);
    if (pcEntity) {
      if (pcEntity.show) {
        pcEntity.show = false; //先隐藏被排除的noPickEntity对象
        cartesian = getCurrentMousePosition(scene, position, noPickEntity);
        pcEntity.show = true; //还原被排除的noPickEntity对象
        if (cartesian) {
          return cartesian;
        } else {
          daslog.log("拾取到被排除的noPickEntity模型", noPickEntity);
        }
      } else {
        cartesian = scene.pickPosition(position);
        if (Cesium.defined(cartesian)) {
          var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
          if (cartographic.height >= 0) return cartesian;
          if (!Cesium.defined(pickedObject.id) && cartographic.height >= -500) return cartesian;
        }
      }
    } else {
      cartesian = scene.pickPosition(position);
      if (Cesium.defined(cartesian)) {
        var _cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        if (_cartographic.height >= 0) return cartesian;

        //不是entity时，支持3dtiles地下
        if (!Cesium.defined(pickedObject.id) && _cartographic.height >= -500) return cartesian;
        //daslog.log("scene.pickPosition 拾取模型时 高度值异常：" + cartographic.height);
      } else {
          //daslog.log("scene.pickPosition 拾取模型 返回为空");
        }
    }
  } else {}
    //daslog.log("scene.pick 拾取位置 返回为空");


    //超图s3m数据拾取
  if (Cesium.defined(Cesium.S3MTilesLayer)) {
    cartesian = scene.pickPosition(position);
    if (Cesium.defined(cartesian)) {
      return cartesian;
    }
  }

  //onlyPickModelPosition是在 ViewerEx 中定义的对外属性
  //通过 viewer.das.onlyPickModelPosition 进行修改
  if (scene.onlyPickModelPosition) return cartesian; //只取模型上的时候，不继续读取了

  //测试scene.pickPosition和globe.pick的适用场景 https://zhuanlan.zhihu.com/p/44767866
  //1. globe.pick的结果相对稳定准确，不论地形深度检测开启与否，不论加载的是默认地形还是别的地形数据；
  //2. scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。
  //注意点： 1. globe.pick只能求交地形； 2. scene.pickPosition不仅可以求交地形，还可以求交除地形以外其他所有写深度的物体。

  //提取鼠标点的地理坐标
  if (scene.mode === Cesium.SceneMode.SCENE3D) {
    //三维模式下
    var pickRay = scene.camera.getPickRay(position);
    cartesian = scene.globe.pick(pickRay, scene);
  } else {
    //二维模式下
    cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
  }

  if (Cesium.defined(cartesian) && scene.camera.positionCartographic.height < 10000) {
    var _cartographic2 = Cesium.Cartographic.fromCartesian(cartesian);
    // daslog.log(cartographic.height);
    if (_cartographic2.height < -5000) return null; //屏蔽无效值
  }

  return cartesian;
}

//提取屏幕中心点坐标
function getCenter(viewer, isToWgs) {
  var bestTarget = pickCenterPoint(viewer.scene);
  if (!Cesium.defined(bestTarget)) {
    bestTarget = setPositionSurfaceHeight(viewer, viewer.scene.camera.positionWC);
  }

  var result = formatPosition(bestTarget);
  if (isToWgs) result = viewer.das.point2wgs(result); //坐标转换为wgs

  // 获取地球中心点世界位置  与  摄像机的世界位置  之间的距离
  // var distance = Cesium.Cartesian3.distance(bestTarget, viewer.scene.camera.positionWC);
  // result.cameraZ = distance;

  return result;
}

//取屏幕中心点坐标
function pickCenterPoint(scene) {
  var canvas = scene.canvas;
  var center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);

  var ray = scene.camera.getPickRay(center);
  var target = scene.globe.pick(ray, scene);
  if (!target) target = scene.camera.pickEllipsoid(center);
  return target;
}

//提取地球视域边界
function getExtent(target, opts) {
  opts = opts || {};

  // 范围对象
  var extent = {
    xmin: 0,
    xmax: 0,
    ymin: 0,
    ymax: 0
  };

  if (target instanceof Cesium.Viewer) {
    // var rectangle = viewer.camera.computeViewRectangle(); //不支持二维模式
    // if (rectangle == null) return null;
    // var extent = formatRectangle(rectangle);  // 范围对象

    //默认值：中国区域
    extent = {
      xmin: 70,
      xmax: 140,
      ymin: 0,
      ymax: 55,
      height: 0
    };

    // 得到当前三维场景
    var viewer = target;
    var scene = viewer.scene;

    // 得到当前三维场景的椭球体
    var ellipsoid = scene.globe.ellipsoid;
    var canvas = scene.canvas;

    // canvas左上角
    var car3_lt = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), ellipsoid);
    if (car3_lt) {
      // 在椭球体上
      var carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
      extent.xmin = Cesium.Math.toDegrees(carto_lt.longitude);
      extent.ymax = Cesium.Math.toDegrees(carto_lt.latitude);
      extent.height = Math.max(extent.height, carto_lt.height);
    } else {
      // 不在椭球体上
      var xMax = canvas.width / 2;
      var yMax = canvas.height / 2;

      var car3_lt2;
      // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率
      for (var yIdx = 0; yIdx <= yMax; yIdx += 10) {
        var xIdx = yIdx <= xMax ? yIdx : xMax;
        car3_lt2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(xIdx, yIdx), ellipsoid);
        if (car3_lt2) break;
      }
      if (car3_lt2) {
        var _carto_lt = ellipsoid.cartesianToCartographic(car3_lt2);
        extent.xmin = Cesium.Math.toDegrees(_carto_lt.longitude);
        extent.ymax = Cesium.Math.toDegrees(_carto_lt.latitude);
        extent.height = Math.max(extent.height, _carto_lt.height);
      }
    }

    // canvas右下角
    var car3_rb = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), ellipsoid);
    if (car3_rb) {
      // 在椭球体上
      var carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
      extent.xmax = Cesium.Math.toDegrees(carto_rb.longitude);
      extent.ymin = Cesium.Math.toDegrees(carto_rb.latitude);
      extent.height = Math.max(extent.height, carto_rb.height);
    } else {
      // 不在椭球体上
      var _xMax = canvas.width / 2;
      var _yMax = canvas.height / 2;

      var car3_rb2;
      // 这里每次10像素递减，一是10像素相差不大，二是为了提高程序运行效率
      for (var _yIdx = canvas.height; _yIdx >= _yMax; _yIdx -= 10) {
        var _xIdx = _yIdx >= _xMax ? _yIdx : _xMax;
        car3_rb2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(_xIdx, _yIdx), ellipsoid);
        if (car3_rb2) break;
      }
      if (car3_rb2) {
        var _carto_rb = ellipsoid.cartesianToCartographic(car3_rb2);
        extent.xmax = Cesium.Math.toDegrees(_carto_rb.longitude);
        extent.ymin = Cesium.Math.toDegrees(_carto_rb.latitude);
        extent.height = Math.max(extent.height, _carto_rb.height);
      }
    }

    if (opts.isToWgs) {
      //坐标转换为wgs
      var pt1 = viewer.das.point2wgs({
        x: extent.xmin,
        y: extent.ymin
      });
      extent.xmin = pt1.x;
      extent.ymin = pt1.y;

      var pt2 = viewer.das.point2wgs({
        x: extent.xmax,
        y: extent.ymax
      });
      extent.xmax = pt2.x;
      extent.ymax = pt2.y;
    }
  } else if (target instanceof Cesium.Entity) {
    //传入Entity对象
    var positions = drawAttr.getPositions(target);
    extent = getRectangle(positions, true);
    extent.height = getMaxHeight(positions);
  } else if ((0, _util.isArray)(target)) {
    //传入Entity对象数组
    var _positions = [];
    for (var i = 0, len = target.length; i < len; i++) {
      var pts = drawAttr.getPositions(target[i]);
      _positions = _positions.concat(pts);
    }
    extent = getRectangle(_positions, true);
    extent.height = getMaxHeight(_positions);
  }

  //交换
  if (extent.xmax < extent.xmin) {
    var temp = extent.xmax;
    extent.xmax = extent.xmin;
    extent.xmin = temp;
  }
  if (extent.ymax < extent.ymin) {
    var _temp = extent.ymax;
    extent.ymax = extent.ymin;
    extent.ymin = _temp;
  }

  //缩放
  if (opts.scale) {
    var old_xmin = extent.xmin;
    var old_xmax = extent.xmax;
    var old_ymin = extent.ymin;
    var old_ymax = extent.ymax;

    //限定最大倍数
    if (opts.scale > 3) opts.scale = 3;
    if (opts.scale < -3) opts.scale = -3;

    var stepx = (extent.xmax - extent.xmin) * opts.scale;
    extent.xmin -= stepx;
    extent.xmax += stepx;
    var stepy = (extent.ymax - extent.ymin) * opts.scale;
    extent.ymin -= stepy;
    extent.ymax += stepy;

    //如果超出地球范围，还原放大的值
    if (extent.xmin < -180 || extent.xmax > 180 || extent.ymin < -90 || extent.ymax > 90) {
      extent.xmin = old_xmin;
      extent.xmax = old_xmax;
      extent.ymin = old_ymin;
      extent.ymax = old_ymax;
    }
  }

  //截取长度
  if (opts.formatNum) {
    extent.xmin = formatNum(extent.xmin, 6);
    extent.xmax = formatNum(extent.xmax, 6);
    extent.ymin = formatNum(extent.ymin, 6);
    extent.ymax = formatNum(extent.ymax, 6);
  }

  return extent;
}

//提取相机视角范围参数
function getCameraView(viewer, isToWgs) {
  var camera = viewer.camera;
  var position = camera.positionCartographic;

  var bookmark = {};
  bookmark.y = formatNum(Cesium.Math.toDegrees(position.latitude), 6);
  bookmark.x = formatNum(Cesium.Math.toDegrees(position.longitude), 6);
  bookmark.z = formatNum(position.height, 2);
  bookmark.heading = formatNum(Cesium.Math.toDegrees(camera.heading || 0) % 360, 1);
  bookmark.pitch = formatNum(Cesium.Math.toDegrees(camera.pitch || 0) % 360, 1);
  bookmark.roll = formatNum(Cesium.Math.toDegrees(camera.roll || 0) % 360, 1);

  if (isToWgs) bookmark = viewer.das.point2wgs(bookmark); //坐标转换为wgs

  return bookmark;
}

//Turf求面的中心点
function centerOfMass(positions, height) {
  try {
    if (positions.length == 1) {
      return positions[0];
    } else if (positions.length == 2) {
      return Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
    }

    if (height == null) {
      height = getMaxHeight(positions);
    }

    var coordinates = pointconvert.cartesians2lonlats(positions);
    coordinates.push(coordinates[0]);

    var center = (0, _turf.centerOfMass)({
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [coordinates]
      }
    });
    var centerX = center.geometry.coordinates[0];
    var centerY = center.geometry.coordinates[1];

    //所求的中心点在边界外时，求矩形中心点
    var extent = getRectangle(positions, true);
    if (centerX < extent.xmin || centerX > extent.xmax || centerY < extent.ymin || centerY > extent.ymax) {
      centerX = (extent.xmin + extent.xmax) / 2;
      centerY = (extent.ymin + extent.ymax) / 2;
    }

    var ptcenter = Cesium.Cartesian3.fromDegrees(centerX, centerY, height);
    return ptcenter;
  } catch (e) {
    return positions[Math.floor(positions.length / 2)];
  }
}

//点 是否在 entity（面、圆、多边形）内
function isInPoly(position, entity) {
  if (!entity || !position) return false;

  if (entity.rectangle) {
    var rectangle = entity.rectangle.coordinates.getValue((0, _util.currentTime)());

    var isInRectangle = Cesium.Rectangle.contains(rectangle, Cesium.Cartographic.fromCartesian(position));
    return isInRectangle;
  } else if (entity.ellipse) {
    var center = getPositionValue(entity.position);
    center = setPositionsHeight(center, 0);
    var radiu = entity.ellipse.semiMajorAxis.getValue((0, _util.currentTime)());

    var len = Cesium.Cartesian3.distance(center, position);
    return len <= radiu; //小于半径的说明在圆内
  } else if (entity.polygon) {
    var pt = {
      type: "Feature",
      geometry: { type: "Point", coordinates: pointconvert.cartesian2lonlat(position) }
    };
    var poly = polygonAttr.toGeoJSON(entity);
    var isInArea = (0, _turf.booleanPointInPolygon)(pt, poly); //turf插件计算的
    return isInArea;
  } else if (entity.type && entity.type == "Feature") {
    //entity为geojson
    var _pt = {
      type: "Feature",
      geometry: { type: "Point", coordinates: pointconvert.cartesian2lonlat(position) }
    };
    var _isInArea = (0, _turf.booleanPointInPolygon)(_pt, entity); //turf插件计算的
    return _isInArea;
  }
  return false;
}

//geojson转entity
function getPositionByGeoJSON(geojson, defHeight) {
  var geometry = geojson.type === "Feature" ? geojson.geometry : geojson,
      coords = geometry ? geometry.coordinates : null;

  if (!coords && !geometry) {
    return null;
  }

  switch (geometry.type) {
    case "Point":
      return pointconvert.lonlat2cartesian(coords, defHeight);
    case "MultiPoint":
    case "LineString":
      return pointconvert.lonlats2cartesians(coords, defHeight);

    case "MultiLineString":
    case "Polygon":
      return pointconvert.lonlats2cartesians(coords[0], defHeight);
    case "MultiPolygon":
      return pointconvert.lonlats2cartesians(coords[0][0], defHeight);
    default:
      throw new Error("Invalid GeoJSON object.");
  }
}

//绕点 环绕飞行
var windingPoint = exports.windingPoint = {
  isStart: false,
  viewer: null,
  start: function start(viewer, point) {
    var _this = this;

    this.viewer = viewer;
    if (point && point instanceof Cesium.Cartesian3) {
      this.position = point;
    } else {
      if (!point) point = getCenter(viewer);
      this.position = Cesium.Cartesian3.fromDegrees(point.x, point.y, point.z);
    }

    this.distance = point.distance || Cesium.Cartesian3.distance(this.position, viewer.camera.positionWC); // 给定相机距离点多少距离飞行

    this.direction = point.direction ? 1 : -1; //控制方向, true逆时针，false顺时针
    this.angle = 360 / (point.time || 60); //time：给定飞行一周所需时间(单位 秒)，控制速度
    this.autoStopAngle = point.autoStopAngle; //自动停止

    this.heading = viewer.camera.heading; // 相机的当前heading
    this.pitch = viewer.camera.pitch;

    this.viewer.clock.shouldAnimate = true;

    this.viewer.das.centerPoint(this.position, {
      radius: this.distance,
      duration: Cesium.defaultValue(point.duration, 2),
      complete: function complete(e) {
        _this.time = viewer.clock.currentTime.clone();
        _this.isStart = true;
        _this.viewer.clock.onTick.addEventListener(_this.clock_onTickHandler, _this);
      }
    });
  },
  clock_onTickHandler: function clock_onTickHandler(e) {
    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
    var angle = delTime * this.angle;
    if (this.autoStopAngle && angle >= this.autoStopAngle) {
      this.stop();
    }

    var heading = Cesium.Math.toRadians(angle * this.direction) + this.heading;

    this.viewer.scene.camera.setView({
      destination: this.position, // 点的坐标
      orientation: {
        heading: heading,
        pitch: this.pitch
      }
    });
    this.viewer.scene.camera.moveBackward(this.distance);
  },
  stop: function stop() {
    if (!this.isStart) return;

    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
    this.isStart = false;
  }
};

//固定点 向四周旋转
var aroundPoint = exports.aroundPoint = {
  isStart: false,
  viewer: null,
  start: function start(viewer, options) {
    this.viewer = viewer;
    this.options = options || {};

    this.angle = 360 / (this.options.time || 60); //time：给定飞行一周所需时间(单位 秒)，控制速度
    this.direction = this.options.direction ? -1 : 1; //控制方向, true逆时针，false顺时针

    this.time = viewer.clock.currentTime.clone();
    this.heading = viewer.camera.heading; // 相机的当前heading
    this.pitch = viewer.camera.pitch;

    this.viewer.clock.shouldAnimate = true;
    this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
    this.isStart = true;
  },
  clock_onTickHandler: function clock_onTickHandler(e) {
    // 当前已经过去的时间，单位s
    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time);
    var heading = Cesium.Math.toRadians(delTime * this.angle * this.direction) + this.heading;

    this.viewer.scene.camera.setView({
      orientation: {
        heading: heading,
        pitch: this.pitch
      }
    });
  },
  stop: function stop() {
    if (!this.isStart) return;

    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
    this.isStart = false;
  }
};

//截取路线指定最大长度的新路线[最后一个点往前截取maxDistance长度的新数组]
function sliceByMaxDistance(positions, maxDistance) {
  if (positions.length < 2) return positions;
  var distance = 0;
  for (var i = positions.length - 2; i >= 0; i--) {
    var pt1 = positions[i + 1];
    var pt2 = positions[i];
    distance += Cesium.Cartesian3.distance(pt1, pt2);
    var cha = distance - maxDistance;
    if (cha == 0) return positions.slice(i);else if (cha > 0) {
      //求指定长度拼接上去
      var newpt = (0, _matrix.getOnLinePointByLen)(pt2, pt1, cha);
      return [newpt].concat(positions.slice(i));
    }
  }
  return positions;
}

//点位弹力效果
/**
 *
 * @param {*} options
 *  options.position:点位位置
 *  options.height:点位起始降落高度
 * options.acceleration:重力系数(默认值0.1)
 * options.elasticSpeed:弹力系数(默认值0.5)
 * options.speed:起始速度(默认值50)
 * @returns
 * 运行示例
 * var entity = viewer.entities.add({
                name: "根据视距显示图标",
                 position: BouncePosition({
                     position:{lng:116.329102,lat:30.977955,height:1548.6}
                 }),
                billboard: {
                    image: 'img/marker/mark4.png',
                }
            });
 */
function BouncePosition(options) {
  var position = options.position;
  var lng;
  var lat;
  var thisHeight;
  if (!position) {
    console.error("点位坐标为空");
    return;
  }
  if (Array.isArray(position)) {
    lng = position[0];
    lat = position[1];
    thisHeight = position[2];
  } else {
    lng = position.lng;
    lat = position.lat;
    thisHeight = position.height;
  }
  var bounceHeight = options.height || 100; //起始高度
  var acceleration = options.acceleration || 0.1; //重力系数
  var elasticSpeed = options.elasticSpeed || 0.5; //弹力系数
  var baseSpeed = options.speed || 1; //初始速度
  var speed = Cesium.clone(baseSpeed);
  var entityHeight = thisHeight + bounceHeight;
  var tempType = "down";
  return new Cesium.CallbackProperty(function (a) {
    if (tempType == "down") {
      if (entityHeight > thisHeight) {
        speed += speed * acceleration;
        entityHeight -= speed;
      } else {
        if (speed < thisHeight * elasticSpeed) {
          entityHeight = thisHeight;
          tempType = "stop";
        } else {
          tempType = "up";
          speed = speed * elasticSpeed;
        }
      }
    } else if (tempType == "up") {
      if (speed > baseSpeed) {
        speed -= speed * acceleration;
        entityHeight += speed;
      } else {
        tempType = "down";
        speed = speed * elasticSpeed;
      }
    } else {
      entityHeight = thisHeight;
    }
    return Cesium.Cartesian3.fromDegrees(lng, lat, entityHeight);
  }, false);
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loopArrayForFun = exports.isArray = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.printVersion = printVersion;
exports.isNumber = isNumber;
exports.isString = isString;
exports.isObject = isObject;
exports.alert = alert;
exports.msg = msg;
exports.getRequest = getRequest;
exports.getRequestByName = getRequestByName;
exports.removeArrayItem = removeArrayItem;
exports.clone = clone;
exports.isPCBroswer = isPCBroswer;
exports.getExplorerInfo = getExplorerInfo;
exports.webglreport = webglreport;
exports.downloadBase64Image = downloadBase64Image;
exports.downloadFile = downloadFile;
exports.formatDegree = formatDegree;
exports.formatLength = formatLength;
exports.formatArea = formatArea;
exports.heightToZoom = heightToZoom;
exports.buffer = buffer;
exports.getGranularity = getGranularity;
exports.currentTime = currentTime;
exports.getProxyUrl = getProxyUrl;
exports.template = template;
exports.getAttrVal = getAttrVal;
exports.getPopupForConfig = getPopupForConfig;
exports.getTooltipForConfig = getTooltipForConfig;
exports.getPopup = getPopup;
exports.bindLayerPopup = bindLayerPopup;
exports.highlightEntity = highlightEntity;
exports.unHighlightEntity = unHighlightEntity;
exports.getTextImage = getTextImage;
exports.merge = merge;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _version = __webpack_require__(52);

var ver = _interopRequireWildcard(_version);

var _FlashingEntity = __webpack_require__(98);

var _turf = __webpack_require__(33);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//打印信息
function printVersion() {
  var msg = "";
  var c1 = "\n\tfont-size: 19px;\n\tpadding-left: 10px;\n\tcolor: rgb(240, 133, 25);\n",
      c2 = "\n\tfont-size: 17px;\n\tline-height: 1.5;\n\tfont-weight: 1000;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(240, 133, 25);\n",
      c3 = "\n\tfont-size: 15px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tfont-style: italic;\n\tcolor: rgb(240, 133, 25);\n\tpadding-bottom: 5px;\n",
      c4 = "\n\tfont-size: 12px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(0, 138, 255);\n\t";
  // eslint-disable-next-line no-console
  // console.log(msg, c1, c2, c3, c4);
  console.log('当前版本号:' + ver.version + ",当前Cesium版本:" + Cesium.VERSION);
}

function isNumber(obj) {
  return typeof obj == "number" && obj.constructor == Number;
}

function isString(str) {
  return typeof str == "string" && str.constructor == String;
}

function isObject(obj) {
  return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object" && obj.constructor == Object;
}

var isArray = exports.isArray = Array.isArray || function (obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

function alert(msg, title) {
  if (window.haoutil && window.haoutil.alert)
    //此方法需要引用haoutil
    window.haoutil.alert(msg, title);else if (window.layer)
    //此方法需要引用layer.js
    window.layer.alert(msg, {
      title: title || "提示",
      skin: "layui-layer-lan layer-das-dialog",
      closeBtn: 0,
      anim: 0
    });else window.alert(msg);
}

function msg(msg) {
  if (window.haoutil && window.haoutil.msg)
    //此方法需要引用haoutil
    window.haoutil.msg(msg);else if (window.toastr)
    //此方法需要引用toastr
    window.toastr.info(msg);else if (window.layer) window.layer.msg(msg);
  //此方法需要引用layer.js
  else window.alert(msg);
}

//url参数获取
function getRequest() {
  var url = location.search; //获取url中"?"符后的字串
  var theRequest = new Object();
  if (url.indexOf("?") != -1) {
    var str = url.substr(1);
    var strs = str.split("&");
    for (var i = 0; i < strs.length; i++) {
      theRequest[strs[i].split("=")[0]] = decodeURI(strs[i].split("=")[1]);
    }
  }
  return theRequest;
}

function getRequestByName(name) {
  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
  var r = window.location.search.substr(1).match(reg);
  if (r != null) return decodeURI(r[2]);
  return null;
}

Array.prototype.indexOf = Array.prototype.indexOf || function (val) {
  for (var i = 0; i < this.length; i++) {
    if (this[i] == val) return i;
  }
  return -1;
};

function removeArrayItem(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] == val) {
      arr.splice(i, 1);
      return true;
    }
  }
  return false;
}

function clone(obj, removeKeys, level) {
  if (level == null) level = 5; //避免死循环，拷贝的层级最大深度
  if (removeKeys == null) removeKeys = ["_layer"];

  if (null == obj || "object" != (typeof obj === "undefined" ? "undefined" : _typeof(obj))) return obj;

  // Handle Date
  if (obj instanceof Date) {
    var copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  // Handle Array
  if (isArray(obj) && level >= 0) {
    var _copy = [];
    for (var i = 0, len = obj.length; i < len; ++i) {
      _copy[i] = clone(obj[i], removeKeys, level - 1);
    }
    return _copy;
  }

  // Handle Object
  if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && level >= 0) {
    try {
      var _copy2 = {};
      for (var attr in obj) {
        if (typeof attr === "function") continue;
        if (removeKeys.indexOf(attr) != -1) continue;

        if (obj.hasOwnProperty(attr)) _copy2[attr] = clone(obj[attr], removeKeys, level - 1);
      }
      return _copy2;
    } catch (e) {
      daslog.warn("util.clone方法时异常", e);
    }
  }
  return obj;
}

function isPCBroswer() {
  var sUserAgent = navigator.userAgent.toLowerCase();

  var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
  var bIsIphoneOs = sUserAgent.match(/iphone/i) == "iphone";
  var bIsMidp = sUserAgent.match(/midp/i) == "midp";
  var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
  var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
  var bIsAndroid = sUserAgent.match(/android/i) == "android";
  var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
  var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";
  if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
    return false;
  } else {
    return true;
  }
}

//获取浏览器类型及版本
function getExplorerInfo() {
  var ver;
  var explorer = window.navigator.userAgent.toLowerCase();
  //ie
  if (explorer.indexOf("msie") >= 0) {
    ver = Number(explorer.match(/msie ([\d]+)/)[1]);
    return { type: "IE", version: ver };
  }
  //firefox
  else if (explorer.indexOf("firefox") >= 0) {
      ver = Number(explorer.match(/firefox\/([\d]+)/)[1]);
      return { type: "Firefox", version: ver };
    }
    //Chrome
    else if (explorer.indexOf("chrome") >= 0) {
        ver = Number(explorer.match(/chrome\/([\d]+)/)[1]);
        return { type: "Chrome", version: ver };
      }
      //Opera
      else if (explorer.indexOf("opera") >= 0) {
          ver = Number(explorer.match(/opera.([\d]+)/)[1]);
          return { type: "Opera", version: ver };
        }
        //Safari
        else if (explorer.indexOf("Safari") >= 0) {
            ver = Number(explorer.match(/version\/([\d]+)/)[1]);
            return { type: "Safari", version: ver };
          }
  return { type: explorer, version: -1 };
}

//检测浏览器webgl支持
function webglreport() {
  var exinfo = getExplorerInfo();
  if (exinfo.type == "IE" && exinfo.version < 11) {
    return false;
  }

  try {
    var glContext;
    var canvas = document.createElement("canvas");
    var requestWebgl2 = typeof WebGL2RenderingContext !== "undefined";
    if (requestWebgl2) {
      glContext = canvas.getContext("webgl2") || canvas.getContext("experimental-webgl2") || undefined;
    }
    if (glContext == null) {
      glContext = canvas.getContext("webgl") || canvas.getContext("experimental-webgl") || undefined;
    }
    if (glContext == null) {
      return false;
    }
  } catch (e) {
    return false;
  }
  return true;
}

function download(fileName, blob) {
  var aLink = document.createElement("a");
  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  document.body.appendChild(aLink);
  aLink.click();
  document.body.removeChild(aLink);
}

function base64Img2Blob(code) {
  var parts = code.split(";base64,");
  var contentType = parts[0].split(":")[1];
  var raw = window.atob(parts[1]);
  var rawLength = raw.length;

  var uInt8Array = new Uint8Array(rawLength);
  for (var i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }
  return new Blob([uInt8Array], { type: contentType });
}

//下载导出图片
function downloadBase64Image(name, base64) {
  var blob = base64Img2Blob(base64);
  download(name + ".png", blob);
}

//下载保存文件
function downloadFile(fileName, string) {
  var blob = new Blob([string]);
  download(fileName, blob);
}

//格式化经度/纬度，返回度分秒字符串
function formatDegree(value) {
  value = Math.abs(value);
  var v1 = Math.floor(value); //度
  var v2 = Math.floor((value - v1) * 60); //分
  var v3 = Math.round((value - v1) * 3600 % 60); //秒
  return v1 + "° " + v2 + "'  " + v3 + '"';
}

//  计算长度后，格式化显示长度值, 可指定单位
//  unit支持:m、km、mile、zhang   默认自动判断 m 或 km
function formatLength(val, unit) {
  if (val == null) return "";

  if (unit == null || unit == "auto") {
    if (val < 1000) unit = "m";else unit = "km";
  }

  var valstr = "";
  switch (unit) {
    default:
    case "m":
      valstr = val.toFixed(2) + "米";
      break;
    case "km":
      valstr = (val * 0.001).toFixed(2) + "公里";
      break;
    case "mile":
      valstr = (val * 0.00054).toFixed(2) + "海里";
      break;
    case "zhang":
      valstr = (val * 0.3).toFixed(2) + "丈";
      break;
  }
  return valstr;
}

//  计算面积后，格式化显示面积值, 可指定单位
//  unit支持:m、km、mu、ha   默认自动判断 m 或 km
function formatArea(val, unit) {
  if (val == null) return "";

  if (unit == null || unit == "auto") {
    if (val < 1000000) unit = "m";else unit = "km";
  }

  var valstr = "";
  switch (unit) {
    default:
    case "m":
      valstr = val.toFixed(2) + "m²";
      break;
    case "km":
      valstr = (val / 1000000).toFixed(2) + "km²";
      break;
    case "mu":
      valstr = (val * 0.0015).toFixed(2) + "亩";
      break;
    case "ha":
      valstr = (val * 0.0001).toFixed(2) + "ha²";
      break;
  }

  return valstr;
}

//根据高度获取地图层级
function heightToZoom(altitude) {
  var A = 40487.57;
  var B = 0.00007096758;
  var C = 91610.74;
  var D = -40467.74;

  return Math.round(D + (A - D) / (1 + Math.pow(altitude / C, B)));
}

//缓冲分析（比如是建筑物单体化时,缓冲扩大点范围）,单位：米
function buffer(geojson, width) {
  try {
    width = Cesium.defaultValue(width, 1);
    //API: http://turfjs.org/docs/#buffer
    geojson = (0, _turf.buffer)(geojson, width, { units: "meters", steps: 64 });
  } catch (e) {
    daslog.log("buffer缓冲分析异常", e);
  }
  return geojson;
}

//求Rectangle范围内 按count等比插值的granularity值
function getGranularity(positions, count) {
  var recta = Cesium.Rectangle.fromCartesianArray(positions);
  var granularity = Math.max(recta.height, recta.width);
  granularity /= Cesium.defaultValue(count, 10); //默认分割10次
  return granularity;
}

//取当前时间，用于getValue传参
function currentTime() {
  if (window.viewer) return window.viewer.clock.currentTime;else return Cesium.JulianDate.now();
}

//判断url加上配置的代理
function getProxyUrl(config) {
  if (!config.url || !config.proxy && !config.headers && !config.queryParameters) return config;

  if (config.url instanceof Cesium.Resource) {
    config.url.headers = config.headers;
    return config;
  }

  var opts = {};
  for (var key in config) {
    opts[key] = config[key];
  }
  opts.url = new Cesium.Resource({
    url: opts.url,
    proxy: opts.proxy ? new Cesium.DefaultProxy(opts.proxy) : null,
    headers: opts.headers,
    queryParameters: opts.queryParameters
  });

  return opts;
}

var templateRe = /\{ *([a-zA-Z0-9_\u4e00-\u9fa5]+) *\}/g;

//popup的字符串模板
function template(str, data) {
  if (str == null) return str;

  return str.replace(templateRe, function (str, key) {
    var value = data[key];
    if (!Cesium.defined(value)) return "";

    if (typeof value === "function") {
      value = value(data);
      if (!Cesium.defined(value)) return "";
    } else if (value.getValue && typeof value.getValue == "function") {
      value = value.getValue(currentTime());
      if (!Cesium.defined(value)) return "";
    }

    return value;
  });
}

//简化Cesium内的属性，去掉getValue等，取最简的键值对。方便popup、tooltip等使用
function getAttrVal(attr) {
  if (!attr) return attr;

  try {
    if (attr.getValue) attr = attr.getValue(currentTime());

    var newattr = {};
    if (attr._propertyNames && attr._propertyNames.length > 0) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = attr._propertyNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _key = _step.value;

          var showval = attr[_key];
          if (showval == null || showval == "" || showval == "Null" || showval == "Unknown") continue;

          if (showval.getValue && typeof showval.getValue == "function") {
            newattr[_key] = showval.getValue(currentTime());
          } else {
            if (typeof showval === "function") continue;
            newattr[_key] = showval;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      for (var key in attr) {
        var _showval = attr[key];
        if (_showval == null || _showval == "" || _showval == "Null" || _showval == "Unknown") continue;

        if (_showval.getValue && typeof _showval.getValue == "function") {
          newattr[key] = _showval.getValue(currentTime());
        } else {
          if (typeof _showval === "function") continue;
          newattr[key] = _showval;
        }
      }
    }
    return newattr;
  } catch (e) {
    daslog.log("getAttrVal 出错", e);
  }
  return attr;
}

//根据config配置规则获取popup使用的html字符串
function getPopupForConfig(cfg, attr) {
  var _title = cfg.popupNameField ? attr[cfg.popupNameField] : cfg.name;
  if (cfg.popupNoTitle) _title = null;

  if (cfg.popup) {
    return getPopup(cfg.popup, attr, { title: _title });
  } else if (cfg.columns) {
    return getPopup(cfg.columns, attr, { title: _title });
  }
  return false;
}

//根据config配置规则获取tooltip使用的html字符串
function getTooltipForConfig(cfg, attr) {
  var _title = cfg.tooltipNameField ? attr[cfg.tooltipNameField] : cfg.name;

  if (cfg.tooltip) {
    return getPopup(cfg.tooltip, attr, { title: _title });
  }
  return false;
}

//获取Popup或Tooltip格式化字符串
function getPopup(cfg, attr, options) {
  if (!attr) return false;

  options = options || {};
  if (isString(options)) {
    //兼容旧版本参数
    options = { title: options };
  }

  var title = options.title;
  var isEdit = options.edit;

  attr = getAttrVal(attr); //取值

  if (isArray(cfg)) {
    //数组
    var countsok = 0;
    var inhtml = title ? '<div class="das-popup-titile">' + title + "</div>" : '<div style="height: 10px;"></div>';
    inhtml += '<div class="das-popup-content" >';
    for (var i = 0; i < cfg.length; i++) {
      var thisfield = cfg[i];
      if (thisfield == null) continue;

      var col = thisfield.field;

      if (thisfield.type == "details" || thisfield.type == "button") {
        //详情等button按钮
        var _showval2 = String.prototype.trim.call(attr[col || "OBJECTID"]);
        if (_showval2 == null) continue;

        var onclickHtml = "";
        var callback = thisfield.callback || thisfield.calback;
        if (callback) {
          onclickHtml = "onclick=\"" + callback + "('" + _showval2 + "');\"  ";
        }

        inhtml += "<div style=\"text-align: center;padding: 2px 0;\">\n                            <button type=\"button\"  " + onclickHtml + "\n                            data-type=\"" + col + "\" class=\"btn btn-primary btn-sm das3d-popup-btn\" >" + (thisfield.name || "查看详情") + "</button>\n                        </div>";
        continue;
      } else if (thisfield.type == "html") {
        inhtml += "<div>" + thisfield.html + "</div>";
        continue;
      }

      if (!isEdit) {
        //非编辑状态隐藏空值
        if (col == null || attr[col] == null) continue;
        if (typeof attr[col] === "function") continue;
      }

      //值
      var showval = String.prototype.trim.call(attr[col] || "");

      if (!isEdit) {
        //非编辑状态隐藏空值
        if (showval == null || showval == "" || showval == "Null" || showval == "Unknown" || showval == "0" || showval.length == 0) continue;
      }

      if (thisfield.format) {
        //使用外部 格式化js方法
        try {
          showval = eval(thisfield.format + "(" + showval + ")");
        } catch (e) {
          daslog.log("getPopupByConfig方法format格式化异常", thisfield);
        }
      }

      if (isEdit) {
        switch (thisfield.type) {
          default:
          case "string":
          case "number":
            showval = "<input type=\"" + (thisfield.type || "text") + "\" class=\"das3d-popup-edititem\" style=\"width:" + (options.width || 190) + "px;\"\n                        data-type=\"" + col + "\" value=\"" + showval + "\" placeholder=\"\u8BF7\u8F93\u5165 " + thisfield.name + "\"  />";
            break;
          case "textarea":
            showval = "<textarea class=\"das3d-popup-edititem\" style=\"width:" + (options.width || 190) + "px;\"\n                        data-type=\"" + col + "\"  placeholder=\"\u8BF7\u8F93\u5165 " + thisfield.name + "\"  >" + showval + "</textarea>";
            break;
        }
      }

      if (thisfield.unit) {
        showval += thisfield.unit;
      }

      inhtml += "<div><label>" + thisfield.name + "</label>" + showval + "</div>";
      countsok++;
    }
    inhtml += "</div>";

    if (countsok == 0) return false;
    return inhtml;
  } else if ((typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) === "object") {
    //对象,type区分逻辑
    switch (cfg.type) {
      case "iframe":
        var _url = template(cfg.url, attr);

        var inhtml2 = '<iframe id="ifarm" src="' + _url + '"  style="width:' + (cfg.width || "300") + "px;height:" + (cfg.height || "300") + 'px;overflow:hidden;margin:0;" scrolling="no" frameborder="0" ></iframe>';
        return inhtml2;
      // break;
      case "javascript":
        //回调方法
        var callbackFun = cfg.callback || cfg.calback;
        return eval(callbackFun + "(" + JSON.stringify(attr) + ")");
      // break;
    }
  } else if (typeof cfg === "function") {
    return cfg(attr);
  } else if (cfg == "all") {
    //全部显示
    var _countsok = 0;
    var _inhtml = title ? '<div class="das-popup-titile">' + title + "</div>" : "";
    _inhtml += '<div class="das-popup-content" >';
    for (var _col in attr) {
      try {
        if (_col == null || attr[_col] == null) continue;

        if (_col == "Shape" || _col == "FID" || _col == "OBJECTID" || _col == "_definitionChanged" || _col == "_propertyNames") continue; //不显示的字段

        if (_col.substr(0, 1) == "_") {
          _col = _col.substring(1); //cesium 内部属性
        }

        if (_typeof(attr[_col]) === "object" && attr[_col].hasOwnProperty && attr[_col].hasOwnProperty("getValue")) attr[_col] = attr[_col].getValue(currentTime());
        if (typeof attr[_col] === "function") continue;

        var _showval3 = String.prototype.trim.call(attr[_col]);
        if (_showval3 == null || _showval3 == "" || _showval3 == "Null" || _showval3 == "Unknown" || _showval3 == "0" || _showval3.length == 0) continue; //不显示空值，更美观友好

        _inhtml += "<div><label>" + _col + "</label>" + _showval3 + "</div>";
        _countsok++;
      } catch (e) {
        daslog.log("getPopup方法all构造时异常", e);
      }
    }
    _inhtml += "</div>";

    if (_countsok == 0) return false;
    return _inhtml;
  } else {
    //格式化字符串
    return template(cfg, attr);
  }

  return false;
}

//对das3d内置图层的绑定处理（图层一般因为有属性读取及格式化处理）
function bindLayerPopup(popup, getHtmlFun) {
  //显示内容
  var inhtml;
  if ((typeof popup === "undefined" ? "undefined" : _typeof(popup)) === "object" && popup.html) {
    inhtml = popup.html;
  } else {
    inhtml = popup;
    popup = {
      html: inhtml
    };
  }

  if (typeof inhtml === "function") {
    //自定义的回调方法
    popup.html = function (entity, cartesian, callback) {
      return inhtml(entity, cartesian, callback);
    };
  } else {
    //内置的格式化方法，一般使用getPopup
    popup.html = function (entity) {
      return getHtmlFun(inhtml, entity);
    };
  }
  popup.anchor = popup.anchor || [0, -15];

  return popup;
}

var loopArrayForFun = exports.loopArrayForFun = _FlashingEntity.loopArrayForFun;

var lastFlashingEntity;

//定时闪烁高亮Entity（点、线、面）
function highlightEntity(entitys, opts) {
  var flashingEntity = new _FlashingEntity.FlashingEntity();
  flashingEntity.highlight(entitys, opts);

  lastFlashingEntity = flashingEntity;
  return flashingEntity;
}

//取消定时闪烁高亮Entity（点、线、面）
function unHighlightEntity(flashingEntity) {
  if (flashingEntity) return flashingEntity.unHighlight();else if (lastFlashingEntity) return lastFlashingEntity.unHighlight();
}

//文字转base64图片
function getTextImage(text, textStyle) {
  var canvas = Cesium.writeTextToCanvas(text, textStyle);
  return canvas.toDataURL("image/png");
}

//合并属性
function merge(dest) {
  var i = void 0,
      j = void 0,
      len = void 0,
      src = void 0;

  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  for (j = 0, len = sources.length; j < len; j++) {
    src = sources[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cartesian2lonlat = cartesian2lonlat;
exports.cartesians2lonlats = cartesians2lonlats;
exports.cartesian2mercator = cartesian2mercator;
exports.cartesians2mercators = cartesians2mercators;
exports.lonlat2cartesian = lonlat2cartesian;
exports.lonlats2cartesians = lonlats2cartesians;
exports.lonlat2mercator = lonlat2mercator;
exports.lonlats2mercators = lonlats2mercators;
exports.mercator2cartesian = mercator2cartesian;
exports.mercators2cartesians = mercators2cartesians;
exports.mercator2lonlat = mercator2lonlat;
exports.mercators2lonlats = mercators2lonlats;
exports.bd2gcj = bd2gcj;
exports.gcj2bd = gcj2bd;
exports.wgs2gcj = wgs2gcj;
exports.gcj2wgs = gcj2wgs;
exports.bd2wgs = bd2wgs;
exports.wgs2bd = wgs2bd;
exports.jwd2mct = jwd2mct;
exports.mct2jwd = mct2jwd;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var isArray = Array.isArray || function (obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

//格式化 数字 小数位数
function formatNum(num, digits) {
  return Number(num.toFixed(digits || 0));
}

//===============提供了cesium内部不同对象之间的坐标转换==============

//cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
function cartesian2lonlat(cartesian) {
  var carto = Cesium.Cartographic.fromCartesian(cartesian);
  if (carto == null) return null;

  var x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
  var y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
  var z = formatNum(carto.height, 2);

  return [x, y, z];
}

//数组，cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
function cartesians2lonlats(positions) {
  var coordinates = [];
  for (var i = 0, len = positions.length; i < len; i++) {
    var point = cartesian2lonlat(positions[i]);
    if (point) coordinates.push(point);
  }
  return coordinates;
}

//cesium笛卡尔空间坐标 转 web mercator投影坐标
function cartesian2mercator(position) {
  if (!position) return null;

  var lonlat = cartesian2lonlat(position);
  return lonlat2mercator(lonlat);
}

//数组，cesium笛卡尔空间坐标 转 web mercator投影坐标
function cartesians2mercators(arr) {
  var arrNew = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    var point = cartesian2mercator(arr[i]);
    if (point) arrNew.push(point);
  }
  return arrNew;
}

//经纬度坐标 转 cesium笛卡尔空间坐标
function lonlat2cartesian(coord, defHeight) {
  if (!coord || coord.length < 2) return null;
  return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], coord[2] || defHeight || 0);
}

//数组，经纬度坐标 转 cesium笛卡尔空间坐标
function lonlats2cartesians(coords, defHeight) {
  var arr = [];
  for (var i = 0, len = coords.length; i < len; i++) {
    var item = coords[i];
    if (isArray(item[0])) {
      var arr2 = lonlats2cartesians(item, defHeight);
      if (arr2 && arr2.length > 0) arr.push(arr2);
    } else {
      var cartesian = lonlat2cartesian(item, defHeight);
      if (cartesian) arr.push(cartesian);
    }
  }
  return arr;
}

//地理坐标 转 投影坐标
function lonlat2mercator(lnglat) {
  return jwd2mct(lnglat);
}
//数组，地理坐标 转 投影坐标
function lonlats2mercators(arr) {
  var arrNew = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    var point = lonlat2mercator(arr[i]);
    arrNew.push(point);
  }
  return arrNew;
}

//投影坐标 转 cesium笛卡尔空间坐标
function mercator2cartesian(point) {
  if (isNaN(point[0]) || isNaN(point[1])) return null;

  var lonlat = mercator2lonlat(point);
  return lonlat2cartesian(lonlat);
}
//数组，投影坐标 转 cesium笛卡尔空间坐标
function mercators2cartesians(arr) {
  var arrNew = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    var point = mercator2cartesian(arr[i]);
    if (point) arrNew.push(point);
  }
  return arrNew;
}

//投影坐标 转 地理坐标
function mercator2lonlat(point) {
  return mct2jwd(point);
}
//数组，投影坐标 转 地理坐标
function mercators2lonlats(arr) {
  var arrNew = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    var point = mercator2lonlat(arr[i]);
    arrNew.push(point);
  }
  return arrNew;
}

//========提供了百度（BD09）、国测局（GCJ02）、WGS84、Web墨卡托 4类坐标之间的转换=======
//传入参数 和 返回结果 均是数组：[经度,纬度]

//定义一些常量
var x_PI = 3.14159265358979324 * 3000.0 / 180.0;
var PI = 3.1415926535897932384626;
var a = 6378245.0;
var ee = 0.00669342162296594323;

function transformlat(lng, lat) {
  var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
  ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
  return ret;
}

function transformlng(lng, lat) {
  var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
  ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
  ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
  return ret;
}

/**
 * 判断是否在国内，不在国内则不做偏移
 * @param lng
 * @param lat
 * @returns {boolean}
 */
function out_of_china(lng, lat) {
  return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false;
}

/**
 * 百度坐标系 (BD-09) 与 国测局坐标系 (GCJ-02)的转换
 * 即 百度 转 谷歌、高德
 * @param bd_lon
 * @param bd_lat
 * @returns {*[]}
 */
function bd2gcj(arrdata) {
  var bd_lon = Number(arrdata[0]);
  var bd_lat = Number(arrdata[1]);

  var x_pi = 3.14159265358979324 * 3000.0 / 180.0;
  var x = bd_lon - 0.0065;
  var y = bd_lat - 0.006;
  var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
  var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
  var gg_lng = z * Math.cos(theta);
  var gg_lat = z * Math.sin(theta);

  gg_lng = Number(gg_lng.toFixed(6));
  gg_lat = Number(gg_lat.toFixed(6));
  return [gg_lng, gg_lat];
}

/**
 * 国测局坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换
 * 即谷歌、高德 转 百度
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function gcj2bd(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
  var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
  var bd_lng = z * Math.cos(theta) + 0.0065;
  var bd_lat = z * Math.sin(theta) + 0.006;

  bd_lng = Number(bd_lng.toFixed(6));
  bd_lat = Number(bd_lat.toFixed(6));
  return [bd_lng, bd_lat];
}

/**
 * WGS84转GCj02
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function wgs2gcj(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  if (out_of_china(lng, lat)) {
    return [lng, lat];
  } else {
    var dlat = transformlat(lng - 105.0, lat - 35.0);
    var dlng = transformlng(lng - 105.0, lat - 35.0);
    var radlat = lat / 180.0 * PI;
    var magic = Math.sin(radlat);
    magic = 1 - ee * magic * magic;
    var sqrtmagic = Math.sqrt(magic);
    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);
    var mglat = lat + dlat;
    var mglng = lng + dlng;

    mglng = Number(mglng.toFixed(6));
    mglat = Number(mglat.toFixed(6));
    return [mglng, mglat];
  }
}

/**
 * GCJ02 转换为 WGS84
 * @param lng
 * @param lat
 * @returns {*[]}
 */
function gcj2wgs(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  if (out_of_china(lng, lat)) {
    return [lng, lat];
  } else {
    var dlat = transformlat(lng - 105.0, lat - 35.0);
    var dlng = transformlng(lng - 105.0, lat - 35.0);
    var radlat = lat / 180.0 * PI;
    var magic = Math.sin(radlat);
    magic = 1 - ee * magic * magic;
    var sqrtmagic = Math.sqrt(magic);
    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);

    var mglat = lat + dlat;
    var mglng = lng + dlng;

    var jd = lng * 2 - mglng;
    var wd = lat * 2 - mglat;

    jd = Number(jd.toFixed(6));
    wd = Number(wd.toFixed(6));
    return [jd, wd];
  }
}

//百度经纬度坐标 转 标准WGS84坐标
function bd2wgs(arrdata) {
  return gcj2wgs(bd2gcj(arrdata));
}

//标准WGS84坐标  转 百度经纬度坐标
function wgs2bd(arrdata) {
  return gcj2bd(wgs2gcj(arrdata));
}

//经纬度转Web墨卡托
function jwd2mct(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  var x = lng * 20037508.34 / 180;
  var y = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
  y = y * 20037508.34 / 180; //+ 7.081154553416204e-10;

  x = Number(x.toFixed(2));
  y = Number(y.toFixed(2));
  return [x, y, arrdata[2] || 0];
}

//Web墨卡托转经纬度
function mct2jwd(arrdata) {
  var lng = Number(arrdata[0]);
  var lat = Number(arrdata[1]);

  var x = lng / 20037508.34 * 180;
  var y = lat / 20037508.34 * 180;
  y = 180 / PI * (2 * Math.atan(Math.exp(y * PI / 180)) - PI / 2);

  x = Number(x.toFixed(6));
  y = Number(y.toFixed(6));
  return [x, y, arrdata[2] || 0];
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = log;
exports.warn = warn;
exports.error = error;
exports.update = update;
var hasLog = exports.hasLog = true;

//输出普通信息(含调试)
function log(log, obj) {
  if (!hasLog) return;
  // eslint-disable-next-line no-console
  if (obj) console.log(log, obj);
  // eslint-disable-next-line no-console
  else console.log(log);
}

var hasWarn = exports.hasWarn = true;

//输出警示信息(含错误)
function warn(log, obj) {
  if (!hasWarn) return;

  // eslint-disable-next-line no-console
  if (obj) console.warn(log, obj);
  // eslint-disable-next-line no-console
  else console.warn(log);
}
function error(log, obj) {
  if (!hasWarn) return;

  // eslint-disable-next-line no-console
  if (obj) console.error(log, obj);
  // eslint-disable-next-line no-console
  else console.error(log);
}

function update(val) {
  var val2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  exports.hasLog = hasLog = val;
  exports.hasWarn = hasWarn = val2;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draw = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.register = register;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _Tooltip = __webpack_require__(8);

var _index = __webpack_require__(22);

var attr = _interopRequireWildcard(_index);

var _Draw = __webpack_require__(46);

var _Draw2 = __webpack_require__(25);

var _Draw3 = __webpack_require__(47);

var _Draw4 = __webpack_require__(117);

var _Draw5 = __webpack_require__(118);

var _Draw6 = __webpack_require__(19);

var _Draw7 = __webpack_require__(120);

var _Draw8 = __webpack_require__(121);

var _Draw9 = __webpack_require__(122);

var _Draw10 = __webpack_require__(65);

var _Draw11 = __webpack_require__(11);

var _Draw12 = __webpack_require__(123);

var _Draw13 = __webpack_require__(124);

var _Draw14 = __webpack_require__(125);

var _Draw15 = __webpack_require__(127);

var _Draw16 = __webpack_require__(128);

var _Draw17 = __webpack_require__(129);

var _Draw18 = __webpack_require__(130);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//类库外部扩展的类
var exDraw = {};
function register(type, layerClass) {
  exDraw[type] = layerClass;
}

//绘制entity类型

var Draw = exports.Draw = function (_DasClass) {
  _inherits(Draw, _DasClass);

  //========== 构造方法 ==========
  function Draw(options, oldparam) {
    _classCallCheck(this, Draw);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Draw.__proto__ || Object.getPrototypeOf(Draw)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.options = options;
    _this.viewer = options.viewer;
    _this.popup = options.popup;
    _this.mouseEdit = Cesium.defaultValue(_this.options.mouseEdit, true); //是否开启鼠标编辑事件

    _this.options.groupName = Cesium.defaultValue(_this.options.groupName, "默认分组");

    _this.arrGroup = []; //分组
    _this.dataSource = Cesium.defaultValue(_this.options.dataSource, _this.addGroup(_this.options.groupName));

    if (Cesium.defaultValue(_this.options.removeScreenSpaceEvent, true)) {
      _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
      _this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }

    _this.tooltip = new _Tooltip.Tooltip(_this.viewer.container); //鼠标提示信息

    _this.hasEdit(Cesium.defaultValue(_this.options.hasEdit, true)); //是否可编辑

    //编辑工具初始化
    var _opts = {
      viewer: _this.viewer,
      dataSource: _this.dataSource,
      tooltip: _this.tooltip
    };

    //entity
    _this.drawCtrl = {};
    _this.drawCtrl["point"] = new _Draw2.DrawPoint(_opts);
    _this.drawCtrl["billboard"] = new _Draw3.DrawBillboard(_opts);
    _this.drawCtrl["label"] = new _Draw4.DrawLabel(_opts);
    _this.drawCtrl["model"] = new _Draw5.DrawModel(_opts);

    _this.drawCtrl["polyline"] = new _Draw6.DrawPolyline(_opts);
    _this.drawCtrl["curve"] = new _Draw7.DrawCurve(_opts);
    _this.drawCtrl["polylineVolume"] = new _Draw8.DrawPolylineVolume(_opts);
    _this.drawCtrl["corridor"] = new _Draw9.DrawCorridor(_opts);

    _this.drawCtrl["polygon"] = new _Draw10.DrawPolygon(_opts);
    _this.drawCtrl["rectangle"] = new _Draw12.DrawRectangle(_opts);
    _this.drawCtrl["ellipse"] = new _Draw13.DrawCircle(_opts);
    _this.drawCtrl["circle"] = _this.drawCtrl["ellipse"]; //圆
    _this.drawCtrl["cylinder"] = new _Draw14.DrawCylinder(_opts);
    _this.drawCtrl["ellipsoid"] = new _Draw15.DrawEllipsoid(_opts);
    _this.drawCtrl["wall"] = new _Draw16.DrawWall(_opts);
    _this.drawCtrl["box"] = new _Draw18.DrawBox(_opts);
    _this.drawCtrl["plane"] = new _Draw17.DrawPlane(_opts);

    //外部图层
    for (var key in exDraw) {
      _this.drawCtrl[key] = new exDraw[key](_opts);
    }

    //绑定事件抛出方法
    var that = _this;
    for (var type in _this.drawCtrl) {
      _this.drawCtrl[type]._fire = function (type, data, propagate) {
        that.fire(type, data, propagate);
      };
    }

    _this.isContinued = Cesium.defaultValue(_this.options.isContinued, false);
    _this.isAutoEditing = Cesium.defaultValue(_this.options.isAutoEditing, true);
    _this.on(_DasClass2.eventType.drawCreated, function (e) {
      _this.bindExtension(e.entity);

      setTimeout(function () {
        if (_this.isContinued) {
          //连续标绘时
          _this.stopDraw();
          _this.startDraw(_this._last_attribute, _this._last_drawOkCallback);
        } else if (_this.isAutoEditing) {
          //创建完成后激活编辑
          _this.startEditing(e.entity);
        }
      }, 50);
    }, _this);
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(Draw, [{
    key: "addGroup",


    //==========分组相关==========
    //新增添加分组
    value: function addGroup(name, item) {
      var dataSource = new Cesium.CustomDataSource(name);
      dataSource.attribute = item; //携带数据，非必须
      this.viewer.dataSources.add(dataSource);

      this.arrGroup.push(dataSource);
      return dataSource;
    }
    //校验分组是否有同名的

  }, {
    key: "checkGroupName",
    value: function checkGroupName(name, thisLayer) {
      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        if (thisLayer && layer == thisLayer) continue;

        if (layer.name == name) return true;
      }
      return false;
    }
    //根据name获取分组

  }, {
    key: "getGroup",
    value: function getGroup(name) {
      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        if (layer.name == name) return layer;
      }
      return null;
    }
    //新增或获取已有分组

  }, {
    key: "addOrGetGroup",
    value: function addOrGetGroup(name) {
      if (!name) return this.dataSource;
      var group = this.getGroup(name);
      if (group) {
        return group;
      } else {
        return this.addGroup(name);
      }
    }
    //删除分组后的对默认图层和激活图层的特殊处理

  }, {
    key: "_processForRemoveGroup",
    value: function _processForRemoveGroup() {
      if (this.arrGroup.length == 0) {
        this.dataSource = this.addGroup(this.options.groupName);
      } else if (this.dataSource == null) {
        //如果删除的是当前激活的图层，默认再次激活第1个图层
        this.dataSource = this.arrGroup[0];
      }
    }
    //根据name删除分组

  }, {
    key: "removeGroup",
    value: function removeGroup(name) {
      var layer;
      if (name instanceof Cesium.CustomDataSource) layer = name;else layer = this.getGroup(name);

      if (layer) {
        if (this.dataSource == layer) {
          this.dataSource = null;
        }
        this.removeByGroup(layer);
        this.viewer.dataSources.remove(layer, true);
        util.removeArrayItem(this.arrGroup, layer);

        this._processForRemoveGroup();
        return true;
      }
      return false;
    }
    //删除所有非空数组

  }, {
    key: "removeNullGroup",
    value: function removeNullGroup() {
      for (var i = this.arrGroup.length - 1; i >= 0; i--) {
        var layer = this.arrGroup[i];
        if (layer.entities.values.length == 0) {
          this.viewer.dataSources.remove(layer, true);
          this.arrGroup.splice(i, 1);

          if (this.dataSource == layer) {
            this.dataSource = null;
          }
        }
      }
      this._processForRemoveGroup();
    }
    //激活图层，新增的标绘是加到当前激活的图层中。

  }, {
    key: "activateGroup",
    value: function activateGroup(name) {
      var layer;
      if (name instanceof Cesium.CustomDataSource) layer = name;else layer = this.getGroup(name);

      if (!layer) return false;

      this.dataSource = layer;
      return true;
    }

    //移动标号到新分组

  }, {
    key: "moveEntityGroup",
    value: function moveEntityGroup(entity, group) {
      var dataSource;
      if (group instanceof Cesium.CustomDataSource) dataSource = group;else dataSource = this.getGroup(group);

      entity.entityCollection.remove(entity); //从原有的集合中删除
      dataSource.entities.add(entity); //加入到draw集合图层中

      entity.attribute.group = dataSource.name; //记录分组信息
    }
  }, {
    key: "getDataSource",
    value: function getDataSource() {
      return this.dataSource;
    }

    //==========绘制相关==========

  }, {
    key: "startDraw",
    value: function startDraw(attribute, drawOkCallback) {
      //参数是字符串id或uri时
      if (typeof attribute === "string") {
        attribute = { type: attribute };
      } else {
        if (attribute == null || attribute.type == null) {
          daslog.warn("需要传入指定绘制的type类型！", attribute);
          return;
        }
      }

      var type = attribute.type;
      if (this.drawCtrl[type] == null) {
        daslog.warn("不能进行type为【" + type + "】的绘制，无该类型！");
        return;
      }

      if (!drawOkCallback && attribute.success) {
        drawOkCallback = attribute.success;
        delete attribute.success;
      }
      this._last_drawOkCallback = drawOkCallback;
      this._last_attribute = attribute;

      //赋默认值
      attribute = attr.addGeoJsonDefVal(attribute);

      this.stopDraw();
      var entity = this.drawCtrl[type].activate(attribute, drawOkCallback);
      return entity;
    }
    //对已经绘制完成的entity，重新激活开始编辑[目前仅支持polyline、polygon]

  }, {
    key: "restartDraw",
    value: function restartDraw(entity, drawOkCallback) {
      var attribute = entity.attribute;
      var type = attribute.type;
      if (this.drawCtrl[type] == null) {
        daslog.warn("不能进行type为【" + type + "】的绘制，无该类型！");
        return;
      }

      if (!drawOkCallback && attribute.success) {
        drawOkCallback = attribute.success;
        delete attribute.success;
      }
      this._last_drawOkCallback = drawOkCallback;
      this._last_attribute = attribute;

      this.stopDraw();
      entity = this.drawCtrl[type].activate(entity, drawOkCallback);
      return entity;
    }
    //外部控制，完成绘制，比如手机端无法双击结束

  }, {
    key: "endDraw",
    value: function endDraw() {
      for (var type in this.drawCtrl) {
        if (this.drawCtrl[type].endDraw) this.drawCtrl[type].endDraw();
      }
      return this;
    }
  }, {
    key: "stopDraw",
    value: function stopDraw() {
      this.stopEditing();
      for (var type in this.drawCtrl) {
        this.drawCtrl[type].disable(true);
      }
      return this;
    }
  }, {
    key: "closeTooltip",
    value: function closeTooltip() {
      if (!this.tooltip) return;

      this.tooltip.setVisible(false);
      if (this.tiptimeTik) {
        clearTimeout(this.tiptimeTik);
        delete this.tiptimeTik;
      }
    }
    //==========编辑相关==========
    // currEditFeature: null,      //当前编辑的要素

  }, {
    key: "getCurrentEntity",
    value: function getCurrentEntity() {
      return this.currEditFeature;
    }
    // _hasEdit: null,

  }, {
    key: "hasEdit",
    value: function hasEdit(val) {
      if (this._hasEdit !== null && this._hasEdit === val) return;

      this._hasEdit = val;
      if (val) {
        this.bindSelectEvent();
      } else {
        this.stopEditing();
        this.destroySelectEvent();
      }
    }
    //绑定鼠标选中事件

  }, {
    key: "bindSelectEvent",
    value: function bindSelectEvent() {
      var _this2 = this;

      var _that = this;
      //选取对象
      var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      if (this.mouseEdit) {
        //是否开启鼠标编辑事件
        handler.setInputAction(function (event) {
          if (!_this2._hasEdit || _this2.drawing) return; //无法编辑或还在绘制中时，跳出

          var pickedObject = _this2.viewer.scene.pick(event.position, 5, 5);
          if (Cesium.defined(pickedObject)) {
            var entity = pickedObject.id;
            if (_this2.currEditFeature && _this2.currEditFeature === entity) return; //重复单击了跳出

            if (entity && entity instanceof Cesium.Entity && !entity.inProgress && _this2.isMyEntity(entity) && Cesium.defaultValue(entity.hasEdit, true)) {
              _this2.startEditing(entity);
              _this2.closeTooltip();
              if (entity.draw_tooltip) {
                _this2.tooltip.showAt(event.position, entity.draw_tooltip);
              }
              return;
            }
          }
          _this2.stopEditing();
        }, this.options.editEvent == "dblclick" ? Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK : Cesium.ScreenSpaceEventType.LEFT_CLICK);

        if (this.options.editEvent == "dblclick") {
          _Tooltip.message.edit.start = _Tooltip.message.edit.start.replace("单击", "双击");
          this.viewer.das.on(_DasClass2.eventType.clickMap, function (event) {
            _this2.stopEditing();
          });
        }
      } else {
        this.viewer.das.on(_DasClass2.eventType.clickMap, function (event) {
          _this2.stopEditing();
        });
      }

      //编辑提示事件
      handler.setInputAction(function (event) {
        if (!_this2._hasEdit || _this2.drawing) return; //无法编辑或还在绘制中时，跳出

        //正在拖拽其他的entity时，跳出
        if (!_this2.viewer.scene.screenSpaceCameraController.enableInputs) return;

        _this2.closeTooltip();

        var pickedObject = _this2.viewer.scene.pick(event.endPosition, 5, 5);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id;
          if (entity && entity instanceof Cesium.Entity && Cesium.defaultValue(entity.hasEdit, true) && entity.editing && !entity.inProgress && _that.mouseEdit && _this2.isMyEntity(entity)) {
            var tooltip = _this2.tooltip;

            //删除右键菜单打开了不显示tooltip
            if (_this2.viewer.das.contextmenu && _this2.viewer.das.contextmenu.show && _this2.viewer.das.contextmenu.target == entity) return;

            _this2.tiptimeTik = setTimeout(function () {
              //edit中的MOUSE_MOVE会关闭提示，延迟执行。
              tooltip.showAt(event.endPosition, _Tooltip.message.edit.start);
            }, 100);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      this.selectHandler = handler;
    }
  }, {
    key: "destroySelectEvent",
    value: function destroySelectEvent() {
      this.selectHandler && this.selectHandler.destroy();
      this.selectHandler = undefined;
    }
  }, {
    key: "startEditing",
    value: function startEditing(entity) {
      this.stopEditing();
      if (entity == null || !this._hasEdit) return;

      if (entity.editing && entity.editing.activate) {
        entity.editing.activate();
      }
      this.currEditFeature = entity;
    }
  }, {
    key: "stopEditing",
    value: function stopEditing() {
      this.closeTooltip();
      if (this.currEditFeature && this.currEditFeature.editing && this.currEditFeature.editing.disable) {
        this.currEditFeature.editing.disable();
      }
      this.currEditFeature = null;
    }
    //修改了属性

  }, {
    key: "updateAttribute",
    value: function updateAttribute(attribute, entity) {
      if (entity == null) entity = this.currEditFeature;
      if (entity == null || attribute == null) return;

      attribute.style = attribute.style || {};
      attribute.attr = attribute.attr || {};

      //更新属性
      var type = entity.attribute.type;
      this.drawCtrl[type].style2Entity(attribute.style, entity);
      entity.attribute = attribute;

      //如果在编辑状态，更新绑定的拖拽点
      if (entity.editing) {
        if (entity.editing.updateAttrForEditing) entity.editing.updateAttrForEditing();

        if (entity.editing.updateDraggers) entity.editing.updateDraggers();
      }

      return entity;
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(style, entity) {
      if (entity == null) entity = this.currEditFeature;
      if (entity == null) return;

      var type = entity.attribute.type;

      var oldstyle = entity.attribute.style || {};
      for (var key in style) {
        oldstyle[key] = style[key];
      }
      this.drawCtrl[type].style2Entity(oldstyle, entity);
    }

    //修改坐标、高程

  }, {
    key: "setPositions",
    value: function setPositions(positions, entity) {
      if (entity == null) entity = this.currEditFeature;
      if (entity == null || positions == null) return;

      //如果在编辑状态，更新绑定的拖拽点
      if (entity.editing) {
        entity.editing.setPositions(positions);
        entity.editing.updateDraggers();
      }
      return entity;
    }

    //绑定扩展的右键、popup等处理

  }, {
    key: "bindExtension",
    value: function bindExtension(entity) {
      var _this3 = this;

      var that = this;

      entity.eventTarget = this;

      entity.hasDrawEdit = function () {
        return _this3.edit;
      };

      //右键菜单
      entity.contextmenuItems = entity.contextmenuItems || [];
      entity.contextmenuItems.push({
        text: "删除对象",
        iconCls: "fa fa-trash-o",
        visible: function visible(e) {
          that.closeTooltip();

          var entity = e.target;
          if (entity.inProgress && !entity.editing) return false;

          if (Cesium.defined(that.options.hasDel)) {
            if (typeof that.options.hasDel === "function") return that._hasEdit && that.options.hasDel(e);else return that._hasEdit && that.options.hasDel;
          } else return that._hasEdit;
        },
        callback: function callback(e) {
          var entity = e.target;

          if (entity.editing && entity.editing.disable) {
            entity.editing.disable();
          }
          that.deleteEntity(entity);
        }
      });

      //名称 绑定到tooltip
      if (this.options.nameTooltip) {
        entity.tooltip = {
          visible: function visible() {
            return !that._hasEdit;
          },
          html: function html(entity) {
            if (entity.attribute.attr && entity.attribute.attr.name) return entity.attribute.attr.name;else return null;
          }
        };
      }

      if (this.popup) {
        entity.popup = {
          visible: function visible(entity) {
            return that.popup.enable;
          },
          html: function html(entity) {
            var html = util.getPopup([].concat(_toConsumableArray(that.popup.columns), [that.popup.edit ? { field: "id", name: "确定", type: "button" } : null]), entity.attribute.attr, {
              title: that.popup.title || "属性信息",
              edit: that.popup.edit,
              width: 200
            });
            return html;
          },
          onAdd: function onAdd(eleId, entity) {
            //popup的DOM添加到页面的回调方法
            (0, _zepto.zepto)("#" + eleId + " .das3d-popup-btn").click(function (e) {
              (0, _zepto.zepto)("#" + eleId + " .das3d-popup-edititem").each(function () {
                var val = (0, _zepto.zepto)(this).val();
                var key = (0, _zepto.zepto)(this).attr("data-type");
                entity.attribute.attr[key] = val;
              });
              that.viewer.das.popup.close();
              if (that.popup.callback) that.popup.callback();
            });
          },
          onRemove: function onRemove(eleId, entity) {
            //popup的DOM从页面移除的回调方法
          },
          anchor: this.popup.enable.anchor || [0, -20]
        };
      }
    }
    //==========删除相关==========
    //删除单个

  }, {
    key: "deleteEntity",
    value: function deleteEntity(entity) {
      if (entity == null) entity = this.currEditFeature;
      if (entity == null) return;

      if (entity.editing) {
        entity.editing.destroy();
        delete entity.editing;
      }
      if (entity.featureEx) {
        entity.featureEx.destroy();
        delete entity.featureEx;
      }

      if (entity.entityCollection.contains(entity)) entity.entityCollection.remove(entity);

      this.fire(_DasClass2.eventType.delete, { entity: entity });
    }
  }, {
    key: "remove",
    value: function remove(entity) {
      //兼容不同习惯命名
      return this.deleteEntity(entity);
    }
    //是否为当前编辑器编辑的标号

  }, {
    key: "isMyEntity",
    value: function isMyEntity(entity) {
      if (!entity || !(entity instanceof Cesium.Entity)) return false;

      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        if (layer.entities.contains(entity)) return true;
      }
      return false;
    }
  }, {
    key: "removeByGroup",
    value: function removeByGroup(layer) {
      var arrEntity = layer.entities.values;
      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];
        if (entity.editing) {
          entity.editing.destroy();
          delete entity.editing;
        }
        if (entity.featureEx) {
          entity.featureEx.destroy();
          delete entity.featureEx;
        }
      }
      layer.entities.removeAll();
    }
    //删除所有

  }, {
    key: "deleteAll",
    value: function deleteAll() {
      //兼容不同习惯命名
      this.removeAll();
    }
  }, {
    key: "clearDraw",
    value: function clearDraw() {
      //兼容不同习惯命名
      this.removeAll();
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      this.stopDraw();

      for (var i = 0; i < this.arrGroup.length; i++) {
        this.removeByGroup(this.arrGroup[i]);
      }

      return this;
    }
    //==========转换GeoJSON==========
    //转换当前所有为geojson

  }, {
    key: "toGeoJSON",
    value: function toGeoJSON(entity) {
      this.stopDraw();

      if (entity == null) {
        //全部数据
        var features = [];
        var groupName = [];
        for (var k = 0; k < this.arrGroup.length; k++) {
          var layer = this.arrGroup[k];
          groupName.push(layer.name);
          features = features.concat(this.getJsonByGroup(layer));
        }

        return {
          type: "FeatureCollection",
          group: groupName,
          features: features
        };
      } else if (entity instanceof Cesium.CustomDataSource) {
        return {
          type: "FeatureCollection",
          features: this.getJsonByGroup(entity)
        };
      } else {
        var type = entity.attribute.type;
        var geojson = this.drawCtrl[type].toGeoJSON(entity);
        geojson = attr.removeGeoJsonDefVal(geojson);
        return geojson;
      }
    }
  }, {
    key: "getJsonByGroup",
    value: function getJsonByGroup(layer) {
      var features = [];
      var arrEntity = layer.entities.values;
      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];
        if (entity.attribute == null || entity.attribute.type == null) continue;

        var type = entity.attribute.type;
        var geojson = this.drawCtrl[type].toGeoJSON(entity);
        if (geojson == null) continue;
        geojson = attr.removeGeoJsonDefVal(geojson);
        geojson.properties.group = layer.name; //记录分组信息

        features.push(geojson);
      }
      return features;
    }

    //加载goejson数据

  }, {
    key: "jsonToEntity",
    value: function jsonToEntity(json, isClear, isFly) {
      //兼容旧版本方法名
      return this.loadJson(json, {
        clear: isClear,
        flyTo: isFly
      });
    }
  }, {
    key: "loadJson",
    value: function loadJson(json, opts) {
      opts = opts || {};

      var jsonObjs = json;
      try {
        if (util.isString(json)) jsonObjs = JSON.parse(json);
      } catch (e) {
        util.alert(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
        return;
      }

      if (opts.clear) {
        this.clearDraw();
      }

      var arrthis = [];
      var jsonFeatures = jsonObjs.features ? jsonObjs.features : [jsonObjs];

      //存在分组信息
      var groupName = jsonObjs.group;
      if (groupName) {
        for (var k = 0; k < groupName.length; k++) {
          this.addOrGetGroup(groupName[k]);
        }
      }

      for (var i = 0, len = jsonFeatures.length; i < len; i++) {
        var feature = jsonFeatures[i];

        if (!feature.properties || !feature.properties.type) {
          //非本身保存的外部其他geojson数据
          feature.properties = feature.properties || {};
          switch (feature.geometry.type) {
            case "MultiPolygon":
            case "Polygon":
              feature.properties.type = "polygon";
              break;
            case "MultiLineString":
            case "LineString":
              feature.properties.type = "polyline";
              break;
            case "MultiPoint":
            case "Point":
              feature.properties.type = "point";
              break;
          }
        }
        feature.properties.style = opts.style || feature.properties.style || {};
        feature.properties.attr = feature.properties.attr || {};

        if (opts.onEachFeature)
          //添加到地图前 回调方法
          opts.onEachFeature(feature, feature.properties.type, i);

        var type = feature.properties.type;
        if (this.drawCtrl[type] == null) {
          daslog.warn("数据无法识别或者数据的[" + type + "]类型参数有误");
          continue;
        }

        var entity = this.getEntityById(feature.properties.attr.id);
        if (entity) {
          this.updateStyle(feature.properties.style, entity);

          var positions = (0, _point.getPositionByGeoJSON)(feature);
          if (positions) this.setPositions(positions, entity);
        } else {
          entity = this.addFeature(type, feature);
        }

        if (opts.onEachEntity)
          //添加到地图后回调方法
          opts.onEachEntity(feature, entity, i);

        arrthis.push(entity);
      }

      if (opts.flyTo) {
        this.viewer.das.flyTo(arrthis);
      }

      return arrthis;
    }

    //外部添加billboard点数据

  }, {
    key: "addBillboard",
    value: function addBillboard(point, style) {
      if (point instanceof Cesium.Cartesian3) {
        point = pointconvert.cartesian2lonlat(point);
      }
      var type = "billboard";

      var feature = {
        type: "Feature",
        properties: { style: style },
        geometry: { type: "Point", coordinates: point }
      };

      var entity = this.addFeature(type, feature);
      return entity;
    }
    //外部添加billboard点数据

  }, {
    key: "addPoint",
    value: function addPoint(point, style) {
      if (point instanceof Cesium.Cartesian3) {
        point = pointconvert.cartesian2lonlat(point);
      }

      var type = "point";

      var feature = {
        type: "Feature",
        properties: { style: style },
        geometry: { type: "Point", coordinates: point }
      };

      var entity = this.addFeature(type, feature);
      return entity;
    }
    //外部添加线数据

  }, {
    key: "addPolyline",
    value: function addPolyline(coordinates, style) {
      var type = "polyline";

      var feature = {
        type: "Feature",
        properties: { style: style },
        geometry: {
          type: "LineString",
          coordinates: coordinates
        }
      };

      var entity = this.addFeature(type, feature);
      return entity;
    }
    //外部添加面数据

  }, {
    key: "addPolygon",
    value: function addPolygon(coordinates, style) {
      var type = "polygon";

      var feature = {
        type: "Feature",
        properties: { style: style },
        geometry: {
          type: "Polygon",
          coordinates: [coordinates]
        }
      };

      var entity = this.addFeature(type, feature);
      return entity;
    }
    //外部添加数据（内部使用的）

  }, {
    key: "addFeature",
    value: function addFeature(type, geojson) {
      geojson.properties.type = type;
      geojson.properties.style = geojson.properties.style || {};

      //赋默认值
      geojson.properties = attr.addGeoJsonDefVal(geojson.properties);

      //或者分组
      var group = this.addOrGetGroup(geojson.properties.group);

      var entity = this.drawCtrl[type].jsonToEntity(geojson, group);
      this.bindExtension(entity);
      return entity;
    }
    //属性转entity

  }, {
    key: "attributeToEntity",
    value: function attributeToEntity(attribute, positions) {
      var entity = this.drawCtrl[attribute.type].attributeToEntity(attribute, positions);
      this.bindExtension(entity);
      return entity;
    }
    //绑定外部非Draw产生的entity到标绘

  }, {
    key: "bindExtraEntity",
    value: function bindExtraEntity(entity, attribute) {
      attribute = attribute || {};
      attribute.type = attribute.type || attr.getTypeName(entity);
      attribute.style = attribute.style || {};
      // attribute = attr.addGeoJsonDefVal(attribute);

      entity = this.drawCtrl[attribute.type].bindExtraEntity(entity, attribute);
      this.bindExtension(entity);

      entity.entityCollection.remove(entity); //从原有的集合中删除
      this.dataSource.entities.add(entity); //加入到draw集合图层中
    }
    //==========对外接口==========

  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      this._visible = visible;
      if (!visible) {
        this.stopDraw();
      }

      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        layer.show = visible;
      }
    }
    //是否存在绘制

  }, {
    key: "hasDraw",
    value: function hasDraw() {
      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        if (layer.entities.values.length > 0) return true;
      }
      return false;
    }
    //获取所有绘制的实体对象列表

  }, {
    key: "getEntitys",
    value: function getEntitys(noStop) {
      if (!noStop) this.stopDraw();

      var arr = [];
      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        var arrEntity = layer.entities.values;
        for (var j = 0, len = arrEntity.length; j < len; j++) {
          var entity = arrEntity[j];
          entity.attribute.group = layer.name; //记录分组信息
          arr.push(entity);
        }
      }
      return arr;
    }
  }, {
    key: "getEntityById",
    value: function getEntityById(id) {
      if (!id) return null;

      var arrEntity = this.getEntitys();
      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];
        if (id == entity.attribute.attr.id) {
          return entity;
        }
      }
      return null;
    }
    //获取实体的经纬度值 坐标数组

  }, {
    key: "getCoordinates",
    value: function getCoordinates(entity) {
      var type = entity.attribute.type;
      var coor = this.drawCtrl[type].getCoordinates(entity);
      return coor;
    }
    //获取实体的坐标数组

  }, {
    key: "getPositions",
    value: function getPositions(entity) {
      var type = entity.attribute.type;
      var positions = this.drawCtrl[type].getPositions(entity);
      return positions;
    }
  }, {
    key: "flyTo",
    value: function flyTo(entity, opts) {
      this.viewer.das.flyTo(entity, opts);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.stopDraw();
      this.hasEdit(false);

      for (var type in this.drawCtrl) {
        this.drawCtrl[type].destroy();
      }
      delete this.drawCtrl;
      this.clearDraw();

      for (var i = 0; i < this.arrGroup.length; i++) {
        var layer = this.arrGroup[i];
        if (this.viewer.dataSources.contains(layer)) {
          this.viewer.dataSources.remove(layer, true);
        }
      }
      if (this.tooltip) {
        this.tooltip.destroy();
        delete this.tooltip;
      }

      _get(Draw.prototype.__proto__ || Object.getPrototypeOf(Draw.prototype), "destroy", this).call(this);
    }
  }, {
    key: "visible",
    get: function get() {
      return this.getVisible();
    },
    set: function set(val) {
      this.setVisible(val);
    }
  }, {
    key: "edit",
    get: function get() {
      return this._hasEdit;
    },
    set: function set(val) {
      this.hasEdit(val);
    }

    //是否还在绘制中

  }, {
    key: "drawing",
    get: function get() {
      for (var type in this.drawCtrl) {
        if (this.drawCtrl[type].enabled) return true;
      }
      return false;
    }

    //获取所有分组

  }, {
    key: "dataSources",
    get: function get() {
      return this.arrGroup;
    }

    //当前激活的分组

  }, {
    key: "dataSource",
    get: function get() {
      return this._dataSourceAct;
    },
    set: function set(layer) {
      if (this._dataSourceAct) {
        //上一次的取消激活状态
        delete this._dataSourceAct.isActivate;
      }

      this._dataSourceAct = layer;
      if (this._dataSourceAct) {
        //本次的标记为激活状态
        this._dataSourceAct.isActivate = true;
      }

      if (this.drawCtrl) {
        for (var type in this.drawCtrl) {
          this.drawCtrl[type].dataSource = layer;
        }
      }
    }
  }]);

  return Draw;
}(_DasClass2.DasClass);
//[静态属性]本类中支持的事件类型常量


Draw.event = {
  drawStart: _DasClass2.eventType.drawStart,
  drawAddPoint: _DasClass2.eventType.drawAddPoint,
  drawRemovePoint: _DasClass2.eventType.drawRemovePoint,
  drawMouseMove: _DasClass2.eventType.drawMouseMove,
  drawCreated: _DasClass2.eventType.drawCreated,
  editStart: _DasClass2.eventType.editStart,
  editMouseDown: _DasClass2.eventType.editMouseDown,
  editMouseMove: _DasClass2.eventType.editMouseMove,
  editMovePoint: _DasClass2.eventType.editMovePoint,
  editRemovePoint: _DasClass2.eventType.editRemovePoint,
  editStyle: _DasClass2.eventType.editStyle,
  editStop: _DasClass2.eventType.editStop,
  delete: _DasClass2.eventType.delete,
  load: _DasClass2.eventType.load,

  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

//绑定到draw，方便外部使用
Draw.Base = _Draw.DrawBase;
Draw.Billboard = _Draw3.DrawBillboard;
Draw.Circle = _Draw13.DrawCircle;
Draw.Cylinder = _Draw14.DrawCylinder;
Draw.Corridor = _Draw9.DrawCorridor;
Draw.Curve = _Draw7.DrawCurve;
Draw.Ellipsoid = _Draw15.DrawEllipsoid;
Draw.Label = _Draw4.DrawLabel;
Draw.Model = _Draw5.DrawModel;
Draw.Point = _Draw2.DrawPoint;
Draw.Polygon = _Draw10.DrawPolygon;
Draw.Polyline = _Draw6.DrawPolyline;
Draw.PolylineVolume = _Draw8.DrawPolylineVolume;
Draw.Rectangle = _Draw12.DrawRectangle;
Draw.Wall = _Draw16.DrawWall;
Draw.PolygonEx = _Draw11.DrawPolygonEx;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* zepto v1.2.0 - 替代jquery的库 */

//目前主要用到：DOM的操作和事件、ajax请求。
var zepto = function () {
  var undefined,
      key,
      $,
      classList,
      emptyArray = [],
      _concat = emptyArray.concat,
      _filter = emptyArray.filter,
      _slice = emptyArray.slice,
      document = window.document,
      elementDisplay = {},
      classCache = {},
      cssNumber = {
    "column-count": 1,
    columns: 1,
    "font-weight": 1,
    "line-height": 1,
    opacity: 1,
    "z-index": 1,
    zoom: 1
  },
      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
      singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rootNodeRE = /^(?:body|html)$/i,
      capitalRE = /([A-Z])/g,

  // special attributes that should be get/set via method calls
  methodAttributes = ["val", "css", "html", "text", "data", "width", "height", "offset"],
      adjacencyOperators = ["after", "prepend", "before", "append"],
      table = document.createElement("table"),
      tableRow = document.createElement("tr"),
      containers = {
    tr: document.createElement("tbody"),
    tbody: table,
    thead: table,
    tfoot: table,
    td: tableRow,
    th: tableRow,
    "*": document.createElement("div")
  },
      readyRE = /complete|loaded|interactive/,
      simpleSelectorRE = /^[\w-]*$/,
      class2type = {},
      toString = class2type.toString,
      zepto = {},
      camelize,
      uniq,
      tempParent = document.createElement("div"),
      propMap = {
    tabindex: "tabIndex",
    readonly: "readOnly",
    for: "htmlFor",
    class: "className",
    maxlength: "maxLength",
    cellspacing: "cellSpacing",
    cellpadding: "cellPadding",
    rowspan: "rowSpan",
    colspan: "colSpan",
    usemap: "useMap",
    frameborder: "frameBorder",
    contenteditable: "contentEditable"
  },
      isArray = Array.isArray || function (object) {
    return object instanceof Array;
  };

  zepto.matches = function (element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false;
    var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;
    if (matchesSelector) return matchesSelector.call(element, selector);
    // fall back to performing a selector:
    var match,
        parent = element.parentNode,
        temp = !parent;
    if (temp) (parent = tempParent).appendChild(element);
    match = ~zepto.qsa(parent, selector).indexOf(element);
    temp && tempParent.removeChild(element);
    return match;
  };

  function type(obj) {
    return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
  }

  function isFunction(value) {
    return type(value) == "function";
  }
  function isWindow(obj) {
    return obj != null && obj == obj.window;
  }
  function isDocument(obj) {
    return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
  }
  function isObject(obj) {
    return type(obj) == "object";
  }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
  }

  function likeArray(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = $.type(obj);

    return "function" != type && !isWindow(obj) && ("array" == type || length === 0 || typeof length == "number" && length > 0 && length - 1 in obj);
  }

  function compact(array) {
    return _filter.call(array, function (item) {
      return item != null;
    });
  }
  function flatten(array) {
    return array.length > 0 ? $.fn.concat.apply([], array) : array;
  }
  camelize = function camelize(str) {
    return str.replace(/-+(.)?/g, function (match, chr) {
      return chr ? chr.toUpperCase() : "";
    });
  };
  function dasherize(str) {
    return str.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase();
  }
  uniq = function uniq(array) {
    return _filter.call(array, function (item, idx) {
      return array.indexOf(item) == idx;
    });
  };

  function classRE(name) {
    return name in classCache ? classCache[name] : classCache[name] = new RegExp("(^|\\s)" + name + "(\\s|$)");
  }

  function maybeAddPx(name, value) {
    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  function defaultDisplay(nodeName) {
    var element, display;
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName);
      document.body.appendChild(element);
      display = getComputedStyle(element, "").getPropertyValue("display");
      element.parentNode.removeChild(element);
      display == "none" && (display = "block");
      elementDisplay[nodeName] = display;
    }
    return elementDisplay[nodeName];
  }

  function _children(element) {
    return "children" in element ? _slice.call(element.children) : $.map(element.childNodes, function (node) {
      if (node.nodeType == 1) return node;
    });
  }

  function Z(dom, selector) {
    var i,
        len = dom ? dom.length : 0;
    for (i = 0; i < len; i++) {
      this[i] = dom[i];
    }this.length = len;
    this.selector = selector || "";
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function (html, name, properties) {
    var dom, nodes, container;

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;
      if (!(name in containers)) name = "*";

      container = containers[name];
      container.innerHTML = "" + html;
      dom = $.each(_slice.call(container.childNodes), function () {
        container.removeChild(this);
      });
    }

    if (isPlainObject(properties)) {
      nodes = $(dom);
      $.each(properties, function (key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value);else nodes.attr(key, value);
      });
    }

    return dom;
  };

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function (dom, selector) {
    return new Z(dom, selector);
  };

  // `$.zepto.isZ` should return `true` if the given object is a zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function (object) {
    return object instanceof zepto.Z;
  };

  // `$.zepto.init` is zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function (selector, context) {
    var dom;
    // If nothing given, return an empty zepto collection
    if (!selector) return zepto.Z();
    // Optimize for string selectors
    else if (typeof selector == "string") {
        selector = selector.trim();
        // If it's a html fragment, create nodes from it
        // Note: In both Chrome 21 and Firefox 15, DOM error 12
        // is thrown if the fragment doesn't begin with <
        if (selector[0] == "<" && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null;
        // If there's a context, create a collection on that context first, and select
        // nodes from there
        else if (context !== undefined) return $(context).find(selector);
          // If it's a CSS selector, use it to select nodes.
          else dom = zepto.qsa(document, selector);
      }
      // If a function is given, call it when the DOM is ready
      else if (isFunction(selector)) return $(document).ready(selector);
        // If a zepto collection is given, just return it
        else if (zepto.isZ(selector)) return selector;else {
            // normalize array if an array of nodes is given
            if (isArray(selector)) dom = compact(selector);
            // Wrap DOM nodes.
            else if (isObject(selector)) {
                if (selector.length > 0) dom = selector, selector = null;else dom = [selector], selector = null;
              }
              // If it's a html fragment, create nodes from it
              else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null;
                // If there's a context, create a collection on that context first, and select
                // nodes from there
                else if (context !== undefined) return $(context).find(selector);
                  // And last but no least, if it's a CSS selector, use it to select nodes.
                  else dom = zepto.qsa(document, selector);
          }
    // create a new zepto collection from the nodes found
    return zepto.Z(dom, selector);
  };

  // `$` will be the base `zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating zepto collections
  // patchable in plugins.
  $ = function $(selector, context) {
    return zepto.init(selector, context);
  };

  function extend(target, source, deep) {
    for (key in source) {
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};
        if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
        extend(target[key], source[key], deep);
      } else if (source[key] !== undefined) target[key] = source[key];
    }
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function (target) {
    var deep,
        args = _slice.call(arguments, 1);
    if (typeof target == "boolean") {
      deep = target;
      target = args.shift();
    }
    args.forEach(function (arg) {
      extend(target, arg, deep);
    });
    return target;
  };

  // `$.zepto.qsa` is zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function (element, selector) {
    var found,
        maybeID = selector[0] == "#",
        maybeClass = !maybeID && selector[0] == ".",
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
        // Ensure that a 1 char tag name still gets checked
    isSimple = simpleSelectorRE.test(nameOnly);
    return element.getElementById && isSimple && maybeID // Safari DocumentFragment doesn't have getElementById
    ? // eslint-disable-next-line no-cond-assign
    (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11 ? [] : _slice.call(isSimple && !maybeID && element.getElementsByClassName // DocumentFragment doesn't have getElementsByClassName/TagName
    ? maybeClass ? element.getElementsByClassName(nameOnly) // If it's simple, it could be a class
    : element.getElementsByTagName(selector) // Or a tag
    : element.querySelectorAll(selector) // Or it's not simple, and we need to query all
    );
  };

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector);
  }

  $.contains = document.documentElement.contains ? function (parent, node) {
    return parent !== node && parent.contains(node);
  } : function (parent, node) {
    while (node && (node = node.parentNode)) {
      if (node === parent) return true;
    }return false;
  };

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg;
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value) {
    var klass = node.className || "",
        svg = klass && klass.baseVal !== undefined;

    if (value === undefined) return svg ? klass.baseVal : klass;
    svg ? klass.baseVal = value : node.className = value;
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ? value == "true" || (value == "false" ? false : value == "null" ? null : +value + "" == value ? +value : // eslint-disable-next-line no-useless-escape
      /^[\[\{]/.test(value) ? $.parseJSON(value) : value) : value;
    } catch (e) {
      return value;
    }
  }

  $.type = type;
  $.isFunction = isFunction;
  $.isWindow = isWindow;
  $.isArray = isArray;
  $.isPlainObject = isPlainObject;

  $.isEmptyObject = function (obj) {
    var name;
    for (name in obj) {
      return false;
    }return true;
  };

  $.isNumeric = function (val) {
    var num = Number(val),
        type = typeof val === "undefined" ? "undefined" : _typeof(val);
    return val != null && type != "boolean" && (type != "string" || val.length) && !isNaN(num) && isFinite(num) || false;
  };

  $.inArray = function (elem, array, i) {
    return emptyArray.indexOf.call(array, elem, i);
  };

  $.camelCase = camelize;
  $.trim = function (str) {
    return str == null ? "" : String.prototype.trim.call(str);
  };

  // plugin compatibility
  $.uuid = 0;
  $.support = {};
  $.expr = {};
  $.noop = function () {};

  $.map = function (elements, callback) {
    var value,
        values = [],
        i,
        key;
    if (likeArray(elements)) for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);
      if (value != null) values.push(value);
    } else for (key in elements) {
      value = callback(elements[key], key);
      if (value != null) values.push(value);
    }
    return flatten(values);
  };

  $.each = function (elements, callback) {
    var i, key;
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++) {
        if (callback.call(elements[i], i, elements[i]) === false) return elements;
      }
    } else {
      for (key in elements) {
        if (callback.call(elements[key], key, elements[key]) === false) return elements;
      }
    }

    return elements;
  };

  $.grep = function (elements, callback) {
    return _filter.call(elements, callback);
  };

  if (window.JSON) $.parseJSON = JSON.parse;

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  // Define methods that will be available on all
  // zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function concat() {
      var i,
          value,
          args = [];
      for (i = 0; i < arguments.length; i++) {
        value = arguments[i];
        args[i] = zepto.isZ(value) ? value.toArray() : value;
      }
      return _concat.apply(zepto.isZ(this) ? this.toArray() : this, args);
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },

    ready: function ready(callback) {
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($);else document.addEventListener("DOMContentLoaded", function () {
        callback($);
      }, false);
      return this;
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    toArray: function toArray() {
      return this.get();
    },
    size: function size() {
      return this.length;
    },
    remove: function remove() {
      return this.each(function () {
        if (this.parentNode != null) this.parentNode.removeChild(this);
      });
    },
    each: function each(callback) {
      emptyArray.every.call(this, function (el, idx) {
        return callback.call(el, idx, el) !== false;
      });
      return this;
    },
    filter: function filter(selector) {
      if (isFunction(selector)) return this.not(this.not(selector));
      return $(_filter.call(this, function (element) {
        return zepto.matches(element, selector);
      }));
    },
    add: function add(selector, context) {
      return $(uniq(this.concat($(selector, context))));
    },
    is: function is(selector) {
      return this.length > 0 && zepto.matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];
      if (isFunction(selector) && selector.call !== undefined) this.each(function (idx) {
        if (!selector.call(this, idx)) nodes.push(this);
      });else {
        var excludes = typeof selector == "string" ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);
        this.forEach(function (el) {
          if (excludes.indexOf(el) < 0) nodes.push(el);
        });
      }
      return $(nodes);
    },
    has: function has(selector) {
      return this.filter(function () {
        return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();
      });
    },
    eq: function eq(idx) {
      return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
    },
    first: function first() {
      var el = this[0];
      return el && !isObject(el) ? el : $(el);
    },
    last: function last() {
      var el = this[this.length - 1];
      return el && !isObject(el) ? el : $(el);
    },
    find: function find(selector) {
      var result,
          $this = this;
      if (!selector) result = $();else if ((typeof selector === "undefined" ? "undefined" : _typeof(selector)) == "object") result = $(selector).filter(function () {
        var node = this;
        return emptyArray.some.call($this, function (parent) {
          return $.contains(parent, node);
        });
      });else if (this.length == 1) result = $(zepto.qsa(this[0], selector));else result = this.map(function () {
        return zepto.qsa(this, selector);
      });
      return result;
    },
    closest: function closest(selector, context) {
      var nodes = [],
          collection = (typeof selector === "undefined" ? "undefined" : _typeof(selector)) == "object" && $(selector);
      this.each(function (_, node) {
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) {
          node = node !== context && !isDocument(node) && node.parentNode;
        }if (node && nodes.indexOf(node) < 0) nodes.push(node);
      });
      return $(nodes);
    },
    parents: function parents(selector) {
      var ancestors = [],
          nodes = this;
      while (nodes.length > 0) {
        nodes = $.map(nodes, function (node) {
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node);
            return node;
          }
        });
      }return filtered(ancestors, selector);
    },
    parent: function parent(selector) {
      return filtered(uniq(this.pluck("parentNode")), selector);
    },
    children: function children(selector) {
      return filtered(this.map(function () {
        return _children(this);
      }), selector);
    },
    contents: function contents() {
      return this.map(function () {
        return this.contentDocument || _slice.call(this.childNodes);
      });
    },
    siblings: function siblings(selector) {
      return filtered(this.map(function (i, el) {
        return _filter.call(_children(el.parentNode), function (child) {
          return child !== el;
        });
      }), selector);
    },
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = "";
      });
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function pluck(property) {
      return $.map(this, function (el) {
        return el[property];
      });
    },
    show: function show() {
      return this.each(function () {
        this.style.display == "none" && (this.style.display = "");
        if (getComputedStyle(this, "").getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName);
      });
    },
    replaceWith: function replaceWith(newContent) {
      return this.before(newContent).remove();
    },
    wrap: function wrap(structure) {
      var func = isFunction(structure);
      if (this[0] && !func) var dom = $(structure).get(0),
          clone = dom.parentNode || this.length > 1;

      return this.each(function (index) {
        $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
      });
    },
    wrapAll: function wrapAll(structure) {
      if (this[0]) {
        $(this[0]).before(structure = $(structure));
        var children;
        // drill down to the inmost element
        while ((children = structure.children()).length) {
          structure = children.first();
        }$(structure).append(this);
      }
      return this;
    },
    wrapInner: function wrapInner(structure) {
      var func = isFunction(structure);
      return this.each(function (index) {
        var self = $(this),
            contents = self.contents(),
            dom = func ? structure.call(this, index) : structure;
        contents.length ? contents.wrapAll(dom) : self.append(dom);
      });
    },
    unwrap: function unwrap() {
      this.parent().each(function () {
        $(this).replaceWith($(this).children());
      });
      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    hide: function hide() {
      return this.css("display", "none");
    },
    toggle: function toggle(setting) {
      return this.each(function () {
        var el = $(this);
        (setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
      });
    },
    prev: function prev(selector) {
      return $(this.pluck("previousElementSibling")).filter(selector || "*");
    },
    next: function next(selector) {
      return $(this.pluck("nextElementSibling")).filter(selector || "*");
    },
    html: function html(_html) {
      return 0 in arguments ? this.each(function (idx) {
        var originHtml = this.innerHTML;
        $(this).empty().append(funcArg(this, _html, idx, originHtml));
      }) : 0 in this ? this[0].innerHTML : null;
    },
    text: function text(_text) {
      return 0 in arguments ? this.each(function (idx) {
        var newText = funcArg(this, _text, idx, this.textContent);
        this.textContent = newText == null ? "" : "" + newText;
      }) : 0 in this ? this.pluck("textContent").join("") : null;
    },
    attr: function attr(name, value) {
      var result;
      return typeof name == "string" && !(1 in arguments) ? 0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined : this.each(function (idx) {
        if (this.nodeType !== 1) return;
        if (isObject(name)) for (key in name) {
          setAttribute(this, key, name[key]);
        } else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));
      });
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        this.nodeType === 1 && name.split(" ").forEach(function (attribute) {
          setAttribute(this, attribute);
        }, this);
      });
    },
    prop: function prop(name, value) {
      name = propMap[name] || name;
      return 1 in arguments ? this.each(function (idx) {
        this[name] = funcArg(this, value, idx, this[name]);
      }) : this[0] && this[0][name];
    },
    removeProp: function removeProp(name) {
      name = propMap[name] || name;
      return this.each(function () {
        delete this[name];
      });
    },
    data: function data(name, value) {
      var attrName = "data-" + name.replace(capitalRE, "-$1").toLowerCase();

      var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName);

      return data !== null ? deserializeValue(data) : undefined;
    },
    val: function val(value) {
      if (0 in arguments) {
        if (value == null) value = "";
        return this.each(function (idx) {
          this.value = funcArg(this, value, idx, this.value);
        });
      } else {
        return this[0] && (this[0].multiple ? $(this[0]).find("option").filter(function () {
          return this.selected;
        }).pluck("value") : this[0].value);
      }
    },
    offset: function offset(coordinates) {
      if (coordinates) return this.each(function (index) {
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
          top: coords.top - parentOffset.top,
          left: coords.left - parentOffset.left
        };

        if ($this.css("position") == "static") props["position"] = "relative";
        $this.css(props);
      });
      if (!this.length) return null;
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0])) return { top: 0, left: 0 };
      var obj = this[0].getBoundingClientRect();

      obj.width = this[0].offsetWidth; //wanghao 2020-3-22 add
      obj.height = this[0].offsetHeight;

      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      };
    },
    css: function css(property, value) {
      if (arguments.length < 2) {
        var element = this[0];
        if (typeof property == "string") {
          if (!element) return;
          return element.style[camelize(property)] || getComputedStyle(element, "").getPropertyValue(property);
        } else if (isArray(property)) {
          if (!element) return;
          var props = {};
          var computedStyle = getComputedStyle(element, "");
          $.each(property, function (_, prop) {
            props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
          });
          return props;
        }
      }

      var css = "";
      if (type(property) == "string") {
        if (!value && value !== 0) this.each(function () {
          this.style.removeProperty(dasherize(property));
        });else css = dasherize(property) + ":" + maybeAddPx(property, value);
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) this.each(function () {
            this.style.removeProperty(dasherize(key));
          });else css += dasherize(key) + ":" + maybeAddPx(key, property[key]) + ";";
        }
      }

      return this.each(function () {
        if (!this.style) return;
        this.style.cssText += ";" + css;
      });
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    hasClass: function hasClass(name) {
      if (!name) return false;
      return emptyArray.some.call(this, function (el) {
        return this.test(className(el));
      }, classRE(name));
    },
    addClass: function addClass(name) {
      if (!name) return this;
      return this.each(function (idx) {
        if (!("className" in this)) return;
        classList = [];
        var cls = className(this),
            newName = funcArg(this, name, idx, cls);
        newName.split(/\s+/g).forEach(function (klass) {
          if (!$(this).hasClass(klass)) classList.push(klass);
        }, this);
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
      });
    },
    removeClass: function removeClass(name) {
      return this.each(function (idx) {
        if (!("className" in this)) return;
        if (name === undefined) return className(this, "");
        classList = className(this);
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function (klass) {
          classList = classList.replace(classRE(klass), " ");
        });
        className(this, classList.trim());
      });
    },
    toggleClass: function toggleClass(name, when) {
      if (!name) return this;
      return this.each(function (idx) {
        var $this = $(this),
            names = funcArg(this, name, idx, className(this));
        names.split(/\s+/g).forEach(function (klass) {
          (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);
        });
      });
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) return;
      var hasScrollTop = "scrollTop" in this[0];
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) return;
      var hasScrollLeft = "scrollLeft" in this[0];
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    position: function position() {
      if (!this.length) return;

      var elem = this[0],

      // Get *real* offsetParent
      offsetParent = this.offsetParent(),

      // Get correct offsets
      offset = this.offset(),
          parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top -= parseFloat($(elem).css("margin-top")) || 0;
      offset.left -= parseFloat($(elem).css("margin-left")) || 0;

      // Add offsetParent borders
      parentOffset.top += parseFloat($(offsetParent[0]).css("border-top-width")) || 0;
      parentOffset.left += parseFloat($(offsetParent[0]).css("border-left-width")) || 0;

      // Subtract the two offsets
      return {
        top: offset.top - parentOffset.top,
        left: offset.left - parentOffset.left
      };
    },
    offsetParent: function offsetParent() {
      return this.map(function () {
        var parent = this.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static") {
          parent = parent.offsetParent;
        }return parent;
      });
    }
  };

  // for now
  $.fn.detach = $.fn.remove;

  // Generate the `width` and `height` functions
  ["width", "height"].forEach(function (dimension) {
    var dimensionProperty = dimension.replace(/./, function (m) {
      return m[0].toUpperCase();
    });

    $.fn[dimension] = function (value) {
      var offset,
          el = this[0];
      if (value === undefined) return isWindow(el) ? el["inner" + dimensionProperty] : isDocument(el) ? el.documentElement["scroll" + dimensionProperty] : (offset = this.offset()) && offset[dimension];else return this.each(function (idx) {
        el = $(this);
        el.css(dimension, funcArg(this, value, idx, el[dimension]()));
      });
    };
  });

  function traverseNode(node, fun) {
    fun(node);
    for (var i = 0, len = node.childNodes.length; i < len; i++) {
      traverseNode(node.childNodes[i], fun);
    }
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function (operator, operatorIndex) {
    var inside = operatorIndex % 2; //=> prepend, append

    $.fn[operator] = function () {
      // arguments can be nodes, arrays of nodes, zepto objects and HTML strings
      var argType,
          nodes = $.map(arguments, function (arg) {
        var arr = [];
        argType = type(arg);
        if (argType == "array") {
          arg.forEach(function (el) {
            if (el.nodeType !== undefined) return arr.push(el);else if ($.zepto.isZ(el)) return arr = arr.concat(el.get());
            arr = arr.concat(zepto.fragment(el));
          });
          return arr;
        }
        return argType == "object" || arg == null ? arg : zepto.fragment(arg);
      }),
          parent,
          copyByClone = this.length > 1;
      if (nodes.length < 1) return this;

      return this.each(function (_, target) {
        parent = inside ? target : target.parentNode;

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;

        var parentInDocument = $.contains(document.documentElement, parent);

        nodes.forEach(function (node) {
          if (copyByClone) node = node.cloneNode(true);else if (!parent) return $(node).remove();

          parent.insertBefore(node, target);
          if (parentInDocument) traverseNode(node, function (el) {
            if (el.nodeName != null && el.nodeName.toUpperCase() === "SCRIPT" && (!el.type || el.type === "text/javascript") && !el.src) {
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target["eval"].call(target, el.innerHTML);
            }
          });
        });
      });
    };

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator + "To" : "insert" + (operatorIndex ? "Before" : "After")] = function (html) {
      $(html)[operator](this);
      return this;
    };
  });

  zepto.Z.prototype = Z.prototype = $.fn;

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq;
  zepto.deserializeValue = deserializeValue;
  $.zepto = zepto;

  return $;
}();

(function ($) {
  var _zid = 1,
      undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function isString(obj) {
    return typeof obj == "string";
  },
      handlers = {},
      specialEvents = {},
      focusinSupported = "onfocusin" in window,
      focus = { focus: "focusin", blur: "focusout" },
      hover = { mouseenter: "mouseover", mouseleave: "mouseout" };

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = "MouseEvents";

  function zid(element) {
    return element._zid || (element._zid = _zid++);
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event);
    if (event.ns) var matcher = matcherFor(event.ns);
    return (handlers[zid(element)] || []).filter(function (handler) {
      return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);
    });
  }
  function parse(event) {
    var parts = ("" + event).split(".");
    return {
      e: parts[0],
      ns: parts.slice(1).sort().join(" ")
    };
  }
  function matcherFor(ns) {
    return new RegExp("(?:^| )" + ns.replace(" ", " .* ?") + "(?: |$)");
  }

  function eventCapture(handler, captureSetting) {
    return handler.del && !focusinSupported && handler.e in focus || !!captureSetting;
  }

  function realEvent(type) {
    return hover[type] || focusinSupported && focus[type] || type;
  }

  function add(element, events, fn, data, selector, delegator, capture) {
    var id = zid(element),
        set = handlers[id] || (handlers[id] = []);
    events.split(/\s/).forEach(function (event) {
      if (event == "ready") return $(document).ready(fn);
      var handler = parse(event);
      handler.fn = fn;
      handler.sel = selector;
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function fn(e) {
        var related = e.relatedTarget;
        if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);
      };
      handler.del = delegator;
      var callback = delegator || fn;
      handler.proxy = function (e) {
        e = compatible(e);
        if (e.isImmediatePropagationStopped()) return;
        e.data = data;
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));
        if (result === false) e.preventDefault(), e.stopPropagation();
        return result;
      };
      handler.i = set.length;
      set.push(handler);
      if ("addEventListener" in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
    });
  }
  function remove(element, events, fn, selector, capture) {
    var id = zid(element);
    (events || "").split(/\s/).forEach(function (event) {
      findHandlers(element, event, fn, selector).forEach(function (handler) {
        delete handlers[id][handler.i];
        if ("removeEventListener" in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
      });
    });
  }

  $.event = { add: add, remove: remove };

  $.proxy = function (fn, context) {
    var args = 2 in arguments && slice.call(arguments, 2);
    if (isFunction(fn)) {
      var proxyFn = function proxyFn() {
        return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
      };
      proxyFn._zid = zid(fn);
      return proxyFn;
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn);
        return $.proxy.apply(null, args);
      } else {
        return $.proxy(fn[context], fn);
      }
    } else {
      throw new TypeError("expected function");
    }
  };

  $.fn.bind = function (event, data, callback) {
    return this.on(event, data, callback);
  };
  $.fn.unbind = function (event, callback) {
    return this.off(event, callback);
  };
  $.fn.one = function (event, selector, data, callback) {
    return this.on(event, selector, data, callback, 1);
  };

  var returnTrue = function returnTrue() {
    return true;
  },
      returnFalse = function returnFalse() {
    return false;
  },
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
    preventDefault: "isDefaultPrevented",
    stopImmediatePropagation: "isImmediatePropagationStopped",
    stopPropagation: "isPropagationStopped"
  };

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event);

      $.each(eventMethods, function (name, predicate) {
        var sourceMethod = source[name];
        event[name] = function () {
          this[predicate] = returnTrue;
          return sourceMethod && sourceMethod.apply(source, arguments);
        };
        event[predicate] = returnFalse;
      });

      event.timeStamp || (event.timeStamp = Date.now());

      if (source.defaultPrevented !== undefined ? source.defaultPrevented : "returnValue" in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;
    }
    return event;
  }

  function createProxy(event) {
    var key,
        proxy = { originalEvent: event };
    for (key in event) {
      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];
    }return compatible(proxy, event);
  }

  $.fn.delegate = function (selector, event, callback) {
    return this.on(event, selector, callback);
  };
  $.fn.undelegate = function (selector, event, callback) {
    return this.off(event, selector, callback);
  };

  $.fn.live = function (event, callback) {
    $(document.body).delegate(this.selector, event, callback);
    return this;
  };
  $.fn.die = function (event, callback) {
    $(document.body).undelegate(this.selector, event, callback);
    return this;
  };

  $.fn.on = function (event, selector, data, callback, one) {
    var autoRemove,
        delegator,
        $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.on(type, selector, data, fn, one);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, data = selector, selector = undefined;
    if (callback === undefined || data === false) callback = data, data = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function (_, element) {
      if (one) autoRemove = function autoRemove(e) {
        remove(element, e.type, callback);
        return callback.apply(this, arguments);
      };

      if (selector) delegator = function delegator(e) {
        var evt,
            match = $(e.target).closest(selector, element).get(0);
        if (match && match !== element) {
          evt = $.extend(createProxy(e), { currentTarget: match, liveFired: element });
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)));
        }
      };

      add(element, event, callback, data, selector, delegator || autoRemove);
    });
  };
  $.fn.off = function (event, selector, callback) {
    var $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.off(type, selector, fn);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, selector = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function () {
      remove(this, event, callback, selector);
    });
  };

  $.fn.trigger = function (event, args) {
    event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);
    event._args = args;
    return this.each(function () {
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]();
      // items in the collection might not be DOM elements
      else if ("dispatchEvent" in this) this.dispatchEvent(event);else $(this).triggerHandler(event, args);
    });
  };

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function (event, args) {
    var e, result;
    this.each(function (i, element) {
      e = createProxy(isString(event) ? $.Event(event) : event);
      e._args = args;
      e.target = element;
      $.each(findHandlers(element, event.type || event), function (i, handler) {
        result = handler.proxy(e);
        if (e.isImmediatePropagationStopped()) return false;
      });
    });
    return result;
  };

  // shortcut methods for `.bind(event, fn)` for each event type
  ("focusin focusout focus blur load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select keydown keypress keyup error").split(" ").forEach(function (event) {
    $.fn[event] = function (callback) {
      return 0 in arguments ? this.bind(event, callback) : this.trigger(event);
    };
  });

  $.Event = function (type, props) {
    if (!isString(type)) props = type, type = props.type;
    var event = document.createEvent(specialEvents[type] || "Events"),
        bubbles = true;
    if (props) for (var name in props) {
      name == "bubbles" ? bubbles = !!props[name] : event[name] = props[name];
    }event.initEvent(type, bubbles, true);
    return compatible(event);
  };
})(zepto);

(function ($) {
  var jsonpID = +new Date(),
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = "application/json",
      htmlType = "text/html",
      blankRE = /^\s*$/,
      originAnchor = document.createElement("a");

  originAnchor.href = window.location.href;

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName);
    $(context).trigger(event, data);
    return !event.isDefaultPrevented();
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data);
  }

  // Number of active Ajax requests
  $.active = 0;

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, "ajaxStart");
  }
  function ajaxStop(settings) {
    if (settings.global && ! --$.active) triggerGlobal(settings, null, "ajaxStop");
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context;
    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, "ajaxBeforeSend", [xhr, settings]) === false) return false;

    triggerGlobal(settings, context, "ajaxSend", [xhr, settings]);
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context,
        status = "success";
    settings.success.call(context, data, status, xhr);
    if (deferred) deferred.resolveWith(context, [data, status, xhr]);
    triggerGlobal(settings, context, "ajaxSuccess", [xhr, settings, data]);
    ajaxComplete(status, xhr, settings);
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context;
    settings.error.call(context, xhr, type, error);
    if (deferred) deferred.rejectWith(context, [xhr, type, error]);
    triggerGlobal(settings, context, "ajaxError", [xhr, settings, error || type]);
    ajaxComplete(type, xhr, settings);
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context;
    settings.complete.call(context, xhr, status);
    triggerGlobal(settings, context, "ajaxComplete", [xhr, settings]);
    ajaxStop(settings);
  }

  function ajaxDataFilter(data, type, settings) {
    if (settings.dataFilter == empty) return data;
    var context = settings.context;
    return settings.dataFilter.call(context, data, type);
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function (options, deferred) {
    if (!("type" in options)) return $.ajax(options);

    var _callbackName = options.jsonpCallback,
        callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || "Zepto" + jsonpID++,
        script = document.createElement("script"),
        originalCallback = window[callbackName],
        responseData,
        abort = function abort(errorType) {
      $(script).triggerHandler("error", errorType || "abort");
    },
        xhr = { abort: abort },
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    $(script).on("load error", function (e, errorType) {
      clearTimeout(abortTimeout);
      $(script).off().remove();

      if (e.type == "error" || !responseData) {
        ajaxError(null, errorType || "error", xhr, options, deferred);
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred);
      }

      window[callbackName] = originalCallback;
      if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);

      originalCallback = responseData = undefined;
    });

    if (ajaxBeforeSend(xhr, options) === false) {
      abort("abort");
      return xhr;
    }

    window[callbackName] = function () {
      responseData = arguments;
    };

    script.src = options.url.replace(/\?(.+)=\?/, "?$1=" + callbackName);
    document.head.appendChild(script);

    if (options.timeout > 0) abortTimeout = setTimeout(function () {
      abort("timeout");
    }, options.timeout);

    return xhr;
  };

  $.ajaxSettings = {
    // Default type of request
    type: "GET",
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function xhr() {
      return new window.XMLHttpRequest();
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: "text/javascript, application/javascript, application/x-javascript",
      json: jsonType,
      xml: "application/xml, text/xml",
      html: htmlType,
      text: "text/plain"
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true,
    //Used to handle the raw response data of XMLHttpRequest.
    //This is a pre-filtering function to sanitize the response.
    //The sanitized response should be returned
    dataFilter: empty
  };

  function mimeToDataType(mime) {
    if (mime) mime = mime.split(";", 2)[0];
    return mime && (mime == htmlType ? "html" : mime == jsonType ? "json" : scriptTypeRE.test(mime) ? "script" : xmlTypeRE.test(mime) && "xml") || "text";
  }

  function appendQuery(url, query) {
    if (query == "") return url;
    return (url + "&" + query).replace(/[&?]{1,2}/, "?");
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string") options.data = $.param(options.data, options.traditional);
    if (options.data && (!options.type || options.type.toUpperCase() == "GET" || "jsonp" == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined;
  }

  $.ajax = function (options) {
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor,
        hashIndex;
    for (key in $.ajaxSettings) {
      if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];
    }ajaxStart(settings);

    if (!settings.crossDomain) {
      urlAnchor = document.createElement("a");
      urlAnchor.href = settings.url;
      settings.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
    }

    if (!settings.url) settings.url = window.location.toString();
    if ((hashIndex = settings.url.indexOf("#")) > -1) settings.url = settings.url.slice(0, hashIndex);
    serializeData(settings);

    var dataType = settings.dataType,
        hasPlaceholder = /\?.+=\?/.test(settings.url);
    if (hasPlaceholder) dataType = "jsonp";

    if (settings.cache === false || (!options || options.cache !== true) && ("script" == dataType || "jsonp" == dataType)) settings.url = appendQuery(settings.url, "_=" + Date.now());

    if ("jsonp" == dataType) {
      if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + "=?" : settings.jsonp === false ? "" : "callback=?");
      return $.ajaxJSONP(settings, deferred);
    }

    var mime = settings.accepts[dataType],
        headers = {},
        setHeader = function setHeader(name, value) {
      headers[name.toLowerCase()] = [name, value];
    },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    if (!settings.crossDomain) setHeader("X-Requested-With", "XMLHttpRequest");
    setHeader("Accept", mime || "*/*");
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(",") > -1) mime = mime.split(",", 2)[0];
      xhr.overrideMimeType && xhr.overrideMimeType(mime);
    }
    if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != "GET") setHeader("Content-Type", settings.contentType || "application/x-www-form-urlencoded");

    if (settings.headers) for (name in settings.headers) {
      setHeader(name, settings.headers[name]);
    }xhr.setRequestHeader = setHeader;

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty;
        clearTimeout(abortTimeout);
        var result,
            error = false;
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == "file:") {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader("content-type"));

          if (xhr.responseType == "arraybuffer" || xhr.responseType == "blob") result = xhr.response;else {
            result = xhr.responseText;

            try {
              // http://perfectionkills.com/global-eval-what-are-the-options/
              // sanitize response accordingly if data filter callback provided
              result = ajaxDataFilter(result, dataType, settings);
              if (dataType == "script") (1, eval)(result);else if (dataType == "xml") result = xhr.responseXML;else if (dataType == "json") result = blankRE.test(result) ? null : $.parseJSON(result);
            } catch (e) {
              error = e;
            }

            if (error) return ajaxError(error, "parsererror", xhr, settings, deferred);
          }

          ajaxSuccess(result, xhr, settings, deferred);
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? "error" : "abort", xhr, settings, deferred);
        }
      }
    };

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort();
      ajaxError(null, "abort", xhr, settings, deferred);
      return xhr;
    }

    var async = "async" in settings ? settings.async : true;
    xhr.open(settings.type, settings.url, async, settings.username, settings.password);

    if (settings.xhrFields) for (name in settings.xhrFields) {
      xhr[name] = settings.xhrFields[name];
    }for (name in headers) {
      nativeSetHeader.apply(xhr, headers[name]);
    }if (settings.timeout > 0) abortTimeout = setTimeout(function () {
      xhr.onreadystatechange = empty;
      xhr.abort();
      ajaxError(null, "timeout", xhr, settings, deferred);
    }, settings.timeout);

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null);
    return xhr;
  };

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) dataType = success, success = data, data = undefined;
    if (!$.isFunction(success)) dataType = success, success = undefined;
    return {
      url: url,
      data: data,
      success: success,
      dataType: dataType
    };
  }

  $.get = function () /* url, data, success, dataType */{
    return $.ajax(parseArguments.apply(null, arguments));
  };

  $.post = function () /* url, data, success, dataType */{
    var options = parseArguments.apply(null, arguments);
    options.type = "POST";
    return $.ajax(options);
  };

  $.getJSON = function () /* url, data, success */{
    var options = parseArguments.apply(null, arguments);
    options.dataType = "json";
    return $.ajax(options);
  };

  $.fn.load = function (url, data, success) {
    if (!this.length) return this;
    var self = this,
        parts = url.split(/\s/),
        selector,
        options = parseArguments(url, data, success),
        callback = options.success;
    if (parts.length > 1) options.url = parts[0], selector = parts[1];
    options.success = function (response) {
      self.html(selector ? $("<div>").html(response.replace(rscript, "")).find(selector) : response);
      callback && callback.apply(self, arguments);
    };
    $.ajax(options);
    return this;
  };

  var escape = encodeURIComponent;

  function serialize(params, obj, traditional, scope) {
    var type,
        array = $.isArray(obj),
        hash = $.isPlainObject(obj);
    $.each(obj, function (key, value) {
      type = $.type(value);
      if (scope) key = traditional ? scope : scope + "[" + (hash || type == "object" || type == "array" ? key : "") + "]";
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value);
      // recurse into nested objects
      else if (type == "array" || !traditional && type == "object") serialize(params, value, traditional, key);else params.add(key, value);
    });
  }

  $.param = function (obj, traditional) {
    var params = [];
    params.add = function (key, value) {
      if ($.isFunction(value)) value = value();
      if (value == null) value = "";
      this.push(escape(key) + "=" + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join("&").replace(/%20/g, "+");
  };
})(zepto);

(function ($) {
  $.fn.serializeArray = function () {
    var name,
        type,
        result = [],
        add = function add(value) {
      if (value.forEach) return value.forEach(add);
      result.push({ name: name, value: value });
    };
    if (this[0]) $.each(this[0].elements, function (_, field) {
      type = field.type, name = field.name;
      if (name && field.nodeName.toLowerCase() != "fieldset" && !field.disabled && type != "submit" && type != "reset" && type != "button" && type != "file" && (type != "radio" && type != "checkbox" || field.checked)) add($(field).val());
    });
    return result;
  };

  $.fn.serialize = function () {
    var result = [];
    this.serializeArray().forEach(function (elm) {
      result.push(encodeURIComponent(elm.name) + "=" + encodeURIComponent(elm.value));
    });
    return result.join("&");
  };

  $.fn.submit = function (callback) {
    if (0 in arguments) this.bind("submit", callback);else if (this.length) {
      var event = $.Event("submit");
      this.eq(0).trigger(event);
      if (!event.isDefaultPrevented()) this.get(0).submit();
    }
    return this;
  };
})(zepto);

(function () {
  // getComputedStyle shouldn't freak out when called
  // without a valid element as argument
  try {
    getComputedStyle(undefined);
  } catch (e) {
    var nativeGetComputedStyle = getComputedStyle;
    window.getComputedStyle = function (element, pseudoElement) {
      try {
        return nativeGetComputedStyle(element, pseudoElement);
      } catch (e) {
        return null;
      }
    };
  }
})();

(function () {
  'use strict';

  /**
   *  base64.ts
   *
   *  Licensed under the BSD 3-Clause License.
   *    http://opensource.org/licenses/BSD-3-Clause
   *
   *  References:
   *    http://en.wikipedia.org/wiki/Base64
   *
   * @author Dan Kogai (https://github.com/dankogai)
   */

  var version = '3.6.1';
  /**
   * @deprecated use lowercase `version`.
   */
  var VERSION = version;
  var _hasatob = typeof atob === 'function';
  var _hasbtoa = typeof btoa === 'function';
  var _hasBuffer = typeof Buffer === 'function';
  var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
  var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
  var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var b64chs = [].concat(_toConsumableArray(b64ch));
  var b64tab = function (a) {
    var tab = {};
    a.forEach(function (c, i) {
      return tab[c] = i;
    });
    return tab;
  }(b64chs);
  var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
  var _fromCC = String.fromCharCode.bind(String);
  var _U8Afrom = typeof Uint8Array.from === 'function' ? Uint8Array.from.bind(Uint8Array) : function (it) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {
      return x;
    };
    return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
  };
  var _mkUriSafe = function _mkUriSafe(src) {
    return src.replace(/[+\/]/g, function (m0) {
      return m0 == '+' ? '-' : '_';
    }).replace(/=+$/m, '');
  };
  var _tidyB64 = function _tidyB64(s) {
    return s.replace(/[^A-Za-z0-9\+\/]/g, '');
  };
  /**
   * polyfill version of `btoa`
   */
  var btoaPolyfill = function btoaPolyfill(bin) {
    // console.log('polyfilled');
    var u32 = void 0,
        c0 = void 0,
        c1 = void 0,
        c2 = void 0,
        asc = '';
    var pad = bin.length % 3;
    for (var i = 0; i < bin.length;) {
      if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError('invalid character found');
      u32 = c0 << 16 | c1 << 8 | c2;
      asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
  };
  /**
   * does what `window.btoa` of web browsers do.
   * @param {String} bin binary string
   * @returns {string} Base64-encoded string
   */
  var _btoa = _hasbtoa ? function (bin) {
    return btoa(bin);
  } : _hasBuffer ? function (bin) {
    return Buffer.from(bin, 'binary').toString('base64');
  } : btoaPolyfill;
  var _fromUint8Array = _hasBuffer ? function (u8a) {
    return Buffer.from(u8a).toString('base64');
  } : function (u8a) {
    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
    var maxargs = 0x1000;
    var strs = [];
    for (var i = 0, l = u8a.length; i < l; i += maxargs) {
      strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
    }
    return _btoa(strs.join(''));
  };
  /**
   * converts a Uint8Array to a Base64 string.
   * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
   * @returns {string} Base64 string
   */
  var fromUint8Array = function fromUint8Array(u8a) {
    var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
  };
  // This trick is found broken https://github.com/dankogai/js-base64/issues/130
  // const utob = (src: string) => unescape(encodeURIComponent(src));
  // reverting good old fationed regexp
  var cb_utob = function cb_utob(c) {
    if (c.length < 2) {
      var cc = c.charCodeAt(0);
      return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    } else {
      var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
      return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
    }
  };
  var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
  /**
   * @deprecated should have been internal use only.
   * @param {string} src UTF-8 string
   * @returns {string} UTF-16 string
   */
  var utob = function utob(u) {
    return u.replace(re_utob, cb_utob);
  };
  //
  var _encode = _hasBuffer ? function (s) {
    return Buffer.from(s, 'utf8').toString('base64');
  } : _TE ? function (s) {
    return _fromUint8Array(_TE.encode(s));
  } : function (s) {
    return _btoa(utob(s));
  };
  /**
   * converts a UTF-8-encoded string to a Base64 string.
   * @param {boolean} [urlsafe] if `true` make the result URL-safe
   * @returns {string} Base64 string
   */
  var encode = function encode(src) {
    var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
  };
  /**
   * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
   * @returns {string} Base64 string
   */
  var encodeURI = function encodeURI(src) {
    return encode(src, true);
  };
  // This trick is found broken https://github.com/dankogai/js-base64/issues/130
  // const btou = (src: string) => decodeURIComponent(escape(src));
  // reverting good old fationed regexp
  var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
  var cb_btou = function cb_btou(cccc) {
    switch (cccc.length) {
      case 4:
        var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
            offset = cp - 0x10000;
        return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
      case 3:
        return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
      default:
        return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
    }
  };
  /**
   * @deprecated should have been internal use only.
   * @param {string} src UTF-16 string
   * @returns {string} UTF-8 string
   */
  var btou = function btou(b) {
    return b.replace(re_btou, cb_btou);
  };
  /**
   * polyfill version of `atob`
   */
  var atobPolyfill = function atobPolyfill(asc) {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc)) throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    var u24 = void 0,
        bin = '',
        r1 = void 0,
        r2 = void 0;
    for (var i = 0; i < asc.length;) {
      u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
      bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
  };
  /**
   * does what `window.atob` of web browsers do.
   * @param {String} asc Base64-encoded string
   * @returns {string} binary string
   */
  var _atob = _hasatob ? function (asc) {
    return atob(_tidyB64(asc));
  } : _hasBuffer ? function (asc) {
    return Buffer.from(asc, 'base64').toString('binary');
  } : atobPolyfill;
  //
  var _toUint8Array = _hasBuffer ? function (a) {
    return _U8Afrom(Buffer.from(a, 'base64'));
  } : function (a) {
    return _U8Afrom(_atob(a), function (c) {
      return c.charCodeAt(0);
    });
  };
  /**
   * converts a Base64 string to a Uint8Array.
   */
  var toUint8Array = function toUint8Array(a) {
    return _toUint8Array(_unURI(a));
  };
  //
  var _decode = _hasBuffer ? function (a) {
    return Buffer.from(a, 'base64').toString('utf8');
  } : _TD ? function (a) {
    return _TD.decode(_toUint8Array(a));
  } : function (a) {
    return btou(_atob(a));
  };
  var _unURI = function _unURI(a) {
    return _tidyB64(a.replace(/[-_]/g, function (m0) {
      return m0 == '-' ? '+' : '/';
    }));
  };
  /**
   * converts a Base64 string to a UTF-8 string.
   * @param {String} src Base64 string.  Both normal and URL-safe are supported
   * @returns {string} UTF-8 string
   */
  var decode = function decode(src) {
    return _decode(_unURI(src));
  };
  /**
   * check if a value is a valid Base64 string
   * @param {String} src a value to check
    */
  var isValid = function isValid(src) {
    if (typeof src !== 'string') return false;
    var s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
  };
  //
  var _noEnum = function _noEnum(v) {
    return {
      value: v, enumerable: false, writable: true, configurable: true
    };
  };
  /**
   * extend String.prototype with relevant methods
   */
  var extendString = function extendString() {
    var _add = function _add(name, body) {
      return Object.defineProperty(String.prototype, name, _noEnum(body));
    };
    _add('fromBase64', function () {
      return decode(this);
    });
    _add('toBase64', function (urlsafe) {
      return encode(this, urlsafe);
    });
    _add('toBase64URI', function () {
      return encode(this, true);
    });
    _add('toBase64URL', function () {
      return encode(this, true);
    });
    _add('toUint8Array', function () {
      return toUint8Array(this);
    });
  };
  /**
   * extend Uint8Array.prototype with relevant methods
   */
  var extendUint8Array = function extendUint8Array() {
    var _add = function _add(name, body) {
      return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    };
    _add('toBase64', function (urlsafe) {
      return fromUint8Array(this, urlsafe);
    });
    _add('toBase64URI', function () {
      return fromUint8Array(this, true);
    });
    _add('toBase64URL', function () {
      return fromUint8Array(this, true);
    });
  };
  /**
   * extend Builtin prototypes with relevant methods
   */
  var extendBuiltins = function extendBuiltins() {
    extendString();
    extendUint8Array();
  };
  var gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins
  };

  //
  // export Base64 to the namespace
  //
  // ES5 is yet to have Object.assign() that may make transpilers unhappy.
  // gBase64.Base64 = Object.assign({}, gBase64);
  gBase64.Base64 = {};
  Object.keys(gBase64).forEach(function (k) {
    return gBase64.Base64[k] = gBase64[k];
  });
  window.Base64 = gBase64;
})();
if (window.jQuery) {
  exports.zepto = zepto = window.jQuery;
  window.$ = window.jQuery;
} else {
  window.$ = zepto;
}

exports.zepto = zepto;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(105).Buffer))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.message = exports.Tooltip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _zepto = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = exports.Tooltip = function () {
  //========== 构造方法 ==========
  function Tooltip(frameDiv) {
    _classCallCheck(this, Tooltip);

    var div = document.createElement("DIV");
    div.className = "das3d-draw-tooltip right";

    var arrow = document.createElement("DIV");
    arrow.className = "das3d-draw-tooltip-arrow";
    div.appendChild(arrow);

    var title = document.createElement("DIV");
    title.className = "das3d-draw-tooltip-inner";
    div.appendChild(title);

    this._div = div;
    this._title = title;

    // add to frame div and display coordinates
    frameDiv.appendChild(div);

    //鼠标的移入
    (0, _zepto.zepto)(".das3d-draw-tooltip").mouseover(function () {
      (0, _zepto.zepto)(this).hide();
    });
  }

  _createClass(Tooltip, [{
    key: "setVisible",
    value: function setVisible(visible) {
      this._div.style.display = visible ? "block" : "none";
    }
  }, {
    key: "showAt",
    value: function showAt(position, message) {
      if (position && message) {
        this.setVisible(true);

        this._title.innerHTML = message;
        this._div.style.top = position.y - this._div.clientHeight / 2 + "px";

        //left css时
        //this._div.style.left = (position.x - this._div.clientWidth - 30) + "px";

        //right css时
        this._div.style.left = position.x + 30 + "px";
      } else {
        this.setVisible(false);
      }
    }
  }, {
    key: "destroy",
    value: function destroy(visible) {
      this.setVisible(false);
      (0, _zepto.zepto)(this._div).remove();
    }
  }]);

  return Tooltip;
}();

//样式文件在map.css


var message = exports.message = {
  draw: {
    point: {
      start: "单击 完成绘制"
    },
    polyline: {
      //线面
      start: "单击 开始绘制",
      cont: "单击增加点，右击删除点",
      end: "单击增加点，右击删除点<br/>双击完成绘制",
      end2: "单击完成绘制"
    }
  },
  edit: {
    start: "单击后 激活编辑<br/>右击 单击菜单删除",
    end: "释放后 完成修改"
  },
  dragger: {
    def: "拖动该点后<br/>修改位置 ", //默认
    moveAll: "拖动该点后<br/>整体平移",
    addMidPoint: "拖动该点后<br/>增加点",
    moveHeight: "拖动该点后<br/>修改高度",
    editRadius: "拖动该点后<br/>修改半径",
    editHeading: "拖动该点后<br/>修改方向",
    editScale: "拖动该点后<br/>修改缩放比例"
  },
  del: {
    def: "<br/>右击 删除该点",
    min: "无法删除，点数量不能少于"
  }
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plotUtil = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//基本计算方法
var PlotUtilClass = function () {
  function PlotUtilClass() {
    _classCallCheck(this, PlotUtilClass);

    this.HALF_PI = Math.PI / 2;
    this.ZERO_TOLERANCE = 0.0001;
  }

  //获取第三点


  _createClass(PlotUtilClass, [{
    key: "getThirdPoint",
    value: function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
      var azimuth = this.getAzimuth(startPnt, endPnt);
      var alpha = clockWise ? azimuth + angle : azimuth - angle;
      var dx = distance * Math.cos(alpha);
      var dy = distance * Math.sin(alpha);
      return [endPnt[0] + dx, endPnt[1] + dy];
    }

    //计算夹角

  }, {
    key: "getAzimuth",
    value: function getAzimuth(startPoint, endPoint) {
      var azimuth = void 0;
      var angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / this.MathDistance(startPoint, endPoint));
      if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = angle + Math.PI;
      } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = Math.PI * 2 - angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = Math.PI - angle;
      }
      return azimuth;
    }
  }, {
    key: "MathDistance",
    value: function MathDistance(pnt1, pnt2) {
      return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
    }
    //计算闭合曲面上的点

  }, {
    key: "isClockWise",
    value: function isClockWise(pnt1, pnt2, pnt3) {
      return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
    }
  }, {
    key: "getBisectorNormals",
    value: function getBisectorNormals(t, pnt1, pnt2, pnt3) {
      var normal = this.getNormal(pnt1, pnt2, pnt3);
      var bisectorNormalRight = null,
          bisectorNormalLeft = null,
          dt = null,
          x = null,
          y = null;

      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var uX = normal[0] / dist;
      var uY = normal[1] / dist;
      var d1 = this.MathDistance(pnt1, pnt2);
      var d2 = this.MathDistance(pnt2, pnt3);
      if (dist > this.ZERO_TOLERANCE) {
        if (this.isClockWise(pnt1, pnt2, pnt3)) {
          dt = t * d1;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalLeft = [x, y];
        } else {
          dt = t * d1;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalLeft = [x, y];
        }
      } else {
        x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
        bisectorNormalRight = [x, y];
        x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
        bisectorNormalLeft = [x, y];
      }
      return [bisectorNormalRight, bisectorNormalLeft];
    }
  }, {
    key: "getCubicValue",
    value: function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
      t = Math.max(Math.min(t, 1), 0);
      var tp = 1 - t,
          t2 = t * t;

      var t3 = t2 * t;
      var tp2 = tp * tp;
      var tp3 = tp2 * tp;
      var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
      var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
      return [x, y];
    }
  }, {
    key: "getNormal",
    value: function getNormal(pnt1, pnt2, pnt3) {
      var dX1 = pnt1[0] - pnt2[0];
      var dY1 = pnt1[1] - pnt2[1];
      var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
      dX1 /= d1;
      dY1 /= d1;
      var dX2 = pnt3[0] - pnt2[0];
      var dY2 = pnt3[1] - pnt2[1];
      var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
      dX2 /= d2;
      dY2 /= d2;
      var uX = dX1 + dX2;
      var uY = dY1 + dY2;
      return [uX, uY];
    }
  }, {
    key: "getArcPoints",
    value: function getArcPoints(center, radius, startAngle, endAngle) {
      var x = null,
          y = null,
          pnts = [],
          angleDiff = endAngle - startAngle;
      angleDiff = angleDiff < 0 ? angleDiff + Math.PI * 2 : angleDiff;
      for (var i = 0; i <= 100; i++) {
        var angle = startAngle + angleDiff * i / 100;
        x = center[0] + radius * Math.cos(angle);
        y = center[1] + radius * Math.sin(angle);
        pnts.push([x, y]);
      }
      return pnts;
    }
  }, {
    key: "getBaseLength",
    value: function getBaseLength(points) {
      return Math.pow(this.wholeDistance(points), 0.99);
    }
  }, {
    key: "wholeDistance",
    value: function wholeDistance(points) {
      var distance = 0;
      var that = this;
      if (points && Array.isArray(points) && points.length > 0) {
        points.forEach(function (item, index) {
          if (index < points.length - 1) {
            distance += that.MathDistance(item, points[index + 1]);
          }
        });
      }
      return distance;
    }
  }, {
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(obj) {
      if (!obj) return [];
      var points = obj.points;
      var tailLeft = obj.tailLeft;
      var tailRight = obj.tailRight;
      var headTailFactor = obj.headTailFactor;
      var neckWidthFactor = obj.neckWidthFactor;
      var neckHeightFactor = obj.neckHeightFactor;
      var headWidthFactor = obj.headWidthFactor;
      var headHeightFactor = obj.headHeightFactor;
      var len = this.getBaseLength(points);
      var headHeight = len * headHeightFactor;
      var headPnt = points[points.length - 1];
      len = this.MathDistance(headPnt, points[points.length - 2]);
      var tailWidth = this.MathDistance(tailLeft, tailRight);
      if (headHeight > tailWidth * headTailFactor) {
        headHeight = tailWidth * headTailFactor;
      }
      var headWidth = headHeight * headWidthFactor;
      var neckWidth = headHeight * neckWidthFactor;
      headHeight = headHeight > len ? len : headHeight;
      var neckHeight = headHeight * neckHeightFactor;
      var headEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, false);
      var headRight = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, true);
      var neckLeft = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, false);
      var neckRight = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(obj) {
      if (!obj) return;
      var points = obj.points;
      var tailWidthFactor = obj.tailWidthFactor;
      var swallowTailFactor = obj.swallowTailFactor;
      var allLen = this.getBaseLength(points);
      var tailWidth = allLen * tailWidthFactor;
      var tailLeft = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, false);
      var tailRight = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, true);
      var len = tailWidth * swallowTailFactor;
      var swallowTailPnt = this.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.wholeDistance(points);
      var len = this.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.MathDistance(neckLeft, neckRight);
      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts);
    }
  }, {
    key: "getAngleOfThreePoints",
    value: function getAngleOfThreePoints(pntA, pntB, pntC) {
      var angle = this.getAzimuth(pntB, pntA) - this.getAzimuth(pntB, pntC);
      return angle < 0 ? angle + Math.PI * 2 : angle;
    }
  }, {
    key: "getQBSplinePoints",
    value: function getQBSplinePoints(points) {
      if (points.length <= 2) {
        return points;
      } else {
        var n = 2,
            bSplinePoints = [];

        var m = points.length - n - 1;
        bSplinePoints.push(points[0]);
        for (var i = 0; i <= m; i++) {
          for (var t = 0; t <= 1; t += 0.05) {
            var x = 0,
                y = 0;

            for (var k = 0; k <= n; k++) {
              var factor = this.getQuadricBSplineFactor(k, t);
              x += factor * points[i + k][0];
              y += factor * points[i + k][1];
            }
            bSplinePoints.push([x, y]);
          }
        }
        bSplinePoints.push(points[points.length - 1]);
        return bSplinePoints;
      }
    }
  }, {
    key: "getQuadricBSplineFactor",
    value: function getQuadricBSplineFactor(k, t) {
      var res = 0;
      if (k === 0) {
        res = Math.pow(t - 1, 2) / 2;
      } else if (k === 1) {
        res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
      } else if (k === 2) {
        res = Math.pow(t, 2) / 2;
      }
      return res;
    }
  }, {
    key: "Mid",
    value: function Mid(point1, point2) {
      return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
    }
  }, {
    key: "getCircleCenterOfThreePoints",
    value: function getCircleCenterOfThreePoints(point1, point2, point3) {
      var pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
      var pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0]];
      var pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2];
      var pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0]];
      return this.getIntersectPoint(pntA, pntB, pntC, pntD);
    }
  }, {
    key: "getIntersectPoint",
    value: function getIntersectPoint(pntA, pntB, pntC, pntD) {
      if (pntA[1] === pntB[1]) {
        var _f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
        var _x = _f * (pntA[1] - pntC[1]) + pntC[0];
        var _y = pntA[1];
        return [_x, _y];
      }
      if (pntC[1] === pntD[1]) {
        var _e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
        var _x2 = _e * (pntC[1] - pntA[1]) + pntA[0];
        var _y2 = pntC[1];
        return [_x2, _y2];
      }
      var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
      var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
      var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
      var x = e * y - e * pntA[1] + pntA[0];
      return [x, y];
    }
  }, {
    key: "getBezierPoints",
    value: function getBezierPoints(points) {
      if (points.length <= 2) {
        return points;
      } else {
        var bezierPoints = [];
        var n = points.length - 1;
        for (var t = 0; t <= 1; t += 0.01) {
          var x = 0,
              y = 0;

          for (var index = 0; index <= n; index++) {
            var factor = this.getBinomialFactor(n, index);
            var a = Math.pow(t, index);
            var b = Math.pow(1 - t, n - index);
            x += factor * a * b * points[index][0];
            y += factor * a * b * points[index][1];
          }
          bezierPoints.push([x, y]);
        }
        // bezierPoints.push(points[n]);
        return bezierPoints;
      }
    }
  }, {
    key: "getFactorial",
    value: function getFactorial(n) {
      var result = 1;
      switch (n) {
        case n <= 1:
          result = 1;
          break;
        case n === 2:
          result = 2;
          break;
        case n === 3:
          result = 6;
          break;
        case n === 24:
          result = 24;
          break;
        case n === 5:
          result = 120;
          break;
        default:
          for (var i = 1; i <= n; i++) {
            result *= i;
          }
          break;
      }
      return result;
    }
  }, {
    key: "getBinomialFactor",
    value: function getBinomialFactor(n, index) {
      return this.getFactorial(n) / (this.getFactorial(index) * this.getFactorial(n - index));
    }
  }]);

  return PlotUtilClass;
}();

//外部使用，单例模式


var plotUtil = exports.plotUtil = new PlotUtilClass();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.interPolygon = interPolygon;
exports.getHeightRange = getHeightRange;
exports.computeVolume = computeVolume;
exports.updateVolumeByMinHeight = updateVolumeByMinHeight;
exports.updateVolume = updateVolume;
exports.getEllipseOuterPositions = getEllipseOuterPositions;
exports.getRectangleOuterPositions = getRectangleOuterPositions;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _polyline = __webpack_require__(23);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//面内进行贴地(或贴模型)插值, 返回三角网等计算结果
function interPolygon(opts) {
  var scene = opts.scene;

  //坐标数组
  var positions = [];
  var pos = opts.positions;
  for (var i = 0; i < pos.length; i++) {
    positions.push(pos[i].clone());
  }

  //splitNum分割的个数
  var granularity = (0, _util.getGranularity)(positions, opts.splitNum);

  //插值求面的三角网
  var arrPoly = [];

  var polygonGeometry = new Cesium.PolygonGeometry.fromPositions({
    positions: positions,
    vertexFormat: Cesium.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
    granularity: granularity
  });
  var geom = new Cesium.PolygonGeometry.createGeometry(polygonGeometry);

  var i0, i1, i2;
  var cartesian1, cartesian2, cartesian3;
  for (var _i = 0; _i < geom.indices.length; _i += 3) {
    i0 = geom.indices[_i];
    i1 = geom.indices[_i + 1];
    i2 = geom.indices[_i + 2];

    //三角形 点1
    cartesian1 = new Cesium.Cartesian3(geom.attributes.position.values[i0 * 3], geom.attributes.position.values[i0 * 3 + 1], geom.attributes.position.values[i0 * 3 + 2]);
    arrPoly.push(cartesian1);

    //三角形 点2
    cartesian2 = new Cesium.Cartesian3(geom.attributes.position.values[i1 * 3], geom.attributes.position.values[i1 * 3 + 1], geom.attributes.position.values[i1 * 3 + 2]);
    arrPoly.push(cartesian2);

    //三角形 点3
    cartesian3 = new Cesium.Cartesian3(geom.attributes.position.values[i2 * 3], geom.attributes.position.values[i2 * 3 + 1], geom.attributes.position.values[i2 * 3 + 2]);
    arrPoly.push(cartesian3);
  }

  var maxHeight = 0;
  var minHeight = 9999;
  var onlyPoint = Cesium.defaultValue(opts.onlyPoint, false); //只返回点，不需要三角网时

  //格式化每个点
  function onFormatPoint(position, noHeight) {
    var height;
    var point;
    var pointDM;
    var carto;

    if (noHeight) {
      height = (0, _point.getSurfaceHeight)(scene, position, opts);

      carto = Cesium.Cartographic.fromCartesian(position);
      point = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
      pointDM = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
    } else {
      carto = Cesium.Cartographic.fromCartesian(position);
      height = carto.height;

      point = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
      pointDM = position;
    }

    if (maxHeight < height) maxHeight = height;
    if (minHeight > height) minHeight = height;

    return {
      height: height,
      point: point,
      pointDM: pointDM
    };
  }

  function interCallback(raisedPositions, noHeight) {
    var arrSJW = [];
    var obj1, obj2, obj3;
    for (var i = 0; i < raisedPositions.length; i += 3) {
      //三角形 点1
      obj1 = onFormatPoint(raisedPositions[i], noHeight);
      //三角形 点2
      obj2 = onFormatPoint(raisedPositions[i + 1], noHeight);
      //三角形 点3
      obj3 = onFormatPoint(raisedPositions[i + 2], noHeight);

      if (onlyPoint) {
        //只返回点，不需要三角网
        addPointFoyArrOnly(arrSJW, obj1);
        addPointFoyArrOnly(arrSJW, obj2);
        addPointFoyArrOnly(arrSJW, obj3);
      } else {
        //常规返回，三角网
        arrSJW.push({
          point1: obj1,
          point2: obj2,
          point3: obj3
        });
      }
    }

    if (Cesium.defined(opts.minHeight)) {
      minHeight = Math.max(opts.minHeight, minHeight);
      maxHeight = Math.max(maxHeight, minHeight);
    }

    var result = {
      granularity: granularity,
      maxHeight: maxHeight,
      minHeight: minHeight,
      list: arrSJW //三角网
    };
    var callback = opts.callback || opts.calback; //兼容不同参数名
    if (callback) callback(result);

    return result;
  }

  //是否异步求精确高度
  if (opts.asyn) {
    //求高度
    return (0, _polyline.computeSurfacePoints)({
      scene: scene,
      positions: arrPoly,
      has3dtiles: opts.has3dtiles,
      callback: interCallback
    });
  } else {
    return interCallback(arrPoly, true);
  }
}

//判断坐标点是否在数组内
function addPointFoyArrOnly(arr, newItem) {
  var isIn = false;
  var point = newItem.point;
  for (var z = 0; z < arr.length; z++) {
    var item = arr[z].point;
    if (point.x == item.x && point.y == item.y && point.z == item.z) {
      isIn = true;
      break;
    }
  }
  if (!isIn) arr.push(newItem);
}

//计算面内最大、最小高度值
function getHeightRange(positions, scene, opts) {
  var resultInter = interPolygon(_extends({
    positions: positions,
    scene: scene
  }, opts));

  return {
    has3dtiles: resultInter._has3dtiles,
    maxHeight: resultInter.maxHeight,
    minHeight: resultInter.minHeight
  };
}

//计算三角形空间面积
function getAreaOfTriangle(pos1, pos2, pos3) {
  var a = Cesium.Cartesian3.distance(pos1, pos2);
  var b = Cesium.Cartesian3.distance(pos2, pos3);
  var c = Cesium.Cartesian3.distance(pos3, pos1);
  var S = (a + b + c) / 2;
  return Math.sqrt(S * (S - a) * (S - b) * (S - c));
}

//体积计算
function computeVolume(opts) {
  var resultInter = interPolygon(opts);
  if (resultInter) resultInter = updateVolumeByMinHeight(resultInter);

  return resultInter;
}

//根据 最低底面高度 重新计算填挖方体积
function updateVolumeByMinHeight(resultInter) {
  var minHeight = resultInter.minHeight;

  var totalArea = 0; //总面积(横截面/投影底面)
  var totalVolume = 0; //总体积

  for (var i = 0, len = resultInter.list.length; i < len; i++) {
    var item = resultInter.list[i];

    var pt1 = item.point1;
    var pt2 = item.point2;
    var pt3 = item.point3;

    //横截面面积
    var bottomArea = getAreaOfTriangle(pt1.point, pt2.point, pt3.point);
    item.area = bottomArea;
    totalArea += bottomArea;

    var height1 = pt1.height;
    var height2 = pt2.height;
    var height3 = pt3.height;
    if (height1 < minHeight) height1 = minHeight;
    if (height2 < minHeight) height2 = minHeight;
    if (height3 < minHeight) height3 = minHeight;

    //挖方体积 （横截面面积 * 3个点的平均高）
    var cutVolume = bottomArea * (height1 - minHeight + height2 - minHeight + height3 - minHeight) / 3;
    item.cutVolume = cutVolume;
    totalVolume = totalVolume + cutVolume;
  }

  resultInter.totalArea = totalArea; //总面积(横截面/投影底面)
  resultInter.totalVolume = totalVolume; //总体积

  return resultInter;
}

//根据 基准面高度 重新计算填挖方体积
function updateVolume(resultInter, cutHeight) {
  if (!resultInter) return;

  var minHeight = resultInter.minHeight;
  var totalVolume = resultInter.totalVolume; //总体积

  if (cutHeight <= minHeight) {
    resultInter.fillVolume = 0; //填方体积
    resultInter.digVolume = totalVolume; //挖方体积

    return resultInter;
  }

  var totalV = 0; //底部到基准面的总体积
  var totalBottomV = 0; //挖方体积
  for (var i = 0, len = resultInter.list.length; i < len; i++) {
    var item = resultInter.list[i];

    //底部到基准面的总体积
    totalV += item.area * (cutHeight - minHeight);

    var pt1 = item.point1;
    var pt2 = item.point2;
    var pt3 = item.point3;

    var height1 = pt1.height;
    var height2 = pt2.height;
    var height3 = pt3.height;
    if (height1 < cutHeight) height1 = cutHeight;
    if (height2 < cutHeight) height2 = cutHeight;
    if (height3 < cutHeight) height3 = cutHeight;

    //挖方体积 （横截面面积 * 3个点的平均高）
    totalBottomV += item.area * (height1 - cutHeight + height2 - cutHeight + height3 - cutHeight) / 3;
  }

  resultInter.digVolume = totalBottomV; //挖方体积
  resultInter.fillVolume = totalV - (totalVolume - totalBottomV); //填方体积

  return resultInter;
}

//获取圆（或椭圆）边线上的坐标点数组
function getEllipseOuterPositions(opts) {
  var position = opts.position;
  if (!position) return null;

  var count = Cesium.defaultValue(opts.count, 1); //点的数量，总数为count*4
  var semiMajorAxis = Cesium.defaultValue(opts.semiMajorAxis, opts.radius);
  var semiMinorAxis = Cesium.defaultValue(opts.semiMinorAxis, opts.radius);
  var rotation = Cesium.defaultValue(opts.rotation, 0);

  if (!semiMajorAxis || !semiMinorAxis) return [position, position, position];

  //获取椭圆上的坐标点数组
  var cep = Cesium.EllipseGeometryLibrary.computeEllipsePositions({
    center: position,
    semiMajorAxis: semiMajorAxis, //长半轴
    semiMinorAxis: semiMinorAxis, //短半轴
    rotation: rotation,
    granularity: Math.PI / (16 * count)
  }, true, true);

  var arr = cep.outerPositions;
  var positions = [];
  for (var i = 0, len = arr.length; i < len; i += 3) {
    //长半轴上的坐标点
    var pt = new Cesium.Cartesian3(arr[i], arr[i + 1], arr[i + 2]);
    positions.push(pt);
  }
  return positions;
}

//获取矩形（含旋转角度）的边线上的4个顶点坐标点数组
function getRectangleOuterPositions(options) {
  var rectangle = options.rectangle;
  var rotation = Cesium.defaultValue(options.rotation, 0.0);
  var height = Cesium.defaultValue(options.height, 0.0);

  if (rotation == 0) {
    return [Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.south, height), Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.south, height), Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.north, height), Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.north, height)];
  }

  var granularity = Cesium.defaultValue(options.granularity, Cesium.Math.RADIANS_PER_DEGREE);

  var rectangleScratch = new Cesium.Rectangle();
  var nwScratch = new Cesium.Cartographic();
  var computedOptions = Cesium.RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);

  var w_height = computedOptions.height;
  var w_width = computedOptions.width;
  var ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);

  var scratchRectanglePoints = [new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3()];

  Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, scratchRectanglePoints[0]);
  Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, w_width - 1, scratchRectanglePoints[1]);

  Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, w_width - 1, scratchRectanglePoints[2]);

  Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, 0, scratchRectanglePoints[3]);

  if (height != 0) {
    scratchRectanglePoints = (0, _point.setPositionsHeight)(scratchRectanglePoints, height);
  }

  return scratchRectanglePoints;
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolygonEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(65);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//用于外部扩展使用，绘制的点与显示的点不一致的标号

var DrawPolygonEx = exports.DrawPolygonEx = function (_DrawPolygon) {
  _inherits(DrawPolygonEx, _DrawPolygon);

  function DrawPolygonEx() {
    _classCallCheck(this, DrawPolygonEx);

    return _possibleConstructorReturn(this, (DrawPolygonEx.__proto__ || Object.getPrototypeOf(DrawPolygonEx)).apply(this, arguments));
  }

  _createClass(DrawPolygonEx, [{
    key: "getDrawPosition",
    value: function getDrawPosition() {
      return this._positions_show;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
        this._positions_show = this._positions_draw;
        return;
      }

      this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);
      _get(DrawPolygonEx.prototype.__proto__ || Object.getPrototypeOf(DrawPolygonEx.prototype), "updateAttrForDrawing", this).call(this);
    }
    //子类中重写 ，根据标绘绘制的点，生成显示的边界点

  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return positions;
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      //抛弃多余的无效绘制点
      if (this._positions_draw.length > this._maxPointNum) this._positions_draw.splice(this._maxPointNum, this._positions_draw.length - this._maxPointNum);

      this.entity._positions_draw = this._positions_draw;
      this.entity._positions_show = this._positions_show;

      entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
        var positions = entity._positions_show;
        return new Cesium.PolygonHierarchy(positions);
      }, false);

      this._positions_draw = null;
      this._positions_show = null;
    }
  }, {
    key: "toGeoJSON",
    value: function toGeoJSON(entity) {
      return this.attrClass.toGeoJSON(entity, true); //不用闭合最后一个点
    }
  }]);

  return DrawPolygonEx;
}(_Draw.DrawPolygon);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPolygonEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(28);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//用于外部扩展使用，绘制的点与显示的点不一致的标号

var EditPolygonEx = exports.EditPolygonEx = function (_EditPolygon) {
  _inherits(EditPolygonEx, _EditPolygon);

  //========== 构造方法 ==========
  function EditPolygonEx(entity, viewer) {
    _classCallCheck(this, EditPolygonEx);

    var _this = _possibleConstructorReturn(this, (EditPolygonEx.__proto__ || Object.getPrototypeOf(EditPolygonEx)).call(this, entity, viewer));

    _this._hasMidPoint = false;
    return _this;
  }

  //修改坐标会回调，提高显示的效率


  _createClass(EditPolygonEx, [{
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;
      this._positions_show = this.entity._positions_show;
    }
    //坐标位置相关

  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
        this._positions_show = this._positions_draw;
        return;
      }
      this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);

      this.entity._positions_show = this._positions_show;
      _get(EditPolygonEx.prototype.__proto__ || Object.getPrototypeOf(EditPolygonEx.prototype), "updateAttrForEditing", this).call(this);
    }
    //子类中重写 ，根据标绘绘制的点，生成显示的边界点

  }, {
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return positions;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_show = this._positions_show;
      this.entity._positions_draw = this._positions_draw;
    }
  }]);

  return EditPolygonEx;
}(_Edit.EditPolygon);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr, textAttr) {
  style = style || {};
  if (entityattr == null) {
    //默认值
    entityattr = {
      scale: 1.0,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM
    };
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "font_style": //跳过扩展其他属性的参数
      case "font_weight":
      case "font_size":
      case "font_family":
      case "scaleByDistance_near":
      case "scaleByDistance_nearValue":
      case "scaleByDistance_far":
      case "scaleByDistance_farValue":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
      case "background_opacity":
      case "pixelOffsetY":
        break;

      case "text":
        //文字内容
        if (textAttr) {
          //存在属性时，采用格式化字符串
          value = (0, _util.template)(value, textAttr);
        }
        entityattr.text = value.replace(new RegExp("<br />", "gm"), "\n");
        break;
      case "color":
        //颜色
        entityattr.fillColor = Cesium.Color.fromCssColorString(value || "#ffffff").withAlpha(Number(style.opacity || 1.0));
        break;

      case "border":
        //是否衬色
        entityattr.style = value ? Cesium.LabelStyle.FILL_AND_OUTLINE : Cesium.LabelStyle.FILL;
        break;
      case "border_color":
        //衬色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.opacity || 1.0));
        break;
      case "border_width":
        entityattr.outlineWidth = value;
        break;
      case "background":
        //是否背景色
        entityattr.showBackground = value;
        break;
      case "background_color":
        //背景色
        entityattr.backgroundColor = Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.background_opacity || style.opacity || 0.5));
        break;
      case "pixelOffset":
        //偏移量
        if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
        break;
      case "hasPixelOffset":
        //是否存在偏移量
        if (!value) entityattr.pixelOffset = new Cesium.Cartesian2(0, 0);
        break;
      case "pixelOffsetX":
        //偏移量
        entityattr.pixelOffset = new Cesium.Cartesian2(value, style.pixelOffsetY);
        break;
      case "scaleByDistance":
        //是否按视距缩放
        if (value) {
          entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
        } else {
          entityattr.scaleByDistance = undefined;
        }
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
      case "heightReference":
        switch (value) {
          case "NONE":
            entityattr.heightReference = Cesium.HeightReference.NONE;
            break;
          case "CLAMP_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            break;
          case "RELATIVE_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
            break;
          default:
            entityattr.heightReference = value;
            break;
        }
        break;

      case "visibleDepth":
        if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

        break;
    }
  }

  //样式（倾斜、加粗等）
  var fontStyle = (style.font_style || "normal") + " small-caps " + (style.font_weight || "normal") + " " + (style.font_size || "25") + "px " + (style.font_family || "楷体");
  entityattr.font = fontStyle;

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseLayer = exports.BaseLayer = function (_DasClass) {
  _inherits(BaseLayer, _DasClass);

  //========== 构造方法 ==========
  function BaseLayer(viewer, options) {
    _classCallCheck(this, BaseLayer);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (BaseLayer.__proto__ || Object.getPrototypeOf(BaseLayer)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      var temppar = options;
      options = viewer;
      viewer = temppar;
    }
    if (options.calback) {
      var callbackfun = options.calback;
      delete options.calback;
      _this.on(_DasClass2.eventType.load, function (event) {
        callbackfun(event.tileset);
      });
    }
    if (options.click) {
      var clickfun = options.click;
      delete options.click;
      _this.on(_DasClass2.eventType.click, function (event) {
        clickfun(event.sourceTarget, event);
      });
    }
    if (options.mouseover) {
      var mouseoverfun = options.mouseover;
      delete options.mouseover;
      _this.on(_DasClass2.eventType.mouseOver, function (event) {
        mouseoverfun(event.sourceTarget, event);
      });
    }
    if (options.mouseout) {
      var mouseoutfun = options.mouseout;
      delete options.mouseout;
      _this.on(_DasClass2.eventType.mouseOut, function (event) {
        mouseoutfun(event.sourceTarget, event);
      });
    }
    _this.config = options;
    _this.getVisible = function () {
      return _this.visible;
    };
    _this.setVisible = function (val) {
      _this.visible = val;
    };
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = viewer;
    _this.options = options; //配置的config信息

    _this.name = options.name;
    _this.hasZIndex = Cesium.defaultValue(options.hasZIndex, false);
    _this.hasOpacity = Cesium.defaultValue(options.hasOpacity, false);
    _this._opacity = Cesium.defaultValue(options.opacity, 1);
    if (options.hasOwnProperty("alpha")) _this._opacity = Number(options.alpha);

    //单体化时，不可调整透明度
    if (options.dth) {
      _this.hasOpacity = false;

      options.symbol = options.symbol || {};
      options.symbol.styleOptions = options.symbol.styleOptions || {};
      options.symbol.styleOptions.clampToGround = true;
    }

    _this.create();

    _this._visible = false;
    if (options.visible) {
      if (_this.options.visibleTimeout) {
        setTimeout(function () {
          _this.visible = true;
        }, _this.options.visibleTimeout);
      } else {
        _this.visible = true;
      }

      if (options.flyTo) {
        _this.centerAtByFlyEnd(_this.options.flyToDuration || 0);
      }
    }
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(BaseLayer, [{
    key: "create",


    //========== 方法==========
    value: function create() {
      if (this.options.onCreate) {
        this.options.onCreate(this.viewer);
      }
    }
  }, {
    key: "showError",
    value: function showError(title, error) {
      if (!error) error = "未知错误";

      if (this.viewer) this.viewer.cesiumWidget.showErrorPanel(title, undefined, error);

      daslog.warn("layer错误:" + title + error);
    }

    //添加

  }, {
    key: "add",
    value: function add() {
      this._visible = true;
      this.options.visible = this._visible;

      if (this.options.onAdd) {
        this.options.onAdd(this.viewer);
      }
      this.fireMap(_DasClass2.eventType.add);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this._visible = false;
      this.options.visible = this._visible;

      if (this.options.onRemove) {
        this.options.onRemove(this.viewer);
      }
      this.fireMap(_DasClass2.eventType.remove);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else if (this.options.onCenterAt) {
        this.options.onCenterAt(duration, this.viewer);
      }
    }
  }, {
    key: "centerAtByFlyEnd",
    value: function centerAtByFlyEnd(duration) {
      var _this2 = this;

      if (this.viewer.das.isFlyAnimation()) {
        this.viewer.das.openFlyAnimationEndFun = function () {
          duration = Cesium.defined(duration) ? duration : _this2.options.flyToDuration;
          _this2.centerAt(duration);
        };
      } else {
        this.centerAt(0);
      }
    }

    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      if (this.options.onSetOpacity) {
        this.options.onSetOpacity(value, this.viewer);
      }
    }
    //设置叠加顺序

  }, {
    key: "setZIndex",
    value: function setZIndex(value) {
      if (this.options.onSetZIndex) {
        this.options.onSetZIndex(value, this.viewer);
      }
    }

    //同时在viewer.das上抛出事件

  }, {
    key: "fireMap",
    value: function fireMap(type, data, propagate) {
      data = data || {};
      data.sourceTarget = this;

      this.fire(type, data, propagate);
      this.viewer.das.fire(type, data, propagate);
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.visible = false;
      _get(BaseLayer.prototype.__proto__ || Object.getPrototypeOf(BaseLayer.prototype), "destroy", this).call(this);
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(val) {
      if (this._visible == val) return;

      this._visible = val;
      this.options.visible = val;

      if (val) {
        if (this.options.msg) (0, _util.msg)(this.options.msg);
        this.add();
      } else {
        this.remove();
      }
    }
  }, {
    key: "opacity",
    get: function get() {
      return this._opacity;
    },
    set: function set(val) {
      this.setOpacity(val);
    }

    //提示框

  }, {
    key: "popup",
    get: function get() {
      return this.options.popup;
    },
    set: function set(value) {
      this.options.popup = value;
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this.options.tooltip;
    },
    set: function set(value) {
      this.options.tooltip = value;
    }
  }]);

  return BaseLayer;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


BaseLayer.event = {
  add: _DasClass2.eventType.add,
  remove: _DasClass2.eventType.remove,
  load: _DasClass2.eventType.load,
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointColor = exports.PointType = exports.PixelSize = undefined;
exports.createDragger = createDragger;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Tooltip = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//拖拽点控制类
var PixelSize = exports.PixelSize = 12; //编辑点的像素大小

//拖拽点分类
var PointType = exports.PointType = {
  Control: 1, //位置控制
  MoveAll: 2, //整体平移(如线面)
  AddMidPoint: 3, //辅助增加新点
  MoveHeight: 4, //上下移动高度
  EditAttr: 5, //辅助修改属性（如半径）
  EditRotation: 6 //旋转角度修改
};

//拖拽点分类
var PointColor = exports.PointColor = {
  Control: Cesium.Color.fromCssColorString("#1c197d"), //位置控制拖拽点
  MoveAll: Cesium.Color.fromCssColorString("#8c003a"), //整体平移(如线面)拖拽点
  MoveHeight: Cesium.Color.fromCssColorString("#9500eb"), //上下移动高度的拖拽点
  EditAttr: Cesium.Color.fromCssColorString("#f531e8"), //辅助修改属性（如半径）的拖拽点
  AddMidPoint: Cesium.Color.fromCssColorString("#04c2c9").withAlpha(0.3) //增加新点，辅助拖拽点
};

function getAttrForType(type, attr) {
  switch (type) {
    case PointType.AddMidPoint:
      attr.color = PointColor.AddMidPoint;
      attr.outlineColor = Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.4);
      break;
    case PointType.MoveAll:
      attr.color = PointColor.MoveAll;
      break;
    case PointType.MoveHeight:
      attr.color = PointColor.MoveHeight;
      break;
    case PointType.EditAttr:
      attr.color = PointColor.EditAttr;
      break;
    case PointType.Control:
    default:
      attr.color = PointColor.Control;
      break;
  }
  return attr;
}

/** 创建Dragger拖动点的公共方法 */
function createDragger(entityCollection, options) {
  var dragger;
  if (options.dragger) {
    dragger = options.dragger;
  } else {
    var attr = {
      scale: 1,
      pixelSize: PixelSize,
      outlineColor: Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.5),
      outlineWidth: 2,
      scaleByDistance: new Cesium.NearFarScalar(1000, 1, 1000000, 0.5),
      disableDepthTestDistance: Number.POSITIVE_INFINITY //一直显示，不被地形等遮挡
    };
    attr = getAttrForType(options.type, attr);

    dragger = entityCollection.add({
      position: Cesium.defaultValue(options.position, Cesium.Cartesian3.ZERO),
      point: attr,
      draw_tooltip: options.tooltip || _Tooltip.message.dragger.def
    });
    dragger.contextmenuItems = false; //不加右键菜单
  }

  dragger._isDragger = true;
  dragger._noMousePosition = true; //不被getCurrentMousePosition拾取
  dragger._pointType = options.type || PointType.Control; //默认是位置控制拖拽点

  dragger.onDragStart = Cesium.defaultValue(options.onDragStart, null);
  dragger.onDrag = Cesium.defaultValue(options.onDrag, null);
  dragger.onDragEnd = Cesium.defaultValue(options.onDragEnd, null);

  return dragger;
}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHeadingPitchRollByOrientation = getHeadingPitchRollByOrientation;
exports.getHeadingPitchRollByMatrix = getHeadingPitchRollByMatrix;
exports.getHeadingPitchRollByMatrixOld = getHeadingPitchRollByMatrixOld;
exports.getHeadingPitchRollForLine = getHeadingPitchRollForLine;
exports.getRotateCenterPoint = getRotateCenterPoint;
exports.getOnLinePointByLen = getOnLinePointByLen;
exports.getPositionTranslation = getPositionTranslation;
exports.getOffsetLine = getOffsetLine;
exports.getPositionByDirectionAndLen = getPositionByDirectionAndLen;
exports.getPositionByHprAndLen = getPositionByHprAndLen;
exports.getRayEarthPosition = getRayEarthPosition;
exports.getRayEarthPositionByMatrix = getRayEarthPositionByMatrix;
exports.extend2Earth = extend2Earth;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// 根据模型的orientation求方位角
function getHeadingPitchRollByOrientation(position, orientation, ellipsoid, fixedFrameTransform) {
  if (!Cesium.defined(orientation) || !Cesium.defined(position)) return new Cesium.HeadingPitchRoll();

  var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, new Cesium.Matrix3()), position, new Cesium.Matrix4());
  var hpr = getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform);
  return hpr;
}

// 根据模型的matrix矩阵求方位角
//一些涉及矩阵计算的方法
function getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform, result) {
  return Cesium.Transforms.fixedFrameToHeadingPitchRoll(matrix, ellipsoid, fixedFrameTransform, result);
}

// 根据模型的matrix矩阵求方位角
function getHeadingPitchRollByMatrixOld(position, matrix, ellipsoid, fixedFrameTransform) {
  fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

  // 计算当前模型中心处的变换矩阵
  var m1 = fixedFrameTransform(position, ellipsoid, new Cesium.Matrix4());
  // 矩阵相除
  var m3 = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(m1, new Cesium.Matrix4()), matrix, new Cesium.Matrix4());
  // 得到旋转矩阵
  var mat3 = Cesium.Matrix4.getMatrix3(m3, new Cesium.Matrix3());
  // 计算四元数
  var q = Cesium.Quaternion.fromRotationMatrix(mat3);
  // 计算旋转角(弧度)
  var hpr = Cesium.HeadingPitchRoll.fromQuaternion(q);
  return hpr;
}

//求localStart点到localEnd点的方向
function getHeadingPitchRollForLine(localStart, localEnd, ellipsoid, fixedFrameTransform) {
  ellipsoid = ellipsoid || Cesium.Ellipsoid.WGS84;

  var cartesian3 = new Cesium.Cartesian3();
  var matrix4Scratch2 = new Cesium.Matrix4();
  var rotationScratch = new Cesium.Matrix3();

  var velocity = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(localEnd, localStart, cartesian3), cartesian3);
  Cesium.Transforms.rotationMatrixFromPositionVelocity(localStart, velocity, ellipsoid, rotationScratch);
  var modelMatrix = Cesium.Matrix4.fromRotationTranslation(rotationScratch, localStart, matrix4Scratch2);

  Cesium.Matrix4.multiplyTransformation(modelMatrix, Cesium.Axis.Z_UP_TO_X_UP, modelMatrix);

  var hpr = getHeadingPitchRollByMatrix(modelMatrix, ellipsoid, fixedFrameTransform);
  return hpr;
}

//获取点point1绕点center的地面法向量旋转顺时针angle角度后新坐标
function getRotateCenterPoint(center, point1, angle) {
  // 计算center的地面法向量
  var chicB = Cesium.Cartographic.fromCartesian(center);
  chicB.height = 0;
  var dB = Cesium.Cartographic.toCartesian(chicB);
  var normaB = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(dB, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());

  // 构造基于center的法向量旋转90度的矩阵
  var Q = Cesium.Quaternion.fromAxisAngle(normaB, Cesium.Math.toRadians(angle));
  var m3 = Cesium.Matrix3.fromQuaternion(Q);
  var m4 = Cesium.Matrix4.fromRotationTranslation(m3);

  // 计算point1点相对center点的坐标A1
  var A1 = Cesium.Cartesian3.subtract(point1, center, new Cesium.Cartesian3());

  //对A1应用旋转矩阵
  var p = Cesium.Matrix4.multiplyByPoint(m4, A1, new Cesium.Cartesian3());
  // 新点的坐标
  var pointNew = Cesium.Cartesian3.add(p, center, new Cesium.Cartesian3());

  return pointNew;
}

//求p1指向p2方向线上，距离p1指定len长度的新的点 ，addBS：true时为距离p2
function getOnLinePointByLen(p1, p2, len, addBS) {
  var mtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(p1);
  var mtx4_inverser = Cesium.Matrix4.inverse(mtx4, new Cesium.Matrix4());
  p1 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium.Cartesian3());
  p2 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium.Cartesian3());

  var substrct = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());

  var dis = Cesium.Cartesian3.distance(p1, p2);
  var scale = len / dis; //求比例
  if (addBS) scale += 1;

  var newP = Cesium.Cartesian3.multiplyByScalar(substrct, scale, new Cesium.Cartesian3());
  newP = Cesium.Matrix4.multiplyByPoint(mtx4, newP, new Cesium.Cartesian3());
  return newP;
}

//获取点的offest平移矩阵后点
function getPositionTranslation(position, offest, degree, type, fixedFrameTransform) {
  fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

  var rotate = Cesium.Math.toRadians(-Cesium.defaultValue(degree, 0)); //转成弧度

  type = (type || "z").toUpperCase();
  var _normal = Cesium.Cartesian3["UNIT_" + type];

  var quaternion = Cesium.Quaternion.fromAxisAngle(_normal, rotate); //quaternion为围绕这个z轴旋转d度的四元数
  var rotateMatrix3 = Cesium.Matrix3.fromQuaternion(quaternion); //rotateMatrix3为根据四元数求得的旋转矩阵

  var pointCartesian3 = new Cesium.Cartesian3(Cesium.defaultValue(offest.x, 0), Cesium.defaultValue(offest.y, 0), Cesium.defaultValue(offest.z, 0)); //point的局部坐标
  var rotateTranslationMatrix4 = Cesium.Matrix4.fromRotationTranslation(rotateMatrix3, Cesium.Cartesian3.ZERO); //rotateTranslationMatrix4为旋转加平移的4x4变换矩阵，这里平移为(0,0,0)，故填个Cesium.Cartesian3.ZERO
  Cesium.Matrix4.multiplyByTranslation(rotateTranslationMatrix4, pointCartesian3, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4  X  pointCartesian3
  var originPositionCartesian3 = Cesium.Ellipsoid.WGS84.cartographicToCartesian(Cesium.Cartographic.fromCartesian(position)); //得到局部坐标原点的全局坐标
  var originPositionTransform = fixedFrameTransform(originPositionCartesian3); //m1为局部坐标的z轴垂直于地表，局部坐标的y轴指向正北的4x4变换矩阵
  Cesium.Matrix4.multiplyTransformation(originPositionTransform, rotateTranslationMatrix4, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4 X originPositionTransform
  var pointCartesian = new Cesium.Cartesian3();
  Cesium.Matrix4.getTranslation(rotateTranslationMatrix4, pointCartesian); //根据最终变换矩阵m得到p2
  return pointCartesian;
}

//计算平行线，offset正负决定方向（单位米）
function getOffsetLine(positions, offset) {
  var arrNew = [];
  for (var i = 1; i < positions.length; i++) {
    var point1 = positions[i - 1];
    var point2 = positions[i];

    var dir12 = Cesium.Cartesian3.subtract(point1, point2, new Cesium.Cartesian3());
    var dir21left = Cesium.Cartesian3.cross(point1, dir12, new Cesium.Cartesian3());

    var p1offset = computedOffsetData(point1, dir21left, offset * 1000);
    var p2offset = computedOffsetData(point2, dir21left, offset * 1000);

    if (i == 1) {
      arrNew.push(p1offset);
    }
    arrNew.push(p2offset);
  }
  return arrNew;
}

function computedOffsetData(ori, dir, wid) {
  var currRay = new Cesium.Ray(ori, dir);
  return Cesium.Ray.getPoint(currRay, wid, new Cesium.Cartesian3());
}

/**
 * 根据 距离方向 和 观察点 计算 目标点
 * @param {Object} viewPoint 观察点
 * @param {Object} direction 方向(正北方向为0)
 * @param {Object} radius 可视距离
 */
function getPositionByDirectionAndLen(position, angle, radius) {
  var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

  //旋转
  var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle || 0));
  var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
  Cesium.Matrix4.multiply(matrix, rotationZ, matrix);

  var result = Cesium.Matrix4.multiplyByPoint(matrix, new Cesium.Cartesian3(0, radius, 0), new Cesium.Cartesian3());
  return result;
}

/**
 * 求某位置指定方向和距离的点
 * @param {Object} viewPoint 观察点
 * @param {Object} direction 方向
 * @param {Object} radius 可视距离
 */
function getPositionByHprAndLen(position, hpr, radiusZ) {
  var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
  var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, new Cesium.Matrix3()), position, new Cesium.Matrix4());
  var result = Cesium.Matrix4.multiplyByPoint(matrix, new Cesium.Cartesian3(0, 0, -radiusZ), new Cesium.Cartesian3());
  return result;
}

//求点按orientation方向射向地球与地球的交点
function getRayEarthPosition(position, orientation, _reverse, ellipsoid) {
  if (orientation instanceof Cesium.HeadingPitchRoll) {
    orientation = Cesium.Transforms.headingPitchRollQuaternion(position, orientation);
  }

  var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, new Cesium.Matrix3()), position, new Cesium.Matrix4());
  return getRayEarthPositionByMatrix(matrix, _reverse, ellipsoid);
}

//求矩阵射向地球与地球的交点
function getRayEarthPositionByMatrix(_matrix, _reverse, ellipsoid) {
  var scratchWC = new Cesium.Cartesian3();
  var scratchRay = new Cesium.Ray();

  Cesium.Matrix4.multiplyByPoint(_matrix, Cesium.Cartesian3.ZERO, scratchWC);
  scratchWC.clone(scratchRay.origin);

  var bottomCenter = new Cesium.Cartesian3(0, 0, _reverse ? -100 : 100);
  var groundPosition = extend2Earth(bottomCenter, _matrix, scratchRay, ellipsoid);
  return groundPosition;
}

//求地球交点
function extend2Earth(positionLC, matrix, ray, ellipsoid) {
  ellipsoid = ellipsoid ? ellipsoid : Cesium.Ellipsoid.WGS84;

  var scratchWC = new Cesium.Cartesian3();
  Cesium.Matrix4.multiplyByPoint(matrix, positionLC, scratchWC);

  //取延长线与地球相交的点
  Cesium.Cartesian3.subtract(scratchWC, ray.origin, ray.direction);
  Cesium.Cartesian3.normalize(ray.direction, ray.direction);

  //Get the first intersection point of a ray and an ellipsoid.
  var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
  var point = null;
  if (intersection) {
    point = Cesium.Ray.getPoint(ray, intersection.start);
  }
  if (point) {
    try {
      var scratchCartographic2 = new Cesium.Cartographic();
      Cesium.Cartographic.fromCartesian(point, null, scratchCartographic2);
    } catch (e) {
      return null;
    }
  }
  return point;
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.line2curve = line2curve;
exports.line2curve2 = line2curve2;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _LineFlowMaterialProperty = __webpack_require__(40);

var _turf = __webpack_require__(33);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
    if (style.clampToGround) {
      entityattr.arcType = Cesium.ArcType.GEODESIC;
    }
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "lineType": //跳过扩展其他属性的参数
      case "color":
      case "opacity":
      case "outline":
      case "outlineWidth":
      case "outlineColor":
      case "outlineOpacity":
      case "flowDuration":
      case "flowImage":
      case "dashLength":
      case "glowPower":
      case "grid_lineCount":
      case "grid_lineThickness":
      case "grid_cellAlpha":
      case "checkerboard_repeat":
      case "checkerboard_oddcolor":
      case "stripe_oddcolor":
      case "stripe_repeat":
      case "animationDuration":
      case "animationImage":
      case "animationRepeatX":
      case "animationRepeatY":
      case "animationAxisY":
      case "animationGradient":
      case "animationCount":
      case "randomColor":
      case "depthFailColor":
      case "depthFailOpacity":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "depthFail":
        if (value) {
          if (style.depthFailType && style.depthFailType === 'dash') {
            entityattr.depthFailMaterial = new Cesium.PolylineDashMaterialProperty({
              dashLength: style.dashLength || 16.0,
              color: Cesium.Color.fromCssColorString(style.depthFailColor || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.depthFailOpacity, Cesium.defaultValue(style.opacity, 0.9))))
            });
          } else {
            entityattr.depthFailMaterial = Cesium.Color.fromCssColorString(style.depthFailColor || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.depthFailOpacity, Cesium.defaultValue(style.opacity, 0.9))));
          }
          if (style.opacity == 1.0) style.opacity = 0.9; //不透明时，竟然不显示depthFailMaterial？！
        } else {
          entityattr.depthFailMaterial = undefined;
        }
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
    }
  }

  if (style.color || style.lineType) {
    var color;
    if (style.color) {
      color = Cesium.Color.fromCssColorString(style.color).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
    } else if (style.randomColor) {
      color = Cesium.Color.fromRandom({
        minimumRed: Cesium.defaultValue(style.minimumRed, 0.0),
        maximumRed: Cesium.defaultValue(style.maximumRed, 0.75),
        minimumGreen: Cesium.defaultValue(style.minimumGreen, 0.0),
        maximumGreen: Cesium.defaultValue(style.maximumGreen, 0.75),
        minimumBlue: Cesium.defaultValue(style.minimumBlue, 0.0),
        maximumBlue: Cesium.defaultValue(style.maximumBlue, 0.75),
        alpha: Cesium.defaultValue(style.opacity, 1.0)
      });
    } else {
      color = Cesium.Color.fromCssColorString("#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
    }

    switch (style.lineType) {
      default:
      case "solid":
        //实线
        if (style.outline) {
          //存在衬色时
          entityattr.material = new Cesium.PolylineOutlineMaterialProperty({
            color: color,
            outlineWidth: Number(style.outlineWidth || 1.0),
            outlineColor: Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
          });
        } else {
          entityattr.material = color;
        }
        break;
      case "dash":
        //虚线
        if (style.outline) {
          //存在衬色时
          entityattr.material = new Cesium.PolylineDashMaterialProperty({
            dashLength: style.dashLength || style.outlineWidth || 16.0,
            color: color,
            gapColor: Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
          });
        } else {
          entityattr.material = new Cesium.PolylineDashMaterialProperty({
            dashLength: style.dashLength || 16.0,
            color: color
          });
        }

        break;
      case "glow":
        //发光线
        entityattr.material = new Cesium.PolylineGlowMaterialProperty({
          glowPower: style.glowPower || 0.1,
          color: color
        });
        break;
      case "arrow":
        //箭头线
        entityattr.material = new Cesium.PolylineArrowMaterialProperty(color);
        break;
      case "animation":
        //流动线
        var repeatX = Cesium.defaultValue(style.animationRepeatX, 1);
        var repeatY = Cesium.defaultValue(style.animationRepeatY, 1);
        entityattr.material = new _LineFlowMaterialProperty.LineFlowMaterialProperty({
          //动画线材质
          color: color,
          duration: style.animationDuration || 2000, //时长，控制速度
          url: style.animationImage, //图片
          repeat: new Cesium.Cartesian2(repeatX, repeatY)
        });
        break;
    }
  }

  //材质优先
  if (style.material) entityattr.material = style.material;

  return entityattr;
}

//获取entity的坐标
function getPositions(entity, isShowPositions) {
  if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //曲线等情形时，取绑定的数据

  return entity.polyline.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  };
}

//折线转曲线[基于bezierSpline算法]
function line2curve(_positions_draw, closure) {
  var coordinates = _positions_draw.map(function (position) {
    return pointconvert.cartesian2lonlat(position);
  });
  if (closure)
    //闭合曲线
    coordinates.push(coordinates[0]);
  var defHeight = coordinates[coordinates.length - 1][2];

  var curved = (0, _turf.bezierSpline)({
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  });
  var _positions_show = pointconvert.lonlats2cartesians(curved.geometry.coordinates, defHeight);
  return _positions_show;
}

//折线转曲线[基于自己的算法]
function line2curve2(_positions_draw, closure) {
  var points = pointconvert.cartesians2mercators(_positions_draw);
  if (closure)
    //闭合曲线
    points.push(points[0]);

  var pointsNew = _PlotUtil.plotUtil.getBezierPoints(points);
  var _positions_show = pointconvert.mercators2cartesians(pointsNew);
  return _positions_show;
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLength = getLength;
exports.getClampLength = getClampLength;
exports.getArea = getArea;
exports.getAreaOfTriangle = getAreaOfTriangle;
exports.getClampArea = getClampArea;
exports.getAngle = getAngle;
exports.getSlope = getSlope;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _pointconvert = __webpack_require__(4);

var _polygon = __webpack_require__(10);

var _Slope = __webpack_require__(61);

var _turf = __webpack_require__(33);

var _polyline = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//计算空间距离，单位：米
function getLength(positions) {
  if (!Cesium.defined(positions) || positions.length < 2) return 0;

  var distance = 0;
  for (var i = 1, len = positions.length; i < len; i++) {
    distance += Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
  }
  return distance;
}

//计算计算地表贴地距离，单位：米
function getClampLength(positions, options) {
  var all_distance = 0;
  var arrDistance = [];

  (0, _polyline.computeStepSurfaceLine)({
    scene: options.scene,
    positions: positions,
    splitNum: options.splitNum,
    has3dtiles: options.has3dtiles,
    //计算每个分段后的回调方法
    endItem: function endItem(raisedPositions, noHeight, index) {
      var distance = getLength(raisedPositions);
      if (noHeight && options.disTerrainScale) {
        distance = distance * options.disTerrainScale; //求高度失败，概略估算值
      }
      all_distance += distance;

      arrDistance.push(distance);

      if (options.endItem) options.endItem({
        index: index,
        positions: raisedPositions,
        distance: distance,
        arrDistance: arrDistance,
        all_distance: all_distance
      });
    },
    //计算全部完成的回调方法
    end: function end() {
      var callback = options.callback || options.calback; //兼容不同参数名
      if (callback) callback(all_distance, arrDistance);
    }
  });
}

//计算地表投影平面面积，单位：平方米
function getArea(positions, noAdd) {
  var coordinates = (0, _pointconvert.cartesians2lonlats)(positions);

  if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

  //API: http://turfjs.org/docs/#area
  var area = (0, _turf.area)({
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: [coordinates]
    }
  });
  return area;
}

//计算三角形空间面积
function getAreaOfTriangle(pos1, pos2, pos3) {
  var a = Cesium.Cartesian3.distance(pos1, pos2);
  var b = Cesium.Cartesian3.distance(pos2, pos3);
  var c = Cesium.Cartesian3.distance(pos3, pos1);
  var S = (a + b + c) / 2;
  return Math.sqrt(S * (S - a) * (S - b) * (S - c));
}

//计算贴地面积
function getClampArea(positions, options) {
  function _restultArea(resultInter) {
    var area = 0; //总面积(贴地三角面)
    for (var i = 0, len = resultInter.list.length; i < len; i++) {
      var item = resultInter.list[i];
      var pt1 = item.point1;
      var pt2 = item.point2;
      var pt3 = item.point3;

      //求面积
      area += getAreaOfTriangle(pt1.pointDM, pt2.pointDM, pt3.pointDM);
    }
    return area;
  }
  var _callback = options.callback || options.calback; //兼容不同参数名
  var resultInter = (0, _polygon.interPolygon)({
    positions: positions,
    scene: options.scene,
    splitNum: options.splitNum,
    has3dtiles: options.has3dtiles,
    asyn: options.asyn,
    callback: function callback(resultInter) {
      var area = _restultArea(resultInter);
      if (_callback) _callback(area, resultInter);
    }
  });

  if (options.asyn) return null;else {
    var area = _restultArea(resultInter);
    if (_callback) _callback(area, resultInter);
    return area;
  }
}

//求地表方位角，返回：0-360度
function getAngle(firstPoint, endPoints) {
  var carto1 = Cesium.Cartographic.fromCartesian(firstPoint);
  var carto2 = Cesium.Cartographic.fromCartesian(endPoints);
  if (!carto1 || !carto2) return 0;

  var pt1 = {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: [Cesium.Math.toDegrees(carto1.longitude), Cesium.Math.toDegrees(carto1.latitude), carto1.height]
    }
  };
  var pt2 = {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: [Cesium.Math.toDegrees(carto2.longitude), Cesium.Math.toDegrees(carto2.latitude), carto2.height]
    }
  };
  //API: http://turfjs.org/docs/#rhumbBearing
  var bearing = Math.round((0, _turf.rhumbBearing)(pt1, pt2));
  return bearing;
}

//获取点相对于中心点的地面角度
// export function getAngle(positionCenter, positionNew) {
//     //获取该位置的默认矩阵
//     var mat = Cesium.Transforms.eastNorthUpToFixedFrame(positionCenter);
//     mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());

//     var xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
//     var yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
//     var zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());

//     //计算该位置 和  positionCenter 的 角度值
//     var dir = Cesium.Cartesian3.subtract(positionNew, positionCenter, new Cesium.Cartesian3());
//     //z crosss (dirx cross z) 得到在 xy平面的向量
//     dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
//     dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
//     dir = Cesium.Cartesian3.normalize(dir, dir);

//     var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

//     var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
//     if (ay > Math.PI * 0.5) {
//         heading = 2 * Math.PI - heading;
//     }
//     return -Cesium.Math.toDegrees(heading);
// }

//求多个点的  坡度坡向
function getSlope(options) {
  var slope = new _Slope.Slope({
    viewer: options.viewer,
    positions: options.positions,
    splitNum: 1,
    radius: options.radius, //缓冲半径（影响坡度坡向的精度）
    count: options.count, //缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
    has3dtiles: options.has3dtiles,
    point: Cesium.defaultValue(options.point, { show: false }),
    arrow: Cesium.defaultValue(options.arrow, { show: false })
  });
  if (options.endItem) {
    slope.on(_DasClass.eventType.endItem, options.endItem);
  }
  slope.on(_DasClass.eventType.end, function (e) {
    if (options.callback) options.callback(e);
    slope.destroy();
  });
  return slope;
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolyline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _point = __webpack_require__(2);

var _Tooltip = __webpack_require__(8);

var _Attr = __webpack_require__(17);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(27);

var _Draw = __webpack_require__(46);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolyline = exports.DrawPolyline = function (_DrawBase) {
  _inherits(DrawPolyline, _DrawBase);

  //========== 构造方法 ==========
  function DrawPolyline(opts) {
    _classCallCheck(this, DrawPolyline);

    var _this = _possibleConstructorReturn(this, (DrawPolyline.__proto__ || Object.getPrototypeOf(DrawPolyline)).call(this, opts));

    _this.type = "polyline";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditPolyline; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 9999; //最多允许点的个数
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawPolyline, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      var that = this;
      var addattr = {
        polyline: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      addattr.polyline.positions = new Cesium.CallbackProperty(function (time) {
        var arr = that.getDrawPosition();
        if (attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.entity._positions_draw = this._positions_draw;
      return this.entity;
    }
    //重新激活绘制

  }, {
    key: "reCreateFeature",
    value: function reCreateFeature(entity) {
      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      var attribute = entity.attribute;
      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      this.entity = entity;
      this._positions_draw = entity._positions_draw || entity.polyline.positions.getValue(this.viewer.clock.currentTime);
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.polyline);
    }
  }, {
    key: "removeNearPoint",
    value: function removeNearPoint() {
      if (this._positions_draw.length < 3) return;
      //消除双击带来的多余经纬度
      for (var i = this._positions_draw.length - 1; i > 0; i--) {
        var mpt1 = this._positions_draw[i];
        var mpt2 = this._positions_draw[i - 1];
        if (Math.abs(mpt1.x - mpt2.x) < 0.01 && Math.abs(mpt1.y - mpt2.y) < 0.01 && Math.abs(mpt1.z - mpt2.z) < 0.01) this._positions_draw.pop();else break;
      }
    }
    //绑定鼠标事件

  }, {
    key: "bindEvent",
    value: function bindEvent() {
      var _this2 = this;

      var lastPointTemporary = false;
      this.getHandler().setInputAction(function (event) {
        //单击添加点
        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
        if (!point && lastPointTemporary) {
          //如果未拾取到点，并且存在MOUSE_MOVE时，取最后一个move的点
          point = _this2._positions_draw[_this2._positions_draw.length - 1];
        }

        if (point) {
          if (lastPointTemporary) {
            _this2._positions_draw.pop();
          }
          lastPointTemporary = false;

          _this2.removeNearPoint(); //消除双击带来的多余经纬度

          //在绘制点基础自动增加高度
          if (_this2.entity.attribute && _this2.entity.attribute.config && _this2.entity.attribute.config.addHeight) point = (0, _point.addPositionsHeight)(point, _this2.entity.attribute.config.addHeight);

          _this2._positions_draw.push(point);
          _this2.updateAttrForDrawing();

          _this2.fire(_DasClass.eventType.drawAddPoint, {
            drawtype: _this2.type,
            entity: _this2.entity,
            position: point,
            positions: _this2._positions_draw
          });

          if (_this2._positions_draw.length >= _this2._maxPointNum) {
            //点数满足最大数量，自动结束
            _this2.disable();
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      this.getHandler().setInputAction(function (event) {
        //右击删除上一个点
        _this2._positions_draw.pop(); //删除最后标的一个点

        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
        if (point) {
          if (lastPointTemporary) {
            _this2._positions_draw.pop();
          }
          lastPointTemporary = true;

          _this2.fire(_DasClass.eventType.drawRemovePoint, {
            drawtype: _this2.type,
            entity: _this2.entity,
            position: point,
            positions: _this2._positions_draw
          });

          _this2._positions_draw.push(point);
          _this2.updateAttrForDrawing();
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

      this.getHandler().setInputAction(function (event) {
        //鼠标移动

        if (_this2._positions_draw.length <= 1) _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.start);else if (_this2._positions_draw.length < _this2._minPointNum)
          //点数不满足最少数量
          _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.cont);else if (_this2._positions_draw.length >= _this2._maxPointNum)
          //点数满足最大数量
          _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end2);else _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end);

        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);
        if (point) {
          if (lastPointTemporary) {
            _this2._positions_draw.pop();
          }
          lastPointTemporary = true;

          _this2._positions_draw.push(point);
          _this2.updateAttrForDrawing();

          _this2.fire(_DasClass.eventType.drawMouseMove, {
            drawtype: _this2.type,
            entity: _this2.entity,
            position: point,
            positions: _this2._positions_draw
          });
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      this.getHandler().setInputAction(function (event) {
        //双击结束标绘
        _this2.removeNearPoint(); //消除双击带来的多余经纬度
        _this2.endDraw();
      }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    }
    //外部控制，完成绘制，比如手机端无法双击结束

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (!this._enabled) {
        return this;
      }

      if (this._positions_draw.length < this._minPointNum) return; //点数不够
      this.updateAttrForDrawing();
      this.disable();
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isLoad) {}
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      // entity.polyline.positions = new Cesium.CallbackProperty((time)=> {
      //     return entity._positions_draw;
      // }, false);

      //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
      if (Cesium.defined(entity.polyline.depthFailMaterial)) {
        var arr = entity._positions_draw;
        if (entity.attribute.style.closure) arr = arr.concat(arr[0]); //闭合
        entity.polyline.positions = arr;
      } else {
        entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
          var arr = entity._positions_draw;
          if (entity.attribute.style.closure) return arr.concat(arr[0]);
          //闭合
          else return arr;
        }, false);
      }
    }
  }]);

  return DrawPolyline;
}(_Draw.DrawBase);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setFillMaterial = setFillMaterial;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _LineFlowMaterialProperty = __webpack_require__(40);

var _CircleWaveMaterialProperty = __webpack_require__(54);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function setFillMaterial(entityattr, style) {
  if (style.material) {
    //material属性优先
    entityattr.material = style.material;
    return entityattr;
  }

  if (style.color || style.fillType) {
    var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));

    switch (style.fillType) {
      default:
      case "color":
        //纯色填充
        entityattr.material = color;
        break;
      case "image":
        //图片填充
        var repeat = Cesium.defaultValue(style.image_repeat, 1);
        entityattr.material = new Cesium.ImageMaterialProperty({
          image: style.image,
          color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
          transparent: style.transparent, //是否png透明
          repeat: new Cesium.Cartesian2(repeat, repeat)
        });
        break;
      case "grid":
        //网格
        var lineCount = Cesium.defaultValue(style.grid_lineCount, 8);
        var lineThickness = Cesium.defaultValue(style.grid_lineThickness, 2.0);
        entityattr.material = new Cesium.GridMaterialProperty({
          color: color,
          cellAlpha: Cesium.defaultValue(style.grid_cellAlpha, 0.1),
          lineCount: new Cesium.Cartesian2(lineCount, lineCount),
          lineThickness: new Cesium.Cartesian2(lineThickness, lineThickness)
        });
        break;
      case "checkerboard":
        //棋盘
        var checkerboard_repeat = Cesium.defaultValue(style.checkerboard_repeat, 4);
        entityattr.material = new Cesium.CheckerboardMaterialProperty({
          evenColor: color,
          oddColor: Cesium.Color.fromCssColorString(style.checkerboard_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
          repeat: new Cesium.Cartesian2(checkerboard_repeat, checkerboard_repeat)
        });
        break;
      case "stripe":
        // 条纹
        entityattr.material = new Cesium.StripeMaterialProperty({
          evenColor: color,
          oddColor: Cesium.Color.fromCssColorString(style.stripe_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
          repeat: Cesium.defaultValue(style.stripe_repeat, 6)
        });
        break;
      case "animationLine":
        //流动线
        entityattr.material = new _LineFlowMaterialProperty.LineFlowMaterialProperty({
          //动画线材质
          color: color,
          duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
          url: style.animationImage, //图片
          repeat: new Cesium.Cartesian2(style.animationRepeatX || 1, style.animationRepeatY || 1),
          axisY: style.animationAxisY,
          bgUrl: style.bgUrl,
          bgColor: style.bgColor ? Cesium.Color.fromCssColorString(style.bgColor) : null
        });
        break;
      case "animationCircle":
        //动态圆
        entityattr.material = new _CircleWaveMaterialProperty.CircleWaveMaterialProperty({
          duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
          color: Cesium.Color.fromCssColorString(style.color || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
          gradient: Cesium.defaultValue(style.animationGradient, 0),
          count: Cesium.defaultValue(style.animationCount, 1)
        });
        break;
    }
  }

  //如果未设置任何material，默认设置随机颜色
  if (entityattr.material == null || style.randomColor) {
    entityattr.material = Cesium.Color.fromRandom({
      minimumRed: Cesium.defaultValue(style.minimumRed, 0.0),
      maximumRed: Cesium.defaultValue(style.maximumRed, 0.75),
      minimumGreen: Cesium.defaultValue(style.minimumGreen, 0.0),
      maximumGreen: Cesium.defaultValue(style.maximumGreen, 0.75),
      minimumBlue: Cesium.defaultValue(style.minimumBlue, 0.0),
      maximumBlue: Cesium.defaultValue(style.maximumBlue, 0.75),
      alpha: Cesium.defaultValue(style.opacity, 1.0)
    });
  }

  return entityattr;
} //通用处理方法

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getAllPositions = getAllPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
    if (style.clampToGround) {
      entityattr.arcType = Cesium.ArcType.GEODESIC;
    }
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "color": //跳过扩展其他属性的参数
      case "opacity":
      case "outlineOpacity":
      case "grid_lineCount":
      case "grid_lineThickness":
      case "grid_cellAlpha":
      case "checkerboard_repeat":
      case "checkerboard_oddcolor":
      case "stripe_oddcolor":
      case "stripe_repeat":
      case "animationDuration":
      case "animationImage":
      case "animationRepeatX":
      case "animationRepeatY":
      case "animationAxisY":
      case "animationGradient":
      case "animationCount":
      case "randomColor":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outline":
        //边线
        if (entityattr[key] instanceof Cesium.CallbackProperty) {
          //回调时不覆盖
        } else {
          entityattr[key] = value;
        }
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || style.color || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
        break;
      case "extrudedHeight":
        //高度
        if ((0, _util.isNumber)(value)) {
          var maxHight = 0;
          if (entityattr.hierarchy) {
            var positions = getPositions({ polygon: entityattr });
            maxHight = (0, _point.getMaxHeight)(positions);
          }
          entityattr.extrudedHeight = Number(value) + maxHight;
        } else {
          entityattr.extrudedHeight = value;
        }
        break;
      case "clampToGround":
        //贴地
        entityattr.perPositionHeight = !value;
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
      case "stRotation":
        //材质旋转角度
        entityattr.stRotation = Cesium.Math.toRadians(value);
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标【只取最外层圈坐标】
function getPositions(entity, isShowPositions) {
  if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //箭头标绘等情形时，取绑定的数据

  var arr = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
  if (arr && arr instanceof Cesium.PolygonHierarchy) {
    arr = arr.positions;
  }
  return arr;
}

//获取entity的多个坐标【只取多圈的坐标，如挖洞多边形】
function getAllPositions(entity) {
  var arr = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
  var result = getHierarchyVal(arr);
  return result;
}
function getHierarchyVal(arr) {
  if (arr && arr instanceof Cesium.PolygonHierarchy) {
    var result = [];
    for (var i = 0, len = arr.holes.length; i < len; i++) {
      var item = arr.holes[i]; //PolygonHierarchy
      result = result.concat(getHierarchyVal(item));
    }
    result.push(arr.positions);
    return result;
  } else {
    return [arr];
  }
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity, noAdd) {
  var coordinates = getCoordinates(entity);

  if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "Polygon",
      coordinates: [coordinates]
    }
  };
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.box = exports.plane = exports.corridor = exports.ellipsoid = exports.rectangle = exports.cylinder = exports.ellipse = exports.circle = exports.polygon = exports.wall = exports.polylineVolume = exports.polyline = exports.model = exports.point = exports.label = exports.billboard = undefined;
exports.getTypeName = getTypeName;
exports.getCoordinates = getCoordinates;
exports.getPositions = getPositions;
exports.getCenterPosition = getCenterPosition;
exports.toGeoJSON = toGeoJSON;
exports.style2Entity = style2Entity;
exports.removeGeoJsonDefVal = removeGeoJsonDefVal;
exports.addGeoJsonDefVal = addGeoJsonDefVal;
exports.getDefStyle = getDefStyle;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _Attr = __webpack_require__(34);

var billboard = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(13);

var label = _interopRequireWildcard(_Attr2);

var _Attr3 = __webpack_require__(35);

var point = _interopRequireWildcard(_Attr3);

var _Attr4 = __webpack_require__(36);

var model = _interopRequireWildcard(_Attr4);

var _Attr5 = __webpack_require__(53);

var plane = _interopRequireWildcard(_Attr5);

var _Attr6 = __webpack_require__(55);

var box = _interopRequireWildcard(_Attr6);

var _Attr7 = __webpack_require__(17);

var polyline = _interopRequireWildcard(_Attr7);

var _Attr8 = __webpack_require__(56);

var polylineVolume = _interopRequireWildcard(_Attr8);

var _Attr9 = __webpack_require__(57);

var wall = _interopRequireWildcard(_Attr9);

var _Attr10 = __webpack_require__(41);

var corridor = _interopRequireWildcard(_Attr10);

var _Attr11 = __webpack_require__(21);

var polygon = _interopRequireWildcard(_Attr11);

var _Attr12 = __webpack_require__(42);

var circle = _interopRequireWildcard(_Attr12);

var _Attr13 = __webpack_require__(69);

var cylinder = _interopRequireWildcard(_Attr13);

var _Attr14 = __webpack_require__(66);

var rectangle = _interopRequireWildcard(_Attr14);

var _Attr15 = __webpack_require__(70);

var ellipsoid = _interopRequireWildcard(_Attr15);

var _defaultStyle = __webpack_require__(136);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ellipse = circle;

exports.billboard = billboard;
exports.label = label;
exports.point = point;
exports.model = model;
exports.polyline = polyline;
exports.polylineVolume = polylineVolume;
exports.wall = wall;
exports.polygon = polygon;
exports.circle = circle;
exports.ellipse = ellipse;
exports.cylinder = cylinder;
exports.rectangle = rectangle;
exports.ellipsoid = ellipsoid;
exports.corridor = corridor;
exports.plane = plane;
exports.box = box;
function getTypeName(entity) {
  if (entity.polygon) return "polygon";
  if (entity.rectangle) return "rectangle";

  if (entity.polyline) return "polyline";
  if (entity.polylineVolume) return "polylineVolume";
  if (entity.corridor) return "corridor";
  if (entity.wall) return "wall";

  if (entity.ellipse) return "circle";
  if (entity.ellipsoid) return "ellipsoid";
  if (entity.cylinder) return "cylinder";
  if (entity.plane) return "plane";
  if (entity.box) return "box";

  if (entity.billboard) return "billboard";
  if (entity.point) return "point";
  if (entity.model) return "model";
  if (entity.label) return "label";

  return "";
}

function defNullFun(entity) {
  return null;
}

function getAttrClass(entity) {
  if (entity.polygon) return polygon;
  if (entity.rectangle) return rectangle;

  if (entity.polyline) return polyline;
  if (entity.polylineVolume) return polylineVolume;
  if (entity.corridor) return corridor;
  if (entity.wall) return wall;

  if (entity.ellipse) return circle;
  if (entity.cylinder) return cylinder;
  if (entity.ellipsoid) return ellipsoid;
  if (entity.plane) return plane;
  if (entity.box) return box;

  if (entity.point) return point;
  if (entity.billboard) return billboard;
  if (entity.model) return model;
  if (entity.label) return label;

  return {
    getCoordinates: defNullFun,
    getPositions: defNullFun,
    toGeoJSON: defNullFun,
    style2Entity: defNullFun
  };
}

function getCoordinates(entity) {
  return getAttrClass(entity).getCoordinates(entity);
}

function getPositions(entity) {
  return getAttrClass(entity).getPositions(entity);
}

function getCenterPosition(entity) {
  var position;
  if (entity.position) {
    //存在position属性时，直接取
    position = (0, _point.getPositionValue)(entity.position);
    if (position) return position;
  }

  var pots = getPositions(entity);
  if (!pots || pots.length == 0) return null;
  if (pots.length == 1) return pots[0];

  if (entity.polygon) position = (0, _point.centerOfMass)(pots);else position = pots[Math.floor(pots.length / 2)];
  return position;
}

function toGeoJSON(entity) {
  return getAttrClass(entity).toGeoJSON(entity);
}

function style2Entity(style, entity) {
  return getAttrClass(entity).style2Entity(style, entity);
}

//剔除与默认值相同的值
function removeGeoJsonDefVal(geojson) {
  if (!geojson.properties || !geojson.properties.type) return geojson;

  var type = geojson.properties.edittype || geojson.properties.type;
  var defStyle = _defaultStyle.defaultStyle[type];
  if (!defStyle) return geojson;

  var newgeojson = (0, _util.clone)(geojson);
  if (geojson.properties.style) {
    var newstyle = {};
    for (var i in geojson.properties.style) {
      var val = geojson.properties.style[i];
      if (!Cesium.defined(val)) continue;

      var valDef = defStyle[i];
      if (valDef === val) continue;
      newstyle[i] = val;
    }
    newgeojson.properties.style = newstyle;
  }

  return newgeojson;
}

function addGeoJsonDefVal(properties) {
  //赋默认值
  var defStyle = _defaultStyle.defaultStyle[properties.edittype || properties.type];
  if (defStyle) {
    properties.style = properties.style || {};
    for (var key in defStyle) {
      var val = properties.style[key];
      if (Cesium.defined(val)) continue;

      properties.style[key] = defStyle[key];
    }
  }
  return properties;
}

//获取默认的样式
function getDefStyle(type, style) {
  style = style || {};
  //赋默认值
  var defStyle = _defaultStyle.defaultStyle[type];
  if (defStyle) {
    for (var key in defStyle) {
      var val = style[key];
      if (val != null) continue;

      style[key] = defStyle[key];
    }
  }
  return (0, _util.clone)(style);
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interPolyline = interPolyline;
exports.computeSurfaceLine = computeSurfaceLine;
exports.computeSurfacePoints = computeSurfacePoints;
exports.computeStepSurfaceLine = computeStepSurfaceLine;
exports.interLine = interLine;
exports.getLinkedPointList = getLinkedPointList;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _layer = __webpack_require__(24);

var _util = __webpack_require__(3);

var _tileset = __webpack_require__(32);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//路线进行贴地(或贴模型)插值, splitNum为次数
function interPolyline(opts) {
  var positions = opts.positions;
  var scene = opts.scene;

  var granularity = (0, _util.getGranularity)(positions, opts.splitNum || 100);
  if (granularity <= 0) granularity = null;

  var flatPositions = Cesium.PolylinePipeline.generateArc({
    positions: positions,
    height: opts.height, //未传入时，内部默认为0
    minDistance: opts.minDistance, //插值间隔(米)，优先级高于granularity
    granularity: granularity //splitNum分割的个数
  });

  var arr = [];
  for (var i = 0; i < flatPositions.length; i += 3) {
    var position = Cesium.Cartesian3.unpack(flatPositions, i);
    if (scene && Cesium.defaultValue(opts.surfaceHeight, true)) {
      var height = (0, _point.getSurfaceHeight)(scene, position, opts);
      var car = Cesium.Cartographic.fromCartesian(position);
      position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
    }
    arr.push(position);
  }
  return arr;
}

//计算贴地(或贴模型)路线（异步）
var surfaceLineWork = {
  start: function start(params) {
    this.params = params;
    this.scene = params.viewer ? params.viewer.scene : params.scene;

    var positions = params.positions;
    if (positions == null || positions.length == 0) {
      //无数据
      this.end(positions);
      return;
    }
    this.positions = positions;

    //线中间插值
    var _split = Cesium.defaultValue(params.split, true);
    if (_split) {
      positions = interPolyline({
        scene: this.scene,
        positions: positions,
        height: params.height,
        minDistance: params.minDistance,
        surfaceHeight: params.splitSurfaceHeight,
        splitNum: Cesium.defaultValue(params.splitNum, 100)
      });

      var positionsClone = [];
      for (var i = 0, len = positions.length; i < len; ++i) {
        positionsClone.push(positions[i].clone());
      }
      this.positions = positionsClone;
    }

    var _has3dtiles = Cesium.defaultValue(params.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(this.scene, positions))); //是否在3ditiles上面
    var _hasTerrain = (0, _layer.hasTerrain)(this.scene); //是否有地形

    this._has3dtiles = _has3dtiles;
    this._hasTerrain = _hasTerrain;

    if (!_hasTerrain && !_has3dtiles) {
      //无地形和无模型时，直接返回
      this.end(positions);
      return;
    }

    //开始分析
    if (_hasTerrain) {
      this.clampToTerrain(positions);
    } else {
      this.clampTo3DTileset(positions);
    }
    return this;
  },
  clampToTerrain: function clampToTerrain(positions) {
    var ellipsoid = this.scene.globe.ellipsoid;
    var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions);

    //用于缺少地形数据时，赋值的高度
    var tempHeight = Cesium.Cartographic.fromCartesian(positions[0]).height;

    var that = this;
    Cesium.when(Cesium.sampleTerrainMostDetailed(this.scene.terrainProvider, cartographicArray), function (samples) {
      samples = that.removeNullData(samples);

      var noHeight = false;
      var offset = Cesium.defaultValue(that.params.offset, 0); //增高高度，便于可视

      for (var i = 0; i < samples.length; ++i) {
        if (samples[i].height == null) {
          noHeight = true;
          samples[i].height = tempHeight;
        } else {
          samples[i].height = offset + samples[i].height * that.scene._terrainExaggeration;
        }
      }

      var raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);

      if (that._has3dtiles) {
        that.clampTo3DTileset(raisedPositions);
      } else {
        that.end(raisedPositions, noHeight);
      }
    });
  },
  clampTo3DTileset: function clampTo3DTileset(positions) {
    var that = this;
    var positionsClone = [];
    for (var i = 0, len = positions.length; i < len; ++i) {
      positionsClone.push(positions[i].clone());
    }
    this.scene.clampToHeightMostDetailed(positionsClone, this.params.objectsToExclude, 0.2).then(function (clampedCartesians) {
      clampedCartesians = that.removeNullData(clampedCartesians);
      if (clampedCartesians.length == 0) {
        clampedCartesians = positions;
      }
      that.end(clampedCartesians);
    });
  },
  end: function end(raisedPositions, noHeight) {
    var callback = this.params.callback || this.params.calback; //兼容不同参数名
    if (callback) {
      callback(raisedPositions, noHeight, this.positions);
    }
  },
  removeNullData: function removeNullData(samples) {
    var arrNew = [];
    for (var i = 0; i < samples.length; ++i) {
      if (samples[i] != null) {
        arrNew.push(samples[i]);
      }
    }
    return arrNew;
  }
};

//对外接口,求路线的贴地线
function computeSurfaceLine(params) {
  return surfaceLineWork.start(params);
}

//对外接口,求多个点的的贴地新坐标（不插值）
function computeSurfacePoints(params) {
  params.split = false;
  return surfaceLineWork.start(params);
}

//对外接口,按2个坐标点分段计算 求路线的贴地线
function computeStepSurfaceLine(opts) {
  var positions = opts.positions;

  var params = {};
  for (var key in opts) {
    if (key == "positions" || key == "callback" || key == "calback") continue;
    params[key] = opts[key];
  }

  var index = 0;
  var allcount = positions.length - 1;
  function getLineFD() {
    if (index >= allcount) {
      if (opts.callback) opts.callback();
      if (opts.end) opts.end();

      //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
      if (opts.calback) opts.calback();
      if (opts.calbakEnd) opts.calbakEnd();
      //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
      return;
    }

    params.positions = [positions[index], positions[index + 1]];
    params.callback = function (raisedPositions, noHeight) {
      if (opts.endItem) {
        opts.endItem(raisedPositions, noHeight, index);
      }

      //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
      if (opts.calbakStep) {
        opts.calbakStep(raisedPositions, noHeight, index);
      }
      //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

      index++;
      getLineFD();
    };
    surfaceLineWork.start(params);
  }
  getLineFD();
}

//插值线（高度值按原高度等比计算）
function interLine(positions, opts) {
  if (!positions || positions.length < 2) return positions;

  opts = opts || {};

  var granularity;
  if (opts.splitNum) {
    //splitNum分割的个数
    granularity = (0, _util.getGranularity)(positions, opts.splitNum);
    if (granularity <= 0) granularity = null;
  }

  var arr = [positions[0]];
  for (var index = 1, length = positions.length; index < length; index++) {
    var startP = positions[index - 1];
    var endP = positions[index];

    var interPositions = Cesium.PolylinePipeline.generateArc({
      positions: [startP, endP],
      minDistance: opts.minDistance, //插值间隔(米)，优先级高于granularity
      granularity: granularity //splitNum分割的个数
    });

    //剖面的数据
    var h1 = Cesium.Cartographic.fromCartesian(startP).height;
    var h2 = Cesium.Cartographic.fromCartesian(endP).height;
    var hstep = (h2 - h1) / interPositions.length;

    for (var i = 3, len = interPositions.length; i < len; i += 3) {
      var position = Cesium.Cartesian3.unpack(interPositions, i);

      var car = Cesium.Cartographic.fromCartesian(position);

      var height = Number((h1 + hstep * i).toFixed(1));
      position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);

      arr.push(position);
    }
  }
  return arr;
}

/**
 * 计算曲线链路的点集（a点到b点的，空中曲线）
 * @param startPoint 开始节点
 * @param endPoint 结束节点
 * @param angularityFactor 曲率
 * @param numOfSingleLine 点集数量
 * @returns {Array}
 */
function getLinkedPointList(startPoint, endPoint, angularityFactor, numOfSingleLine) {
  var result = [];

  var startPosition = Cesium.Cartographic.fromCartesian(startPoint);
  var endPosition = Cesium.Cartographic.fromCartesian(endPoint);

  var startLon = startPosition.longitude * 180 / Math.PI;
  var startLat = startPosition.latitude * 180 / Math.PI;
  var endLon = endPosition.longitude * 180 / Math.PI;
  var endLat = endPosition.latitude * 180 / Math.PI;

  var dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat));

  //var dist = Cesium.Cartesian3.distance(startPoint, endPoint);
  var angularity = dist * angularityFactor;

  var startVec = Cesium.Cartesian3.clone(startPoint);
  var endVec = Cesium.Cartesian3.clone(endPoint);

  var startLength = Cesium.Cartesian3.distance(startVec, Cesium.Cartesian3.ZERO);
  var endLength = Cesium.Cartesian3.distance(endVec, Cesium.Cartesian3.ZERO);

  Cesium.Cartesian3.normalize(startVec, startVec);
  Cesium.Cartesian3.normalize(endVec, endVec);

  if (Cesium.Cartesian3.distance(startVec, endVec) == 0) {
    return result;
  }

  //var cosOmega = Cesium.Cartesian3.dot(startVec, endVec);
  //var omega = Math.acos(cosOmega);

  var omega = Cesium.Cartesian3.angleBetween(startVec, endVec);

  result.push(startPoint);
  for (var i = 1; i < numOfSingleLine - 1; i++) {
    var t = i * 1.0 / (numOfSingleLine - 1);
    var invT = 1 - t;

    var startScalar = Math.sin(invT * omega) / Math.sin(omega);
    var endScalar = Math.sin(t * omega) / Math.sin(omega);

    var startScalarVec = Cesium.Cartesian3.multiplyByScalar(startVec, startScalar, new Cesium.Cartesian3());
    var endScalarVec = Cesium.Cartesian3.multiplyByScalar(endVec, endScalar, new Cesium.Cartesian3());

    var centerVec = Cesium.Cartesian3.add(startScalarVec, endScalarVec, new Cesium.Cartesian3());

    var ht = t * Math.PI;
    var centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
    centerVec = Cesium.Cartesian3.multiplyByScalar(centerVec, centerLength, centerVec);

    result.push(centerVec);
  }

  result.push(endPoint);

  return result;
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createImageryProvider = exports.createLayer = exports.regLayerForConfig = exports.FeatureGridImageryProvider = exports.TencentImageryProvider = exports.BaiduImageryProvider = exports.I3SLayer = exports.ShpLayer = exports.DrawLayer = exports.TerrainLayer = exports.CzmlLayer = exports.KmlLayer = exports.Tiles3dLayer = exports.GltfLayer = exports.WaterLayer = exports.GeoJsonLayer = exports.WFSLayer = exports.POILayer = exports.CustomFeatureGridLayer = exports.GraticuleLayer = exports.SuperMapImgLayer = exports.TileLayer = exports.GroupLayer = exports.BaseLayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.hasTerrain = hasTerrain;
exports.getEllipsoidTerrain = getEllipsoidTerrain;
exports.getTerrainProvider = getTerrainProvider;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _util = __webpack_require__(3);

var _token = __webpack_require__(30);

var token = _interopRequireWildcard(_token);

var _BaseLayer = __webpack_require__(14);

var _GroupLayer = __webpack_require__(99);

var _TileLayer = __webpack_require__(43);

var _SuperMapImgLayer = __webpack_require__(100);

var _GraticuleLayer = __webpack_require__(101);

var _CustomFeatureGridLayer = __webpack_require__(44);

var _POILayer = __webpack_require__(104);

var _WFSLayer = __webpack_require__(109);

var _GeoJsonLayer = __webpack_require__(45);

var _WaterLayer = __webpack_require__(110);

var _GltfLayer = __webpack_require__(111);

var _Tiles3dLayer = __webpack_require__(112);

var _KmlLayer = __webpack_require__(113);

var _CzmlLayer = __webpack_require__(114);

var _TerrainLayer = __webpack_require__(115);

var _DrawLayer = __webpack_require__(116);

var _ShpLayer = __webpack_require__(131);

var _I3SLayer = __webpack_require__(132);

var _BaiduImageryProvider = __webpack_require__(133);

var _TencentImageryProvider = __webpack_require__(134);

var _FeatureGridImageryProvider = __webpack_require__(135);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//类库外部的类
var exLayer = {};
function regLayerForConfig(type, layerClass) {
  exLayer[type] = layerClass;
}

//创建图层
function createLayer(viewer, item, serverURL) {
  //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
  if (item instanceof Cesium.Viewer) {
    var temppar = item;
    item = viewer;
    viewer = temppar;
  }
  //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

  var layer;

  if (item.url) {
    if (serverURL) {
      item.url = item.url.replace("$serverURL$", serverURL);
    }
    item.url = item.url.replace("$hostname$", location.hostname).replace("$host$", location.host);
  }

  switch (item.type) {
    //===============地图数组====================
    case "group":
      //示例：{ "name": "电子地图", "type": "group","layers": [    ]}
      if (item.layers && item.layers.length > 0) {
        var arrVec = [];
        for (var index = 0; index < item.layers.length; index++) {
          var temp = createLayer(viewer, item.layers[index], serverURL);
          if (temp == null) continue;
          arrVec.push(temp);
        }
        var newItem = {};
        for (var key in item) {
          newItem[key] = item[key];
        }
        newItem._layers = arrVec;
        layer = new _GroupLayer.GroupLayer(viewer, newItem);
      }
      break;
    case "base":
      layer = new _BaseLayer.BaseLayer(viewer, item);
      break;
    case "www_ion": //cesium ion资源地图
    case "www_bing": //bing地图
    case "www_osm": //OSM开源地图
    case "www_google": //谷歌国内
    case "www_gaode": //高德
    case "www_baidu": //百度
    case "www_tencent": //腾讯
    case "www_tdt": //天地图
    case "mapbox":
    case "www_mapbox":
    case "mapboxstyle":
    case "www_mapboxstyle":
    case "arcgis_cache":
    case "arcgis":
    case "arcgis_tile":
    case "arcgis_dynamic":
    case "wmts":
    case "tms":
    case "wms":
    case "xyz":
    case "tile":
    case "single":
    case "image":
    case "gee":
    case "custom_tilecoord": //瓦片信息
    case "custom_grid":
      //网格线
      //瓦片图层
      layer = new _TileLayer.TileLayer(viewer, item);
      layer.isTile = true;
      break;
    case "sm_img": //超图底图支持
    case "supermap_img":
      //瓦片图层
      layer = new _SuperMapImgLayer.SuperMapImgLayer(viewer, item);
      layer.isTile = true;
      break;
    case "www_poi":
      //在线poi数据
      layer = new _POILayer.POILayer(viewer, item);
      break;
    case "custom_featuregrid":
      //自定义矢量网格图层
      layer = new _CustomFeatureGridLayer.CustomFeatureGridLayer(viewer, item);
      break;
    case "custom_graticule":
      layer = new _GraticuleLayer.GraticuleLayer(viewer, item);
      break;

    case "3dtiles":
      //倾斜模型加入一些基础参数

      item["dynamicScreenSpaceError"] = Cesium.defaultValue(item["dynamicScreenSpaceError"], true);
      item["dynamicScreenSpaceErrorDensity"] = Cesium.defaultValue(item["dynamicScreenSpaceErrorDensity"], 0.00278);
      item["dynamicScreenSpaceErrorFactor"] = Cesium.defaultValue(item["dynamicScreenSpaceErrorFactor"], 4.0);
      item["dynamicScreenSpaceErrorHeightFalloff"] = Cesium.defaultValue(item["dynamicScreenSpaceErrorHeightFalloff"], 0.25);
      item["skipLevelOfDetail"] = Cesium.defaultValue(item["skipLevelOfDetail"], true);
      item["immediatelyLoadDesiredLevelOfDetail"] = Cesium.defaultValue(item["immediatelyLoadDesiredLevelOfDetail"], true);

      layer = new _Tiles3dLayer.Tiles3dLayer(viewer, item);
      break;
    case "gltf":
      layer = new _GltfLayer.GltfLayer(viewer, item);
      break;
    case "geojson":
      layer = new _GeoJsonLayer.GeoJsonLayer(viewer, item);
      break;
    case "geojson-draw":
      //基于框架内部draw绘制保存的geojson数据的加载
      layer = new _DrawLayer.DrawLayer(viewer, item);
      break;
    case "water":
    case "geojson-water":
      layer = new _WaterLayer.WaterLayer(viewer, item);
      break;
    case "kml":
      layer = new _KmlLayer.KmlLayer(viewer, item);
      break;
    case "czml":
      layer = new _CzmlLayer.CzmlLayer(viewer, item);
      break;
    case "wfs":
      layer = new _WFSLayer.WFSLayer(viewer, item);
      break;
    case "terrain":
      if (serverURL && item.terrain && item.terrain.url) {
        item.terrain.url = item.terrain.url.replace("$serverURL$", serverURL);
      }
      layer = new _TerrainLayer.TerrainLayer(viewer, item);
      break;
    case "shp":
      layer = new _ShpLayer.ShpLayer(viewer, item);
      break;
    case "i3s":
      layer = new _I3SLayer.I3SLayer(viewer, item);
      break;
    default:
      if (exLayer[item.type]) {
        layer = new exLayer[item.type](viewer, item);
      }
      if (layer == null) {
        daslog.warn("配置中的图层未处理", item);
      }
      break;
  }

  return layer;
}

//创建地图底图
function createImageryProvider(item, serverURL) {
  if (item.url) {
    if (serverURL) {
      item.url = item.url.replace("$serverURL$", serverURL);
    }
    item.url = item.url.replace("$hostname$", location.hostname).replace("$host$", location.host);
  }

  var opts = {};
  for (var key in item) {
    var value = item[key];
    if (value == null) continue;

    switch (key) {
      default:
        //直接赋值
        opts[key] = value;
        break;
      case "crs":
        value = (value + "").toUpperCase();
        if (value == "4326" || value == "EPSG4326" || value == "EPSG:4326") {
          opts.tilingScheme = new Cesium.GeographicTilingScheme({
            numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
            numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
          });
        } else if (value == "4490" || value == "EPSG4490" || value == "EPSG:4490") {
          opts.tilingScheme = new Cesium.GeographicTilingScheme({
            numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
            numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
          });
          opts.is4490 = true;
        } else {
          opts.tilingScheme = new Cesium.WebMercatorTilingScheme({
            numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 1,
            numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
          });
        }
        break;
      case "rectangle":
        opts.rectangle = Cesium.Rectangle.fromDegrees(value.xmin, value.ymin, value.xmax, value.ymax);
        break;
      case "bbox":
        //[xmin,ymin,xmax,ymax]
        opts.rectangle = Cesium.Rectangle.fromDegrees(value[0], value[1], value[2], value[3]);
        break;
    }
  }

  //4490坐标系z值是+1的
  if (opts.is4490 && opts.url) {
    opts.url = opts.url.replace("{z}", "{z4490}");
    opts.url = opts.url.replace("{arc_z}", "{arc_z4490}");
    opts.url = opts.url.replace("{arc_Z}", "{arc_Z4490}");
  }

  if (opts.url && (opts.proxy || opts.headers || opts.queryParameters)) {
    opts = (0, _util.getProxyUrl)(opts);
  }

  var layer;
  var _url;
  switch (opts.type_new || opts.type) {
    //===============地图底图====================
    case "single":
    case "image":
      layer = new Cesium.SingleTileImageryProvider(opts);
      break;
    case "xyz":
    case "tile":
      opts.customTags = opts.customTags || {};
      opts.customTags["z4490"] = function (imageryProvider, x, y, level) {
        return level + 1;
      };
      layer = new Cesium.UrlTemplateImageryProvider(opts);
      break;
    case "wms":
      layer = new Cesium.WebMapServiceImageryProvider(opts);
      break;
    case "tms":
      if (!opts.url) opts.url = Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII");
      layer = new Cesium.TileMapServiceImageryProvider(opts);
      break;
    case "wmts":
      if (opts.is4490) {
        opts.tileMatrixLabels = [].concat(_toConsumableArray(Array(20).keys())).map(function (item) {
          return (item + 1).toString();
        });
      }
      layer = new Cesium.WebMapTileServiceImageryProvider(opts);
      break;
    case "gee":
      //谷歌地球
      layer = new Cesium.GoogleEarthEnterpriseImageryProvider({
        metadata: new Cesium.GoogleEarthEnterpriseMetadata(opts)
      });
      break;
    case "mapbox": //mapbox
    case "www_mapbox":
      opts.accessToken = Cesium.defaultValue(opts.accessToken, token.mapbox);
      layer = new Cesium.MapboxImageryProvider(opts);
      break;
    case "mapboxstyle":
    case "www_mapboxstyle":
      //参考：https://docs.mapbox.com/api/maps/#request-embeddable-html
      opts.url = Cesium.defaultValue(opts.url, "https://api.mapbox.com/styles/v1");
      opts.username = Cesium.defaultValue(opts.username, "dasgis");
      opts.accessToken = Cesium.defaultValue(opts.accessToken, token.mapbox);

      layer = new Cesium.MapboxStyleImageryProvider(opts);
      break;
    case "arcgis":
    case "arcgis_tile":
    case "arcgis_dynamic":
      layer = new Cesium.ArcGisMapServerImageryProvider(opts);
      break;
    case "sm_img": //超图底图支持
    case "supermap_img":
      layer = new Cesium.SuperMapImageryProvider(opts);
      break;
    case "arcgis_cache":
      // 示例 /google/_alllayers/L{arc_z}/R{arc_y}/C{arc_x}.jpg
      if (!Cesium.UrlTemplateImageryProvider.prototype.padLeft0) {
        Cesium.UrlTemplateImageryProvider.prototype.padLeft0 = function (numStr, n) {
          numStr = String(numStr);
          var len = numStr.length;
          while (len < n) {
            numStr = "0" + numStr;
            len++;
          }
          return numStr;
        };
      }
      opts.customTags = {
        //小写
        arc_x: function arc_x(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(x.toString(16), 8);
        },
        arc_y: function arc_y(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(y.toString(16), 8);
        },
        arc_z: function arc_z(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(level.toString(), 2);
        },
        arc_z4490: function arc_z4490(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0((level + 1).toString(), 2);
        },
        //大写
        arc_X: function arc_X(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(x.toString(16), 8).toUpperCase();
        },
        arc_Y: function arc_Y(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(y.toString(16), 8).toUpperCase();
        },
        arc_Z: function arc_Z(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0(level.toString(), 2).toUpperCase();
        },
        arc_Z4490: function arc_Z4490(imageryProvider, x, y, level) {
          return imageryProvider.padLeft0((level + 1).toString(), 2).toUpperCase();
        }
      };

      layer = new Cesium.UrlTemplateImageryProvider(opts);
      break;

    //===============互联网常用地图====================
    case "www_ion":
      //cesium ion资源地图
      layer = new Cesium.IonImageryProvider(opts);
      break;
    case "www_tdt":
      //天地图
      var _layer;
      var maxLevel = 18;
      switch (opts.layer) {
        default:
        case "vec_d":
          _layer = "vec";
          break;
        case "vec_z":
          _layer = "cva";
          break;
        case "img_d":
          _layer = "img";
          break;
        case "img_z":
          _layer = "cia";
          break;
        case "ter_d":
          _layer = "ter";
          maxLevel = 14;
          break;
        case "ter_z":
          _layer = "cta";
          maxLevel = 14;
          break;
      }

      var _key;
      if (opts.key == null || opts.key.length == 0) _key = token.tianditu;
      //默认
      else _key = getOneKey(opts.key);

      if (item.crs == "4326") {
        //wgs84
        _url = "https://t{s}.tianditu.gov.cn/" + _layer + "_c/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" + _layer + "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" + _key;

        if (opts.proxy || opts.headers || opts.queryParameters) {
          //存在代理等参数时
          _url = (0, _util.getProxyUrl)({
            url: _url.replace("{s}", "0"),
            proxy: opts.proxy,
            headers: opts.headers,
            queryParameters: opts.queryParameters
          }).url;
        }

        layer = new Cesium.WebMapTileServiceImageryProvider(_extends({
          subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
          maximumLevel: maxLevel
        }, opts, {

          url: _url,
          layer: _layer,
          style: "default",
          format: "tiles",
          tileMatrixSetID: "c",
          tileMatrixLabels: [].concat(_toConsumableArray(Array(18).keys())).map(function (item) {
            return (item + 1).toString();
          }),
          tilingScheme: new Cesium.GeographicTilingScheme() //WebMercatorTilingScheme、GeographicTilingScheme
        }));
      } else {
        //墨卡托
        _url = "https://t{s}.tianditu.gov.cn/" + _layer + "_w/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" + _layer + "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" + _key;

        if (opts.proxy || opts.headers || opts.queryParameters) {
          //存在代理等参数时
          _url = (0, _util.getProxyUrl)({
            url: _url.replace("{s}", "0"),
            proxy: opts.proxy,
            headers: opts.headers,
            queryParameters: opts.queryParameters
          }).url;
        }

        layer = new Cesium.WebMapTileServiceImageryProvider(_extends({
          subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
          maximumLevel: maxLevel
        }, opts, {

          url: _url,
          layer: _layer,
          style: "default",
          format: "tiles",
          tileMatrixSetID: "w",
          tileMatrixLabels: [].concat(_toConsumableArray(Array(18).keys())).map(function (item) {
            return item.toString();
          }),
          tilingScheme: new Cesium.WebMercatorTilingScheme()
        }));
      }
      break;
    case "www_gaode":
      //高德
      _url;
      switch (opts.layer) {
        case "vec":
        default:
          //style=7是立体的，style=8是灰色平面的
          _url = "https://" + (opts.bigfont ? "wprd" : "webrd") + "0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}";
          break;
        case "img_d":
          _url = "https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}";
          break;
        case "img_z":
          _url = "https://webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8";
          break;
        case "time":
          var time = new Date().getTime();
          _url = "https://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&&t=" + time;
          break;
      }

      if (opts.proxy || opts.headers || opts.queryParameters) {
        //存在代理等参数时
        _url = (0, _util.getProxyUrl)({
          url: _url.replace("{s}", "1"),
          proxy: opts.proxy,
          headers: opts.headers,
          queryParameters: opts.queryParameters
        }).url;
      }
      layer = new Cesium.UrlTemplateImageryProvider(_extends({
        subdomains: ["1", "2", "3", "4"],
        maximumLevel: 18
      }, opts, {
        url: _url
      }));
      break;
    case "www_baidu":
      //百度
      layer = new _BaiduImageryProvider.BaiduImageryProvider(opts);
      break;
    case "www_tencent":
      //腾讯
      layer = new _TencentImageryProvider.TencentImageryProvider(opts);
      break;

    case "www_google":
      //谷歌国内
      _url;

      if (item.crs == "4326" || item.crs == "wgs84") {
        //无偏移
        switch (opts.layer) {
          default:
          case "img_d":
            // _url = 'http://www.google.cn/maps/vt?lyrs=s&x={x}&y={y}&z={z}';
            // _url = 'http://mt{s}.google.cn/vt/lyrs=s&x={x}&y={y}&z={z}';
            _url = "http://mt3.google.cn/vt?lyrs=s@187&hl=us&gl=us&x={x}&y={y}&z={z}";
            break;
        }
      } else {
        //有偏移
        switch (opts.layer) {
          case "vec":
          default:
            _url = "http://mt{s}.google.cn/vt/lyrs=m@207000000&hl=zh-CN&gl=CN&src=app&x={x}&y={y}&z={z}&s=Galile";
            break;
          case "img_d":
            _url = "http://mt{s}.google.cn/vt/lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}&s=Gali";
            break;
          case "img_z":
            _url = "http://mt{s}.google.cn/vt/imgtp=png32&lyrs=h@207000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galil";
            break;
          case "ter":
            _url = "http://mt{s}.google.cn/vt/lyrs=t@131,r@227000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galile";
            break;
        }
      }

      if (opts.proxy || opts.headers || opts.queryParameters) {
        //存在代理等参数时
        _url = (0, _util.getProxyUrl)({
          url: _url.replace("{s}", "1"),
          proxy: opts.proxy,
          headers: opts.headers,
          queryParameters: opts.queryParameters
        }).url;
      }
      layer = new Cesium.UrlTemplateImageryProvider(_extends({
        subdomains: ["1", "2", "3"],
        maximumLevel: 20
      }, opts, {
        url: _url
      }));
      break;

    case "www_osm":
      //OSM开源地图
      _url = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

      if (opts.proxy || opts.headers || opts.queryParameters) {
        //存在代理等参数时
        _url = (0, _util.getProxyUrl)({
          url: _url.replace("{s}", "a"),
          proxy: opts.proxy,
          headers: opts.headers,
          queryParameters: opts.queryParameters
        }).url;
      }
      layer = new Cesium.UrlTemplateImageryProvider(_extends({
        subdomains: "abc",
        maximumLevel: 18
      }, opts, {
        url: _url
      }));
      break;
    case "www_bing":
      //bing地图
      _url = "https://dev.virtualearth.net";

      if (opts.proxy || opts.headers || opts.queryParameters) {
        //存在代理等参数时
        _url = (0, _util.getProxyUrl)({
          url: _url,
          proxy: opts.proxy,
          headers: opts.headers,
          queryParameters: opts.queryParameters
        }).url;
      }
      opts.key = opts.key || token.bing;

      //无标记影像 Aerial,
      //有英文标记影像   AerialWithLabels,
      //矢量道路  Road
      //OrdnanceSurvey,
      //CollinsBart
      var style = opts.layer || Cesium.BingMapsStyle.Aerial;
      layer = new Cesium.BingMapsImageryProvider(_extends({
        mapStyle: style
      }, opts, {
        url: _url
      }));
      break;

    //===============内部定义的图层====================
    case "custom_grid":
      //网格线
      opts.cells = opts.cells || 2;
      opts.color = Cesium.Color.fromCssColorString(opts.color || "rgba(255,255,255,1)");
      opts.glowWidth = opts.glowWidth || 3;
      if (opts.glowColor) opts.glowColor = Cesium.Color.fromCssColorString(opts.glowColor);else opts.glowColor = opts.color.withAlpha(0.3);
      opts.backgroundColor = Cesium.Color.fromCssColorString(opts.backgroundColor || "rgba(0,0,0,0)");

      layer = new Cesium.GridImageryProvider(opts);
      break;
    case "custom_tilecoord":
      //瓦片信息
      layer = new Cesium.TileCoordinatesImageryProvider(opts);
      break;
    case "custom_featuregrid":
      //自定义矢量网格图层
      layer = new _FeatureGridImageryProvider.FeatureGridImageryProvider(opts);
      break;
    default:
      daslog.warn("配置中的图层未处理", item);
      break;
  }
  layer.config = opts;

  return layer;
}

function getOneKey(arr) {
  var n = Math.floor(Math.random() * arr.length + 1) - 1;
  return arr[n];
}

exports.BaseLayer = _BaseLayer.BaseLayer;
exports.GroupLayer = _GroupLayer.GroupLayer;
exports.TileLayer = _TileLayer.TileLayer;
exports.SuperMapImgLayer = _SuperMapImgLayer.SuperMapImgLayer;
exports.GraticuleLayer = _GraticuleLayer.GraticuleLayer;
exports.CustomFeatureGridLayer = _CustomFeatureGridLayer.CustomFeatureGridLayer;
exports.POILayer = _POILayer.POILayer;
exports.WFSLayer = _WFSLayer.WFSLayer;
exports.GeoJsonLayer = _GeoJsonLayer.GeoJsonLayer;
exports.WaterLayer = _WaterLayer.WaterLayer;
exports.GltfLayer = _GltfLayer.GltfLayer;
exports.Tiles3dLayer = _Tiles3dLayer.Tiles3dLayer;
exports.KmlLayer = _KmlLayer.KmlLayer;
exports.CzmlLayer = _CzmlLayer.CzmlLayer;
exports.TerrainLayer = _TerrainLayer.TerrainLayer;
exports.DrawLayer = _DrawLayer.DrawLayer;
exports.ShpLayer = _ShpLayer.ShpLayer;
exports.I3SLayer = _I3SLayer.I3SLayer;
exports.BaiduImageryProvider = _BaiduImageryProvider.BaiduImageryProvider;
exports.TencentImageryProvider = _TencentImageryProvider.TencentImageryProvider;
exports.FeatureGridImageryProvider = _FeatureGridImageryProvider.FeatureGridImageryProvider;
exports.regLayerForConfig = regLayerForConfig;
exports.createLayer = createLayer;
exports.createImageryProvider = createImageryProvider;

//===================================== 地形相关 =================================

var _ellipsoid = new Cesium.EllipsoidTerrainProvider({
  ellipsoid: Cesium.Ellipsoid.WGS84
});

//是否无地形
function hasTerrain(viewer) {
  return !(viewer.terrainProvider == _ellipsoid || viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider);
}
function getEllipsoidTerrain() {
  return _ellipsoid;
}
function getTerrainProvider(cfg) {
  cfg = cfg || { type: "ion" };
  cfg.requestWaterMask = Cesium.defaultValue(cfg.requestWaterMask, true);
  cfg.requestVertexNormals = Cesium.defaultValue(cfg.requestVertexNormals, true);

  var terrainProvider;
  switch (cfg.type) {
    default:
      //默认是自定义的
      terrainProvider = new Cesium.CesiumTerrainProvider((0, _util.getProxyUrl)(cfg));
      break;
    case "ion":
    case "cesium":
      //cesium官方在线的
      terrainProvider = new Cesium.CesiumTerrainProvider({
        url: Cesium.IonResource.fromAssetId(1),
        requestWaterMask: cfg.requestWaterMask,
        requestVertexNormals: cfg.requestVertexNormals
      });
      break;
    case "gee":
    case "google":
      //谷歌地球地形服务
      terrainProvider = new Cesium.GoogleEarthEnterpriseTerrainProvider({
        metadata: new Cesium.GoogleEarthEnterpriseMetadata((0, _util.getProxyUrl)(cfg))
      });
      break;
    case "arcgis":
      //ArcGIS地形服务
      terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider((0, _util.getProxyUrl)(cfg));
      break;
    case "ellipsoid":
      terrainProvider = _ellipsoid;
      break;
  }

  return terrainProvider;
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(35);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(13);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(60);

var _Draw = __webpack_require__(46);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPoint = exports.DrawPoint = function (_DrawBase) {
  _inherits(DrawPoint, _DrawBase);

  //========== 构造方法 ==========
  function DrawPoint(opts) {
    _classCallCheck(this, DrawPoint);

    var _this = _possibleConstructorReturn(this, (DrawPoint.__proto__ || Object.getPrototypeOf(DrawPoint)).call(this, opts));

    _this.type = "point";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditPoint; //获取编辑对象
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawPoint, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = null;

      //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

      var that = this;
      var addattr = {
        show: _drawShow,
        _drawShow: _drawShow, //edit编辑时使用
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        point: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      if (attribute.style && attribute.style.label) {
        //同时加文字
        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
      }

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      //子类使用
      if (this.createFeatureEx) this.createFeatureEx(attribute.style, this.entity);
      return this.entity;
    }
    //重新激活绘制

  }, {
    key: "reCreateFeature",
    value: function reCreateFeature(entity) {
      this.entity = entity;
      this._positions_draw = entity.position;
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      if (style && style.label) {
        //同时加文字
        (0, _Attr2.style2Entity)(style.label, entity.label);
      }
      if (entity.featureEx) {
        entity.featureEx.updateStyle(style);
      }
      return attr.style2Entity(style, entity.point);
    }
    //绑定鼠标事件

  }, {
    key: "bindEvent",
    value: function bindEvent() {
      var _this2 = this;

      this.getHandler().setInputAction(function (event) {
        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);
        if (point) {
          _this2._positions_draw = point;
          if (_this2.entity.featureEx) {
            _this2.entity.featureEx.position = point;
          }
        }
        _this2.tooltip.showAt(event.endPosition, _this2.entity.draw_tooltip || _Tooltip.message.draw.point.start);

        _this2.fire(_DasClass.eventType.drawMouseMove, {
          drawtype: _this2.type,
          entity: _this2.entity,
          position: point
        });
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      this.getHandler().setInputAction(function (event) {
        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
        if (point) {
          _this2._positions_draw = point;
        }

        if (_this2._positions_draw && _this2.isLoadOk()) _this2.disable();
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    }
    //子类使用，gltf时判断是否加载完成

  }, {
    key: "isLoadOk",
    value: function isLoadOk() {
      return true;
    }
    //获取外部entity的坐标到_positions_draw

  }, {
    key: "setDrawPositionByEntity",
    value: function setDrawPositionByEntity(entity) {
      var positions = this.getPositions(entity);
      this._positions_draw = positions[0];
    }
    //图形绘制结束,更新属性

  }, {
    key: "finish",
    value: function finish() {
      this.entity.show = true;

      this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象
      this.entity.position = this.getDrawPosition();
      if (this.entity.featureEx) {
        this.entity.featureEx.position = this.getDrawPosition();
        this.entity.featureEx.finish();
      }
    }
  }]);

  return DrawPoint;
}(_Draw.DrawBase);

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditBase = exports.EditBase = function (_DasClass) {
  _inherits(EditBase, _DasClass);

  //========== 构造方法 ==========
  function EditBase(entity, viewer) {
    _classCallCheck(this, EditBase);

    var _this = _possibleConstructorReturn(this, (EditBase.__proto__ || Object.getPrototypeOf(EditBase)).call(this));

    _this.entity = entity;
    _this.viewer = viewer;

    _this.draggers = [];
    _this._minPointNum = 1; //至少需要点的个数 (值是draw中传入)
    _this._maxPointNum = 9999; //最多允许点的个数 (值是draw中传入)
    return _this;
  }

  _createClass(EditBase, [{
    key: "fire",
    value: function fire(type, data, propagate) {
      if (this._fire) this._fire(type, data, propagate);
    }
  }, {
    key: "formatNum",
    value: function formatNum(num, digits) {
      return (0, _point.formatNum)(num, digits);
    }
  }, {
    key: "setCursor",
    value: function setCursor(val) {
      this.viewer._container.style.cursor = val ? "crosshair" : "";
    }
    //激活绘制

  }, {
    key: "activate",
    value: function activate() {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;

      this.entity.inProgress = true;
      this.changePositionsToCallback();
      this.bindDraggers();
      this.bindEvent();

      this.fire(_DasClass2.eventType.editStart, { edittype: this.entity.attribute.type, entity: this.entity });

      return this;
    }
    //释放绘制

  }, {
    key: "disable",
    value: function disable() {
      if (!this._enabled) {
        return this;
      }
      this._enabled = false;

      this.destroyEvent();
      this.destroyDraggers();
      this.finish();

      this.entity.inProgress = false;
      this.fire(_DasClass2.eventType.editStop, { edittype: this.entity.attribute.type, entity: this.entity });
      this.tooltip.setVisible(false);

      return this;
    }
  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {}
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {}
    //拖拽点 事件

  }, {
    key: "bindEvent",
    value: function bindEvent() {
      var _this2 = this;

      var scratchBoundingSphere = new Cesium.BoundingSphere();
      var zOffset = new Cesium.Cartesian3();

      var draggerHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
      draggerHandler.dragger = null;

      //选中后拖动
      draggerHandler.setInputAction(function (event) {
        var pickedObject = _this2.viewer.scene.pick(event.position);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
          if (entity && Cesium.defaultValue(entity._isDragger, false)) {
            _this2.viewer._hasEdit = true;
            _this2.viewer.scene.screenSpaceCameraController.enableRotate = false;
            _this2.viewer.scene.screenSpaceCameraController.enableTilt = false;
            _this2.viewer.scene.screenSpaceCameraController.enableTranslate = false;
            _this2.viewer.scene.screenSpaceCameraController.enableInputs = false;

            if (_this2.viewer.das && _this2.viewer.das.popup) _this2.viewer.das.popup.close(entity);

            draggerHandler.dragger = entity;
            draggerHandler.dragger.show = Cesium.defaultValue(entity._drawShow, false);

            _this2.setCursor(true);

            if (draggerHandler.dragger.onDragStart) {
              var position = (0, _point.getPositionValue)(draggerHandler.dragger.position);
              draggerHandler.dragger.onDragStart(draggerHandler.dragger, position);
            }

            _this2.fire(_DasClass2.eventType.editMouseDown, {
              edittype: _this2.entity.attribute.type,
              entity: _this2.entity,
              position: event.position
            });
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      draggerHandler.setInputAction(function (event) {
        var dragger = draggerHandler.dragger;
        if (dragger) {
          switch (dragger._pointType) {
            case draggerCtl.PointType.MoveHeight:
              //改变高度垂直拖动
              var dy = event.endPosition.y - event.startPosition.y;

              var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);
              var tangentPlane = new Cesium.EllipsoidTangentPlane(position);

              scratchBoundingSphere.center = position;
              scratchBoundingSphere.radius = 1;

              var metersPerPixel = _this2.viewer.scene.frameState.camera.getPixelSize(scratchBoundingSphere, _this2.viewer.scene.frameState.context.drawingBufferWidth, _this2.viewer.scene.frameState.context.drawingBufferHeight) * 1.5;

              Cesium.Cartesian3.multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
              var newPosition = Cesium.Cartesian3.clone(position);
              Cesium.Cartesian3.add(position, zOffset, newPosition);

              dragger.position = newPosition;
              if (dragger.onDrag) {
                dragger.onDrag(dragger, newPosition, position);
              }
              _this2.updateAttrForEditing();
              break;
            default:
              //默认修改位置
              _this2.tooltip.showAt(event.endPosition, _Tooltip.message.edit.end);

              var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);

              if (point) {
                dragger.position = point;
                if (dragger.onDrag) {
                  dragger.onDrag(dragger, point);
                }
                _this2.updateAttrForEditing();
              }
              break;
          }
          _this2.fire(_DasClass2.eventType.editMouseMove, {
            edittype: _this2.entity.attribute.type,
            entity: _this2.entity,
            position: event.endPosition
          });
        } else {
          _this2.tooltip.setVisible(false);

          var pickedObject = _this2.viewer.scene.pick(event.endPosition);
          if (Cesium.defined(pickedObject)) {
            var entity = pickedObject.id;
            if (entity && Cesium.defaultValue(entity._isDragger, false) && entity.draw_tooltip) {
              var draw_tooltip = entity.draw_tooltip;

              //可删除时，提示右击删除
              if (draggerCtl.PointType.Control == entity._pointType && _this2._positions_draw && _this2._positions_draw.length && _this2._positions_draw.length > _this2._minPointNum) draw_tooltip += _Tooltip.message.del.def;

              if (_this2.viewer.das.contextmenu && _this2.viewer.das.contextmenu.show && _this2.viewer.das.contextmenu.target == entity) {
                //删除右键菜单打开了不显示tooltip
              } else {
                _this2.tooltip.showAt(event.endPosition, draw_tooltip);
              }
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      draggerHandler.setInputAction(function (event) {
        var dragger = draggerHandler.dragger;
        if (dragger) {
          _this2.setCursor(false);
          dragger.show = true;

          var position = (0, _point.getPositionValue)(dragger.position, _this2.viewer.clock.currentTime);

          if (dragger.onDragEnd) {
            dragger.onDragEnd(dragger, position);
          }
          _this2.fire(_DasClass2.eventType.editMovePoint, {
            edittype: _this2.entity.attribute.type,
            entity: _this2.entity,
            position: position
          });

          draggerHandler.dragger = null;
          _this2.viewer._hasEdit = false;
          _this2.viewer.scene.screenSpaceCameraController.enableRotate = true;
          _this2.viewer.scene.screenSpaceCameraController.enableTilt = false;
          _this2.viewer.scene.screenSpaceCameraController.enableTranslate = true;
          _this2.viewer.scene.screenSpaceCameraController.enableInputs = true;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);

      //右击删除一个点
      draggerHandler.setInputAction(function (event) {
        //右击删除上一个点
        var pickedObject = _this2.viewer.scene.pick(event.position);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id;
          if (entity && Cesium.defaultValue(entity._isDragger, false) && draggerCtl.PointType.Control == entity._pointType) {
            var isDelOk = _this2.deletePointForDragger(entity, event.position);

            if (isDelOk) _this2.fire(_DasClass2.eventType.editRemovePoint, {
              edittype: _this2.entity.attribute.type,
              entity: _this2.entity
            });
          }
        }
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

      this.draggerHandler = draggerHandler;
    }
  }, {
    key: "destroyEvent",
    value: function destroyEvent() {
      this.viewer._hasEdit = false;
      this.viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.viewer.scene.screenSpaceCameraController.enableTilt = false;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
      this.viewer.scene.screenSpaceCameraController.enableInputs = true;

      this.setCursor(false);

      if (this.draggerHandler) {
        if (this.draggerHandler.dragger) this.draggerHandler.dragger.show = true;

        this.draggerHandler.destroy();
        this.draggerHandler = null;
      }
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {}
  }, {
    key: "updateDraggers",
    value: function updateDraggers() {
      if (!this._enabled) {
        return this;
      }

      this.destroyDraggers();
      this.bindDraggers();
    }
  }, {
    key: "destroyDraggers",
    value: function destroyDraggers() {
      for (var i = 0, len = this.draggers.length; i < len; i++) {
        this.entityCollection.remove(this.draggers[i]);
      }
      this.draggers = [];
    }
    //删除点

  }, {
    key: "deletePointForDragger",
    value: function deletePointForDragger(dragger, position) {
      if (!this._positions_draw) return;
      if (this._positions_draw.length - 1 < this._minPointNum) {
        this.tooltip.showAt(position, _Tooltip.message.del.min + this._minPointNum);
        return false;
      }

      var index = dragger.index;
      if (index >= 0 && index < this._positions_draw.length) {
        this._positions_draw.splice(index, 1);
        this.updateDraggers();
        this.updateAttrForEditing();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {}
  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      _get(EditBase.prototype.__proto__ || Object.getPrototypeOf(EditBase.prototype), "destroy", this).call(this);
    }
  }, {
    key: "entityCollection",
    get: function get() {
      return this.entity.entityCollection;
    }
  }]);

  return EditBase;
}(_DasClass2.DasClass);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPolyline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolyline = exports.EditPolyline = function (_EditBase) {
  _inherits(EditPolyline, _EditBase);

  //========== 构造方法 ==========
  function EditPolyline(entity, viewer) {
    _classCallCheck(this, EditPolyline);

    var _this = _possibleConstructorReturn(this, (EditPolyline.__proto__ || Object.getPrototypeOf(EditPolyline)).call(this, entity, viewer));

    _this._positions_draw = [];
    _this._hasMidPoint = true;
    _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    return _this;
  }

  //取enity对象的对应矢量数据


  _createClass(EditPolyline, [{
    key: "getGraphic",
    value: function getGraphic() {
      return this.entity.polyline;
    }
    //坐标位置相关

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this._positions_draw;
    }
    //外部更新位置

  }, {
    key: "setPositions",
    value: function setPositions(positions) {
      this._positions_draw = positions;
      this.updateAttrForEditing();
      this.finish();
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
    }
  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
      if (this.entity.attribute.type == "polyline" && Cesium.defined(this.entity.polyline.depthFailMaterial)) {
        this.entity.polyline.positions = this.getPosition();
      }
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this.getPosition();

      var entity = this.entity;
      if (this.entity.attribute.type == "polyline") {
        //显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
        if (Cesium.defined(entity.polyline.depthFailMaterial)) {
          var arr = entity._positions_draw;
          if (entity.attribute.style.closure) arr = arr.concat(arr[0]); //闭合
          entity.polyline.positions = arr;
        } else {
          entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
            var arr = entity._positions_draw;
            if (entity.attribute.style.closure) return arr.concat(arr[0]);
            //闭合
            else return arr;
          }, false);
        }
      }
    }
  }, {
    key: "isClampToGround",
    value: function isClampToGround() {
      return this.entity.attribute.style.clampToGround;
    }
    //是否可在中间新增点

  }, {
    key: "hasMidPoint",
    value: function hasMidPoint() {
      return this._hasMidPoint && this.getPosition().length < this._maxPointNum;
    }
    //子类用，根据属性更新坐标

  }, {
    key: "updatePositionsHeightByAttr",
    value: function updatePositionsHeightByAttr(position) {
      return position;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var positions = this.getPosition();

      var clampToGround = this.isClampToGround();
      var hasMidPoint = this.hasMidPoint();

      for (var i = 0, len = positions.length; i < len; i++) {
        var loc = positions[i];

        loc = this.updatePositionsHeightByAttr(loc);
        if (clampToGround) {
          //贴地时求贴模型和贴地的高度
          loc = (0, _point.setPositionSurfaceHeight)(this.viewer, loc);
          positions[i] = loc;
        }

        //各顶点
        var dragger = draggerCtl.createDragger(this.entityCollection, {
          position: loc,
          //clampToGround: clampToGround,
          onDrag: function onDrag(dragger, position) {
            position = that.updatePositionsHeightByAttr(position);
            dragger.position = position;
            positions[dragger.index] = position;

            if (that.heightDraggers && that.heightDraggers.length > 0) {
              that.updateDraggers();
            } else {
              //============新增点拖拽点处理=============
              if (hasMidPoint) {
                var draggersIdx;
                var nextPositionIdx;
                var midpoint;
                //与前一个点之间的中点
                if (that.hasClosure || !that.hasClosure && dragger.index != 0) {
                  if (dragger.index == 0) {
                    draggersIdx = len * 2 - 1;
                    nextPositionIdx = len - 1;
                  } else {
                    draggersIdx = dragger.index * 2 - 1;
                    nextPositionIdx = dragger.index - 1;
                  }
                  var nextPosition = positions[nextPositionIdx];
                  midpoint = Cesium.Cartesian3.midpoint(position, nextPosition, new Cesium.Cartesian3());
                  midpoint = that.updatePositionsHeightByAttr(midpoint);
                  if (clampToGround) {
                    //贴地时求贴模型和贴地的高度
                    midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                  }
                  that.draggers[draggersIdx].position = midpoint;
                }

                //与后一个点之间的中点
                if (that.hasClosure || !that.hasClosure && dragger.index != len - 1) {
                  if (dragger.index == len - 1) {
                    draggersIdx = dragger.index * 2 + 1;
                    nextPositionIdx = 0;
                  } else {
                    draggersIdx = dragger.index * 2 + 1;
                    nextPositionIdx = dragger.index + 1;
                  }
                  midpoint = Cesium.Cartesian3.midpoint(position, positions[nextPositionIdx], new Cesium.Cartesian3());
                  midpoint = that.updatePositionsHeightByAttr(midpoint);
                  if (clampToGround) {
                    //贴地时求贴模型和贴地的高度
                    midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                  }
                  that.draggers[draggersIdx].position = midpoint;
                }
              }

              //============整体平移移动点处理=============
              positionMove = (0, _point.centerOfMass)(positions);
              positionMove = that.updatePositionsHeightByAttr(positionMove);
              if (clampToGround) {
                //贴地时求贴模型和贴地的高度
                positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
              }
              draggerMove.position = positionMove;
            }
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);

        //中间点，拖动后新增点
        if (hasMidPoint && (this.hasClosure || !this.hasClosure && i < len - 1)) {
          var nextIndex = (i + 1) % len;
          var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
          midpoint = that.updatePositionsHeightByAttr(midpoint);
          if (clampToGround) {
            //贴地时求贴模型和贴地的高度
            midpoint = (0, _point.setPositionSurfaceHeight)(this.viewer, midpoint);
          }

          var draggerMid = draggerCtl.createDragger(this.entityCollection, {
            position: midpoint,
            type: draggerCtl.PointType.AddMidPoint,
            tooltip: _Tooltip.message.dragger.addMidPoint,
            //clampToGround: clampToGround,
            onDragStart: function onDragStart(dragger, position) {
              positions.splice(dragger.index, 0, position); //插入点
            },
            onDrag: function onDrag(dragger, position) {
              positions[dragger.index] = position;
            },
            onDragEnd: function onDragEnd(dragger, position) {
              that.updateDraggers();
            }
          });
          draggerMid.index = nextIndex;
          this.draggers.push(draggerMid);
        }
      }

      //整体平移移动点
      var positionMove = (0, _point.centerOfMass)(positions);
      positionMove = this.updatePositionsHeightByAttr(positionMove);
      if (clampToGround) {
        //贴地时求贴模型和贴地的高度
        positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
      }

      var draggerMove = draggerCtl.createDragger(this.entityCollection, {
        position: positionMove,
        type: draggerCtl.PointType.MoveAll,
        tooltip: _Tooltip.message.dragger.moveAll,
        onDrag: function onDrag(dragger, position) {
          // dragger.position = position;

          //记录差值
          var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
          positionMove = position;

          positions.forEach(function (pos, index, arr) {
            var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
            positions[index] = newPos;
          });

          //=====全部更新==========
          that.updateDraggers();
        }
      });
      this.draggers.push(draggerMove);

      //创建高程拖拽点
      if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
    }
    //子类用，高度调整拖拽点

  }, {
    key: "bindHeightDraggers",
    value: function bindHeightDraggers(positions) {
      var that = this;

      this.heightDraggers = [];

      positions = positions || this.getPosition();
      var extrudedHeight = that.getGraphic().extrudedHeight.getValue(this.viewer.clock.currentTime);

      for (var i = 0, len = positions.length; i < len; i++) {
        var loc = positions[i];
        loc = (0, _point.setPositionsHeight)(loc, extrudedHeight);

        var dragger = draggerCtl.createDragger(this.entityCollection, {
          position: loc,
          type: draggerCtl.PointType.MoveHeight,
          tooltip: _Tooltip.message.dragger.moveHeight,
          onDrag: function onDrag(dragger, position) {
            var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
            that.getGraphic().extrudedHeight = thisHeight;

            var maxHeight = (0, _point.getMaxHeight)(that.getPosition());
            that.entity.attribute.style.extrudedHeight = that.formatNum(thisHeight - maxHeight, 2);

            that.updateHeightDraggers(thisHeight);
          }
        });

        this.draggers.push(dragger);
        this.heightDraggers.push(dragger);
      }
    }
  }, {
    key: "updateHeightDraggers",
    value: function updateHeightDraggers(extrudedHeight) {
      for (var i = 0; i < this.heightDraggers.length; i++) {
        var heightDragger = this.heightDraggers[i];

        var position = (0, _point.setPositionsHeight)((0, _point.getPositionValue)(heightDragger.position, this.viewer.clock.currentTime), extrudedHeight);
        heightDragger.position.setValue(position);
      }
    }
  }]);

  return EditPolyline;
}(_Edit.EditBase);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPolygon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Attr = __webpack_require__(21);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(27);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolygon = exports.EditPolygon = function (_EditPolyline) {
  _inherits(EditPolygon, _EditPolyline);

  //========== 构造方法 ==========
  function EditPolygon(entity, viewer) {
    _classCallCheck(this, EditPolygon);

    //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    var _this = _possibleConstructorReturn(this, (EditPolygon.__proto__ || Object.getPrototypeOf(EditPolygon)).call(this, entity, viewer));

    _this.hasClosure = true;
    return _this;
  }

  //取enity对象的对应矢量数据


  _createClass(EditPolygon, [{
    key: "getGraphic",
    value: function getGraphic() {
      return this.entity.polygon;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw || attr.getPositions(this.entity);
    }
  }, {
    key: "isClampToGround",
    value: function isClampToGround() {
      return this.entity.attribute.style.hasOwnProperty("clampToGround") ? this.entity.attribute.style.clampToGround : !this.entity.attribute.style.perPositionHeight;
    }
  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      var style = this.entity.attribute.style;
      if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
        //存在extrudedHeight高度设置时
        var maxHight = (0, _point.getMaxHeight)(this.getPosition());
        this.getGraphic().extrudedHeight = maxHight + Number(style.extrudedHeight);
      }
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this.getPosition();
    }
  }]);

  return EditPolygon;
}(_Edit.EditPolyline);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureBase = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _index = __webpack_require__(22);

var _Draw = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//显示测量结果文本的字体
var defaultLabelStyle = (0, _index.getDefStyle)("label", {
  color: "#ffffff",
  font_size: 20,
  border: true,
  border_color: "#000000",
  border_width: 3,
  background: true,
  background_color: "#000000",
  background_opacity: 0.5,
  scaleByDistance: true,
  scaleByDistance_far: 800000,
  scaleByDistance_farValue: 0.5,
  scaleByDistance_near: 1000,
  scaleByDistance_nearValue: 1,
  pixelOffset: [0, -15],
  visibleDepth: false //一直显示，不被地形等遮挡
});

var MeasureBase = exports.MeasureBase = function (_DasClass) {
  _inherits(MeasureBase, _DasClass);

  //========== 构造方法 ==========
  function MeasureBase(options, target) {
    _classCallCheck(this, MeasureBase);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (MeasureBase.__proto__ || Object.getPrototypeOf(MeasureBase)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      target.viewer = options;
      options = target;
      target = null;
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    _this.config = options;
    _this.target = target || _this; //用于抛出的事件对象

    //文本样式
    if (Cesium.defined(options.label)) {
      _this.labelStyle = _extends({}, defaultLabelStyle, options.label);
    } else {
      _this.labelStyle = _extends({}, defaultLabelStyle);
    }

    //标绘对象
    _this.drawControl = options.draw;
    if (!_this.drawControl) {
      _this.drawControl = new _Draw.Draw(_this.viewer, _extends({
        hasEdit: false
      }, options));
      _this.hasDelDraw = true;
    }

    _this._bindEvent();
    return _this;
  }

  _createClass(MeasureBase, [{
    key: "_bindEvent",
    value: function _bindEvent() {
      var _this2 = this;

      //事件监听
      this.drawControl.on(_Draw.Draw.event.drawAddPoint, function (e) {
        var entity = e.entity;
        if (entity.type != _this2.type) return;

        _this2.entity = entity;
        _this2.showAddPointLength(entity);
        _this2.target.fire(_Draw.Draw.event.drawAddPoint, e);
      });
      this.drawControl.on(_Draw.Draw.event.drawRemovePoint, function (e) {
        if (e.entity.type != _this2.type) return;

        _this2.showRemoveLastPointLength(e);
        _this2.target.fire(_Draw.Draw.event.drawRemovePoint, e);
      });
      this.drawControl.on(_Draw.Draw.event.drawMouseMove, function (e) {
        var entity = e.entity;
        if (entity.type != _this2.type) return;

        _this2.entity = entity;
        _this2.showMoveDrawing(entity);
        _this2.target.fire(_Draw.Draw.event.drawMouseMove, e);
      });

      this.drawControl.on(_Draw.Draw.event.drawCreated, function (e) {
        var entity = e.entity;
        if (entity.type != _this2.type) return;

        _this2.entity = entity;
        _this2.showDrawEnd(entity);
        _this2.bindDeleteContextmenu(entity);
        _this2.entity = null;
        _this2.target.fire(_Draw.Draw.event.drawCreated, e);
      });

      //编辑了线
      this.drawControl.on([_Draw.Draw.event.editMovePoint, _Draw.Draw.event.editRemovePoint], function (e) {
        var entity = e.entity;
        if (entity.type != _this2.type) return;
        _this2.updateForEdit(entity);
      });
      //编辑中，拖动了点
      this.drawControl.on(_Draw.Draw.event.editMouseMove, function (e) {
        var entity = e.entity;
        if (entity.type != _this2.type) return;
        if (_this2.updateForEditMouseMove) _this2.updateForEditMouseMove(entity);
      });
    }
  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(entity) {}
  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {}
  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {}
  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {}
  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {}
  }, {
    key: "startDraw",
    value: function startDraw(options) {
      this.options = options || {};
      this.options.style = this.options.style || {};

      //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
      if (this.options.calback) {
        var calbackfun = options.calback;
        delete options.calback;
        this.target.off(_DasClass2.eventType.change);
        this.target.on(_DasClass2.eventType.change, function (e) {
          if (e.mtype == "section") calbackfun(e);else calbackfun(e.label, Number(Number(e.value || 0).toFixed(2)), e);
        });
      }
      if (this.options.onStart) {
        var onStartfun = options.onStart;
        delete options.onStart;
        this.target.off(_DasClass2.eventType.start);
        this.target.on(_DasClass2.eventType.start, onStartfun);
      }
      if (this.options.onEnd) {
        var onEndfun = options.onEnd;
        delete options.onEnd;
        this.target.off(_DasClass2.eventType.end);
        this.target.on(_DasClass2.eventType.end, function (e) {
          onEndfun(e.entity, e);
        });
      }
      //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

      var entity = this._startDraw(this.options);
      entity.type = this.type;
    }
  }, {
    key: "_startDraw",
    value: function _startDraw() {}

    //取消并停止绘制
    //如果上次未完成绘制就单击了新的，清除之前未完成的。

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      this.clearLastNoEnd();
      this.drawControl.stopDraw();
    }

    //外部控制，完成绘制，比如手机端无法双击结束

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (this.entity) {
        var entity = this.entity;
        this.showMoveDrawing(entity);
        this.drawControl.endDraw(); //会触发drawCreated
        // this.showDrawEnd(entity);
        // this.bindDeleteContextmenu(entity);
        // this.target.fire(Draw.event.drawCreated, { entity: entity });
        this.entity = null;
      }
    }

    /*清除测量*/

  }, {
    key: "clear",
    value: function clear() {
      this.stopDraw();
      this.drawControl.deleteAll();

      this.target.fire(_DasClass2.eventType.delete, {
        mtype: this.type
      });
    }

    //右键菜单

  }, {
    key: "bindDeleteContextmenu",
    value: function bindDeleteContextmenu(entity) {
      var that = this;
      entity.contextmenuItems = entity.contextmenuItems || [];
      entity.contextmenuItems.push({
        text: "删除测量",
        iconCls: "fa fa-trash-o",
        visible: function visible(e) {
          that.drawControl.closeTooltip();

          var entity = e.target;
          if (entity.inProgress && !entity.editing) return false;else return true;
        },
        callback: function callback(e) {
          var entity = e.target;

          if (entity.target) entity = entity.target;

          if (Cesium.defined(entity._totalLable)) {
            that.dataSource.entities.remove(entity._totalLable);
            delete entity._totalLable;
          }
          if (Cesium.defined(entity.arrEntityEx) && entity.arrEntityEx.length > 0) {
            var arrLables = entity.arrEntityEx;
            if (arrLables && arrLables.length > 0) {
              for (var i = 0, len = arrLables.length; i < len; i++) {
                that.dataSource.entities.remove(arrLables[i]);
              }
            }
            delete entity.arrEntityEx;
          }
          // if (entity._exLine) {
          //     that.dataSource.entities.remove(entity._exLine);
          //     delete entity._exLine;
          // }

          that.drawControl.deleteEntity(entity);

          that.drawControl.closeTooltip();
          that.viewer.das.popup.close();

          that.target.fire(_DasClass2.eventType.delete, {
            mtype: that.type,
            entity: entity
          });
        }
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();

      if (this.hasDelDraw) {
        this.drawControl.destroy();
        delete this.drawControl;
      }
      _get(MeasureBase.prototype.__proto__ || Object.getPrototypeOf(MeasureBase.prototype), "destroy", this).call(this);
    }
  }, {
    key: "draw",
    get: function get() {
      return this.drawControl;
    }
  }, {
    key: "dataSource",
    get: function get() {
      return this.drawControl.dataSource;
    }
  }]);

  return MeasureBase;
}(_DasClass2.DasClass);
//[静态属性]本类中支持的事件类型常量


MeasureBase.event = {
  start: _DasClass2.eventType.start,
  change: _DasClass2.eventType.change,
  end: _DasClass2.eventType.end,
  delete: _DasClass2.eventType.delete
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//SDK中涉及到的所有第3放地图服务的 默认key 【重要提示：为了避免后期失效，请全部换成自己的key】

//cesium官方的ion服务,官网：https://cesium.com/ion/signin/
var ion = exports.ion = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZDFjYWVhMi00MGNlLTRmM2EtOTk2NS1hZWJmZGZmNTJjNjciLCJpZCI6MTQ4MiwiaWF0IjoxNjA1NzQ3MjE3fQ.6nJuDDPTno9yVR6TUeQtZb8nf4wrhvfwzg2AQTSmN4w";

//mapbox地图，官网：https://account.mapbox.com
var mapbox = exports.mapbox = "pk.eyJ1IjoibWFyc2dpcyIsImEiOiJja2Fod2xlanIwNjJzMnhvMXBkMnNqcjVpIn0.WnxikCaN2KV_zn9tLZO77A";

//微软Bing地图，官网：https://www.bingmapsportal.com/Application
var bing = exports.bing = "AuKhM0WRkjhX8E4y1OM0TukYycaw_4Vh3eSfXONDf7OARls-WEB3K_Rfx89bWxof"; //2020-11-19

//天地图，官网：https://console.tianditu.gov.cn/api/key
var tiandituArr = exports.tiandituArr = ["9ae78c51a0a28f06444d541148496e36", //2020-10-10
"2a0e637a8772d92b123ee8866dee4a82"];
var tianditu = exports.tianditu = tiandituArr[0];

//高德，官网：https://console.amap.com/dev/key/app
var gaodeArr = exports.gaodeArr = ["ae29a37307840c7ae4a785ac905927e0", //2020-6-18
"888a52a74c55ca47abe6c55ab3661d11", "0bc2903efcb3b67ebf1452d2f664a238", "0df8f6f984adc49fca5b7b1108664da2", "72f75689dff38a781055e68843474751"];
var gaode = exports.gaode = gaodeArr[0];

//百度，官网：http://lbsyun.baidu.com/apiconsole/key#/home
var baiduArr = exports.baiduArr = ["c3qarrKcqnB9HbCOPfKOHgneH6AGXCVU", //2020-6-6
"6g6evLsHT4M0DVZnRXRpXDDq1t95ESrg", "4j0HA8IeuvAPCl62ni8xCZkBhc2YGr67", "F4CZ3cvHf8vbL8rkuTNtx8w2eflpdzj5", "qObioeG8HeeQVrOVAGScPVhDzlmv6rL9"];
var baidu = exports.baidu = baiduArr[0];

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.config2Entity = config2Entity;
exports.style2Entity = style2Entity;
exports.createDthEntity = createDthEntity;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(34);

var _Attr2 = __webpack_require__(13);

var _Attr3 = __webpack_require__(36);

var _Attr4 = __webpack_require__(35);

var _Attr5 = __webpack_require__(41);

var _Attr6 = __webpack_require__(17);

var _Attr7 = __webpack_require__(21);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var nullColor = new Cesium.Color(0.0, 0.0, 0.0, 0.01);

//根据config配置，更新entitys
function config2Entity(entities, config, lblAddFun) {
  for (var i = 0, len = entities.length; i < len; i++) {
    var entity = entities[i];

    //属性
    if (typeof config.getAttrVal === "function") {
      var attr = config.getAttrVal(entity);
      entity.properties = attr || {}; //重新绑定，后续使用
    }

    //样式
    var symbol = config.symbol;
    if (symbol) {
      if (typeof symbol === "function") {
        //完全自定义的回调方法，自行处理entity
        symbol(entity, entity.properties);
      } else {
        setConfigSymbol(entity, config, lblAddFun);
      }
    }

    //popup、鼠标事件等
    bindMourseEvnet(entity, config);
  }

  return entities;
}

//根据config配置，更新entitys
function style2Entity(entities, style, lblAddFun) {
  for (var i = 0, len = entities.length; i < len; i++) {
    var entity = entities[i];
    //样式
    setConfigSymbol(entity, { symbol: { styleOptions: style }, lblAddFun: lblAddFun });
  }
  return entities;
}

//外部配置的symbol
function setConfigSymbol(entity, config, lblAddFun) {
  var attr = entity.properties;
  if (attr && attr.type && attr.attr) {
    //说明是内部标绘生产的geojson
    attr = attr.attr;
  }
  attr = (0, _util.getAttrVal)(attr);

  var symbol = config.symbol;
  var styleOpt = symbol.styleOptions;

  if (symbol.styleField) {
    //存在多个symbol，按styleField进行分类
    var styleFieldVal = attr[symbol.styleField];
    var styleOptField = symbol.styleFieldOptions[styleFieldVal];
    if (styleOptField != null) {
      styleOpt = (0, _util.clone)(styleOpt);
      styleOpt = _extends({}, styleOpt, styleOptField);
    }
  }

  //外部使用代码示例
  // var layerWork = viewer.das.getLayer(301087, "id")
  // layerWork.config.symbol.callback = function (attr, entity, styleOpt) {
  //     var val = attr.floor;
  //     if (val < 10)
  //         return { color: "#ff0000" };
  //     else
  //         return { color: "#0000ff" };
  // }
  var callback = symbol.callback || symbol.calback; //兼容不同参数名
  if (typeof callback === "function") {
    //只是动态返回symbol的自定义的回调方法，返回style
    styleOpt = (0, _util.clone)(styleOpt);
    var _styleOptField = callback(attr, entity, styleOpt);
    if (!_styleOptField) return;

    styleOpt = _extends({}, styleOpt, _styleOptField);
  }
  styleOpt = styleOpt || {};

  //兼容v1历史的 label.field 定义方式
  if (styleOpt.label && styleOpt.label.field) styleOpt.label.text = "{" + styleOpt.label.field + "}";

  var entityCollection = entity.entityCollection; //entity原有的集合

  //添加文本的统一回调方法 ，默认为entity方式，可以外部处理。
  function defaultLblAdd(position, labelattr, attr) {
    if (labelattr.text == "") return null;

    if (Cesium.defined(labelattr.height)) {
      position = (0, _point.setPositionsHeight)(position, labelattr.height);
    }

    var lblEx = entityCollection.add({
      position: position,
      label: labelattr,
      properties: attr
    });
    return lblEx;
  }
  lblAddFun = lblAddFun || defaultLblAdd;

  if (entity.polyline) {
    (0, _Attr6.style2Entity)(styleOpt, entity.polyline);

    //存在附加的条带时
    if (styleOpt.corridor) {
      var corridorStyle = _extends({
        color: styleOpt.color,
        opacity: styleOpt.opacity
      }, styleOpt.corridor);
      // 可采用格式化字符串
      if ((0, _util.isString)(styleOpt.corridor.width)) corridorStyle.width = (0, _util.template)(styleOpt.corridor.width, attr);

      if (entity._corridorEx) {
        (0, _Attr5.style2Entity)(corridorStyle, entity._corridorEx.corridor);
      } else {
        var corridor = (0, _Attr5.style2Entity)(corridorStyle);
        corridor.positions = (0, _Attr6.getPositions)(entity);
        var lineEx = entityCollection.add({
          corridor: corridor,
          properties: attr
        });
        bindMourseEvnet(lineEx, config);
        entity._corridorEx = lineEx;
      }
    }

    //线时，加上文字标签
    if (styleOpt.label && styleOpt.label.text) {
      if (entity._labelEx) {
        (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var pots = (0, _Attr6.getPositions)(entity);
        var position = pots[Math.floor(pots.length / 2)];
        if (styleOpt.label.position) {
          if (styleOpt.label.position == "center") {
            position = (0, _point.centerOfMass)(pots, styleOpt.label.height);
          } else if ((0, _util.isNumber)(styleOpt.label.position)) {
            position = pots[styleOpt.label.position];
          }
        }

        //文本属性
        var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
        labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var lblEx = lblAddFun(position, labelattr, attr);
        if (lblEx) bindMourseEvnet(lblEx, config);
        entity._labelEx = lblEx;
      }
    }
  }
  if (entity.polygon) {
    (0, _Attr7.style2Entity)(styleOpt, entity.polygon);
    //是建筑物时
    if (config.buildings) {
      var floor = Number(attr[config.buildings.cloumn] || 1); //层数

      var height = 3.5; //层高
      var heightCfg = config.buildings.height;
      if ((0, _util.isNumber)(heightCfg)) {
        height = heightCfg;
      } else if ((0, _util.isString)(heightCfg)) {
        height = attr[heightCfg] || height;
      }

      entity.polygon.extrudedHeight = floor * height;
    }
    //是建筑物单体化时
    if (config.dth) {
      entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
      if (!Cesium.defined(styleOpt.color)) entity.polygon.material = nullColor;
      entity.polygon.perPositionHeight = false;
      entity.polygon.zIndex = 99;
    }

    //加上线宽
    if (styleOpt.outlineWidth && styleOpt.outlineWidth > 1) {
      entity.polygon.outline = false;
      var outlineStyle = _extends({}, styleOpt, {
        outline: false,
        color: styleOpt.outlineColor,
        width: styleOpt.outlineWidth,
        opacity: styleOpt.outlineOpacity
      }, styleOpt.outlineStyle || {});
      //_outlineEx是数组，支持挖洞多边形的多个边线。
      if (entity._outlineEx) {
        for (var i = 0, len = entity._outlineEx.length; i < len; i++) {
          (0, _Attr6.style2Entity)(outlineStyle, entity._outlineEx[i].polyline);
        }
      } else {
        var arrline = (0, _Attr7.getAllPositions)(entity);
        entity._outlineEx = [];
        for (var _i = 0, _len = arrline.length; _i < _len; _i++) {
          var polyline = (0, _Attr6.style2Entity)(outlineStyle);
          polyline.positions = arrline[_i];
          var _lineEx = entityCollection.add({
            polyline: polyline,
            properties: attr
          });
          bindMourseEvnet(_lineEx, config);
          entity._outlineEx.push(_lineEx);
        }
      }
    }

    //面时，加上文字标签
    if (styleOpt.label && styleOpt.label.text) {
      if (entity._labelEx) {
        (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var _position = (0, _point.centerOfMass)((0, _Attr7.getPositions)(entity), styleOpt.label.height);

        //文本属性
        var _labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
        _labelattr.heightReference = Cesium.defaultValue(_labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var _lblEx = lblAddFun(_position, _labelattr, attr);
        if (_lblEx) bindMourseEvnet(_lblEx, config);
        entity._labelEx = _lblEx;
      }
    }
  }

  //entity本身存在文字标签
  if (entity.label) {
    styleOpt.label = styleOpt.label || styleOpt || {};

    if (!Cesium.defined(styleOpt.label.clampToGround) && !Cesium.defined(styleOpt.label.heightReference)) styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

    (0, _Attr2.style2Entity)(styleOpt.label, entity.label, attr);
  } else {
    //外部完全自定义的方式
    if (styleOpt.label && typeof styleOpt.label === "function") {
      styleOpt.label(entity, attr, function (position, styleLbl) {
        //文本属性
        var labelattr = (0, _Attr2.style2Entity)(styleLbl, null, attr);
        labelattr.heightReference = Cesium.defaultValue(labelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var lblEx = lblAddFun(position, labelattr, attr);
        if (lblEx) bindMourseEvnet(lblEx, config);
      });
    }
  }

  //图标时
  if (entity.billboard) {
    if (!Cesium.defined(styleOpt.clampToGround) && !Cesium.defined(styleOpt.heightReference)) styleOpt.heightReference = Cesium.defaultValue(styleOpt.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
    // 可采用格式化字符串
    styleOpt.image = (0, _util.template)(styleOpt.image, attr);

    (0, _Attr.style2Entity)(styleOpt, entity.billboard);

    //支持小模型
    if (styleOpt.model) {
      if (entity._modelEx) {
        (0, _Attr3.style2Entity)(styleOpt.model, entity._modelEx.model);
      } else {
        var modelattr = (0, _Attr3.style2Entity)(styleOpt.model);
        modelattr.heightReference = Cesium.defaultValue(modelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var modelEx = entityCollection.add({
          position: entity.position,
          model: modelattr,
          properties: attr
        });
        bindMourseEvnet(lblEx, config);
        entity._modelEx = modelEx;
      }
    }

    //支持point
    if (styleOpt.point) {
      if (entity._pointEx) {
        (0, _Attr4.style2Entity)(styleOpt.point, entity._pointEx.point);
      } else {
        var _modelattr = (0, _Attr4.style2Entity)(styleOpt.point);
        _modelattr.heightReference = Cesium.defaultValue(_modelattr.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var pointEx = entityCollection.add({
          position: entity.position,
          point: _modelattr,
          properties: attr
        });
        bindMourseEvnet(lblEx, config);
        entity._pointEx = pointEx;
      }
    }

    //加上文字标签 (entity本身不存在label时)
    if (styleOpt.label && styleOpt.label.text && !entity.label) {
      if (entity._labelEx) {
        (0, _Attr2.style2Entity)(styleOpt.label, entity._labelEx.label, attr);
      } else {
        //计算中心点
        var _position2 = entity.position;

        //文本属性
        var _labelattr2 = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
        _labelattr2.heightReference = Cesium.defaultValue(_labelattr2.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

        var _lblEx2 = lblAddFun(_position2, _labelattr2, attr);
        if (_lblEx2) bindMourseEvnet(_lblEx2, config);
        entity._labelEx = _lblEx2;
      }
    }
  }

  //记录下样式配置
  entity.styleOpt = styleOpt;
}

//鼠标事件，popup tooltip
function bindMourseEvnet(entity, config) {
  //popup弹窗
  if (config.columns || config.popup) {
    entity.popup = (0, _util.bindLayerPopup)(config.columns || config.popup, function (inhtml, entity) {
      var attr = entity.properties || entity.attribute;
      if (attr && attr.type && attr.attr) {
        //说明是内部标绘生产的geojson
        attr = attr.attr;
      }
      if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)({
        name: config.name,
        popup: inhtml,
        popupNameField: config.popupNameField
      }, attr);
    });
  }
  if (config.tooltip) {
    entity.tooltip = (0, _util.bindLayerPopup)(config.tooltip, function (inhtml, entity) {
      var attr = entity.properties || entity.attribute;
      if (attr && attr.type && attr.attr) {
        //说明是内部标绘生产的geojson
        attr = attr.attr;
      }

      if ((0, _util.isString)(attr)) return attr;else return (0, _util.getTooltipForConfig)({
        name: config.name,
        tooltip: inhtml,
        tooltipNameField: config.tooltipNameField
      }, attr);
    });
  }

  if (config.click) {
    entity.click = config.click;
  }
  if (config.mouseover) {
    entity.mouseover = config.mouseover;
  }
  if (config.mouseout) {
    entity.mouseout = config.mouseout;
  }

  if (config.eventTarget) {
    entity.eventTarget = config.eventTarget;
  }

  if (config.contextmenuItems) {
    entity.contextmenuItems = config.contextmenuItems;
  }
}

//单体化处理
var highlighted_hierarchy; //单体化坐标位置

var highlighColor; //高亮时颜色
var highlightedEntity; //单体化显示的面

function mouseover(entity) {
  //移入
  highlighted_hierarchy = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
  highlightedEntity.polygon.show = true;

  highlightedEntity.properties = entity.properties;
  highlightedEntity.tooltip = entity.tooltip ? entity.tooltip : null;
  highlightedEntity.popup = entity.popup ? entity.popup : null;
}

function mouseout() {
  //移出
  if (Cesium.defined(highlightedEntity)) {
    highlightedEntity.polygon.show = false;
  }
}

//创建单体化显示的面【每个对象只用一次】
function createDthEntity(dataSource, styleOpt) {
  styleOpt = styleOpt || {};

  if (!highlightedEntity) {
    //高亮时颜色
    highlighColor = Cesium.Color.fromCssColorString(Cesium.defaultValue(styleOpt.color, "#ffff00")).withAlpha(Cesium.defaultValue(styleOpt.opacity, 0.3)); //高亮时颜色

    //单体化显示的面
    highlightedEntity = dataSource.entities.add({
      name: "单体化高亮面",
      noMouseMove: true, //标识下，内部不监听其移入事件
      polygon: {
        perPositionHeight: false,
        classificationType: Cesium.ClassificationType.BOTH,
        material: highlighColor,
        hierarchy: new Cesium.CallbackProperty(function (time) {
          return highlighted_hierarchy;
        }, false),
        zIndex: 0
      }
    });
  }

  return {
    mouseover: mouseover,
    mouseout: mouseout
  };
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick3DTileset = pick3DTileset;
exports.style2Tileset = style2Tileset;
exports.getCenter = getCenter;
exports.updateMatrix = updateMatrix;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//获取坐标点处的3dtiles模型，用于计算贴地时进行判断（和视角有关系，不一定精确）
function pick3DTileset(scene, positions) {
  if (!positions) return null;

  if (scene instanceof Cesium.Viewer)
    //兼容scene传入viewer
    scene = scene.scene;

  //判断场景下是否有3dtiles模型
  // var has3dtiles = false;
  // for (var i = 0, len = scene.primitives.length; i < len; ++i) {
  //     var p = scene.primitives.get(i);
  //     if (p instanceof Cesium.Cesium3DTileset) {
  //         has3dtiles = true;
  //         break;
  //     }
  // }
  // if (!has3dtiles) return null; //没有3dtiles模型时，直接return

  if (positions instanceof Cesium.Cartesian3) positions = [positions];

  for (var i = 0, len = positions.length; i < len; ++i) {
    var position = positions[i];
    var coorPX = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position);
    if (!Cesium.defined(coorPX)) continue;

    var pickedObject = scene.pick(coorPX, 10, 10);
    if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive) && pickedObject.primitive instanceof Cesium.Cesium3DTileset) {
      // Cesium.defined(pickedObject.primitive.isCesium3DTileset)
      return pickedObject.primitive;
    }
  }

  return null;
}

//属性赋值到3DTiles
//3dtiles相关计算常用方法
function style2Tileset(tileset, style) {
  style = style || {};

  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        tileset[key] = value;
        break;
      case "scaleByDistance_near": //跳过扩展其他属性的参数
      case "scaleByDistance_nearValue":
      case "scaleByDistance_far":
      case "scaleByDistance_farValue":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "scaleByDistance":
        //是否按视距缩放
        if (value) {
          tileset.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
        } else {
          tileset.scaleByDistance = undefined;
        }
        break;
    }
  }

  return tileset;
}

//[兼容旧版本，不建议使用]获取模型的中心点信息
function getCenter(tileset) {
  return tileset.das.orginPosition;
}
//[兼容旧版本，不建议使用]变换模型位置等
function updateMatrix(tileset, opts) {
  tileset.das.updateStyle({ offset: opts });
  return tileset.das.updateMatrix();
}

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__33__;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {
      scale: 1,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM
    };
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "scaleByDistance_near": //跳过扩展其他属性的参数
      case "scaleByDistance_nearValue":
      case "scaleByDistance_far":
      case "scaleByDistance_farValue":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "opacity":
        //透明度
        entityattr.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Cesium.defaultValue(value, 1.0));
        break;
      case "rotation":
        //旋转角度
        entityattr.rotation = Cesium.Math.toRadians(value);
        break;
      case "pixelOffset":
        //偏移量
        if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
        break;
      case "scaleByDistance":
        //是否按视距缩放
        if (value) {
          entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
        } else {
          entityattr.scaleByDistance = undefined;
        }
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
      case "heightReference":
        switch (value) {
          case "NONE":
            entityattr.heightReference = Cesium.HeightReference.NONE;
            break;
          case "CLAMP_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            break;
          case "RELATIVE_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
            break;
          default:
            entityattr.heightReference = value;
            break;
        }
        break;
      case "horizontalOrigin":
        switch (value) {
          case "CENTER":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
            break;
          case "LEFT":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
            break;
          case "RIGHT":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
            break;
          default:
            entityattr.horizontalOrigin = value;
            break;
        }
        break;
      case "verticalOrigin":
        switch (value) {
          case "CENTER":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.CENTER;
            break;
          case "TOP":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.TOP;
            break;
          case "BOTTOM":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
            break;
          default:
            entityattr.verticalOrigin = value;
            break;
        }
        break;
      case "visibleDepth":
        if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

        break;
    }
  }

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "scaleByDistance_near":
      case "scaleByDistance_nearValue":
      case "scaleByDistance_far":
      case "scaleByDistance_farValue":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.color = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;

      case "pixelOffset":
        //偏移量
        if (Cesium.defined(value[0]) && Cesium.defined(value[1])) entityattr.pixelOffset = new Cesium.Cartesian2(value[0], value[1]);else entityattr.pixelOffset = value;
        break;
      case "scaleByDistance":
        //是否按视距缩放
        if (value) {
          entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
        } else {
          entityattr.scaleByDistance = undefined;
        }
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
      case "heightReference":
        switch (value) {
          case "NONE":
            entityattr.heightReference = Cesium.HeightReference.NONE;
            break;
          case "CLAMP_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            break;
          case "RELATIVE_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
            break;
          default:
            entityattr.heightReference = value;
            break;
        }
        break;

      case "visibleDepth":
        if (value) entityattr.disableDepthTestDistance = 0;else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

        break;
    }
  }

  //无边框时，需设置宽度为0
  if (!style.outline) entityattr.outlineWidth = 0.0;

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "silhouette": //跳过扩展其他属性的参数
      case "silhouetteColor":
      case "silhouetteAlpha":
      case "silhouetteSize":
      case "fill":
      case "color":
      case "opacity":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "modelUrl": //模型uri
      case "uri":
        entityattr.uri = value;
        break;

      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
      case "heightReference":
        switch (value) {
          case "NONE":
            entityattr.heightReference = Cesium.HeightReference.NONE;
            break;
          case "CLAMP_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            break;
          case "RELATIVE_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
            break;
          default:
            entityattr.heightReference = value;
            break;
        }
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //轮廓
  if (style.silhouette) {
    entityattr.silhouetteColor = Cesium.Color.fromCssColorString(style.silhouetteColor || "#FFFFFF").withAlpha(Number(style.silhouetteAlpha || 1.0));
    entityattr.silhouetteSize = Number(style.silhouetteSize || 1.0);
  } else entityattr.silhouetteSize = 0.0;

  //透明度、颜色
  var opacity = Cesium.defaultValue(style.opacity, 1);
  if (style.fill) entityattr.color = Cesium.Color.fromCssColorString(style.color || "#FFFFFF").withAlpha(opacity);else entityattr.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(opacity);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureArea = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(18);

var measureUtil = _interopRequireWildcard(_measure);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(13);

var _MeasureBase2 = __webpack_require__(29);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureArea = exports.MeasureArea = function (_MeasureBase) {
  _inherits(MeasureArea, _MeasureBase);

  //========== 构造方法 ==========
  function MeasureArea(opts, target) {
    _classCallCheck(this, MeasureArea);

    var _this = _possibleConstructorReturn(this, (MeasureArea.__proto__ || Object.getPrototypeOf(MeasureArea)).call(this, opts, target));

    _this.totalLable = null; //面积label
    return _this;
  }

  _createClass(MeasureArea, [{
    key: "clearLastNoEnd",


    //清除未完成的数据
    value: function clearLastNoEnd() {
      if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
      this.totalLable = null;
    }
    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: false
      });

      this.totalLable = this.dataSource.entities.add({
        label: entityattr,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.totalLable.showText = function (unit) {
        var areastr = util.formatArea(this.attribute.value, unit);
        this.label.text = "面积:" + areastr;
        return areastr;
      };

      return this.drawControl.startDraw({
        type: "polygon",
        style: _extends({
          color: "#00fff2",
          outline: true,
          outlineColor: "#fafa5a",
          outlineWidth: 2,
          opacity: 0.4,
          clampToGround: true }, options.style)
      });
    }
    //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(entity) {
      this.showMoveDrawing(entity); //兼容手机端
    }
    //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      var positions = this.drawControl.getPositions(e.entity);
      if (positions.length < 3) {
        this.totalLable.label.show = false;
      }
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 3) {
        this.totalLable.label.show = false;
        return;
      }

      var area = measureUtil.getArea(positions);
      this.totalLable.attribute.value = area;
      var areastr = this.totalLable.showText(this.options.unit);

      //求中心点
      var ptcenter = (0, _point.centerOfMass)(positions);
      this.totalLable.position = ptcenter;
      this.totalLable.label.show = true;

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: area,
        label: areastr
      });
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      if (entity.polygon == null) return;

      entity._totalLable = this.totalLable;
      this.totalLable = null;

      this.target.fire(_DasClass.eventType.end, {
        mtype: this.type,
        entity: entity,
        value: entity._totalLable.attribute.value
      });
    }

    //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      var positions = this.drawControl.getPositions(entity);
      var totalLable = entity._totalLable;

      var area = measureUtil.getArea(positions);
      totalLable.attribute.value = area;
      totalLable.position = (0, _point.centerOfMass)(positions); //求中心点

      var areastr = totalLable.showText(this.options.unit);

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: area,
        label: areastr
      });
    }
  }, {
    key: "type",
    get: function get() {
      return "area";
    }
  }]);

  return MeasureArea;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureLength = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(18);

var measureUtil = _interopRequireWildcard(_measure);

var _Attr = __webpack_require__(13);

var _MeasureBase2 = __webpack_require__(29);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureLength = exports.MeasureLength = function (_MeasureBase) {
  _inherits(MeasureLength, _MeasureBase);

  //========== 构造方法 ==========
  function MeasureLength(opts, target) {
    _classCallCheck(this, MeasureLength);

    var _this = _possibleConstructorReturn(this, (MeasureLength.__proto__ || Object.getPrototypeOf(MeasureLength)).call(this, opts, target));

    _this.arrLables = []; //各线段label
    _this.totalLable = null; //总长label
    _this.disTerrainScale = 1.2; //贴地时的概略比例
    return _this;
  }

  _createClass(MeasureLength, [{
    key: "clearLastNoEnd",

    //清除未完成的数据
    value: function clearLastNoEnd() {
      if (Cesium.defined(this.totalLable)) this.dataSource.entities.remove(this.totalLable);
      if (Cesium.defined(this.arrLables) && this.arrLables.length > 0) {
        var arrLables = this.arrLables;
        if (arrLables && arrLables.length > 0) {
          for (var i = 0, len = arrLables.length; i < len; i++) {
            this.dataSource.entities.remove(arrLables[i]);
          }
        }
      }
      this.totalLable = null;
      this.arrLables = [];
    }

    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      this.stopDraw();

      //总长label
      var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: false
      });
      this.totalLable = this.dataSource.entities.add({
        label: entityattr,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.totalLable.showText = function (unit) {
        var distancestr = util.formatLength(this.attribute.value, unit);
        if (this.attribute.value != this.attribute.valueFD) {
          var lastLenStr = util.formatLength(this.attribute.valueFD, unit);
          this.label.text = "总长:" + distancestr + "\n(+" + lastLenStr + ")";
        } else {
          this.label.text = "总长:" + distancestr;
        }
        return distancestr;
      };
      this.arrLables = [];

      return this.drawControl.startDraw({
        type: "polyline",
        config: {
          addHeight: options.addHeight,
          maxPointNum: options.maxPointNum
        },
        style: _extends({
          lineType: "glow",
          color: "#ebe12c",
          width: 2,
          glowPower: 0.1,
          clampToGround: false, //是否贴地
          depthFail: true,
          depthFailType: "dash",
          depthFailOpacity: 0.5,
          depthFailColor: "#ebe12c"
        }, options.style)
      });
    }

    //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(entity) {
      var positions = this.drawControl.getPositions(entity);

      var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: true
      });

      var labelEntity = this.dataSource.entities.add({
        position: positions[positions.length - 1],
        label: entityattr,
        _noMousePosition: true,
        attribute: {
          unit: this.options.unit,
          type: this.options.type
        }
      });

      if (positions.length == 1) {
        labelEntity.label.text = "起点";
        //labelEntity.attribute.value = 0;
      } else {
        var distance = measureUtil.getLength(positions);
        var lastLen = measureUtil.getLength([positions[positions.length - 2], positions[positions.length - 1]]); //最后2点间距离
        //屏蔽比较小的数值
        // if (lastLen < 5)
        //     labelEntity.show = false;

        labelEntity.attribute.value = distance;
        labelEntity.attribute.valueFD = lastLen;
        labelEntity.showText = function (unit) {
          var distancestr = util.formatLength(this.attribute.value, unit);
          if (this.attribute.value != this.attribute.valueFD) {
            var lastLenStr = util.formatLength(this.attribute.valueFD, unit);
            this.label.text = distancestr + "\n(+" + lastLenStr + ")";
          } else {
            this.label.text = distancestr;
          }
        };
        labelEntity.showText(this.options.unit);
      }
      this.arrLables.push(labelEntity);
    }
  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      var label = this.arrLables.pop();
      this.dataSource.entities.remove(label);

      this.showMoveDrawing(e.entity);
      this.totalLable.position = e.position;
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 2) {
        this.totalLable.label.show = false;
        return;
      }

      var distance = measureUtil.getLength(positions);
      var distancestr = util.formatLength(distance, this.options.unit);

      //最后2点间距离
      var lastLen = measureUtil.getLength([positions[positions.length - 2], positions[positions.length - 1]]);
      if (lastLen == 0 && positions.length > 2) {
        lastLen = measureUtil.getLength([positions[positions.length - 3], positions[positions.length - 2]]);
      }
      this.totalLable.attribute.value = distance;
      this.totalLable.attribute.valueFD = lastLen;

      this.totalLable.showText(this.options.unit);
      this.totalLable.position = positions[positions.length - 1];
      this.totalLable.label.show = true;

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: distance,
        label: distancestr
      });
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      var positions = this.drawControl.getPositions(entity);
      var count = this.arrLables.length - positions.length;
      if (count >= 0) {
        for (var i = this.arrLables.length - 1; i >= positions.length - 1; i--) {
          this.dataSource.entities.remove(this.arrLables[i]);
        }
        this.arrLables.splice(positions.length - 1, count + 1);
      }
      entity._totalLable = this.totalLable;
      entity.arrEntityEx = this.arrLables;

      this.totalLable = null;
      this.arrLables = [];

      if (this.type == "length") {
        this.target.fire(_DasClass.eventType.end, {
          mtype: this.type,
          entity: entity,
          value: entity._totalLable.attribute.value
        });
      }
    }
    //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      var positions = this.drawControl.getPositions(entity);

      var arrLables = entity.arrEntityEx;
      if (arrLables && arrLables.length > 0) {
        for (var i = 1, len = arrLables.length; i < len; i++) {
          this.dataSource.entities.remove(arrLables[i]);
        }
      }

      //起点
      var qidian = arrLables[0];
      qidian.position = positions[0];

      entity.arrEntityEx = [qidian];

      var alllen = 0;
      for (var _i = 1, _len = positions.length - 1; _i < _len; _i++) {
        var lastLen = util.getLength([positions[_i - 1], positions[_i]]); //2点间距离
        alllen += lastLen;

        var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
          horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM
        });
        var labelEntity = this.dataSource.entities.add({
          position: positions[_i],
          label: entityattr,
          _noMousePosition: true,
          attribute: {
            unit: this.options.unit,
            type: this.options.type
          }
        });
        labelEntity.attribute.value = alllen;
        labelEntity.attribute.valueFD = lastLen;
        labelEntity.showText = function (unit) {
          var distancestr = util.formatLength(this.attribute.value, unit);
          if (this.attribute.value != this.attribute.valueFD) {
            var lastLenStr = util.formatLength(this.attribute.valueFD, unit);
            this.label.text = distancestr + "\n(+" + lastLenStr + ")";
          } else {
            this.label.text = distancestr;
          }
        };
        labelEntity.showText(this.options.unit);

        entity.arrEntityEx.push(labelEntity);
      }

      var lastlen = util.getLength([positions[positions.length - 2], positions[positions.length - 1]]);
      alllen += lastlen;

      entity._totalLable.attribute.value = alllen;
      entity._totalLable.attribute.valueFD = lastlen;
      var alllenstr = entity._totalLable.showText();
      entity._totalLable.position = positions[positions.length - 1];

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: alllen,
        label: alllenstr
      });
    }
  }, {
    key: "type",
    get: function get() {
      return "length";
    }
  }]);

  return MeasureLength;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowParent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//箭头的父类
var ArrowParent = exports.ArrowParent = function () {
  function ArrowParent() {
    _classCallCheck(this, ArrowParent);

    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(ArrowParent, [{
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(points, tailLeft, tailRight) {
      var len = this.plotUtil.getBaseLength(points);
      var headHeight = len * this.headHeightFactor;
      var headPnt = points[points.length - 1];
      len = this.plotUtil.MathDistance(headPnt, points[points.length - 2]);
      var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
      if (headHeight > tailWidth * this.headTailFactor) {
        headHeight = tailWidth * this.headTailFactor;
      }
      var headWidth = headHeight * this.headWidthFactor;
      var neckWidth = headHeight * this.neckWidthFactor;
      headHeight = headHeight > len ? len : headHeight;
      var neckHeight = headHeight * this.neckHeightFactor;
      var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.plotUtil.wholeDistance(points);
      var len = this.plotUtil.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts);
    }
  }]);

  return ArrowParent;
}();

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineFlowMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//线状 流动效果 材质
var LineFlowMaterialProperty = exports.LineFlowMaterialProperty = function () {
  //========== 构造方法 ==========
  function LineFlowMaterialProperty(options) {
    _classCallCheck(this, LineFlowMaterialProperty);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    this._color = undefined;
    this._colorSubscription = undefined;
    this._time = undefined;
    this._definitionChanged = new Cesium.Event();

    //支持的属性
    this._image = options.image || options.url; //背景图片
    this._color = Cesium.defaultValue(options.color, new Cesium.Color(0, 0, 0, 0)); //背景图片颜色
    this._axisY = Cesium.defaultValue(options.axisY, false);
    this._speed = Cesium.defaultValue(options.speed, 10); //速度，建议取值范围1-100
    this._repeat = Cesium.defaultValue(options.repeat, new Cesium.Cartesian2(1.0, 1.0));

    this._image2 = options.image2 || options.bgUrl; //第2张背景图片
    this._color2 = options.color2 || options.bgColor || new Cesium.Color(1, 1, 1); //第2张背景图片颜色
    this._hasImage2 = Cesium.defined(this._image2);

    if (options.duration) {
      //兼容v2.2之前老版本
      this._speed = 30000 / options.duration;
    }
  }

  //========== 对外属性 ==========


  _createClass(LineFlowMaterialProperty, [{
    key: "getType",


    //========== 方法 ==========
    /**
     * Gets the {@link Cesium.Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    value: function getType(time) {
      return Cesium.Material.LineFlowType;
    }

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.image = this._image;
      result.color = this._color; //Cesium.Property.getValueOrClonedDefault(this.color, time, Cesium.Color.WHITE, result.color);
      result.repeat = this._repeat;
      result.axisY = this._axisY;
      result.speed = this._speed;

      result.hasImage2 = this._hasImage2;
      result.image2 = this._image2;
      result.color2 = this._color2; // Cesium.Property.getValueOrClonedDefault(this.color2, time, Cesium.Color.WHITE, result.color2)

      return result;
    }

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param {Cesium.Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof LineFlowMaterialProperty &&
      // && Cesium.Property.equals(this._color, other._color)
      // && Cesium.Property.equals(this._repeat, other._repeat)
      this._color === other._color && this._repeat === other._repeat && this._image === other._image && this._axisY === other._axisY && this._speed === other._speed;
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return LineFlowMaterialProperty;
}();

Object.defineProperties(LineFlowMaterialProperty.prototype, {
  // image: Cesium.createPropertyDescriptor('image'),
  // color: Cesium.createPropertyDescriptor('color'),
  // repeat: Cesium.createPropertyDescriptor('repeat'),
  // axisY: Cesium.createPropertyDescriptor('axisY'),
  // speed: Cesium.createPropertyDescriptor('speed'),
  // image2: Cesium.createPropertyDescriptor('image2'),
  // color2: Cesium.createPropertyDescriptor('color2')
});

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {
      fill: true
    };
  }

  //贴地时，剔除高度相关属性
  if (style.clampToGround) {
    if (style.hasOwnProperty("height")) delete style.height;
    if (style.hasOwnProperty("extrudedHeight")) delete style.extrudedHeight;
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;
      case "cornerType":
        switch (value) {
          case "BEVELED":
            entityattr.cornerType = Cesium.CornerType.BEVELED;
            break;
          case "MITERED":
            entityattr.cornerType = Cesium.CornerType.MITERED;
            break;
          case "ROUNDED":
            entityattr.cornerType = Cesium.CornerType.ROUNDED;
            break;
          default:
            entityattr.cornerType = value;
            break;
        }
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return entity.corridor.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  };
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.getOutlinePositions = getOutlinePositions;
exports.getOutlineCoordinates = getOutlineCoordinates;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {
      fill: true
    };
  }
  //贴地时，剔除高度相关属性
  if (style.clampToGround) {
    if (style.hasOwnProperty("height")) delete style.height;
    if (style.hasOwnProperty("extrudedHeight")) delete style.extrudedHeight;
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];

    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "color":
      case "animation":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outline":
        //边线
        if (entityattr[key] instanceof Cesium.CallbackProperty) {
          //回调时不覆盖
        } else {
          entityattr[key] = value;
        }
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
        break;
      case "rotation":
        //旋转角度
        entityattr.rotation = Cesium.Math.toRadians(value);
        if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
        break;
      case "stRotation":
        entityattr.stRotation = Cesium.Math.toRadians(value);
        break;
      case "height":
        entityattr.height = value;
        if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
        break;
      case "extrudedHeight":
        if ((0, _util.isNumber)(value)) {
          entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
        } else {
          entityattr.extrudedHeight = value;
        }
        break;
      case "radius":
        //半径（圆）
        entityattr.semiMinorAxis = Number(value);
        entityattr.semiMajorAxis = Number(value);
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

//获取entity对应的 边界 的坐标
function getOutlinePositions(entity, noAdd, count) {
  var time = (0, _util.currentTime)();

  //获取圆（或椭圆）边线上的坐标点数组
  var outerPositions = (0, _polygon.getEllipseOuterPositions)({
    position: (0, _point.getPositionValue)(entity.position),
    semiMajorAxis: entity.ellipse.semiMajorAxis && entity.ellipse.semiMajorAxis.getValue(time), //长半轴
    semiMinorAxis: entity.ellipse.semiMinorAxis && entity.ellipse.semiMinorAxis.getValue(time), //短半轴
    rotation: entity.ellipse.rotation && entity.ellipse.rotation.getValue(time),
    count: Cesium.defaultValue(count, 90) //共返回360个点
  });

  if (!noAdd && outerPositions) outerPositions.push(outerPositions[0]);

  return outerPositions;
}

//获取entity对应的 边界 的坐标（geojson规范的格式）
function getOutlineCoordinates(entity, noAdd, count) {
  var positions = getOutlinePositions(entity, noAdd, count);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TileLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _BaseLayer2 = __webpack_require__(14);

var _layer = __webpack_require__(24);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TileLayer = exports.TileLayer = function (_BaseLayer) {
  _inherits(TileLayer, _BaseLayer);

  //========== 构造方法 ==========
  function TileLayer(viewer, options) {
    _classCallCheck(this, TileLayer);

    var _this = _possibleConstructorReturn(this, (TileLayer.__proto__ || Object.getPrototypeOf(TileLayer)).call(this, viewer, options));

    _this.hasOpacity = true;
    _this.hasZIndex = true;
    return _this;
  }

  _createClass(TileLayer, [{
    key: "add",


    //添加
    value: function add() {
      if (this.imageryLayer != null) {
        this.remove();
      }

      this.addEx();
      var imageryProvider = this.createImageryProvider(this.options);
      if (!Cesium.defined(imageryProvider)) return;

      var options = this.options;

      var imageryOpt = {
        show: true,
        alpha: this._opacity
      };
      if (Cesium.defined(options.rectangle) && Cesium.defined(options.rectangle.xmin) && Cesium.defined(options.rectangle.xmax) && Cesium.defined(options.rectangle.ymin) && Cesium.defined(options.rectangle.ymax)) {
        var xmin = options.rectangle.xmin;
        var xmax = options.rectangle.xmax;
        var ymin = options.rectangle.ymin;
        var ymax = options.rectangle.ymax;
        var rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
        this.rectangle = rectangle;
        imageryOpt.rectangle = rectangle;
      }
      if (Cesium.defined(options.bbox) && options.bbox.length && options.bbox.length == 4) {
        var _rectangle = Cesium.Rectangle.fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]); //[xmin,ymin,xmax,ymax]
        this.rectangle = _rectangle;
        imageryOpt.rectangle = _rectangle;
      }

      if (Cesium.defined(options.brightness)) imageryOpt.brightness = options.brightness;
      if (Cesium.defined(options.contrast)) imageryOpt.contrast = options.contrast;
      if (Cesium.defined(options.hue)) imageryOpt.hue = options.hue;
      if (Cesium.defined(options.saturation)) imageryOpt.saturation = options.saturation;
      if (Cesium.defined(options.gamma)) imageryOpt.gamma = options.gamma;
      if (Cesium.defined(options.maximumAnisotropy)) imageryOpt.maximumAnisotropy = options.maximumAnisotropy;
      if (Cesium.defined(options.minimumTerrainLevel)) imageryOpt.minimumTerrainLevel = options.minimumTerrainLevel;
      if (Cesium.defined(options.maximumTerrainLevel)) imageryOpt.maximumTerrainLevel = options.maximumTerrainLevel;

      this.imageryLayer = new Cesium.ImageryLayer(imageryProvider, imageryOpt);
      this.imageryLayer.eventTarget = this;
      this.imageryLayer.config = this.options;

      var that = this;
      this.imageryLayer.onLoadTileStart = function (imagery) {
        that.fireMap(_DasClass.eventType.loadTileStart, { imagery: imagery });
      };
      this.imageryLayer.onLoadTileEnd = function (imagery) {
        that.fireMap(_DasClass.eventType.loadTileEnd, { imagery: imagery });
      };
      this.imageryLayer.onLoadTileError = function (imagery) {
        that.fireMap(_DasClass.eventType.loadTileError, { imagery: imagery });
      };

      this.viewer.imageryLayers.add(this.imageryLayer);

      this.setZIndex(this.options.order);

      _get(TileLayer.prototype.__proto__ || Object.getPrototypeOf(TileLayer.prototype), "add", this).call(this);

      this.fireMap(_DasClass.eventType.load, {
        imageryLayer: this.imageryLayer
      });
    }
    //方便外部继承覆盖该方法

  }, {
    key: "createImageryProvider",
    value: function createImageryProvider(config) {
      return (0, _layer.createImageryProvider)(config); //调用layer.js
    }
  }, {
    key: "addEx",
    value: function addEx() {}
    //子类使用

    //移除

  }, {
    key: "remove",
    value: function remove() {
      if (this.imageryLayer == null) return;

      this.removeEx();
      this.viewer.imageryLayers.remove(this.imageryLayer, false);
      this.imageryLayer = null;
      _get(TileLayer.prototype.__proto__ || Object.getPrototypeOf(TileLayer.prototype), "remove", this).call(this);
    }
  }, {
    key: "removeEx",
    value: function removeEx() {}
    //子类使用

    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.imageryLayer == null) return;

      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else if (Cesium.defined(this.rectangle)) {
        this.viewer.camera.flyTo({
          destination: this.rectangle,
          duration: duration
        });
      } else {
        var rectangle = this.imageryLayer.imageryProvider.rectangle; //arcgis图层等，读取配置信息
        if (Cesium.defined(rectangle) && rectangle != Cesium.Rectangle.MAX_VALUE && rectangle.west > 0 && rectangle.south > 0 && rectangle.east > 0 && rectangle.north > 0) {
          this.viewer.camera.flyTo({
            destination: rectangle,
            duration: duration
          });
        }
      }
    }
    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;
      if (this.imageryLayer == null) return;

      this.imageryLayer.alpha = value;
    }
    //设置叠加顺序

  }, {
    key: "setZIndex",
    value: function setZIndex(order) {
      if (this.imageryLayer == null || order == null) return;

      //先移动到最顶层
      this.viewer.imageryLayers.raiseToTop(this.imageryLayer);

      var layers = this.viewer.imageryLayers._layers;
      for (var i = layers.length - 1; i >= 0; i--) {
        if (layers[i] == this.imageryLayer) continue;
        var _temp = layers[i].config;
        if (_temp && _temp.order) {
          if (order < _temp.order) {
            this.viewer.imageryLayers.lower(this.imageryLayer); //下移一个位置
          }
        }
      }
    }
  }, {
    key: "layer",
    get: function get() {
      return this.imageryLayer;
    }
  }]);

  return TileLayer;
}(_BaseLayer2.BaseLayer);
//[静态属性]本类中支持的事件类型常量


TileLayer.event = {
  loadTileStart: _DasClass.eventType.loadTileStart,
  loadTileEnd: _DasClass.eventType.loadTileEnd,
  loadTileError: _DasClass.eventType.loadTileError,
  load: _DasClass.eventType.load,
  click: _DasClass.eventType.click,
  mouseOver: _DasClass.eventType.mouseOver,
  mouseOut: _DasClass.eventType.mouseOut
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomFeatureGridLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _FeatureGridLayer2 = __webpack_require__(103);

var _config2Entity2 = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //分块加载矢量数据公共类


var CustomFeatureGridLayer = exports.CustomFeatureGridLayer = function (_FeatureGridLayer) {
  _inherits(CustomFeatureGridLayer, _FeatureGridLayer);

  //========== 构造方法 ==========
  function CustomFeatureGridLayer(viewer, options) {
    _classCallCheck(this, CustomFeatureGridLayer);

    var _this = _possibleConstructorReturn(this, (CustomFeatureGridLayer.__proto__ || Object.getPrototypeOf(CustomFeatureGridLayer)).call(this, viewer, options));

    _this._cacheGrid = {}; //网格缓存,存放矢量对象id集合
    _this._cacheFeature = {}; //矢量对象缓存,存放矢量对象和其所对应的网格集合
    _this.hasOpacity = true;
    return _this;
  }

  //========== 方法==========


  _createClass(CustomFeatureGridLayer, [{
    key: "_addImageryCache",
    value: function _addImageryCache(opts) {
      this._cacheGrid[opts.key] = { opts: opts, isLoading: true };

      var that = this;

      this.getDataForGrid(opts, function (arrdata) {
        if (that._visible) that._showData(opts, arrdata);
      });
    }
  }, {
    key: "getDataForGrid",
    value: function getDataForGrid(opts, callback) {
      //子类可继承, callback为回调方法,callback参数传数据数组

      //直接使用本类,传参方式
      if (this.options.getDataForGrid) {
        this.options.getDataForGrid(opts, callback);
      }
    }
  }, {
    key: "checkHasBreak",
    value: function checkHasBreak(cacheKey) {
      if (!this._visible || !this._cacheGrid[cacheKey]) {
        return true;
      }
      return false;
    }
  }, {
    key: "_showData",
    value: function _showData(opts, arrdata) {
      var cacheKey = opts.key;
      if (this.checkHasBreak[cacheKey]) {
        return; //异步请求结束时,如果已经卸载了网格就直接跳出。
      }

      var that = this;

      var arrIds = [];
      for (var i = 0, len = arrdata.length; i < len; i++) {
        var attributes = arrdata[i];
        var id = attributes[this.options.IdName || "id"];

        var layer = this._cacheFeature[id];
        if (layer) {
          //已存在
          layer.grid.push(cacheKey);
          this.updateEntity(layer.entity, attributes);
        } else {
          var entity = this.createEntity(opts, attributes, function (entity) {
            if (that.options.debuggerTileInfo) {
              //测试用
              entity._temp_id = id;
              entity.popup = function (entity) {
                return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
              };
            }
            that._cacheFeature[id] = {
              grid: [cacheKey],
              entity: entity
            };
            if (that.options.onEachEntity)
              //添加到地图后回调方法
              that.options.onEachEntity(entity, that);
          });
          if (entity != null) {
            if (that.options.debuggerTileInfo) {
              //测试用
              entity._temp_id = id;
              entity.popup = function (entity) {
                return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
              };
            }
            that._cacheFeature[id] = {
              grid: [cacheKey],
              entity: entity
            };
            if (that.options.onEachEntity)
              //添加到地图后回调方法
              that.options.onEachEntity(entity, that);
          }
        }
        arrIds.push(id);
      }

      this._cacheGrid[cacheKey] = this._cacheGrid[cacheKey] || {};
      this._cacheGrid[cacheKey].ids = arrIds;
      this._cacheGrid[cacheKey].isLoading = false;
    }
  }, {
    key: "createEntity",
    value: function createEntity(opts, attributes, callback) {
      //子类可以继承,根据数据创造entity

      //直接使用本类,传参方式
      if (this.options.createEntity) {
        return this.options.createEntity(opts, attributes, callback);
      }
      return null;
    }
  }, {
    key: "updateEntity",
    value: function updateEntity(enetity, attributes) {
      //子类可以继承,更新entity（动态数据时有用）

      //直接使用本类,传参方式
      if (this.options.updateEntity) {
        this.options.updateEntity(enetity, attributes);
      }
    }
  }, {
    key: "removeEntity",
    value: function removeEntity(enetity) {
      //子类可以继承,移除entity

      //直接使用本类,传参方式
      if (this.options.removeEntity) {
        this.options.removeEntity(enetity);
      } else {
        this.dataSource.entities.remove(enetity);
      }
    }
  }, {
    key: "_removeImageryCache",
    value: function _removeImageryCache(opts) {
      var cacheKey = opts.key;
      var layers = this._cacheGrid[cacheKey];
      if (layers) {
        if (layers.ids) {
          for (var i = 0; i < layers.ids.length; i++) {
            var id = layers.ids[i];
            var layer = this._cacheFeature[id];
            if (layer) {
              layer.grid.remove(cacheKey);
              if (layer.grid.length == 0) {
                delete this._cacheFeature[id];
                this.removeEntity(layer.entity);
              }
            }
          }
        }
        delete this._cacheGrid[cacheKey];
      }
    }
  }, {
    key: "_removeAllImageryCache",
    value: function _removeAllImageryCache() {
      if (this.options.removeAllEntity) {
        this.options.removeAllEntity();
      } else {
        this.dataSource.entities.removeAll();
        this.primitives.removeAll();
      }

      this._cacheFeature = {};
      this._cacheGrid = {};
    }
    //移除

  }, {
    key: "removeEx",
    value: function removeEx() {
      if (this.options.removeAllEntity) {
        this.options.removeAllEntity();
      } else {
        this.dataSource.entities.removeAll();
        // this.primitives.removeAll(); // 修改删除wfs数据bug
      }

      this._cacheFeature = {};
      this._cacheGrid = {};

      this.viewer.dataSources.remove(this.dataSource);
      // this.viewer.scene.primitives.remove(this.primitives);  // 修改删除wfs数据bug
    }
    //重新加载数据

  }, {
    key: "reload",
    value: function reload() {
      var that = this;
      for (var i in this._cacheGrid) {
        var item = this._cacheGrid[i];
        if (item == null || item.opts == null || item.isLoading) continue;

        var opts = item.opts;
        this.getDataForGrid(opts, function (arrdata) {
          that._showData(opts, arrdata);
        });
      }
    }

    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;

      for (var i in this._cacheFeature) {
        var entity = this._cacheFeature[i].entity;

        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
          this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
          if (entity.polygon.outlineColor) {
            this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
          }
        }

        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
          this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
        }

        if (entity.billboard) {
          entity.billboard.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.model) {
          entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.label) {
          var _opacity = this._opacity;
          if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

          if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
          if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
          if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
        }
      }
    }
  }, {
    key: "_updatEntityAlpha",
    value: function _updatEntityAlpha(color, opacity) {
      if (!color) return;
      var newclr = color.getValue(this.viewer.clock.currentTime);
      if (!newclr || !newclr.withAlpha) return color;

      newclr = newclr.withAlpha(opacity);
      color.setValue(newclr);
    }

    //获取属性

  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      return (0, _util.getAttrVal)(entity.properties);
    }
    //根据config配置，更新entitys

  }, {
    key: "config2Entity",
    value: function config2Entity(entity) {
      return (0, _config2Entity2.config2Entity)([entity], this.options);
    }
  }]);

  return CustomFeatureGridLayer;
}(_FeatureGridLayer2.FeatureGridLayer);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoJsonLayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var _point = __webpack_require__(2);

var _config2Entity = __webpack_require__(31);

var _BaseLayer2 = __webpack_require__(14);

var _zepto = __webpack_require__(7);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GeoJsonLayer = exports.GeoJsonLayer = function (_BaseLayer) {
  _inherits(GeoJsonLayer, _BaseLayer);

  //========== 构造方法 ==========
  function GeoJsonLayer(viewer, options) {
    _classCallCheck(this, GeoJsonLayer);

    var _this = _possibleConstructorReturn(this, (GeoJsonLayer.__proto__ || Object.getPrototypeOf(GeoJsonLayer)).call(this, viewer, options));

    _this.hasOpacity = true;
    _this.hasZIndex = true;
    return _this;
  }

  _createClass(GeoJsonLayer, [{
    key: "create",
    value: function create() {
      var _this2 = this;

      //是建筑物单体化时
      if (this.options.dth) {
        var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.options.dth);

        if (this.options.dth.type == "click") {
          this.on(_DasClass.eventType.click, function (e) {
            dthEvent.mouseover(e.sourceTarget);
          });
          this.viewer.das.on(_DasClass.eventType.clickMap, function (e) {
            if (!_this2._visible) return;
            dthEvent.mouseout();
          });
        } else {
          this.on(_DasClass.eventType.mouseOver, function (e) {
            dthEvent.mouseover(e.sourceTarget);
          });
          this.on(_DasClass.eventType.mouseOut, function (e) {
            dthEvent.mouseout();
          });
        }
        this.dthEvent = dthEvent;
      }
    }
    //添加

  }, {
    key: "add",
    value: function add() {
      if (this.labelCollection && !this.viewer.scene.primitives.contains(this.labelCollection)) {
        this.viewer.scene.primitives.add(this.labelCollection);
      }

      if (!this.options.reload && this.dataSource) {
        //this.options.reload可以外部控制每次都重新请求数据
        this.viewer.dataSources.add(this.dataSource);
      } else {
        this.queryData();
      }
      _get(GeoJsonLayer.prototype.__proto__ || Object.getPrototypeOf(GeoJsonLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      //是建筑物单体化时
      if (this.dthEvent) {
        this.dthEvent.mouseout();
      }
      if (this.dataSource) {
        this.viewer.dataSources.remove(this.dataSource);
        delete this.dataSource;
      }
      if (this.labelCollection && this.viewer.scene.primitives.contains(this.labelCollection)) {
        this.viewer.scene.primitives.destroyPrimitives = false;
        this.viewer.scene.primitives.remove(this.labelCollection);
      }
      _get(GeoJsonLayer.prototype.__proto__ || Object.getPrototypeOf(GeoJsonLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else {
        if (this.dataSource == null) return;
        this.viewer.das.flyTo(this.dataSource.entities.values, { duration: duration });
      }
    }
  }, {
    key: "clearData",
    value: function clearData() {
      if (this.dataSource) this.dataSource.entities.removeAll();

      if (this.labelCollection) this.labelCollection.removeAll();

      this.options.data = null;
    }
  }, {
    key: "setData",
    value: function setData(geojson) {
      //兼容不同命名
      this.clearData();
      return this.queryData(geojson);
    }
    //是否贴地

  }, {
    key: "hasClampToGround",
    value: function hasClampToGround() {
      if (this.options.clampToGround) return true;
      if (this.options.symbol && this.options.symbol.styleOptions && this.options.symbol.styleOptions.clampToGround) return true;
      return false;
    }
  }, {
    key: "getLoadConfig",
    value: function getLoadConfig() {
      var config = (0, _util.getProxyUrl)(this.options);
      if (config.symbol && config.symbol.styleOptions) {
        var style = config.symbol.styleOptions;
        if (Cesium.defined(style.clampToGround)) {
          config.clampToGround = style.clampToGround;
        }
        if (Cesium.defined(style.color)) {
          var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
          config.fill = color;
        }
        if (Cesium.defined(style.outlineColor)) {
          var outlineColor = Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
          config.stroke = outlineColor;
        }
        if (Cesium.defined(style.outlineWidth)) {
          config.strokeWidth = style.outlineWidth;
        }
      }
      return config;
    }
  }, {
    key: "queryData",
    value: function queryData(geojson) {
      var that = this;

      var config = this.getLoadConfig();
      geojson = geojson || config.url || config.data;
      if (!geojson) return; //没有需要加载的对象

      if (config.url) {
        _zepto.zepto.ajax({
          type: "get",
          dataType: "json",
          url: config.url,
          timeout: Cesium.defaultValue(config.timeout, 0), //永不超时
          success: function success(geojson) {
            var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
            dataSource.then(function (dataSource) {
              that.showResult(dataSource);
            }).otherwise(function (error) {
              that.showError("服务出错", error);
            });
          },
          error: function error(XMLHttpRequest, textStatus, errorThrown) {
            daslog.warn("json文件加载失败！", config);
          }
        });
      } else {
        this.options.data = geojson;
        var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
        dataSource.then(function (dataSource) {
          that.showResult(dataSource);
        }).otherwise(function (error) {
          that.showError("服务出错", error);
        });
      }
    }
  }, {
    key: "showResult",
    value: function showResult(dataSource) {
      var _this3 = this;

      if (this.dataSource) {
        this.viewer.dataSources.remove(this.dataSource);
        delete this.dataSource;
      }
      if (this.labelCollection) {
        this.labelCollection.removeAll();
      }

      if (!this._visible) return;

      this.dataSource = dataSource;
      this.dataSource.order = this.options.order;
      this.viewer.dataSources.add(dataSource);

      if (this.hasZIndex) this.setZIndex(this.options.order);

      if (this.options.flyTo) this.centerAtByFlyEnd();

      //根据config配置，更新entitys
      this.options.getAttrVal = function (entity) {
        return _this3.getEntityAttr(entity);
      };
      this.options.eventTarget = this;

      var entities = dataSource.entities.values;
      (0, _config2Entity.config2Entity)(entities, this.options, function (position, labelattr, attr) {
        return _this3.lblAddFun(position, labelattr, attr);
      });

      if (this._opacity != 1) this.setOpacity(this._opacity);

      this.fireMap(_DasClass.eventType.load, {
        dataSource: dataSource,
        entities: entities
      });
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(symbol) {
      var _this4 = this;

      if (!this.dataSource) return;

      if (symbol) {
        this.options.symbol = _extends({}, this.options.symbol, symbol);
      }

      var entities = this.dataSource.entities.values;
      (0, _config2Entity.config2Entity)(entities, this.options, function (position, labelattr, attr) {
        return _this4.lblAddFun(position, labelattr, attr);
      });
    }
  }, {
    key: "lblAddFun",
    value: function lblAddFun(position, labelattr, attr) {
      if (labelattr.text == "") return null;

      if (Cesium.defined(labelattr.height)) {
        position = (0, _point.setPositionsHeight)(position, labelattr.height);
      }

      //entity方式
      var lblEx = this.dataSource.entities.add({
        position: position,
        label: labelattr,
        properties: attr
      });

      //LabelCollection方式
      // if (!this.labelCollection) {
      //     this.labelCollection = new Cesium.LabelCollection({ scene: this.viewer.scene });
      //     this.viewer.scene.primitives.add(this.labelCollection);
      // }
      // labelattr.position = position;
      // var lblEx = this.labelCollection.add(labelattr);
      // lblEx.properties = attr;

      return lblEx;
    }
    //刷新事件

  }, {
    key: "refreshEvent",
    value: function refreshEvent() {
      if (this.dataSource == null) return false;

      var entities = this.dataSource.entities.values;
      for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];

        entity.eventTarget = this;
        entity.contextmenuItems = this.options.contextmenuItems;
      }
      return true;
    }
    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;
      if (this.dataSource == null) return;

      var entities = this.dataSource.entities.values;

      for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];

        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
          this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
          if (entity.polygon.outlineColor) {
            this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
          }
        }

        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
          this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
        }

        if (entity.billboard) {
          entity.billboard.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.model) {
          entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.label) {
          var _opacity = this._opacity;
          if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

          if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
          if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
          if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
        }
      }
    }
  }, {
    key: "_updatEntityAlpha",
    value: function _updatEntityAlpha(color, opacity) {
      if (!color) return;
      var newclr = color.getValue(this.viewer.clock.currentTime);
      if (!newclr || !newclr.withAlpha) return color;

      newclr = newclr.withAlpha(opacity);
      color.setValue(newclr);
    }

    //设置叠加顺序

  }, {
    key: "setZIndex",
    value: function setZIndex(order) {
      if (this.dataSource == null || order == null) return;
      if (!this.viewer.dataSources.contains(this.dataSource)) return;

      //先移动到最顶层
      this.viewer.dataSources.raiseToTop(this.dataSource);

      var layers = this.viewer.dataSources;
      for (var i = layers.length - 1; i >= 0; i--) {
        var layer = layers.get(i);
        if (layer == this.dataSource) continue;
        if (Cesium.defined(layer.order) && order < layer.order) {
          this.viewer.dataSources.lower(this.dataSource); //下移一个位置
        }
      }
    }

    //获取属性

  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      return (0, _util.getAttrVal)(entity.properties);
    }

    //外部自定义添加entity

  }, {
    key: "addEntity",
    value: function addEntity(entitys) {
      var _this5 = this;

      if (!this.dataSource) {
        this.dataSource = new Cesium.CustomDataSource();
        this.viewer.dataSources.add(this.dataSource);
      }

      if (!(0, _util.isArray)(entitys)) entitys = [entitys];

      for (var i = 0, len = entitys.length; i < len; i++) {
        var entity = entitys[i];

        if (entity.entityCollection) entity.entityCollection.remove(entity); //从原有的集合中删除
        this.dataSource.entities.add(entity); //加入到当前图层集合图层中
      }

      (0, _config2Entity.config2Entity)(entitys, this.options, function (position, labelattr, attr) {
        return _this5.lblAddFun(position, labelattr, attr);
      });
    }
  }, {
    key: "removeEntity",
    value: function removeEntity(entity) {
      this.dataSource.entities.remove(entity); //加入到当前图层集合图层中
    }
  }, {
    key: "getEntitys",
    value: function getEntitys() {
      if (this.dataSource) return this.dataSource.entities.values;else return null;
    }
  }, {
    key: "layer",
    get: function get() {
      return this.dataSource;
    }
  }]);

  return GeoJsonLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBase = exports.DrawBase = function (_DasClass) {
  _inherits(DrawBase, _DasClass);

  //========== 构造方法 ==========
  function DrawBase(opts) {
    _classCallCheck(this, DrawBase);

    var _this = _possibleConstructorReturn(this, (DrawBase.__proto__ || Object.getPrototypeOf(DrawBase)).call(this, opts));

    _this.viewer = opts.viewer;
    _this.dataSource = opts.dataSource;
    _this.tooltip = opts.tooltip;

    _this._positions_draw = null; //坐标位置相关
    _this.editClass = null; //编辑对象
    _this.attrClass = null; //对应的属性控制静态类
    return _this;
  }

  _createClass(DrawBase, [{
    key: "fire",
    value: function fire(type, data, propagate) {
      if (this._fire) this._fire(type, data, propagate);
    }
  }, {
    key: "formatNum",
    value: function formatNum(num, digits) {
      return (0, _point.formatNum)(num, digits);
    }
  }, {
    key: "enableControl",
    value: function enableControl(value) {
      if (this.viewer.das.popup) this.viewer.das.popup.enable = value;
      if (this.viewer.das.tooltip) this.viewer.das.tooltip.enable = value;
      if (this.viewer.das.contextmenu) this.viewer.das.contextmenu.enable = value;
    }
    //激活绘制

  }, {
    key: "activate",
    value: function activate(attribute, drawOkCallback, dataSource) {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;
      this.drawOkCallback = drawOkCallback;

      if (attribute instanceof Cesium.Entity) {
        this.reCreateFeature(attribute);
      } else {
        this.createFeature(attribute, dataSource);
      }

      if (this.entity) this.entity.inProgress = true;

      this.setCursor(true);
      this.enableControl(false);
      this.bindEvent();

      this.fire(_DasClass2.eventType.drawStart, { drawtype: this.type, entity: this.entity });

      return this.entity;
    }
    //释放绘制

  }, {
    key: "disable",
    value: function disable(hasWB) {
      if (!this._enabled) {
        return this;
      }
      this._enabled = false;

      this.setCursor(false);
      this.enableControl(true);

      if (hasWB && this.entity.inProgress) {
        //外部释放时，尚未结束的标绘移除。
        if (this.entity.entityCollection.contains(this.entity)) this.entity.entityCollection.remove(this.entity);

        this.destroyHandler();
        this.tooltip.setVisible(false);
      } else {
        var entity = this.entity;
        this.entity.inProgress = false;
        this.finish();

        this.destroyHandler();
        this.tooltip.setVisible(false);
        this._positions_draw = null;
        this.entity = null;

        if (this.drawOkCallback) {
          this.drawOkCallback(entity);
          delete this.drawOkCallback;
        }
        this.fire(_DasClass2.eventType.drawCreated, { drawtype: this.type, entity: entity });
      }

      return this;
    }
  }, {
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {}
  }, {
    key: "reCreateFeature",
    value: function reCreateFeature(entity) {}
    //============= 事件相关 =============

  }, {
    key: "getHandler",
    value: function getHandler() {
      if (!this.handler || this.handler.isDestroyed()) {
        this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      }
      return this.handler;
    }
  }, {
    key: "destroyHandler",
    value: function destroyHandler() {
      this.handler && this.handler.destroy();
      this.handler = undefined;
    }
  }, {
    key: "setCursor",
    value: function setCursor(val) {
      this.viewer._container.style.cursor = val ? "crosshair" : "";
    }
    //绑定鼠标事件

  }, {
    key: "bindEvent",
    value: function bindEvent() {}
    //=============  =============
    //坐标位置相关

  }, {
    key: "getDrawPosition",
    value: function getDrawPosition() {
      return this._positions_draw;
    }
    //获取编辑对象

  }, {
    key: "getEditClass",
    value: function getEditClass(entity) {
      if (this.editClass == null) return null;

      var _edit = new this.editClass(entity, this.viewer);
      if (this._minPointNum != null) _edit._minPointNum = this._minPointNum;
      if (this._maxPointNum != null) _edit._maxPointNum = this._maxPointNum;

      _edit._fire = this._fire;
      _edit.tooltip = this.tooltip;

      return _edit;
    }
    //更新坐标后调用下，更新相关属性，子类使用

  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isLoad) {}
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {}
    //通用方法

  }, {
    key: "getCoordinates",
    value: function getCoordinates(entity) {
      return this.attrClass.getCoordinates(entity);
    }
  }, {
    key: "getPositions",
    value: function getPositions(entity) {
      return this.attrClass.getPositions(entity);
    }
  }, {
    key: "toGeoJSON",
    value: function toGeoJSON(entity) {
      return this.attrClass.toGeoJSON(entity);
    }
    //属性转entity

  }, {
    key: "attributeToEntity",
    value: function attributeToEntity(attribute, positions, dataSource) {
      var entity = this.createFeature(attribute, dataSource);
      this._positions_draw = positions;
      this.updateAttrForDrawing(true);
      this.finish();
      return entity;
    }
    //geojson转entity

  }, {
    key: "jsonToEntity",
    value: function jsonToEntity(geojson, dataSource) {
      var attribute = geojson.properties;
      var positions = (0, _point.getPositionByGeoJSON)(geojson);
      return this.attributeToEntity(attribute, positions, dataSource);
    }
  }, {
    key: "setDrawPositionByEntity",
    value: function setDrawPositionByEntity(entity) {
      var positions = this.getPositions(entity);
      this._positions_draw = positions;
    }
    //绑定外部entity到标绘

  }, {
    key: "bindExtraEntity",
    value: function bindExtraEntity(entity, attribute) {
      this.entity = entity;
      entity.attribute = attribute;

      if (attribute.style) this.style2Entity(attribute.style, entity);

      this.setDrawPositionByEntity(entity);

      this.updateAttrForDrawing(true);
      this.finish();
      return entity;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      _get(DrawBase.prototype.__proto__ || Object.getPrototypeOf(DrawBase.prototype), "destroy", this).call(this);
    }
  }, {
    key: "enabled",
    get: function get() {
      return this._enabled;
    }
  }]);

  return DrawBase;
}(_DasClass2.DasClass);

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(25);

var _Attr = __webpack_require__(34);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBillboard = exports.DrawBillboard = function (_DrawPoint) {
  _inherits(DrawBillboard, _DrawPoint);

  //========== 构造方法 ==========
  function DrawBillboard(opts) {
    _classCallCheck(this, DrawBillboard);

    var _this = _possibleConstructorReturn(this, (DrawBillboard.__proto__ || Object.getPrototypeOf(DrawBillboard)).call(this, opts));

    _this.type = "billboard";
    //对应的属性控制静态类
    _this.attrClass = attr;
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawBillboard, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;

      this._positions_draw = null;

      //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

      var that = this;
      var addattr = {
        show: _drawShow,
        _drawShow: _drawShow, //edit编辑时使用
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        billboard: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      if (attribute.style && attribute.style.label) {
        //同时加文字
        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
      }

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.updateAttrForDrawing();
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      var _this2 = this;

      if (this.updateFeatureEx) {
        //setTimeout是为了优化效率
        if (this.updateTimer) {
          clearTimeout(this.updateTimer);
        }
        this.updateTimer = setTimeout(function () {
          delete _this2.updateTimer;
          _this2.updateFeatureEx(style, entity);
        }, 300);
      }

      if (style && style.label) {
        //同时加文字
        (0, _Attr2.style2Entity)(style.label, entity.label);
      }
      return attr.style2Entity(style, entity.billboard);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      var _this3 = this;

      var entity = this.entity;

      if (this.updateFeatureEx) {
        //setTimeout是为了优化效率
        if (this.updateTimer) {
          clearTimeout(this.updateTimer);
        }
        this.updateTimer = setTimeout(function () {
          delete _this3.updateTimer;
          if (!entity) return;
          _this3.updateFeatureEx(entity.attribute.style, entity);
        }, 300);
      }
    }
    //图形绘制结束,更新属性

  }, {
    key: "finish",
    value: function finish() {
      if (this.updateFeatureEx && this.updateTimer) {
        clearTimeout(this.updateTimer);
        delete this.updateTimer;
        this.updateFeatureEx(this.entity.attribute.style, this.entity);
      }
      this.entity.show = true;

      this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象
      this.entity.position = this.getDrawPosition();
    }
  }]);

  return DrawBillboard;
}(_Draw.DrawPoint);

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventTarget = exports.event = undefined;
exports.init = init;
exports.getDefWindowOptions = getDefWindowOptions;
exports.activate = activate;
exports.getWidget = getWidget;
exports.getClass = getClass;
exports.isActivate = isActivate;
exports.disable = disable;
exports.disableAll = disableAll;
exports.disableGroup = disableGroup;
exports.eachWidget = eachWidget;
exports.bindClass = bindClass;
exports.removeDebugeBar = removeDebugeBar;
exports.getCacheVersion = getCacheVersion;
exports.getBasePath = getBasePath;
exports.on = on;
exports.off = off;
exports.fire = fire;
exports.once = once;
exports.listens = listens;

var _DasClass = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _loader = __webpack_require__(49);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//widget模块公共处理类，勿轻易修改

var basePath = ""; //widgets目录统一前缀，如果widgets目录不在当前页面的同级目录，在其他处时可以传入basePath参数，参数值为：widgets目录相对于当前页面的路径
var defoptions;
var cacheVersion;
var isdebuger;

var thismap;
var widgetsdata = [];

var removeKeys = ["_class"];

//初始化插件
function init(map, widgetcfg, _basePath) {
  thismap = map;
  widgetcfg = widgetcfg || {};
  basePath = _basePath || "";

  widgetsdata = [];
  defoptions = widgetcfg.defaultOptions || {
    windowOptions: { position: "rt", maxmin: false, resize: true },
    autoDisable: true,
    disableOther: true
  };

  cacheVersion = widgetcfg.version;
  if (cacheVersion == "time") cacheVersion = new Date().getTime();

  //将自启动的加入
  var arrtemp = widgetcfg.widgetsAtStart;
  if (arrtemp && arrtemp.length > 0) {
    for (var _i = 0; _i < arrtemp.length; _i++) {
      var _item = arrtemp[_i];
      if (!_item.hasOwnProperty("uri") || _item.uri == "") {
        daslog.log("widget未配置uri", _item);
        continue;
      }
      if (_item.hasOwnProperty("visible") && !_item.visible) continue;

      _item.autoDisable = false;
      _item.openAtStart = true;
      _item._nodebug = true;

      bindDefOptions(_item);

      _item._firstConfigBak = (0, _util.clone)(_item, removeKeys);
      widgetsdata.push(_item);
    }
  }

  //显示测试栏
  //为了方便测试，所有widget会在页面下侧生成一排按钮，每个按钮对应一个widget，单击后激活对应widget
  isdebuger = widgetcfg["debugger"];
  if (isdebuger) {
    var _inhtml = '<div id="widget-testbar" class="das3d-widgetbar animation-slide-bottom no-print-view" > ' + '     <div style="height: 30px; line-height:30px;"><b style="color: #4db3ff;">widget测试栏</b>&nbsp;&nbsp;<button  id="widget-testbar-remove"  type="button" class="btn btn-link btn-xs">关闭</button> </div>' + '     <button id="widget-testbar-disableAll" type="button" class="btn btn-info" ><i class="fa fa-globe"></i>漫游</button>' + "</div>";
    (0, _zepto.zepto)("body").append(_inhtml);

    (0, _zepto.zepto)("#widget-testbar-remove").click(function (e) {
      removeDebugeBar();
    });
    (0, _zepto.zepto)("#widget-testbar-disableAll").click(function (e) {
      disableAll();
    });
  }

  //将配置的加入
  arrtemp = widgetcfg.widgets;
  if (arrtemp && arrtemp.length > 0) {
    for (var _i2 = 0; _i2 < arrtemp.length; _i2++) {
      var _item2 = arrtemp[_i2];
      if (_item2.type == "group") {
        var _inhtml2 = ' <div class="btn-group dropup">  <button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false"><i class="fa fa-align-justify"></i>' + _item2.name + ' <span class="caret"></span></button> <ul class="dropdown-menu">';
        for (var j = 0; j < _item2.children.length; j++) {
          var childItem = _item2.children[j];
          if (!childItem.hasOwnProperty("uri") || childItem.uri == "") {
            daslog.log("widget未配置uri", childItem);
            continue;
          }

          _inhtml2 += ' <li data-widget="' + childItem.uri + '" class="widget-btn" ><a href="#"><i class="fa fa-star"></i>' + childItem.name + "</a></li>";

          bindDefOptions(childItem);
          childItem._firstConfigBak = (0, _util.clone)(childItem, removeKeys);
          widgetsdata.push(childItem); //将配置的加入
        }
        _inhtml2 += "</ul></div>";

        if (isdebuger && !_item2._nodebug) {
          (0, _zepto.zepto)("#widget-testbar").append(_inhtml2);
        }
      } else {
        if (!_item2.hasOwnProperty("uri") || _item2.uri == "") {
          daslog.log("widget未配置uri", _item2);
          continue;
        }

        //显示测试栏
        if (isdebuger && !_item2._nodebug) {
          var inhtml = '<button type="button" class="btn btn-primary widget-btn" data-widget="' + _item2.uri + '"  > <i class="fa fa-globe"></i>' + _item2.name + " </button>";
          (0, _zepto.zepto)("#widget-testbar").append(inhtml);
        }

        bindDefOptions(_item2);
        _item2._firstConfigBak = (0, _util.clone)(_item2, removeKeys);
        widgetsdata.push(_item2); //将配置的加入
      }
    }

    if (isdebuger) {
      (0, _zepto.zepto)("#widget-testbar .widget-btn").each(function () {
        (0, _zepto.zepto)(this).click(function (e) {
          var uri = (0, _zepto.zepto)(this).attr("data-widget");
          if (uri == null || uri == "") return;

          if (isActivate(uri)) {
            disable(uri);
          } else {
            activate(uri);
          }
        });
      });
    }
  }

  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];

    if (item.openAtStart || item.createAtStart) {
      _arrLoadWidget.push(item);
    }
  }

  (0, _zepto.zepto)(window).resize(function () {
    for (var i = 0; i < widgetsdata.length; i++) {
      var item = widgetsdata[i];
      if (item._class) {
        item._class.indexResize(); //BaseWidget: indexResize
      }
    }
  });

  if (isdebuger) {
    var hash = getLocationParam();
    if (hash) {
      activate(hash);
    }
  }

  loadWidgetJs();
}

function getDefWindowOptions() {
  return (0, _util.clone)(defoptions.windowOptions, removeKeys);
}

function getLocationParam() {
  var param = window.location.toString();
  if (param.indexOf("#") === -1) {
    return "";
  }
  param = param.split("#");
  if (param && param.length > 0) {
    return param[1];
  }
}

function bindDefOptions(item) {
  //赋默认值至options（跳过已存在设置值）
  if (defoptions) {
    for (var aa in defoptions) {
      if (aa == "windowOptions") {
        //for (var jj in defoptions['windowOptions']) {
        //    if (!item['windowOptions'].hasOwnProperty(jj)) {
        //        item['windowOptions'][jj] = defoptions['windowOptions'][jj];
        //    }
        //}
      } else if (!item.hasOwnProperty(aa)) {
        item[aa] = defoptions[aa];
      }
    }
  }

  //赋值内部使用属性
  item.path = getFilePath(basePath + item.uri);
  item.name = item.name || item.label; //兼容name和label命名
}

//激活指定模块
function activate(item, noDisableOther) {
  if (thismap == null && item.viewer) {
    init(item.viewer);
  }

  //参数是字符串id或uri时
  if (typeof item === "string") {
    item = { uri: item };

    if (noDisableOther != null) item.disableOther = !noDisableOther; //是否释放其他已激活的插件
  } else {
    if (item.uri == null) {
      daslog.warn("activate激活widget时需要uri参数！", item);
    }
  }

  var thisItem;
  for (var i = 0; i < widgetsdata.length; i++) {
    var othitem = widgetsdata[i];
    if (item.uri == othitem.uri || othitem.id && item.uri == othitem.id) {
      thisItem = othitem;
      if (thisItem.isloading) return thisItem; //激活了正在loading的widget 防止快速双击了菜单

      //赋值
      for (var aa in item) {
        if (aa == "uri") continue;
        thisItem[aa] = item[aa];
      }
      break;
    }
  }

  if (thisItem == null) {
    bindDefOptions(item);
    thisItem = item;
    //非config中配置的，外部传入，首次激活
    if (!item._firstConfigBak) item._firstConfigBak = (0, _util.clone)(item, removeKeys);
    widgetsdata.push(item);
  }

  if (isdebuger) {
    daslog.log("开始激活widget：" + thisItem.uri);
    window.location.hash = "#" + thisItem.uri;
  }

  //兼容之前历史版本的错误命名时的属性名称
  if (thisItem.hasOwnProperty("disableOhter") && !thisItem.hasOwnProperty("disableOther")) thisItem.disableOther = thisItem.disableOhter;

  //释放其他已激活的插件
  if (thisItem.disableOther) {
    disableAll(thisItem.uri, thisItem.group);
  } else {
    disableGroup(thisItem.group, thisItem.uri);
  }

  //激活本插件
  if (thisItem._class) {
    if (thisItem._class.isActivate) {
      //已激活时
      if (thisItem._class.update) {
        //刷新
        thisItem._class.update();
      } else {
        //重启
        thisItem._class.disableBase();
        var timetemp = setInterval(function () {
          if (thisItem._class.isActivate) return;
          thisItem._class.activateBase();
          clearInterval(timetemp);
        }, 200);
      }
    } else {
      thisItem._class.activateBase(); // BaseWidget: activateBase
    }
  } else {
    for (var _i3 = 0; _i3 < _arrLoadWidget.length; _i3++) {
      if (_arrLoadWidget[_i3].uri == thisItem.uri)
        //如果已在加载列表中的直接跳出
        return _arrLoadWidget[_i3];
    }
    _arrLoadWidget.push(thisItem);

    if (_arrLoadWidget.length == 1) {
      loadWidgetJs();
    }
  }
  return thisItem;
}

function getWidget(id) {
  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];

    if (id == item.uri || id == item.id) {
      return item;
    }
  }
}

function getClass(id) {
  var item = getWidget(id);
  if (item) return item._class;else return null;
}

function isActivate(id) {
  var _class = getClass(id);
  if (_class == null) return false;
  return _class.isActivate;
}

function disable(id) {
  if (id == null) return;
  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];

    if (item._class && (id == item.uri || id == item.id)) {
      item._class.disableBase();
      break;
    }
  }
}

//释放所有widget
function disableAll(nodisable, group) {
  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];

    if (group && item.group == group) {
      //同组别的全部释放
    } else {
      if (nodisable !== true && !item.autoDisable) continue;
    }

    //指定不释放的跳过
    if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;

    if (item._class) {
      item._class.disableBase(); ////BaseWidget: disableBase
    }
  }
}

//释放同组widget
function disableGroup(group, nodisable) {
  if (group == null) return;

  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];
    if (item.group == group) {
      //指定不释放的跳过
      if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;
      if (item._class) {
        item._class.disableBase(); ////BaseWidget: disableBase
      }
    }
  }
}

function eachWidget(callback) {
  for (var i = 0; i < widgetsdata.length; i++) {
    var item = widgetsdata[i];
    callback(item);
  }
}

var _arrLoadWidget = [];
var loadItem;
var isloading;
function loadWidgetJs() {
  if (_arrLoadWidget.length == 0) return;

  if (isloading) {
    setTimeout(loadWidgetJs, 500);
    return;
  }
  isloading = true;

  loadItem = _arrLoadWidget[0];
  loadItem.isloading = true;
  var _uri = loadItem.uri;
  if (cacheVersion) {
    if (_uri.indexOf("?") == -1) _uri += "?time=" + cacheVersion;else _uri += "&time=" + cacheVersion;
  }

  if (window.NProgress) {
    window.NProgress.start();
  }

  fire(_DasClass.eventType.loadBefore, {
    sourceTarget: loadItem
  });

  _loader.Loader.async([basePath + _uri], function () {
    isloading = false;
    loadItem.isloading = false;

    if (window.NProgress) {
      window.NProgress.done(true);
    }

    _arrLoadWidget.shift();
    loadWidgetJs();
  });
}

function bindClass(_class) {
  fire(_DasClass.eventType.load, {
    sourceTarget: _class
  });

  if (loadItem == null) {
    var _jspath = getThisJSPath();
    for (var i = 0; i < widgetsdata.length; i++) {
      var item = widgetsdata[i];
      if (_jspath.endsWith(item.uri)) {
        item.isloading = false;
        item._class = new _class(thismap, item);
        item._class.activateBase(); // BaseWidget: activateBase
        return item._class;
      }
    }
  } else {
    loadItem.isloading = false;
    loadItem._class = new _class(thismap, loadItem);
    loadItem._class.activateBase(); // BaseWidget: activateBase
    return loadItem._class;
  }
}

function getThisJSPath() {
  var jsPath;
  var js = document.scripts;
  for (var i = js.length - 1; i >= 0; i--) {
    jsPath = js[i].src;
    if (jsPath == null || jsPath == "") continue;
    if (jsPath.indexOf("widgets") == -1) continue;
    //jsPath = jsPath.substring(0, jsPath.lastIndexOf("/") + 1);
    return jsPath;
  }
  return "";
}

//获取路径
function getFilePath(file) {
  var pos = file.lastIndexOf("/");
  return file.substring(0, pos + 1);
}

function removeDebugeBar() {
  (0, _zepto.zepto)("#widget-testbar").remove();
}

function getCacheVersion() {
  return cacheVersion;
}

function getBasePath() {
  return basePath;
}

//事件相关方法（事件监听在viewer.das）
var event = exports.event = {
  loadBefore: _DasClass.eventType.loadBefore, //开始加载widget.js
  load: _DasClass.eventType.load, //widget.js加载完成

  beforeActivate: _DasClass.eventType.beforeActivate, //在activat挂载开始之前调用
  activated: _DasClass.eventType.activated, //activate方法调用后

  beforeCreate: _DasClass.eventType.beforeCreate, //在实例初始化之后、创建之前执行
  created: _DasClass.eventType.created, //实例创建后执行

  openView: _DasClass.eventType.openView, //view弹窗构造完成后后调用
  beforeDisable: _DasClass.eventType.beforeDisable, //实例销毁之前调用
  disabled: _DasClass.eventType.disabled //实例销毁完成调用
};

var eventTarget = exports.eventTarget = new _DasClass.DasClass();

function on(types, fn, context) {
  return eventTarget.on(types, fn, context);
}
function off(types, fn, context) {
  return eventTarget.off(types, fn, context);
}
function fire(type, data, propagate) {
  return eventTarget.fire(type, data, propagate);
}
function once(types, fn, context) {
  return eventTarget.once(types, fn, context);
}
function listens(type, propagate) {
  return eventTarget.listens(type, propagate);
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loader = undefined;

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// cssExpr 用于判断资源是否是css
var cssExpr = new RegExp("\\.css");
var nHead = document.head || document.getElementsByTagName("head")[0];
// `onload` 在WebKit < 535.23， Firefox < 9.0 不被支持
var isOldWebKit = +navigator.userAgent.replace(/.*(?:AppleWebKit|AndroidWebKit)\/?(\d+).*/i, "$1") < 536;

// 判断对应的node节点是否已经载入完成
function isReady(node) {
  return node.readyState === "complete" || node.readyState === "loaded";
}

// loadCss 用于载入css资源
function loadCss(url, setting, callback) {
  var node = document.createElement("link");

  node.rel = "stylesheet";
  addOnload(node, callback, "css");
  node.async = true;
  node.href = url;

  nHead.appendChild(node);
}

// loadJs 用于载入js资源
function loadJs(url, setting, callback) {
  var node = document.createElement("script");

  node.charset = "utf-8";
  addOnload(node, callback, "js");
  node.async = !setting.sync;
  node.src = url;

  nHead.appendChild(node);
}

// 在老的webkit中，因不支持load事件，这里用轮询sheet来保证
function pollCss(node, callback) {
  var isLoaded;

  if (node.sheet) {
    isLoaded = true;
  }

  setTimeout(function () {
    if (isLoaded) {
      // 在这里callback 是为了让样式有足够的时间渲染
      callback();
    } else {
      pollCss(node, callback);
    }
  }, 20);
}

// 用于给指定的节点绑定onload回调
// 监听元素载入完成事件
function addOnload(node, callback, type) {
  var supportOnload = "onload" in node;
  var isCSS = type === "css";

  // 对老的webkit和老的firefox的兼容
  if (isCSS && (isOldWebKit || !supportOnload)) {
    setTimeout(function () {
      pollCss(node, callback);
    }, 1);
    return;
  }

  if (supportOnload) {
    node.onload = onload;
    node.onerror = function (e) {
      node.onerror = null;
      //window._cdnFallback(node);
      if (type == "css") daslog.warn("该css文件不存在：" + node.href, e);else daslog.warn("该js文件不存在：" + node.src, e);
      onload();
    };
  } else {
    node.onreadystatechange = function () {
      if (isReady(node)) {
        onload();
      }
    };
  }

  function onload() {
    // 执行一次后清除，防止重复执行
    node.onload = node.onreadystatechange = null;

    node = null;

    callback();
  }
}

// 资源下载入口，根绝文件类型的不同，调用loadCss或者loadJs
function loadItem(url, list, setting, callback) {
  // 如果加载的url为空，就直接成功返回
  if (!url) {
    setTimeout(function () {
      onFinishLoading();
    });
    return;
  }

  if (cssExpr.test(url)) {
    loadCss(url, setting, onFinishLoading);
  } else {
    loadJs(url, setting, onFinishLoading);
  }

  // 每次资源下载完成后，检验是否结束整个list下载过程
  // 若已经完成所有下载，执行回调函数
  function onFinishLoading() {
    var urlIndex = list.indexOf(url);
    if (urlIndex > -1) {
      list.splice(urlIndex, 1);
    }

    if (list.length === 0) {
      callback();
    }
  }
}

function doInit(list, setting, callback) {
  var cb = function cb() {
    callback && callback();
  };

  list = Array.prototype.slice.call(list || []);

  if (list.length === 0) {
    cb();
    return;
  }

  for (var i = 0, len = list.length; i < len; i++) {
    loadItem(list[i], list, setting, cb);
  }
}

// 判断当前页面是否加载完
// 加载完，立刻执行下载
// 未加载完，等待页面load事件以后再进行下载
function ready(node, callback) {
  if (isReady(node)) {
    callback();
  } else {
    // 1500ms 以后，直接开始下载资源文件，不再等待load事件
    var timeLeft = 1500;
    var isExecute = false;
    window.addEventListener("load", function () {
      if (!isExecute) {
        callback();
        isExecute = true;
      }
    });

    setTimeout(function () {
      if (!isExecute) {
        callback();
        isExecute = true;
      }
    }, timeLeft);
  }
}

// 暴露出去的Loader
// 提供async, sync两个函数
// async 用作异步下载执行用，不阻塞页面渲染
// sync  用作异步下载，顺序执行，保证下载的js按照数组顺序执行
var Loader = {
  async: function async(list, callback) {
    ready(document, function () {
      doInit(list, {}, callback);
    });
  },

  sync: function sync(list, callback) {
    ready(document, function () {
      doInit(list, {
        sync: true
      }, callback);
    });
  }
};

//window.Loader = Loader;

exports.Loader = Loader;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureHeight = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _Attr = __webpack_require__(13);

var _Attr2 = __webpack_require__(17);

var _MeasureBase2 = __webpack_require__(29);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _point = __webpack_require__(2);

var _Tooltip = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureHeight = exports.MeasureHeight = function (_MeasureBase) {
  _inherits(MeasureHeight, _MeasureBase);

  //========== 构造方法 ==========
  function MeasureHeight(opts, target) {
    _classCallCheck(this, MeasureHeight);

    var _this2 = _possibleConstructorReturn(this, (MeasureHeight.__proto__ || Object.getPrototypeOf(MeasureHeight)).call(this, opts, target));

    _this2.totalLable = null; // 高度label
    _this2.exLine = null; // 辅助线

    _this2.drawDragger = null; // 绘制线的拖拽点
    _this2.exDragger = null; // 辅助线的拖拽点

    _this2.tooltipShow = true; // 是否显示提示菜单
    _this2.tooltip = new _Tooltip.Tooltip(_this2.viewer.container); //鼠标提示信息
    return _this2;
  }

  _createClass(MeasureHeight, [{
    key: "clearLastNoEnd",

    //清除未完成的数据
    value: function clearLastNoEnd() {
      if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
      this.totalLable = null;
      if (this.exLine != null) this.dataSource.entities.remove(this.exLine);
      this.exLine = null;
    }
    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: false
      });
      this.totalLable = this.dataSource.entities.add({
        label: entityattr,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.totalLable.showText = function (unit) {
        var heightstr = util.formatLength(this.attribute.value, unit);
        this.label.text = "高度差:" + heightstr;
        return heightstr;
      };

      return this.drawControl.startDraw({
        type: "polyline",
        config: { maxPointNum: 2 },
        style: _extends({
          lineType: "glow",
          color: "#ebe12c",
          width: 8,
          glowPower: 0.1,
          depthFail: true,
          depthFailType: "dash",
          depthFailOpacity: 0.5,
          depthFailColor: "#ebe12c"
        }, options.style)
      });
    }
    //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(entity) {
      this.showMoveDrawing(entity); //兼容手机端
    }
    //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      if (this.exLine) {
        this.dataSource.entities.remove(this.exLine);
        this.exLine = null;
      }
      if (this.totalLable) this.totalLable.label.show = false;
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 2) {
        this.totalLable.label.show = false;
        return;
      }

      var cartographic = Cesium.Cartographic.fromCartesian(positions[0]);
      var cartographic1 = Cesium.Cartographic.fromCartesian(positions[1]);

      var temPoint = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic1.height, this.viewer.scene.globe.ellipsoid);
      var exLine_positions = [temPoint, positions[1]];
      entity._positions_draw[1] = temPoint;
      if (this.exLine) {
        this.exLine._positions = exLine_positions;
      } else {
        var entityattr = (0, _Attr2.style2Entity)(this.options.styleEx, {
          positions: new Cesium.CallbackProperty(function (time) {
            return exLine._positions;
          }, false),
          width: 2,
          clampToGround: false,
          material: new Cesium.PolylineDashMaterialProperty({
            color: Cesium.Color.RED
          })
        });
        var exLine = this.dataSource.entities.add({
          polyline: entityattr
        });
        exLine._positions = exLine_positions;
        this.exLine = exLine;
      }
      //位置
      this.totalLable.position = Cesium.Cartesian3.midpoint(positions[0], temPoint, new Cesium.Cartesian3());

      var height = Math.abs(cartographic1.height - cartographic.height);

      //绑定值及text显示
      this.totalLable.attribute.value = height;
      var heightstr = this.totalLable.showText(this.options.unit);
      this.totalLable.label.show = true;

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: height,
        label: heightstr
      });
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      var _this3 = this;

      entity.hasEdit = false;
      entity._totalLable = this.totalLable;
      this.totalLable = null;

      entity.arrEntityEx = [this.exLine];
      this.exLine = null;

      var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);

      //编辑提示事件
      handler.setInputAction(function (event) {
        if (_this3.drawing) return; //无法编辑或还在绘制中时，跳出

        //正在拖拽其他的entity时，跳出
        if (!_this3.viewer.scene.screenSpaceCameraController.enableInputs) return;

        _this3.closeTooltip();

        var pickedObject = _this3.viewer.scene.pick(event.endPosition, 5, 5);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id;
          if (entity && entity.type === 'height' && entity instanceof Cesium.Entity && entity.editing && !entity.inProgress && _this3.tooltipShow) {
            var tooltip = _this3.tooltip;

            //删除右键菜单打开了不显示tooltip
            if (_this3.viewer.das.contextmenu && _this3.viewer.das.contextmenu.show && _this3.viewer.das.contextmenu.target == entity) return;

            _this3.tiptimeTik = setTimeout(function () {
              //edit中的MOUSE_MOVE会关闭提示，延迟执行。
              tooltip.showAt(event.endPosition, '单击后 激活编辑<br/>右击 单击菜单删除');
            }, 100);
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      handler.setInputAction(function (event) {
        if (_this3.drawing) return; //无法编辑或还在绘制中时，跳出

        var pickedObject = _this3.viewer.scene.pick(event.position, 5, 5);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id;
          if (_this3.currEditFeature && _this3.currEditFeature === entity) return; //重复单击了跳出

          if (entity && entity instanceof Cesium.Entity && entity.type === 'height' && !entity.inProgress && entity.arrEntityEx) {
            _this3.startEditing(entity);
            _this3.closeTooltip();
            if (entity.draw_tooltip) {
              _this3.tooltip.showAt(event.position, entity.draw_tooltip);
            }
            return;
          }
        }
        _this3.stopEditing();
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      this.target.fire(_DasClass.eventType.end, {
        mtype: this.type,
        entity: entity,
        value: entity._totalLable.attribute.value
      });
    }
  }, {
    key: "startEditing",
    value: function startEditing(entity) {
      this.stopEditing(entity);
      if (entity == null) return;

      this.bindDraggers(entity);
      this.bindEvent();

      this.tooltipShow = false; // 不显示提示
      this.currEditFeature = entity;
    }
  }, {
    key: "stopEditing",
    value: function stopEditing() {
      this.closeTooltip();

      if (this.currEditFeature) {
        this.destroyEvent();
        this.destroyDraggers();
      }

      this.tooltipShow = true; // 显示提示
      this.currEditFeature = null;
    }
  }, {
    key: "closeTooltip",
    value: function closeTooltip() {
      if (!this.tooltip) return;

      this.tooltip.setVisible(false);
      if (this.tiptimeTik) {
        clearTimeout(this.tiptimeTik);
        delete this.tiptimeTik;
        this.tooltipShow = true;
      }
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers(entity) {
      var _this4 = this;

      var _eventType = _DasClass.eventType;
      var _this = this;

      var drawDraggerPostion = entity._positions_draw[0];
      var exDraggerPostion = entity.arrEntityEx[0]._positions[1];

      this.drawDragger = draggerCtl.createDragger(entity.entityCollection, {
        position: drawDraggerPostion,
        onDrag: function onDrag(dragger, position) {
          var cartographic = Cesium.Cartographic.fromCartesian(position);
          var cartographic1 = Cesium.Cartographic.fromCartesian(exDraggerPostion);

          var temPoint = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic1.height, _this4.viewer.scene.globe.ellipsoid);
          var exLine_positions = [temPoint, exDraggerPostion];

          entity.arrEntityEx[0]._positions = exLine_positions;
          entity.polyline.positions = [position, temPoint];
          entity._positions_draw = [position, temPoint];

          var height = Math.abs(cartographic1.height - cartographic.height);

          //绑定值及text显示
          entity._totalLable.attribute.value = height;
          var heightstr = entity._totalLable.showText(_this4.options.unit);
          entity._totalLable.label.show = true;
          entity._totalLable.position = Cesium.Cartesian3.midpoint(drawDraggerPostion, temPoint, new Cesium.Cartesian3());
          _this.target.fire(_eventType.change, {
            mtype: _this.type,
            value: height,
            label: heightstr
          });
        },
        onDragEnd: function onDragEnd(dragger, position) {
          drawDraggerPostion = position;

          _this.target.fire(_eventType.end, {
            mtype: _this.type,
            entity: entity,
            value: entity._totalLable.attribute.value
          });
        }
      });

      this.exDragger = draggerCtl.createDragger(entity.arrEntityEx[0].entityCollection, {
        position: exDraggerPostion,
        onDrag: function onDrag(dragger, position) {
          var cartographic = Cesium.Cartographic.fromCartesian(drawDraggerPostion);
          var cartographic1 = Cesium.Cartographic.fromCartesian(position);

          var temPoint = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, cartographic1.height, _this4.viewer.scene.globe.ellipsoid);
          var exLine_positions = [temPoint, position];

          entity.polyline.positions = [drawDraggerPostion, temPoint];
          entity._positions_draw = [drawDraggerPostion, temPoint];
          entity.arrEntityEx[0]._positions = exLine_positions;

          var height = Math.abs(cartographic1.height - cartographic.height);

          //绑定值及text显示
          entity._totalLable.attribute.value = height;
          var heightstr = entity._totalLable.showText(_this4.options.unit);
          entity._totalLable.label.show = true;
          entity._totalLable.position = Cesium.Cartesian3.midpoint(drawDraggerPostion, temPoint, new Cesium.Cartesian3());
          _this.target.fire(_eventType.change, {
            mtype: _this.type,
            value: height,
            label: heightstr
          });
        },
        onDragEnd: function onDragEnd(dragger, position) {
          exDraggerPostion = position;

          _this.target.fire(_eventType.end, {
            mtype: _this.type,
            entity: entity,
            value: entity._totalLable.attribute.value
          });
        }
      });
    }
  }, {
    key: "bindEvent",
    value: function bindEvent() {
      var _this5 = this;

      var draggerHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
      draggerHandler.dragger = null;
      this.draggerHandler = draggerHandler;

      //选中后拖动
      draggerHandler.setInputAction(function (event) {
        var pickedObject = _this5.viewer.scene.pick(event.position);
        if (Cesium.defined(pickedObject)) {
          var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
          if (entity && Cesium.defaultValue(entity._isDragger, false)) {
            _this5.viewer._hasEdit = true;
            _this5.viewer.scene.screenSpaceCameraController.enableRotate = false;
            _this5.viewer.scene.screenSpaceCameraController.enableTilt = false;
            _this5.viewer.scene.screenSpaceCameraController.enableTranslate = false;
            _this5.viewer.scene.screenSpaceCameraController.enableInputs = false;

            if (_this5.viewer.das && _this5.viewer.das.popup) _this5.viewer.das.popup.close(entity);

            draggerHandler.dragger = entity;
            draggerHandler.dragger.show = false;

            _this5.setCursor(true);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      draggerHandler.setInputAction(function (event) {
        var dragger = draggerHandler.dragger;
        if (dragger) {
          var point = (0, _point.getCurrentMousePosition)(_this5.viewer.scene, event.endPosition, _this5.entity);

          if (point) {
            dragger.position = point;
            if (dragger.onDrag) {
              dragger.onDrag(dragger, point);
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      draggerHandler.setInputAction(function (event) {
        var dragger = draggerHandler.dragger;
        if (dragger) {
          _this5.setCursor(false);
          dragger.show = true;

          var position = (0, _point.getPositionValue)(dragger.position, _this5.viewer.clock.currentTime);
          if (dragger.onDragEnd) {
            dragger.onDragEnd(dragger, position);
          }

          draggerHandler.dragger = null;
          _this5.viewer._hasEdit = false;
          _this5.viewer.scene.screenSpaceCameraController.enableRotate = true;
          _this5.viewer.scene.screenSpaceCameraController.enableTilt = false;
          _this5.viewer.scene.screenSpaceCameraController.enableTranslate = true;
          _this5.viewer.scene.screenSpaceCameraController.enableInputs = true;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
    }
  }, {
    key: "destroyEvent",
    value: function destroyEvent() {
      this.viewer._hasEdit = false;
      this.viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.viewer.scene.screenSpaceCameraController.enableTilt = false;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
      this.viewer.scene.screenSpaceCameraController.enableInputs = true;

      this.setCursor(false);

      if (this.draggerHandler) {
        if (this.draggerHandler.dragger) this.draggerHandler.dragger.show = true;

        this.draggerHandler.destroy();
        this.draggerHandler = null;
      }
    }
  }, {
    key: "destroyDraggers",
    value: function destroyDraggers() {
      if (this.drawDragger) {
        this.currEditFeature.entityCollection.remove(this.drawDragger);
        this.drawDragger = null;
      }

      if (this.exDragger) {
        this.currEditFeature.arrEntityEx[0].entityCollection.remove(this.exDragger);
        this.exDragger = null;
      }
    }
  }, {
    key: "setCursor",
    value: function setCursor(val) {
      this.viewer._container.style.cursor = val ? "crosshair" : "";
    }
  }, {
    key: "type",
    get: function get() {
      return "height";
    }
  }]);

  return MeasureHeight;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PolygonTextureVS = __webpack_require__(174);

var _PolygonTextureVS2 = _interopRequireDefault(_PolygonTextureVS);

var _PolygonTextureFS = __webpack_require__(175);

var _PolygonTextureFS2 = _interopRequireDefault(_PolygonTextureFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 模型分析（裁剪、压平、淹没） 基础类
//原理：利用绘制的点数组，先计算其外包矩形，然后根据点创建一个polygonGeometry，然后利用此geometry创建指令，绘制出polygon纹理，
//源码里会根据此纹理判断模型顶点是否在polygon纹理中，如果在就进行后续操作

//多处压平思考：创建多个polygon纹理有点不大合理，一张FBO里多个polygon纹理，可能会导致压平闪烁（因为到着色器里，增大了顶点和polygon纹理的比对误差）
//多处压平思路之一张FBO里多个polygon纹理：就是想办法在我创建的FBO帧缓存里绘制多少polygon纹理，创建polygon数组，每次绘制都是往这里添加polygon，
//遍历polygon，依次创建指令绘制到fbo里
var TilesBase = exports.TilesBase = function () {
  //========== 构造方法 ==========

  function TilesBase(options) {
    _classCallCheck(this, TilesBase);

    this.viewer = options.viewer;
    this.tileset = options.tileset;

    this.tileset.dasEditor = this.tileset.dasEditor || {};
    this.tileset.dasEditor.enable = true;
    this.positions = options.positions;

    this._b3dmOffset = options.b3dmOffset || new Cesium.Cartesian2();
    if (this.tileset && this.tileset.das.options.editOffset) {
      this.b3dmOffset = new Cesium.Cartesian2(this.tileset.das.options.editOffset.x, this.tileset.das.options.editOffset.y);
    }

    if (this.positions) {
      this._preparePos(this.positions);
    }
    if (this.localPosArr && !(options.floodAll === true)) {
      this._prepareWorks();
    }
  }

  //========== 对外属性 ==========
  //编辑对象


  _createClass(TilesBase, [{
    key: "setPositions",


    //========== 方法 ==========
    value: function setPositions(posArr) {
      if (!posArr || posArr.length == 0) return;

      this.positions = posArr;
      this._preparePos(this.positions);
      if (this.localPosArr) {
        this._prepareWorks();
        this.clear();
        this.activeEdit();
      }
    }

    //输入模型上方向轴向，目前使用实验室的工具，好像会把模型转成Z向上的，所以该功能已遗弃，未被使用

  }, {
    key: "setUpAxis",
    value: function setUpAxis(val) {
      if (val == "X") {
        this.base_height = this.flatRect[0];
        return;
      }
      if (val == "Y") {
        this.base_height = this.flatRect[1];
        return;
      }
      if (val == "Z") {
        this.base_height = this.flatRect[2];
        return;
      }
      this.base_height = this.flatRect[2];
    }
  }, {
    key: "_prepareWorks",
    value: function _prepareWorks() {
      //准备工作
      this._createTexture();
      this._createCommand();
    }
  }, {
    key: "_createTexture",
    value: function _createTexture() {
      //创建FBO以及清除指令
      var context = this.viewer.scene.context;
      var tt = new Cesium.Texture({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.FLOAT,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });

      var depthStencilTexture = new Cesium.Texture({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      });

      this.fbo = new Cesium.Framebuffer({
        context: context,
        colorTextures: [tt],
        depthStencilTexture: depthStencilTexture,
        destroyAttachments: false
      });

      this._fboClearCommand = new Cesium.ClearCommand({
        color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
        framebuffer: this.fbo
      });
    }
  }, {
    key: "_createCamera",
    value: function _createCamera() {
      //创建相机
      return {
        viewMatrix: Cesium.Matrix4.IDENTITY,
        inverseViewMatrix: Cesium.Matrix4.IDENTITY,
        frustum: new Cesium.OrthographicOffCenterFrustum(),
        positionCartographic: new Cesium.Cartographic(),
        positionWC: new Cesium.Cartesian3(),
        directionWC: Cesium.Cartesian3.UNIT_Z,
        upWC: Cesium.Cartesian3.UNIT_Y,
        rightWC: Cesium.Cartesian3.UNIT_X,
        viewProjectionMatrix: Cesium.Matrix4.IDENTITY
      };
    }
  }, {
    key: "_createPolygonGeometry",
    value: function _createPolygonGeometry() {
      //创建geometry
      var flattenPolygon = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(this.localPosArr),
        perPositionHeight: true
      });
      return Cesium.PolygonGeometry.createGeometry(flattenPolygon);
    }
  }, {
    key: "_createCommand",
    value: function _createCommand() {
      //创建指令
      var context = this.viewer.scene.context;
      var ppp = this._createPolygonGeometry();
      var _camera = this._createCamera();
      var sp = Cesium.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: _PolygonTextureVS2.default,
        fragmentShaderSource: _PolygonTextureFS2.default,
        attributeLocations: {
          position: 0
        }
      });
      var vao = Cesium.VertexArray.fromGeometry({
        context: context,
        geometry: ppp,
        attributeLocations: sp._attributeLocations,
        bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
        interleave: true
      });

      var rs = new Cesium.RenderState();
      rs.depthTest.enabled = false;
      rs.depthRange.near = -1000000.0;
      rs.depthRange.far = 1000000.0;

      var bg = Cesium.BoundingRectangle.fromPoints(this.localPosArr, new Cesium.BoundingRectangle());
      _camera.frustum.left = bg.x;
      _camera.frustum.top = bg.y + bg.height;
      _camera.frustum.right = bg.x + bg.width;
      _camera.frustum.bottom = bg.y;

      this._camera = _camera;

      var _myPorjection = Cesium.Matrix4.computeOrthographicOffCenter(_camera.frustum.left, _camera.frustum.right, _camera.frustum.bottom, _camera.frustum.top, _camera.frustum.near, _camera.frustum.far, new Cesium.Matrix4());

      this.polygonBounds = new Cesium.Cartesian4(_camera.frustum.left, _camera.frustum.bottom, _camera.frustum.right, _camera.frustum.top);

      this.drawCommand = new Cesium.DrawCommand({
        boundingVolume: ppp.boundingVolume,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        vertexArray: vao,
        shaderProgram: sp,
        renderState: rs,
        pass: Cesium.Pass.CESIUM_3D_TILE,
        uniformMap: {
          myPorjection: function myPorjection() {
            return _myPorjection;
          }
        }
      });
    }

    //重置编辑对象

  }, {
    key: "clear",
    value: function clear() {
      if (this._tileset && this.tileset.dasEditor) {
        this.tileset.dasEditor.IsYaPing = [false, false, false, false]; //[是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]
        this.tileset.dasEditor.editVar = [false, false, false, false]; //[是否开启裁剪外部，是否开启淹没全局，]

        this.tileset.dasEditor.b3dmOffset = undefined;
        this.tileset.dasEditor.floodColor = [0.0, 0.0, 0.0, 0.5]; //[淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
        this.tileset.dasEditor.floodVar = [0, 0, 0, 0]; //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
        this.tileset.dasEditor.heightVar = [0, 0]; //基础压平高度，调整压平高度值
        this.tileset.dasEditor.enable = false;
      }
      this.drawed = false;
    }
  }, {
    key: "activeEdit",
    value: function activeEdit() {}
  }, {
    key: "deActiveEdit",
    value: function deActiveEdit() {
      //激活
      this.tileset.dasEditor.IsYaPing[0] = false;
    }
  }, {
    key: "update",
    value: function update(frameState) {
      //更新
      if (this.drawed) return; //如果已经绘制过纹理，则退出，无需再绘制
      this.drawed = true;
      var context = frameState.context;
      var width = 4096;
      var height = 4096;
      if (!this._passState) {
        this._passState = new Cesium.PassState(context);
      }
      this._passState.framebuffer = this.fbo;
      this._passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height);
      var us = context.uniformState;
      us.updateCamera(this._camera);
      us.updatePass(this.drawCommand.pass);
      this.drawCommand.framebuffer = this.fbo;
      this.drawCommand.execute(context, this._passState);
    }

    //预处理顶点

  }, {
    key: "_preparePos",
    value: function _preparePos(positions) {
      if (!positions || positions.length == 0) return;
      var localPos = [];
      var minHeight = 99999;
      var minLocalPos;
      for (var i = 0; i < positions.length; i++) {
        var cart = Cesium.Cartographic.fromCartesian(positions[i]);
        var height = cart.height;
        var currLocalPos = Cesium.Matrix4.multiplyByPoint(this.tileInverTransform, positions[i], new Cesium.Cartesian3());

        // if (this.tileset.das.options.offset && this.tileset.das.options.offset.z) {
        //   currLocalPos.z -= this.tileset.das.options.offset.z;
        // }
        if (this.tileset.das.options.editOffset && this.tileset.das.options.editOffset.z) {
          currLocalPos.z += this.tileset.das.options.editOffset.z;
        }

        localPos.push(currLocalPos);
        if (height < minHeight) {
          minHeight = height;
          minLocalPos = currLocalPos;
        }
      }
      this.minHeight = minHeight;
      this.minLocalPos = minLocalPos;
      this.localPosArr = localPos;
    }
  }, {
    key: "addToScene",
    value: function addToScene() {
      if (!this.viewer.scene.primitives.contains(this)) {
        this.viewer.scene.primitives.add(this);
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.viewer.scene.primitives.contains(this)) {
        this.viewer.scene.primitives.remove(this);
        if (!this.viewer) return;
      }
      this.clear();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "tileset",
    get: function get() {
      return this._tileset;
    },
    set: function set(val) {
      this._tileset = val;
      var inverseMat = new Cesium.Matrix4();
      Cesium.Matrix4.fromArray(val._root.transform, 0, inverseMat);
      Cesium.Matrix4.inverse(inverseMat, inverseMat);
      this.tileInverTransform = inverseMat;

      if (this.tileset.das.options.editOffset) {
        this._b3dmOffset = new Cesium.Cartesian2(this.tileset.das.options.editOffset.x, this.tileset.das.options.editOffset.y);
      }
    }

    //偏移量

  }, {
    key: "b3dmOffset",
    get: function get() {
      return this._b3dmOffset;
    },
    set: function set(val) {
      if (!val) return;
      this._b3dmOffset.x = val.x || 0;
      this._b3dmOffset.y = val.y || 0;

      this.tileset.dasEditor.b3dmOffset = this._b3dmOffset;
    }
  }]);

  return TilesBase;
}();

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//当前版本  2020年10月1日 - 至今
var version = exports.version = "2.2.2";
//发布时间
var update = exports.update = "2023-4-24 14:41:53";

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
//平面
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "dimensionsY":
      case "plane_distance":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;
      case "dimensionsX":
        //平面的长宽
        var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
        var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
        entityattr.dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
        break;
      case "plane_normal":
        //平面的方向及距离
        var plane_normal;
        switch (value) {
          case "x":
            plane_normal = Cesium.Cartesian3.UNIT_X;
            break;
          case "y":
            plane_normal = Cesium.Cartesian3.UNIT_Y;
            break;
          default:
            plane_normal = Cesium.Cartesian3.UNIT_Z;
            break;
        }
        var plane_distance = Cesium.defaultValue(style.plane_distance, 0.0);
        entityattr.plane = new Cesium.Plane(plane_normal, plane_distance);
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleWaveMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//圆形扩散波纹效果 材质属性
var CircleWaveMaterialProperty = exports.CircleWaveMaterialProperty = function () {
  //========== 构造方法 ==========
  function CircleWaveMaterialProperty(options) {
    _classCallCheck(this, CircleWaveMaterialProperty);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    this._definitionChanged = new Cesium.Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._time = undefined;

    //支持的属性
    this._color = Cesium.defaultValue(options.color, Cesium.Color.YELLOW); //颜色
    this._speed = Cesium.defaultValue(options.speed, 10); //速度，建议取值范围1-100
    this._count = Cesium.defaultValue(options.count, 1); //圆圈个数
    this._gradient = Cesium.defaultValue(options.gradient, 0.1); //透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变

    //属性容错
    if (options.duration) {
      //兼容v2.2之前老版本
      this._speed = 30000 / options.duration;
    }
    if (this._count <= 0) this._count = 1;
    if (this._gradient < 0) this._gradient = 0;
    if (this._gradient > 1) this._gradient = 1;
  }

  //========== 对外属性 ==========


  _createClass(CircleWaveMaterialProperty, [{
    key: "getType",


    //========== 方法 ==========
    /**
     * Gets the {@link Cesium.Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    value: function getType(time) {
      return Cesium.Material.CircleWaveType;
    }

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.color = this._color;
      result.speed = this._speed;
      result.count = this._count;
      result.gradient = this._gradient;
      return result;
    }

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param { Cesium.Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof CircleWaveMaterialProperty && Cesium.Property.equals(this._color, other._color) && this._count === other._count && this._speed === other._speed && this._gradient === other._gradient;
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return CircleWaveMaterialProperty;
}();

Object.defineProperties(CircleWaveMaterialProperty.prototype, {
  color: Cesium.createPropertyDescriptor("color"),
  speed: Cesium.createPropertyDescriptor("speed"),
  count: Cesium.createPropertyDescriptor("count"),
  gradient: Cesium.createPropertyDescriptor("gradient")
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _point = __webpack_require__(2);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "dimensionsY":
      case "dimensionsZ":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;
      case "dimensionsX":
        //盒子的长宽高
        var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
        var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
        var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
        entityattr.dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
//盒子
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "radius":
      case "shape":
      case "grid_lineCount":
      case "grid_lineThickness":
      case "grid_cellAlpha":
      case "checkerboard_repeat":
      case "checkerboard_oddcolor":
      case "stripe_oddcolor":
      case "stripe_repeat":
      case "animationDuration":
      case "animationImage":
      case "animationRepeatX":
      case "animationRepeatY":
      case "animationAxisY":
      case "animationGradient":
      case "animationCount":
      case "randomColor":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //材质优先
  if (style.material) entityattr.material = style.material;

  //管道样式
  style.radius = style.radius || 10;
  switch (style.shape) {
    default:
    case "pipeline":
      entityattr.shape = getCorridorShape1(style.radius); //（厚度固定为半径的1/3）
      break;
    case "circle":
      entityattr.shape = getCorridorShape2(style.radius);
      break;
    case "star":
      entityattr.shape = getCorridorShape3(style.radius);
      break;
  }

  return entityattr;
}

//管道形状1【内空管道】 radius整个管道的外半径
function getCorridorShape1(radius) {
  var hd = radius / 3;
  var startAngle = 0;
  var endAngle = 360;

  var pss = [];
  for (var i = startAngle; i <= endAngle; i++) {
    var radians = Cesium.Math.toRadians(i);
    pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
  }
  for (var _i = endAngle; _i >= startAngle; _i--) {
    var _radians = Cesium.Math.toRadians(_i);
    pss.push(new Cesium.Cartesian2((radius - hd) * Math.cos(_radians), (radius - hd) * Math.sin(_radians)));
  }
  return pss;
}

//管道形状2【圆柱体】 radius整个管道的外半径
function getCorridorShape2(radius) {
  var startAngle = 0;
  var endAngle = 360;

  var pss = [];
  for (var i = startAngle; i <= endAngle; i++) {
    var radians = Cesium.Math.toRadians(i);
    pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
  }
  return pss;
}

//管道形状3【星状】 radius整个管道的外半径 ,arms星角的个数（默认6个角）
function getCorridorShape3(radius) {
  var arms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;

  var angle = Math.PI / arms;
  var length = 2 * arms;
  var pss = new Array(length);
  for (var i = 0; i < length; i++) {
    var r = i % 2 === 0 ? radius : radius / 3;
    pss[i] = new Cesium.Cartesian2(Math.cos(i * angle) * r, Math.sin(i * angle) * r);
  }
  return pss;
}

//获取entity的坐标
function getPositions(entity) {
  if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //取绑定的数据

  return entity.polylineVolume.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  };
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (!entityattr) {
    entityattr = {
      fill: true
    };
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "color": //填充颜色
      case "materialType":
      case "grid_lineCount":
      case "grid_lineThickness":
      case "grid_cellAlpha":
      case "checkerboard_repeat":
      case "checkerboard_oddcolor":
      case "stripe_oddcolor":
      case "stripe_repeat":
      case "animationDuration":
      case "animationImage":
      case "animationRepeatX":
      case "animationRepeatY":
      case "animationAxisY":
      case "animationGradient":
      case "animationCount":
      case "randomColor":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return entity.wall.positions.getValue((0, _util.currentTime)());
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "LineString",
      coordinates: coordinates
    }
  };
}

/***/ }),
/* 58 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWaterPrimitive = createWaterPrimitive;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//创建水面Primitive
function createWaterPrimitive(polygon, opts) {
  var primitiveOpts = {
    geometryInstances: new Cesium.GeometryInstance({
      geometry: polygon,
      id: opts.id || "water"
    }),
    appearance: new Cesium.EllipsoidSurfaceAppearance({
      aboveGround: false,
      material: new Cesium.Material({
        fabric: {
          type: "Water",
          uniforms: {
            normalMap: opts.normalMap, //水正常扰动的法线图。
            frequency: opts.frequency || 8000.0, //控制波数的数字。
            animationSpeed: opts.animationSpeed || 0.03, //控制水的动画速度的数字。
            amplitude: opts.amplitude || 5.0, //控制水波振幅的数字。
            specularIntensity: opts.specularIntensity || 0.8, //控制镜面反射强度的数字。
            baseWaterColor: Cesium.Color.fromCssColorString(opts.baseWaterColor || "#123e59"), //rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
            blendColor: Cesium.Color.fromCssColorString(opts.blendColor || "#123e59") //从水中混合到非水域时使用的rgba颜色对象。
          }
        }
      }),
      fragmentShaderSource: getWaterShader(opts.opacity)
    }),
    show: true
  };
  if (opts.clampToGround) {
    primitiveOpts.classificationType = opts.classificationType || Cesium.ClassificationType.TERRAIN;
    return new Cesium.GroundPrimitive(primitiveOpts);
  } else {
    return new Cesium.Primitive(primitiveOpts);
  }
}

// 水面shader
//水域相关场景效果
function getWaterShader(opacity) {
  opacity = Cesium.defaultValue(opacity, 0.5);

  return "varying vec3 v_positionMC;\n\
            varying vec3 v_positionEC;\n\
            varying vec2 v_st;\n\
            \n\
            void main()\n\
            {\n\
                czm_materialInput materialInput;\n\
                vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n\
            #ifdef FACE_FORWARD\n\
                normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
            #endif\n\
                materialInput.s = v_st.s;\n\
                materialInput.st = v_st;\n\
                materialInput.str = vec3(v_st, 0.0);\n\
                materialInput.normalEC = normalEC;\n\
                materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\
                vec3 positionToEyeEC = -v_positionEC;\n\
                materialInput.positionToEyeEC = positionToEyeEC;\n\
                czm_material material = czm_getMaterial(materialInput);\n\
            #ifdef FLAT\n\
                gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
            #else\n\
                gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n\
                gl_FragColor.a = " + opacity + ";\n\
            #endif\n\
            }"; //czm_lightDirectionEC在cesium1.66开始加入的
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPoint = exports.EditPoint = function (_EditBase) {
  _inherits(EditPoint, _EditBase);

  function EditPoint() {
    _classCallCheck(this, EditPoint);

    return _possibleConstructorReturn(this, (EditPoint.__proto__ || Object.getPrototypeOf(EditPoint)).apply(this, arguments));
  }

  _createClass(EditPoint, [{
    key: "setPositions",

    //外部更新位置
    value: function setPositions(position) {
      if (util.isArray(position) && position.length == 1) {
        position = position[0];
      }
      this.entity.position.setValue(position);
      if (this.entity.featureEx) {
        this.entity.featureEx.position = position;
      }
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      this.entity.draw_tooltip = _Tooltip.message.dragger.def;
      var dragger = draggerCtl.createDragger(this.entityCollection, {
        dragger: this.entity,
        onDrag: function onDrag(dragger, newPosition) {
          that.entity.position.setValue(newPosition);

          if (that.entity.featureEx) {
            that.entity.featureEx.position = newPosition;
          }
        }
      });
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      delete this.entity.draw_tooltip;
      delete this.entity._isDragger;
      delete this.entity._noMousePosition;
      delete this.entity._pointType;
      delete this.entity.onDrag;
    }
  }]);

  return EditPoint;
}(_Edit.EditBase);

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slope = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _matrix = __webpack_require__(16);

var _measure = __webpack_require__(18);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _polygon = __webpack_require__(10);

var _polyline = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//坡度坡向 类
var Slope = exports.Slope = function (_DasClass) {
  _inherits(Slope, _DasClass);

  function Slope(options) {
    _classCallCheck(this, Slope);

    var _this = _possibleConstructorReturn(this, (Slope.__proto__ || Object.getPrototypeOf(Slope)).call(this, options));

    _this.options = options;
    _this.viewer = options.viewer;

    //箭头的显示长度（米）
    _this.options.arrow = _this.options.arrow || {};
    _this.options.arrow.show = Cesium.defaultValue(_this.options.arrow.show, true);
    _this.options.arrow.scale = Cesium.defaultValue(_this.options.arrow.scale, 0.3); //箭头长度的比例
    _this.options.arrow.width = Cesium.defaultValue(_this.options.arrow.width, 15); //箭头宽度
    _this.options.arrow.color = Cesium.defaultValue(_this.options.arrow.color, Cesium.Color.YELLOW);
    _this.arrowLength = Cesium.defaultValue(_this.options.arrow.length, 40);

    //point点
    _this.options.point = _this.options.point || {};
    _this.options.point.show = Cesium.defaultValue(_this.options.point.show, true);
    _this.options.point.pixelSize = Cesium.defaultValue(_this.options.point.pixelSize, 9);
    _this.options.point.color = Cesium.defaultValue(_this.options.point.color, Cesium.Color.RED.withAlpha(0.5));

    _this.arrowPrimitives = [];
    _this.pointInterPrimitives = new Cesium.PointPrimitiveCollection();
    _this.viewer.scene.primitives.add(_this.pointInterPrimitives);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (_this.options.calbackStep) {
      var calbackStepfun = options.calbackStep;
      delete options.calbackStep;
      _this.on(_DasClass2.eventType.endItem, function (e) {
        calbackStepfun(e.data, e.index);
      });
    }
    if (_this.options.calbakStep) {
      var calbakStepfun = options.calbakStep;
      delete options.calbakStep;
      _this.on(_DasClass2.eventType.endItem, function (e) {
        calbakStepfun(e.data, e.index);
      });
    }
    if (_this.options.calback) {
      var calbackfun = options.calback;
      delete options.calback;
      _this.on(_DasClass2.eventType.end, function (e) {
        calbackfun(e.data);
      });
    }
    if (_this.options.calbak) {
      var calbakfun = options.calbak;
      delete options.calbak;
      _this.on(_DasClass2.eventType.end, function (e) {
        calbakfun(e.data);
      });
    }
    if (_this.options.click) {
      var clickfun = options.click;
      delete options.click;
      _this.on(_DasClass2.eventType.click, function (e) {
        clickfun(e.sourceTarget, e);
      });
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    if (options.positions && options.positions.length > 0) {
      _this.add(options.positions, options);
    }
    return _this;
  }

  // 计算  传入Cartesian3 数组 ，贴地坐标


  _createClass(Slope, [{
    key: "add",
    value: function add(arr, options) {
      if (!arr || arr.length < 1) return;

      options = options || this.options;

      var splitNum = Cesium.defaultValue(options.splitNum, 8);
      if (arr.length > 2 && splitNum > 1) {
        //传入面边界时
        var resultInter = (0, _polygon.interPolygon)({
          scene: this.viewer.scene,
          positions: arr,
          has3dtiles: false,
          onlyPoint: true, //true时只返回点，不返回三角网
          splitNum: Cesium.defaultValue(options.splitNum, 8) //splitNum插值分割的个数
        });
        this.arrowLength = Cesium.Math.chordLength(resultInter.granularity, this.viewer.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;

        arr = [];
        for (var k = 0; k < resultInter.list.length; k++) {
          arr.push(resultInter.list[k].pointDM);
        }
      }

      this.stateAll = arr.length;
      this.stateOkIndex = 0;
      this.instances = [];
      this.arrData = [];

      for (var i = 0; i < this.stateAll; i++) {
        this._fxOnePoint(arr[i], options);
      }
    }

    //分析单个点的对应坡度

  }, {
    key: "_fxOnePoint",
    value: function _fxOnePoint(position, options) {
      if (!position) return;

      //返回该点的周边2米圆上的8个点
      var arcPoint = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        radius: Cesium.defaultValue(options.radius, 2), //半径
        count: Cesium.defaultValue(options.count, 4) //共返回8(count*4)个点
      });
      arcPoint.push(position);

      var ellipsoid = this.viewer.scene.globe.ellipsoid;

      // 求出点的详细高度
      var that = this;
      (0, _polyline.computeSurfacePoints)({
        scene: this.viewer.scene,
        positions: arcPoint,
        has3dtiles: options.has3dtiles,
        callback: function callback(raisedPositions, noHeight) {
          if (noHeight) {
            daslog.log("未获取到高度值，贴地高度计算存在误差");
          }

          var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions);

          // 中心点
          var center = cartographicArray.pop();

          // 其余圆上点
          var maxIndex = 0;
          var maxHeight = cartographicArray[0].height;
          var minIndex = 0;
          var minHeight = cartographicArray[0].height;
          for (var i = 1; i < cartographicArray.length - 1; i++) {
            var item = cartographicArray[i];
            if (item.height > maxHeight) {
              maxHeight = item.height;
              maxIndex = i;
            }
            if (item.height < minHeight) {
              minHeight = item.height;
              minIndex = i;
            }
          }

          var maxPoint = cartographicArray[maxIndex]; //周边最高点
          var minPoint = cartographicArray[minIndex]; //周边最低点

          var slopeVal1 = that.getSlope(center, maxPoint);
          var slopeVal2 = that.getSlope(center, minPoint);

          if (slopeVal1 > slopeVal2) {
            that._fxOnePointOk(position, center, maxPoint, slopeVal1);
          } else {
            that._fxOnePointOk(position, center, minPoint, slopeVal2);
          }
        }
      });
    }

    //分析单个点的对应坡度完成后添加显示的箭头等

  }, {
    key: "_fxOnePointOk",
    value: function _fxOnePointOk(position, center, maxPoint, slopeVal) {
      var centerCar = Cesium.Cartographic.toCartesian(center);
      var maxPointCar = Cesium.Cartographic.toCartesian(maxPoint);
      maxPointCar = (0, _matrix.getOnLinePointByLen)(centerCar, maxPointCar, this.arrowLength);

      // 计算圆上的最高点和中心点的高度 判断箭头方向
      var arrArrowPt;
      if (center.height > maxPoint.height) {
        //中心点高于四周情况下
        arrArrowPt = [centerCar, maxPointCar];
      } else {
        //边缘指向中心
        arrArrowPt = [maxPointCar, centerCar];
      }

      //求方位角
      var slopeAngle = (0, _measure.getAngle)(arrArrowPt[0], arrArrowPt[1]);

      var slopeValDou = Math.atan(slopeVal) * 180 / Math.PI;
      slopeValDou = Number(slopeValDou.toFixed(2));

      // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°
      var text1 = slopeValDou + "°";
      // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%
      var text2 = (slopeVal * 100).toFixed(2) + "%";

      var itemData = {
        position: position, //坐标位置
        slope: slopeValDou, //度数法值【 α(坡度)=arc tan (高程差/水平距离)】
        slopeStr1: text1, //度数法值字符串
        slopeStr2: text2, //百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
        direction: slopeAngle //坡向值（0-360度）
      };
      this.arrData.push(itemData);

      this.fire(_DasClass2.eventType.endItem, {
        data: itemData,
        index: this.stateOkIndex
      });

      // 构建箭头
      if (this.options.arrow.show) {
        var gs = new Cesium.GeometryInstance({
          geometry: new Cesium.PolylineGeometry(_extends({
            positions: arrArrowPt
          }, this.options.arrow)),
          vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
          id: "polylinedashinstance"
        });
        this.instances.push(gs);
      }

      // 添加点 显示坡度
      if (this.options.point.show) {
        var primitive = this.pointInterPrimitives.add(_extends({
          position: centerCar
        }, this.options.point));

        primitive.properties = itemData;
        primitive.eventTarget = this;
        primitive.tooltip = Cesium.defaultValue(this.options.tooltip, "\u5761\u5EA6: " + text1 + "  (" + text2 + ")<br />\u5761\u5411: " + slopeAngle + "\xB0"); // 显示结果
        primitive.popup = this.options.popup;
      }

      // 全部计算完成
      this.stateOkIndex++;
      if (this.stateOkIndex >= this.stateAll) {
        if (this.options.arrow.show && this.instances.length > 0) {
          var arrowPrimitive = this.viewer.scene.primitives.add(new Cesium.Primitive({
            geometryInstances: this.instances,
            appearance: new Cesium.PolylineMaterialAppearance({
              material: Cesium.Material.fromType("PolylineArrow", {
                color: this.options.arrow.color
              })
            })
          }));
          this.arrowPrimitives.push(arrowPrimitive);
          this.instances = [];
        }

        this.fire(_DasClass2.eventType.end, {
          data: this.arrData
        });
      }
    }

    // 两点之间的坡度

  }, {
    key: "getSlope",
    value: function getSlope(c1, c2) {
      if (!c1 || !c2) return;
      var differH = Math.abs(c1.height - c2.height); //高度差
      var differV = Cesium.Cartesian3.distance(Cesium.Cartographic.toCartesian(c1), Cesium.Cartesian3.fromRadians(c2.longitude, c2.latitude, c1.height)); // 水平距离
      var value = differH / differV;
      return value;
    }

    // 清除

  }, {
    key: "clear",
    value: function clear() {
      if (this.pointInterPrimitives) this.pointInterPrimitives.removeAll();

      for (var i = 0, len = this.arrowPrimitives.length; i < len; i++) {
        this.viewer.scene.primitives.remove(this.arrowPrimitives[i]);
      }
      this.arrowPrimitives = [];
      this.instances = [];
      this.arrData = [];
      this.stateAll = 0;
      this.stateOkIndex = 0;
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(Slope.prototype.__proto__ || Object.getPrototypeOf(Slope.prototype), "destroy", this).call(this);
    }
  }]);

  return Slope;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


Slope.event = {
  endItem: _DasClass2.eventType.endItem,
  end: _DasClass2.eventType.end,
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(27);

var _Attr = __webpack_require__(17);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCurve = exports.EditCurve = function (_EditPolyline) {
  _inherits(EditCurve, _EditPolyline);

  function EditCurve() {
    _classCallCheck(this, EditCurve);

    return _possibleConstructorReturn(this, (EditCurve.__proto__ || Object.getPrototypeOf(EditCurve)).apply(this, arguments));
  }

  _createClass(EditCurve, [{
    key: "changePositionsToCallback",

    //修改坐标会回调，提高显示的效率
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;
      this._positions_show = this.entity._positions_show || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
    }
    //坐标位置相关

  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      if (this._positions_draw == null || this._positions_draw.length < 3) {
        this._positions_show = this._positions_draw;
        return;
      }

      this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
      this.entity._positions_show = this._positions_show;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_show = this._positions_show;
      this.entity._positions_draw = this._positions_draw;
    }
  }]);

  return EditCurve;
}(_Edit.EditPolyline);

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPolylineVolume = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(27);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPolylineVolume = exports.EditPolylineVolume = function (_EditPolyline) {
  _inherits(EditPolylineVolume, _EditPolyline);

  function EditPolylineVolume() {
    _classCallCheck(this, EditPolylineVolume);

    return _possibleConstructorReturn(this, (EditPolylineVolume.__proto__ || Object.getPrototypeOf(EditPolylineVolume)).apply(this, arguments));
  }

  _createClass(EditPolylineVolume, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.polylineVolume;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;
    }
  }]);

  return EditPolylineVolume;
}(_Edit.EditPolyline);

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditCorridor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Edit = __webpack_require__(27);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCorridor = exports.EditCorridor = function (_EditPolyline) {
  _inherits(EditCorridor, _EditPolyline);

  function EditCorridor() {
    _classCallCheck(this, EditCorridor);

    return _possibleConstructorReturn(this, (EditCorridor.__proto__ || Object.getPrototypeOf(EditCorridor)).apply(this, arguments));
  }

  _createClass(EditCorridor, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.corridor;
    }
    //继承父类，根据属性更新坐标

  }, {
    key: "updatePositionsHeightByAttr",
    value: function updatePositionsHeightByAttr(position) {
      if (this.getGraphic().height != undefined) {
        var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
        position = (0, _point.setPositionsHeight)(position, newHeight);
      }
      return position;
    }
  }]);

  return EditCorridor;
}(_Edit.EditPolyline);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolygon = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _Attr = __webpack_require__(21);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(28);

var _Attr2 = __webpack_require__(17);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolygon = exports.DrawPolygon = function (_DrawPolyline) {
  _inherits(DrawPolygon, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawPolygon(opts) {
    _classCallCheck(this, DrawPolygon);

    var _this = _possibleConstructorReturn(this, (DrawPolygon.__proto__ || Object.getPrototypeOf(DrawPolygon)).call(this, opts));

    _this.type = "polygon";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditPolygon; //获取编辑对象

    _this._minPointNum = 3; //至少需要点的个数
    _this._maxPointNum = 9999; //最多允许点的个数
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawPolygon, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      var that = this;
      var addattr = {
        polygon: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      addattr.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
        var positions = that.getDrawPosition();

        // fangmm 20210816 采用深拷贝方式传入polygon坐标，可解决贴地面双击结束时双击的两个点之间高度不一致问题
        var coors = [];
        if (positions && positions.length) {
          for (var i = 0, n = positions.length; i < n; i++) {
            var tempPos = positions[i];
            var tempCoor = new Cesium.Cartesian3(tempPos.x, tempPos.y, tempPos.z);
            coors.push(tempCoor);
          }
        }

        return new Cesium.PolygonHierarchy(coors);
      }, false);

      //线：边线宽度大于1时用polyline
      var lineStyle = _extends({
        color: attribute.style.outlineColor,
        width: attribute.style.outlineWidth,
        opacity: attribute.style.outlineOpacity
      }, attribute.style.outlineStyle || {});
      addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
        clampToGround: attribute.style.clampToGround,
        // arcType: Cesium.ArcType.RHUMB,
        outline: false,
        show: false
      });

      this.entity = dataSource.entities.add(addattr); //创建要素对象

      this.bindOutline(this.entity, lineStyle); //边线

      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.polygon);
    }
  }, {
    key: "bindOutline",
    value: function bindOutline(entity, lineStyle) {
      var attribute = entity.attribute;

      //本身的outline需要隐藏
      entity.polygon.outline = new Cesium.CallbackProperty(function (time) {
        return attribute.style.outline && attribute.style.outlineWidth == 1;
      }, false);

      //是否显示：绘制时前2点时 或 边线宽度大于1时
      entity.polyline.show = new Cesium.CallbackProperty(function (time) {
        var arr = attr.getPositions(entity, true);
        if (arr && arr.length < 3) return true;

        return attribute.style.outline && attribute.style.outlineWidth > 1;
      }, false);

      entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
        if (!entity.polyline.show.getValue(time)) return null;

        var arr = attr.getPositions(entity, true);
        if (arr && arr.length < 3) return arr;

        return arr.concat([arr[0]]);
      }, false);
      entity.polyline.width = new Cesium.CallbackProperty(function (time) {
        var arr = attr.getPositions(entity, true);
        if (arr && arr.length < 3) return 2;

        return entity.polygon.outlineWidth;
      }, false);

      //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
      if (!lineStyle.lineType || lineStyle.lineType == "solid") {
        entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
          var arr = attr.getPositions(entity, true);
          if (arr && arr.length < 3) {
            if (entity.polygon.material.color) return entity.polygon.material.color.getValue(time);else return Cesium.Color.YELLOW;
          }
          return entity.polygon.outlineColor.getValue(time);
        }, false));
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      var style = this.entity.attribute.style;
      if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
        //存在extrudedHeight高度设置时
        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
        this.entity.polygon.extrudedHeight = maxHight + Number(style.extrudedHeight);
      }
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
        var positions = entity._positions_draw;
        return new Cesium.PolygonHierarchy(positions);
      }, false);
    }
  }]);

  return DrawPolygon;
}(_Draw.DrawPolyline);

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;
exports.getOutlinePositions = getOutlinePositions;
exports.getOutlineCoordinates = getOutlineCoordinates;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _polygon = __webpack_require__(10);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {};
  }

  //贴地时，剔除高度相关属性
  if (style.clampToGround) {
    if (style.hasOwnProperty("height")) delete style.height;
    if (style.hasOwnProperty("extrudedHeight")) delete style.extrudedHeight;
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "grid_lineCount":
      case "grid_lineThickness":
      case "grid_cellAlpha":
      case "checkerboard_repeat":
      case "checkerboard_oddcolor":
      case "stripe_oddcolor":
      case "stripe_repeat":
      case "animationDuration":
      case "animationImage":
      case "animationRepeatX":
      case "animationRepeatY":
      case "animationAxisY":
      case "animationGradient":
      case "animationCount":
      case "randomColor":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outline":
        //边线
        if (entityattr[key] instanceof Cesium.CallbackProperty) {
          //回调时不覆盖
        } else {
          entityattr[key] = value;
        }
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "height":
        entityattr.height = value;
        if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
        break;
      case "extrudedHeight":
        if ((0, _util.isNumber)(value)) {
          entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
        } else {
          entityattr.extrudedHeight = value;
        }
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;
      case "image":
        //填充图片
        entityattr.material = new Cesium.ImageMaterialProperty({
          image: style.image,
          color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(style.opacity || 1.0))
        });
        break;
      case "rotation":
        //旋转角度
        entityattr.rotation = Cesium.Math.toRadians(value);
        if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
        break;
      case "stRotation":
        entityattr.stRotation = Cesium.Math.toRadians(value);
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  if (!entity.rectangle) return null;

  // if (entity._positions_draw && entity._positions_draw.length > 0)
  //     return entity._positions_draw;

  var time = (0, _util.currentTime)();
  var re = entity.rectangle.coordinates.getValue(time); //Rectangle
  var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

  var ptMin = Cesium.Cartesian3.fromRadians(re.west, re.south, height); //西、南
  var ptMax = Cesium.Cartesian3.fromRadians(re.east, re.north, height); //东、北
  return [ptMin, ptMax];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);

  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: {
      type: "MultiPoint",
      coordinates: coordinates
    }
  };
}

//获取entity对应的 边界 的坐标
function getOutlinePositions(entity, noAdd) {
  if (!entity.rectangle) return null;

  var time = (0, _util.currentTime)();
  var re = entity.rectangle.coordinates.getValue(time); //Rectangle
  if (!re) return null;

  var rotation = entity.rectangle.rotation.getValue(time) || 0; //Rectangle
  var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

  var arr = (0, _polygon.getRectangleOuterPositions)({
    rectangle: re,
    rotation: rotation,
    height: height
  });

  if (!noAdd) arr.push(arr[0]);
  return arr;
}

//获取entity对应的 边界 的坐标（geojson规范的格式）
function getOutlineCoordinates(entity, noAdd) {
  var positions = getOutlinePositions(entity, noAdd);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditRectangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditRectangle = exports.EditRectangle = function (_EditPolygon) {
  _inherits(EditRectangle, _EditPolygon);

  function EditRectangle() {
    _classCallCheck(this, EditRectangle);

    return _possibleConstructorReturn(this, (EditRectangle.__proto__ || Object.getPrototypeOf(EditRectangle)).apply(this, arguments));
  }

  _createClass(EditRectangle, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.rectangle;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this._positions_draw;
    }
  }, {
    key: "isClampToGround",
    value: function isClampToGround() {
      return this.entity.attribute.style.clampToGround;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var clampToGround = this.isClampToGround();
      var positions = this.getPosition();

      for (var i = 0, len = positions.length; i < len; i++) {
        var position = positions[i];

        if (this.getGraphic().height != undefined) {
          var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
          position = (0, _point.setPositionsHeight)(position, newHeight);
        }

        if (clampToGround) {
          //贴地时求贴模型和贴地的高度
          position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
        }

        //各顶点
        var dragger = draggerCtl.createDragger(this.entityCollection, {
          position: position,
          //clampToGround: clampToGround,
          onDrag: function onDrag(dragger, position) {
            var time = that.viewer.clock.currentTime;
            if (that.getGraphic().height != undefined) {
              var _newHeight = that.getGraphic().height.getValue(time);
              position = (0, _point.setPositionsHeight)(position, _newHeight);
              dragger.position = position;
            }

            positions[dragger.index] = position;

            //============高度调整拖拽点处理=============
            if (that.heightDraggers && that.heightDraggers.length > 0) {
              var extrudedHeight = that.getGraphic().extrudedHeight.getValue(time);
              that.heightDraggers[dragger.index].position = (0, _point.setPositionsHeight)(position, extrudedHeight);
            }

            //============整体平移移动点处理=============
            positionMove = (0, _point.centerOfMass)(positions);
            if (that.getGraphic().height != undefined) {
              var _newHeight2 = that.getGraphic().height.getValue(time);
              positionMove = (0, _point.setPositionsHeight)(positionMove, _newHeight2);
            }
            if (clampToGround) {
              //贴地时求贴模型和贴地的高度
              positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
            }
            draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);
      }

      //整体平移移动点
      var positionMove = (0, _point.centerOfMass)(positions);
      if (this.getGraphic().height != undefined) {
        var _newHeight3 = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
        positionMove = (0, _point.setPositionsHeight)(positionMove, _newHeight3);
      }
      if (clampToGround) {
        //贴地时求贴模型和贴地的高度
        positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
      }
      var draggerMove = draggerCtl.createDragger(this.entityCollection, {
        position: positionMove,
        type: draggerCtl.PointType.MoveAll,
        tooltip: _Tooltip.message.dragger.moveAll,
        onDrag: function onDrag(dragger, position) {
          // dragger.position = position;

          //记录差值
          var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
          positionMove = position;

          positions.forEach(function (pos, index, arr) {
            var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
            positions[index] = newPos;
          });

          //=====全部更新==========
          that.updateDraggers();
        }
      });
      this.draggers.push(draggerMove);

      //创建高程拖拽点
      if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
    }
  }]);

  return EditRectangle;
}(_Edit.EditPolygon);

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditCircle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCircle = exports.EditCircle = function (_EditPolygon) {
  _inherits(EditCircle, _EditPolygon);

  function EditCircle() {
    _classCallCheck(this, EditCircle);

    return _possibleConstructorReturn(this, (EditCircle.__proto__ || Object.getPrototypeOf(EditCircle)).apply(this, arguments));
  }

  _createClass(EditCircle, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.ellipse;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;
      this.finish();
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this._positions_draw;
    }
  }, {
    key: "isClampToGround",
    value: function isClampToGround() {
      return this.entity.attribute.style.clampToGround;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      //加上高度
      if (this.getGraphic().height != undefined) {
        var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
        for (var i = 0, len = this._positions_draw.length; i < len; i++) {
          this._positions_draw[i] = (0, _point.setPositionsHeight)(this._positions_draw[i], newHeight);
        }
      }
      return this._positions_draw;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var clampToGround = this.isClampToGround();
      var positions = this.getPosition();

      var style = this.entity.attribute.style;

      //中心点
      var position = positions[0];
      if (clampToGround) {
        //贴地时求贴模型和贴地的高度
        position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
        positions[0] = position;
      }

      var dragger = draggerCtl.createDragger(this.entityCollection, {
        position: position,
        onDrag: function onDrag(dragger, position) {
          //记录差值
          var diff = Cesium.Cartesian3.subtract(position, positions[dragger.index], new Cesium.Cartesian3());

          positions[dragger.index] = position;

          //============高度处理=============
          if (!style.clampToGround) {
            var height = that.formatNum(Cesium.Cartographic.fromCartesian(position).height, 2);
            that.getGraphic().height = height;
            style.height = height;
          }

          var time = that.viewer.clock.currentTime;

          //============半径同步处理=============
          dragger.majorDragger.position = Cesium.Cartesian3.add((0, _point.getPositionValue)(dragger.majorDragger.position, time), diff, new Cesium.Cartesian3());
          if (dragger.minorDragger) {
            dragger.minorDragger.position = Cesium.Cartesian3.add((0, _point.getPositionValue)(dragger.minorDragger.position, time), diff, new Cesium.Cartesian3());
          }

          //============高度调整拖拽点处理=============
          if (that.entity.attribute.style.extrudedHeight != undefined) that.updateDraggers();
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger);

      var time = this.viewer.clock.currentTime;

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        semiMajorAxis: this.getGraphic().semiMajorAxis.getValue(time), //长半轴
        semiMinorAxis: this.getGraphic().semiMinorAxis.getValue(time), //短半轴
        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
      });

      //长半轴上的坐标点
      var majorPos = outerPositions[1];
      if (clampToGround) {
        //贴地时求贴模型和贴地的高度
        majorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, majorPos);
      }
      positions[1] = majorPos;
      var majorDragger = draggerCtl.createDragger(this.entityCollection, {
        position: majorPos,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius,
        //clampToGround: clampToGround,
        onDrag: function onDrag(dragger, position) {
          if (that.getGraphic().height != undefined) {
            var newHeight = that.getGraphic().height.getValue(time);
            position = (0, _point.setPositionsHeight)(position, newHeight);
            dragger.position = position;
          }
          positions[dragger.index] = position;

          var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
          that.getGraphic().semiMajorAxis = radius;

          if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
            //椭圆
            style.semiMajorAxis = radius;
          } else {
            //圆
            that.getGraphic().semiMinorAxis = radius;
            style.radius = radius;
          }

          // if (that.entity.attribute.style.extrudedHeight != undefined)
          that.updateDraggers();
        }
      });
      majorDragger.index = 1;
      dragger.majorDragger = majorDragger;
      this.draggers.push(majorDragger);

      //短半轴上的坐标点
      if (this._maxPointNum == 3) {
        //椭圆
        //短半轴上的坐标点
        var minorPos = outerPositions[0];
        if (clampToGround) {
          //贴地时求贴模型和贴地的高度
          minorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, minorPos);
        }
        positions[2] = minorPos;
        var minorDragger = draggerCtl.createDragger(this.entityCollection, {
          position: minorPos,
          type: draggerCtl.PointType.EditAttr,
          tooltip: _Tooltip.message.dragger.editRadius,
          //clampToGround: clampToGround,
          onDrag: function onDrag(dragger, position) {
            if (that.getGraphic().height != undefined) {
              var newHeight = that.getGraphic().height.getValue(time);
              position = (0, _point.setPositionsHeight)(position, newHeight);
              dragger.position = position;
            }
            positions[dragger.index] = position;

            var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
            that.getGraphic().semiMinorAxis = radius;

            if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
              //椭圆
              style.semiMinorAxis = radius;
            } else {
              //圆
              that.getGraphic().semiMajorAxis = radius;
              style.radius = radius;
            }

            // if (that.entity.attribute.style.extrudedHeight != undefined)
            that.updateDraggers();
          }
        });
        minorDragger.index = 2;
        dragger.minorDragger = minorDragger;
        this.draggers.push(minorDragger);
      }

      //创建高度拖拽点
      if (this.getGraphic().extrudedHeight) {
        var _pos = this._maxPointNum == 3 ? [positions[1], positions[2]] : [positions[1]];
        this.bindHeightDraggers(_pos);
      }
    }
  }]);

  return EditCircle;
}(_Edit.EditPolygon);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {
      fill: true,
      topRadius: 0
    };
  }

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];

    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "color":
      case "animation":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "radius":
        //半径（圆）
        entityattr.topRadius = Number(value);
        entityattr.bottomRadius = Number(value);
        break;

      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)) + 6378137);
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  var positon = (0, _point.getPositionValue)(entity.position);

  if (entity._positions_draw && entity._positions_draw.length > 0) positon = entity._positions_draw[0];

  return [positon];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.style2Entity = style2Entity;
exports.getPositions = getPositions;
exports.getCoordinates = getCoordinates;
exports.toGeoJSON = toGeoJSON;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _point = __webpack_require__(2);

var _globe = __webpack_require__(20);

var globe = _interopRequireWildcard(_globe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//属性赋值到entity
//椭球体
function style2Entity(style, entityattr) {
  style = style || {};

  if (entityattr == null) {
    //默认值
    entityattr = {
      fill: true
    };
  }

  //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
  if (Cesium.defined(style.extentRadii)) style.radii_x = style.extentRadii;
  if (Cesium.defined(style.widthRadii)) style.radii_y = style.widthRadii;
  if (Cesium.defined(style.heightRadii)) style.radii_z = style.heightRadii;
  //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "opacity": //跳过扩展其他属性的参数
      case "outlineOpacity":
      case "radii_y":
      case "radii_z":
      case "innerRadii_y":
      case "innerRadii_z":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "outlineColor":
        //边框颜色
        entityattr.outlineColor = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
        break;
      case "color":
        //填充颜色
        entityattr.material = Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
        break;
      case "radii_x":
        //球体 长宽高半径
        entityattr.radii = new Cesium.Cartesian3(Cesium.defaultValue(style.radii_x, 100), Cesium.defaultValue(style.radii_y, 100), Cesium.defaultValue(style.radii_z, 100));
        break;
      case "innerRadii_x":
        //球体内圈 长宽高半径
        if (style.innerRadii_x > 0 && style.innerRadii_y > 0 && style.innerRadii_z > 0) entityattr.innerRadii = new Cesium.Cartesian3(Cesium.defaultValue(style.innerRadii_x, 0), Cesium.defaultValue(style.innerRadii_y, 0), Cesium.defaultValue(style.innerRadii_z, 0));else entityattr.innerRadii = new Cesium.Cartesian3(0.001, 0.001, 0.001);
        break;
      case "minimumClock":
      case "maximumClock":
      case "minimumCone":
      case "maximumCone":
        entityattr[key] = Cesium.Math.toRadians(value || 0);
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;

      case "hasShadows":
        //阴影
        if (value) entityattr.shadows = Cesium.ShadowMode.ENABLED;
        //对象投射并接收阴影。
        else entityattr.shadows = Cesium.ShadowMode.DISABLED; //该对象不会投射或接收阴影
        break;
    }
  }

  //设置填充材质
  globe.setFillMaterial(entityattr, style);

  return entityattr;
}

//获取entity的坐标
function getPositions(entity) {
  return [(0, _point.getPositionValue)(entity.position)];
}

//获取entity的坐标（geojson规范的格式）
function getCoordinates(entity) {
  var positions = getPositions(entity);
  var coordinates = pointconvert.cartesians2lonlats(positions);
  return coordinates;
}

//entity转geojson
function toGeoJSON(entity) {
  var coordinates = getCoordinates(entity);
  return {
    type: "Feature",
    properties: entity.attribute || {},
    geometry: { type: "Point", coordinates: coordinates[0] }
  };
}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditEllipsoid = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditEllipsoid = exports.EditEllipsoid = function (_EditBase) {
  _inherits(EditEllipsoid, _EditBase);

  function EditEllipsoid() {
    _classCallCheck(this, EditEllipsoid);

    return _possibleConstructorReturn(this, (EditEllipsoid.__proto__ || Object.getPrototypeOf(EditEllipsoid)).apply(this, arguments));
  }

  _createClass(EditEllipsoid, [{
    key: "setPositions",

    //外部更新位置
    value: function setPositions(position) {
      this.entity._positions_draw[0] = position[0];
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {}
  }, {
    key: "updateRadii",
    value: function updateRadii(style) {
      var radii = new Cesium.Cartesian3(Number(style.radii_x), Number(style.radii_y), Number(style.radii_z));
      this.entity.ellipsoid.radii.setValue(radii);
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var style = this.entity.attribute.style;
      var dragger;

      //位置中心点
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: this.entity._positions_draw[0],
        onDrag: function onDrag(dragger, position) {
          that.entity._positions_draw[0] = position;

          that.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //顶部的 高半径 编辑点
      var position = (0, _point.getPositionValue)(this.entity.position, this.viewer.clock.currentTime);
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: (0, _point.addPositionsHeight)(position, style.radii_z),
        type: draggerCtl.PointType.MoveHeight,
        tooltip: _Tooltip.message.dragger.editRadius,
        onDrag: function onDrag(dragger, position) {
          var positionZXD = that.entity._positions_draw[0];
          var length = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.radii_z = length; //高半径

          that.updateRadii(style);
          that.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        semiMajorAxis: Number(style.radii_x),
        semiMinorAxis: Number(style.radii_y),
        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
      });

      //长半轴上的坐标点
      var majorPos = outerPositions[0];
      var majorDragger = draggerCtl.createDragger(this.entityCollection, {
        position: majorPos,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius,
        onDrag: function onDrag(dragger, position) {
          var positionZXD = that.entity._positions_draw[0];
          var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
          position = (0, _point.setPositionsHeight)(position, newHeight);
          dragger.position = position;

          var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.radii_y = radius; //长半轴

          that.updateRadii(style);
          that.updateDraggers();
        }
      });
      dragger.majorDragger = majorDragger;
      this.draggers.push(majorDragger);

      //短半轴上的坐标点
      var minorPos = outerPositions[1];
      var minorDragger = draggerCtl.createDragger(this.entityCollection, {
        position: minorPos,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius,
        onDrag: function onDrag(dragger, position) {
          var positionZXD = that.entity._positions_draw[0];
          var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
          position = (0, _point.setPositionsHeight)(position, newHeight);
          dragger.position = position;

          var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.radii_x = radius; //短半轴

          that.updateRadii(style);
          that.updateDraggers();
        }
      });
      dragger.minorDragger = minorDragger;
      this.draggers.push(minorDragger);
    }
  }]);

  return EditEllipsoid;
}(_Edit.EditBase);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditWall = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(27);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditWall = exports.EditWall = function (_EditPolyline) {
  _inherits(EditWall, _EditPolyline);

  function EditWall() {
    _classCallCheck(this, EditWall);

    return _possibleConstructorReturn(this, (EditWall.__proto__ || Object.getPrototypeOf(EditWall)).apply(this, arguments));
  }

  _createClass(EditWall, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.wall;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      var that = this;

      var time = this.viewer.clock.currentTime;

      this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(time);
      this._minimumHeights = this.entity._minimumHeights || this.getGraphic().minimumHeights.getValue(time);
      this._maximumHeights = this.entity._maximumHeights || this.getGraphic().maximumHeights.getValue(time);
    }
    //坐标位置相关

  }, {
    key: "updateAttrForEditing",
    value: function updateAttrForEditing() {
      var style = this.entity.attribute.style;
      var position = this.getPosition();
      var len = position.length;

      this._maximumHeights = new Array(len);
      this._minimumHeights = new Array(len);

      for (var i = 0; i < len; i++) {
        var height = Cesium.Cartographic.fromCartesian(position[i]).height;
        this._minimumHeights[i] = height;
        this._maximumHeights[i] = height + Number(style.extrudedHeight);
      }

      //同步更新
      this.entity._maximumHeights = this._maximumHeights;
      this.entity._minimumHeights = this._minimumHeights;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this._positions_draw;
      this.entity._maximumHeights = this._maximumHeights;
      this.entity._minimumHeights = this._minimumHeights;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var clampToGround = this.isClampToGround();

      var positions = this.getPosition();
      var style = this.entity.attribute.style;
      var hasMidPoint = positions.length < this._maxPointNum; //是否有新增点

      for (var i = 0, len = positions.length; i < len; i++) {
        var loc = positions[i];

        //各顶点
        var dragger = draggerCtl.createDragger(this.entityCollection, {
          position: loc,
          clampToGround: clampToGround,
          onDrag: function onDrag(dragger, position) {
            positions[dragger.index] = position;

            //============高度调整拖拽点处理=============
            if (that.heightDraggers && that.heightDraggers.length > 0) {
              that.heightDraggers[dragger.index].position = (0, _point.addPositionsHeight)(position, style.extrudedHeight);
            }

            //============新增点拖拽点处理=============
            if (hasMidPoint) {
              if (dragger.index > 0) {
                //与前一个点之间的中点
                that.draggers[dragger.index * 2 - 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index - 1], new Cesium.Cartesian3());
              }
              if (dragger.index < positions.length - 1) {
                //与后一个点之间的中点
                that.draggers[dragger.index * 2 + 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index + 1], new Cesium.Cartesian3());
              }
            }

            //============整体平移移动点处理=============
            positionMove = (0, _point.centerOfMass)(positions);
            draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);

        //中间点，拖动后新增点
        if (hasMidPoint) {
          var nextIndex = i + 1;
          if (nextIndex < len) {
            var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
            var draggerMid = draggerCtl.createDragger(this.entityCollection, {
              position: midpoint,
              type: draggerCtl.PointType.AddMidPoint,
              tooltip: _Tooltip.message.dragger.addMidPoint,
              clampToGround: clampToGround,
              onDragStart: function onDragStart(dragger, position) {
                positions.splice(dragger.index, 0, position); //插入点
                that.updateAttrForEditing();
              },
              onDrag: function onDrag(dragger, position) {
                positions[dragger.index] = position;
              },
              onDragEnd: function onDragEnd(dragger, position) {
                that.updateDraggers();
              }
            });
            draggerMid.index = nextIndex;
            this.draggers.push(draggerMid);
          }
        }
      }

      //整体平移移动点
      var positionMove = (0, _point.centerOfMass)(positions);
      var draggerMove = draggerCtl.createDragger(this.entityCollection, {
        position: positionMove,
        type: draggerCtl.PointType.MoveAll,
        tooltip: _Tooltip.message.dragger.moveAll,
        clampToGround: clampToGround,
        onDrag: function onDrag(dragger, position) {
          // dragger.position = position;

          //记录差值
          var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
          positionMove = position;

          positions.forEach(function (pos, index, arr) {
            var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
            positions[index] = newPos;
          });

          //=====全部更新==========
          that.updateDraggers();
        }
      });
      this.draggers.push(draggerMove);

      //创建高程拖拽点
      this.bindHeightDraggers();
    }
    //高度调整拖拽点

  }, {
    key: "bindHeightDraggers",
    value: function bindHeightDraggers() {
      var that = this;

      this.heightDraggers = [];

      var positions = this.getPosition();
      var style = this.entity.attribute.style;
      var extrudedHeight = Number(style.extrudedHeight);

      for (var i = 0, len = positions.length; i < len; i++) {
        var loc = (0, _point.addPositionsHeight)(positions[i], extrudedHeight);

        var dragger = draggerCtl.createDragger(this.entityCollection, {
          position: loc,
          type: draggerCtl.PointType.MoveHeight,
          tooltip: _Tooltip.message.dragger.moveHeight,
          onDrag: function onDrag(dragger, position) {
            var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
            style.extrudedHeight = that.formatNum(thisHeight - that._minimumHeights[dragger.index], 2);

            for (var i = 0; i < positions.length; i++) {
              if (i == dragger.index) continue;
              that.heightDraggers[i].position = (0, _point.addPositionsHeight)(positions[i], style.extrudedHeight);
            }
            that.updateAttrForEditing();
          }
        });
        dragger.index = i;

        this.draggers.push(dragger);
        this.heightDraggers.push(dragger);
      }
    }
  }]);

  return EditWall;
}(_Edit.EditPolyline);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditPlane = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(16);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditPlane = exports.EditPlane = function (_EditBase) {
  _inherits(EditPlane, _EditBase);

  function EditPlane() {
    _classCallCheck(this, EditPlane);

    return _possibleConstructorReturn(this, (EditPlane.__proto__ || Object.getPrototypeOf(EditPlane)).apply(this, arguments));
  }

  _createClass(EditPlane, [{
    key: "setPositions",

    //外部更新位置
    value: function setPositions(position) {
      if (util.isArray(position) && position.length == 1) {
        position = position[0];
      }
      this.entity._positions_draw = position;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {}
  }, {
    key: "updatePlane",
    value: function updatePlane(style) {
      var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
      var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
      var dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
      this.entity.plane.dimensions.setValue(dimensions);
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this2 = this;

      var style = this.entity.attribute.style;
      var dragger;

      //位置中心点
      var positionZXD = this.entity._positions_draw;
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positionZXD,
        onDrag: function onDrag(dragger, position) {
          _this2.entity._positions_draw = position;
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //平面的x长度调整
      var offest = { x: 0, y: 0, z: 0 };
      switch (style.plane_normal) {
        case "x":
          offest.y = style.dimensionsX / 2;
          break;
        default:
          offest.x = style.dimensionsX / 2;
          break;
      }
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: (0, _matrix.getPositionTranslation)(positionZXD, offest),
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "长度(X方向)"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
          position = (0, _point.setPositionsHeight)(position, newHeight);
          dragger.position = position;

          var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.dimensionsX = radius * 2;

          _this2.updatePlane(style);
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //平面的y宽度调整
      if (style.plane_normal == "z") {
        dragger = draggerCtl.createDragger(this.entityCollection, {
          position: (0, _matrix.getPositionTranslation)(positionZXD, { x: 0, y: style.dimensionsY / 2, z: 0 }),
          type: draggerCtl.PointType.EditAttr,
          tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "宽度(Y方向)"),
          onDrag: function onDrag(dragger, position) {
            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
            position = (0, _point.setPositionsHeight)(position, newHeight);
            dragger.position = position;

            var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
            style.dimensionsY = radius * 2;

            _this2.updatePlane(style);
            _this2.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      } else {
        var offestTop = { x: 0, y: 0, z: 0 };
        switch (style.plane_normal) {
          case "x":
          case "y":
            offestTop.z = style.dimensionsY / 2;
            break;
          default:
            offestTop.y = style.dimensionsY / 2;
            break;
        }
        //顶部的 高半径 编辑点
        dragger = draggerCtl.createDragger(this.entityCollection, {
          position: (0, _matrix.getPositionTranslation)(positionZXD, offestTop),
          type: draggerCtl.PointType.MoveHeight,
          tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "宽度(Y方向)"),
          onDrag: function onDrag(dragger, position) {
            var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
            style.dimensionsY = radius * 2;

            _this2.updatePlane(style);
            _this2.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      }
    }
  }]);

  return EditPlane;
}(_Edit.EditBase);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditBox = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(16);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditBox = exports.EditBox = function (_EditBase) {
  _inherits(EditBox, _EditBase);

  function EditBox() {
    _classCallCheck(this, EditBox);

    return _possibleConstructorReturn(this, (EditBox.__proto__ || Object.getPrototypeOf(EditBox)).apply(this, arguments));
  }

  _createClass(EditBox, [{
    key: "setPositions",

    //外部更新位置
    value: function setPositions(position) {
      if (util.isArray(position) && position.length == 1) {
        position = position[0];
      }
      this.entity._positions_draw = position;
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {}
  }, {
    key: "updateBox",
    value: function updateBox(style) {
      var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
      var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
      var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
      var dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);

      this.entity.box.dimensions.setValue(dimensions);
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this2 = this;

      var style = this.entity.attribute.style;

      var dragger;

      //位置中心点
      var positionZXD = this.entity._positions_draw;
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positionZXD,
        onDrag: function onDrag(dragger, position) {
          _this2.entity._positions_draw = position;
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //x长度调整
      var positionX = (0, _matrix.getPositionTranslation)(positionZXD, { x: style.dimensionsX / 2, y: 0, z: 0 });
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positionX,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "长度(X方向)"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
          position = (0, _point.setPositionsHeight)(position, newHeight);
          dragger.position = position;

          var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.dimensionsX = radius * 2;

          _this2.updateBox(style);
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //y宽度调整
      var positionY = (0, _matrix.getPositionTranslation)(positionZXD, { x: 0, y: style.dimensionsY / 2, z: 0 });
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positionY,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "宽度(Y方向)"),
        onDrag: function onDrag(dragger, position) {
          var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
          position = (0, _point.setPositionsHeight)(position, newHeight);
          dragger.position = position;

          var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.dimensionsY = radius * 2;

          _this2.updateBox(style);
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      //z高度调整
      var positionZ = (0, _matrix.getPositionTranslation)(positionZXD, { x: 0, y: 0, z: style.dimensionsZ / 2 });
      dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positionZ,
        type: draggerCtl.PointType.MoveHeight,
        tooltip: _Tooltip.message.dragger.editRadius.replace("半径", "高度(Z方向)"),
        onDrag: function onDrag(dragger, position) {
          var radius = _this2.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
          style.dimensionsZ = radius * 2;

          _this2.updateBox(style);
          _this2.updateDraggers();
        }
      });
      this.draggers.push(dragger);
    }
  }]);

  return EditBox;
}(_Edit.EditBase);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewerEx = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _Draw = __webpack_require__(6);

var _BaseLayer = __webpack_require__(14);

var _KeyboardRoam = __webpack_require__(137);

var _Popup = __webpack_require__(138);

var _Tooltip = __webpack_require__(139);

var _ContextMenu = __webpack_require__(140);

var _defaultContextMenu = __webpack_require__(76);

var _Location = __webpack_require__(141);

var _MouseZoomStyle = __webpack_require__(142);

var _util2 = __webpack_require__(3);

var _util = _interopRequireWildcard(_util2);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _layer3 = __webpack_require__(24);

var _layer = _interopRequireWildcard(_layer3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//一些默认值的修改【by 木遥】
Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(89.5, 20.4, 110.4, 61.2); //更改默认视域

//Viewer扩展

var ViewerEx = exports.ViewerEx = function (_DasClass) {
  _inherits(ViewerEx, _DasClass);

  //========== 构造方法 ==========
  function ViewerEx(viewer, config) {
    _classCallCheck(this, ViewerEx);

    var _this = _possibleConstructorReturn(this, (ViewerEx.__proto__ || Object.getPrototypeOf(ViewerEx)).call(this, config));

    _this.viewer = viewer;
    _this.viewer.das = _this; //要记录下，内部用
    _this.config = Cesium.defaultValue(config, {});

    _this._isFlyAnimation = false;
    _this.crs = Cesium.defaultValue(_this.config.crs, "3857"); //坐标系

    var that = _this;
    // var ipstr = window.location.hostname + ":" + (window.location.port || 80);
    // var serverIP = that.config.serverIP || "http://" + ipstr;
    // $.ajax({
    //   type: "GET",
    //   async: false,
    //   url: serverIP + "/auth/getAllResource?datetime=" + new Date(),
    //   success: function success(data) {
    //     if (data && data.data) {
    //       data = data.data;
    //       var tempArr = {};
    //       if (data.length > 0) {
    //         that.config.operationallayers.push({
    //           "id": 80,
    //           "name": "后台服务数据",
    //           "type": "group"
    //         });
    //       }
    //       for (var i = 0; i < data.length; i++) {
    //         var item = data[i];
    //         item.format = item.format.toLowerCase();
    //         var layersItem;
    //         switch (item.format) {
    //           case "3dtiles":
    //             if (!tempArr["3dtiles"]) {
    //               tempArr["3dtiles"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 81,
    //                 "pid": 80,
    //                 "name": "倾斜模型",
    //                 "type": "group"
    //               });
    //             }
    //             layersItem = {
    //               cullWithChildrenBounds: false,
    //               dynamicScreenSpaceError: true,
    //               flyTo: false,
    //               hasLayer: true,
    //               id: Number("8010" + (20 + i)),
    //               maximumMemoryUsage: 1024,
    //               maximumScreenSpaceError: 16,
    //               name: item.name,
    //               order: 87,
    //               pid: 81,
    //               preferLeaves: true,
    //               skipLevelOfDetail: true,
    //               type: item.format,
    //               url: item.url,
    //               visible: false,
    //               _key: ""
    //             };
    //             break;
    //           case "geojson":
    //             if (!tempArr["geojson"]) {
    //               tempArr["geojson"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 82,
    //                 "pid": 80,
    //                 "name": "GEOJSON数据",
    //                 "type": "group"
    //               });
    //             }
    //             layersItem = {
    //               "pid": 82,
    //               "type": item.format,
    //               "name": item.name,
    //               "url": item.url,
    //               "symbol": {
    //                 "styleOptions": {
    //                   "clampToGround": true
    //                 }
    //               }
    //             };
    //             break;
    //           case "kml":
    //             if (!tempArr["kml"]) {
    //               tempArr["kml"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 83,
    //                 "pid": 80,
    //                 "name": "KML数据",
    //                 "type": "group"
    //               });
    //             }
    //             layersItem = {
    //               "pid": 83,
    //               "type": item.format,
    //               "name": item.name,
    //               "url": item.url,
    //               "popup": "all"
    //             };
    //             break;
    //           case "gltf":
    //             if (!tempArr["gltf"]) {
    //               tempArr["gltf"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 84,
    //                 "pid": 80,
    //                 "name": "GLTF数据",
    //                 "type": "group"
    //               });
    //             }
    //             layersItem = {
    //               "pid": 84,
    //               "type": item.format,
    //               "name": item.name,
    //               "url": item.url,
    //               "position": {
    //                 "y": 31.821083,
    //                 "x": 117.21832,
    //                 "z": 59.87
    //               },
    //               "style": {
    //                 "scale": 10,
    //                 "heading": -93
    //               },
    //               "popup": "示例信息，测试数据",
    //               "center": {
    //                 "y": 31.821083,
    //                 "x": 117.21832,
    //                 "z": 832.64,
    //                 "heading": 2.3,
    //                 "pitch": -39.2,
    //                 "roll": 0
    //               }
    //             };
    //             break;
    //           case "wmts":
    //             if (!tempArr["wmts"]) {
    //               tempArr["wmts"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 85,
    //                 "pid": 80,
    //                 "name": "wmts数据",
    //                 "type": "group"
    //               });
    //             }

    //             var properties;
    //             var bbox;
    //             if(item.properties) {
    //               properties = JSON.parse(item.properties);
    //               bbox = properties && properties.bbox && properties.bbox.split(',');
    //             }

    //             var maxLevel = 18;
    //             var matrixIds = new Array(maxLevel);
    //             for (var z = 0; z <= maxLevel; z++) {
    //               matrixIds[z] = properties.crs + ':' + (z).toString();
    //             }

    //             layersItem = {
    //               flyTo: false,
    //               hasLayer: true,
    //               id: Number("8010" + (20 + i)),
    //               name: item.name||"wmts数据",
    //               pid: 85,
    //               parameters: {
    //                 "transparent": true,
    //                 "format": item.Format
    //               },
    //               style: "",
    //               tileMatrixSetID: properties && properties.crs,
    //               layer: properties && properties.layer,
    //               extent: {
    //                 xmin: Number(bbox[0]),
    //                 ymin: Number(bbox[1]),
    //                 xmax: Number(bbox[2]),
    //                 ymax: Number(bbox[3]),
    //               },
    //               crs: properties && properties.crs,
    //               maximumLevel: 13,
    //               tileMatrixLabels: matrixIds,
    //               type: "wmts",
    //               url: item.url,
    //               visible: false,

    //             };
    //             break;
    //           case "wfs":
    //             if (!tempArr["wfs"]) {
    //               tempArr["wfs"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 86,
    //                 "pid": 80,
    //                 "name": "wfs数据",
    //                 "type": "group"
    //               });
    //             }

    //             var properties;
    //             var bbox;
    //             if(item.properties) {
    //               properties = JSON.parse(item.properties);
    //               bbox = properties && properties.bbox && properties.bbox.split(',');
    //             }

    //             layersItem = {
    //               flyTo: false,
    //               hasLayer: true,
    //               id: Number("8010" + (20 + i)),
    //               name: item.name||"WFS数据",
    //               pid: 86,
    //               type: "wfs",
    //               url: item.url,
    //               layer: properties && properties.layer,
    //               extent: {
    //                 xmin: Number(bbox[0]),
    //                 ymin: Number(bbox[1]),
    //                 xmax: Number(bbox[2]),
    //                 ymax: Number(bbox[3]),
    //               },
    //               crs: properties && properties.crs,
    //               minimumLevel: 13,
    //               alpha: 0.9,
    //               visible: false,

    //             };
    //             break;
    //           case "wms":
    //             if (!tempArr["wms"]) {
    //               tempArr["wms"] = true;
    //               that.config.operationallayers.push({
    //                 "id": 87,
    //                 "pid": 80,
    //                 "name": "wms数据",
    //                 "type": "group"
    //               });
    //             }

    //             var properties;
    //             var bbox;
    //             if(item.properties) {
    //               properties = JSON.parse(item.properties);
    //               bbox = properties && properties.bbox && properties.bbox.split(',');
    //             }

    //             layersItem = {
    //               flyTo: false,
    //               hasLayer: true,
    //               id: Number("8010" + (20 + i)),
    //               name: item.name||"wms数据",
    //               pid: 87,
    //               layers: properties && properties.layer,
    //               extent: {
    //                 xmin: Number(bbox[0]),
    //                 ymin: Number(bbox[1]),
    //                 xmax: Number(bbox[2]),
    //                 ymax: Number(bbox[3]),
    //               },
    //               crs: properties && properties.crs,
    //               maximumLevel: 13,
    //               type: "wms",
    //               url: item.url,
    //               visible: false,
    //             };
    //             break;
    //           default:
    //             continue;
    //         }

    //         that.config.operationallayers.push(layersItem);
    //       }

    //       //绑定添加相关控件
    //       that._addControls();
    //       //优化viewer默认参数相关的
    //       that._optimization();
    //       //根据参数进行设置相关的
    //       that._initForOpts();
    //       //绑定处理的事件
    //       that._initEvent();
    //       that._initLayers();
    //     } else {
    //       //绑定添加相关控件
    //       that._addControls();
    //       //优化viewer默认参数相关的
    //       that._optimization();
    //       //根据参数进行设置相关的
    //       that._initForOpts();
    //       //绑定处理的事件
    //       that._initEvent();
    //       that._initLayers();
    //     }
    //   },
    //   error: function error(XMLHttpRequest, textStatus, errorThrown) {
    //     //绑定添加相关控件
    //     that._addControls();
    //     //优化viewer默认参数相关的
    //     that._optimization();
    //     //根据参数进行设置相关的
    //     that._initForOpts();
    //     //绑定处理的事件
    //     that._initEvent();
    //     that._initLayers();
    //   }
    // });
    //绑定添加相关控件
    //this._addControls();

    return _this;
  }
  //========== 对外属性 ==========
  //标识只拾取模型上的点


  _createClass(ViewerEx, [{
    key: "onClick",
    value: function onClick(fun) {
      //兼容历史命名
      this.on(_DasClass2.eventType.click, fun);
    }

    //键盘漫游

  }, {
    key: "_optimization",


    //========== 方法 ==========

    //优化viewer默认参数相关的
    value: function _optimization() {
      var that = this;
      var viewer = this.viewer;

      //二三维切换不用动画
      if (this.viewer.sceneModePicker) this.viewer.sceneModePicker.viewModel.duration = 0.0;

      //解决Cesium显示画面模糊的问题 https://zhuanlan.zhihu.com/p/41794242 【1.63已修复，1.66又出现了】
      this.viewer._cesiumWidget._supportsImageRenderingPixelated = Cesium.FeatureDetection.supportsImageRenderingPixelated();
      this.viewer._cesiumWidget._forceResize = true;
      if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {
        var _dpr = window.devicePixelRatio;
        // 适度降低分辨率
        while (_dpr >= 2.0) {
          _dpr /= 2.0;
        }
        this.viewer.resolutionScale = _dpr;
      }
    }
    //根据参数进行设置相关的

  }, {
    key: "_initForOpts",
    value: function _initForOpts() {
      var that = this;
      this.viewer.cesiumWidget.creditContainer.style.display = "none"; //去cesium logo

      //默认定位地点相关设置，默认home键和初始化镜头视角
      if (this.viewer.homeButton) {
        this.viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (commandInfo) {
          that.centerAtHome();
          commandInfo.cancel = true;
        });
      }
      this.centerAtHome({ duration: 0 });

      //地球一些属性设置
      var scene = this.viewer.scene;
      scene.globe.baseColor = Cesium.Color.fromCssColorString(this.config.baseColor || "#546a53"); //地表背景色

      if (this.config.backgroundColor) scene.backgroundColor = Cesium.Color.fromCssColorString(this.config.backgroundColor); //空间背景色

      if (this.config.style) {
        //深度监测
        scene.globe.depthTestAgainstTerrain = this.config.style.testTerrain;

        //光照渲染（阳光照射区域高亮）
        scene.globe.enableLighting = this.config.style.lighting;

        //大气渲染
        scene.skyAtmosphere.show = this.config.style.atmosphere;
        scene.globe.showGroundAtmosphere = this.config.style.atmosphere;

        //雾化效果
        scene.fog.enabled = this.config.style.fog == undefined ? true : this.config.style.fog;

        //设置无地球模式 （单模型是可以设置为false）
        scene.globe.show = Cesium.defaultValue(this.config.style.globe, true);
        scene.moon.show = Cesium.defaultValue(this.config.style.moon, scene.globe.show);
        scene.sun.show = Cesium.defaultValue(this.config.style.sun, scene.globe.show);
        scene.skyBox.show = Cesium.defaultValue(this.config.style.skyBox, scene.globe.show);
      }

      //限制缩放级别
      scene.screenSpaceCameraController.maximumZoomDistance = Cesium.defaultValue(this.config.maxzoom, 20000000); //变焦时相机位置的最大值（以米为单位）
      scene.screenSpaceCameraController.minimumZoomDistance = Cesium.defaultValue(this.config.minzoom, 1); //变焦时相机位置的最小量级（以米为单位）。默认为1.0。

      scene.screenSpaceCameraController._zoomFactor = 3; //鼠标滚轮放大的步长参数
      scene.screenSpaceCameraController.minimumCollisionTerrainHeight = 15000000; //低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
    }
    //绑定添加相关控件

  }, {
    key: "_addControls",
    value: function _addControls() {
      var that = this;

      //绑定popup
      this._popup = new _Popup.Popup(this.viewer, {});

      //绑定tooltip
      this._tooltip = new _Tooltip.Tooltip(this.viewer, {});

      //绑定键盘漫游
      this._keyboardRoam = new _KeyboardRoam.KeyboardRoam({ viewer: this.viewer });

      //绑定右键菜单
      if (this.config.contextmenu) {
        this._contextmenu = new _ContextMenu.ContextMenu(this.viewer);

        this.contextmenuItems = this.defaultContextmenuItems;
        this._contextmenu.resetDefault = function () {
          //右键菜单还原为默认的
          that.contextmenuItems = that.defaultContextmenuItems;
        };
      }

      //导航工具栏控件
      if (this.config.navigation) {
        this._addNavigationWidget(this.config.navigation);
      }

      //鼠标提示控件
      if (this.config.location) {
        this._location = new _Location.Location(this.viewer, this.config.location);
      }

      //鼠标滚轮缩放美化样式
      if (this.config.mouseZoom && _util.isPCBroswer()) {
        this._mouseZoomStyle = new _MouseZoomStyle.MouseZoomStyle(this.viewer, this.config.mouseZoom);
      }
    }
    //绑定处理的事件

  }, {
    key: "_initEvent",
    value: function _initEvent() {
      var _this2 = this;

      this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      //单击事件
      this.handler.setInputAction(function (event) {
        _this2.fire(_DasClass2.eventType.click, event);
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
      //鼠标移动事件
      this.handler.setInputAction(function (event) {
        _this2.fire(_DasClass2.eventType.mouseMove, event);
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      this.handler.setInputAction(function (event) {
        _this2.fire(_DasClass2.eventType.dblClick, event);
      }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

      this.handler.setInputAction(function (event) {
        _this2.fire(_DasClass2.eventType.rightClick, event);
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    }

    //没有id的图层，进行id赋值处理

  }, {
    key: "getNextId",
    value: function getNextId() {
      while (this.arrIdx.indexOf(this._tempIdx) != -1) {
        this._tempIdx++;
      }
      this.arrIdx.push(this._tempIdx);
      return this._tempIdx;
    }
    //添加内部封装的BaseLayer图层到OperationalLayer进行图层控制

  }, {
    key: "addOperationalLayer",
    value: function addOperationalLayer(item) {
      var layer;
      if (item instanceof _BaseLayer.BaseLayer) {
        layer = item;
        item = layer.config;
      } else {
        var _visible = item.visible;
        delete item.visible;

        layer = new _BaseLayer.BaseLayer(this.viewer, item);
        layer._visible = _visible;

        if (!item.type)
          //外部通过bindToLayerControl添加的
          item.type = "base";
      }

      if (!item.name) item.name = "未命名";
      if (!item.id) item.id = this.getNextId();else {
        if (this.layers[item.id]) {
          daslog.warn("id存在冲突，已重新赋值id，或viewer.das.getNextId() 手动获取", item);
          item.id = this.getNextId();
        }
      }
      if (!item.pid) item.pid = -1;

      item.hasLayer = true;

      this.config.operationallayers.push(item);
      this.arrOperationallayers.push(layer);
      this.layers[item.id] = layer;

      return layer;
    }
  }, {
    key: "removeOperationalLayer",
    value: function removeOperationalLayer(id) {
      for (var i = 0; i < this.config.operationallayers.length; i++) {
        var item = this.config.operationallayers[i];
        if (item.id == id) {
          this.config.operationallayers.splice(i, 1);
          break;
        }
      }
      for (var _i = 0; _i < this.arrOperationallayers.length; _i++) {
        var _item = this.arrOperationallayers[_i];
        if (_item.config.id == id) {
          this.arrOperationallayers.splice(_i, 1);
          break;
        }
      }

      delete this.layers[id];
    }
    //处理图层

  }, {
    key: "_initLayers",
    value: function _initLayers() {
      this.config.basemaps = this.config.basemaps || [];
      this.config.operationallayers = this.config.operationallayers || [];

      var basemapsCfg = this.config.basemaps;
      var operationallayersCfg = this.config.operationallayers;

      var layersCfg = []; //计算order
      var guid = function guid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = Math.random() * 16 | 0,
              v = c == 'x' ? r : r & 0x3 | 0x8;
          return v.toString(16);
        });
      };
      //记录所有id，方便计算nextid
      this._tempIdx = 1;
      this.arrIdx = [];
      for (var i = 0; i < basemapsCfg.length; i++) {
        var item = basemapsCfg[i];

        if (item.id) this.arrIdx.push(item.id);
      }
      for (var _i2 = 0; _i2 < operationallayersCfg.length; _i2++) {
        var _item2 = operationallayersCfg[_i2];
        if (_item2 != null) {
          if (!_item2.id) {
            _item2.id = guid();
          }
          if (_item2.id) this.arrIdx.push(_item2.id);
        }
      }
      //  if (item.id) this.arrIdx.push(item.id);
      //}

      var objLayers = {}; //图层对象
      var arrBasemaps = []; //底图数组
      var arrOperationallayers = []; //可叠加图层

      //底图处理
      if (!this.config.baseLayerPicker) {
        //不能取消，如果取消，使用baseLayerPicker时无法切换了
        if (basemapsCfg && basemapsCfg.length > 0) {
          for (var _i3 = 0; _i3 < basemapsCfg.length; _i3++) {
            var _item3 = basemapsCfg[_i3];
            if (!_item3.name) _item3.name = "未命名";
            if (!_item3.id) _item3.id = this.getNextId();
            if (!_item3.pid) _item3.pid = -1;

            if (_item3.visible && _item3.crs) this.crs = _item3.crs;

            var layer = _layer.createLayer(this.viewer, _item3, this.config.serverURL);
            if (layer) {
              _item3.hasLayer = true;
              objLayers[_item3.id] = layer;
              arrBasemaps.push(layer);

              if (this.config.onAddLayer) {
                //加图层回调方法
                this.config.onAddLayer(_item3, layer);
              }
            }

            layersCfg.push(_item3);
            if (_item3.type == "group" && _item3.layers) {
              for (var idx = 0; idx < _item3.layers.length; idx++) {
                var childitem = _item3.layers[idx];
                childitem.pid = _item3.id;
                childitem.id = this.getNextId();
                layersCfg.push(childitem);
              }
            }
          }
        }
      }
      this.arrBasemaps = arrBasemaps;

      //可叠加图层
      if (operationallayersCfg && operationallayersCfg.length > 0) {
        for (var _i4 = 0; _i4 < operationallayersCfg.length; _i4++) {
          var _item4 = operationallayersCfg[_i4];
          if (!_item4.name) _item4.name = "未命名";
          if (!_item4.id) _item4.id = this.getNextId();
          if (!_item4.pid) _item4.pid = -1;

          var _layer2 = _layer.createLayer(this.viewer, _item4, this.config.serverURL);
          if (_layer2) {
            _item4.hasLayer = true;
            arrOperationallayers.push(_layer2);
            objLayers[_item4.id] = _layer2;

            if (this.config.onAddLayer) {
              //加图层回调方法
              this.config.onAddLayer(_item4, _layer2);
            }
          }

          layersCfg.push(_item4);
          if (_item4.type == "group" && _item4.layers) {
            for (var _idx = 0; _idx < _item4.layers.length; _idx++) {
              var _childitem = _item4.layers[_idx];
              _childitem.pid = _item4.id;
              _childitem.id = this.getNextId();
              layersCfg.push(_childitem);
            }
          }
        }
      }
      this.arrOperationallayers = arrOperationallayers;
      this.layers = objLayers;

      //计算 顺序字段,
      for (var _i5 = 0; _i5 < layersCfg.length; _i5++) {
        var _item5 = layersCfg[_i5];

        //计算层次顺序
        var order = Number(_item5.order);
        if (isNaN(order)) order = _i5;
        _item5.order = order;

        //图层的处理
        if (objLayers[_item5.id] != null) {
          objLayers[_item5.id].setZIndex(order);
        }
      }
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return _util.clone(this.config, ["_layer", "_layers", "_parent"]);
    }

    //point的方法兼容到viewer.das直接用

  }, {
    key: "getCenter",
    value: function getCenter(isToWgs) {
      return point.getCenter(this.viewer, isToWgs);
    }
  }, {
    key: "getExtent",
    value: function getExtent(opts) {
      return point.getExtent(this.viewer, opts);
    }
  }, {
    key: "getCameraView",
    value: function getCameraView(isToWgs) {
      return point.getCameraView(this.viewer, isToWgs);
    }
  }, {
    key: "getSurfaceHeight",
    value: function getSurfaceHeight(position, opts) {
      return point.getSurfaceHeight(this.viewer.scene, position, opts);
    }

    //键盘漫游，兼容历史方法

  }, {
    key: "keyboard",
    value: function keyboard(isbind, opts) {
      if (isbind) this._keyboardRoam.bind(opts);else this._keyboardRoam.unbind();
    }
  }, {
    key: "keyboardAuto",
    value: function keyboardAuto() {
      return this._keyboardRoam.enable = !this._keyboardRoam.enable;
    }

    //获取指定图层 keyname默认为名称

  }, {
    key: "getLayer",
    value: function getLayer(key, keyname) {
      if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
        //直接传入config的object对象时
        if (Cesium.defined(key.id)) return this.layers[key.id];
      } else {
        if (keyname == null) {
          if (_util.isNumber(key)) keyname = "id";else keyname = "name";
        }

        var layersCfg = this.arrBasemaps;
        if (layersCfg && layersCfg.length > 0) {
          for (var i = 0; i < layersCfg.length; i++) {
            var item = layersCfg[i];
            if (item == null || item.config[keyname] != key) continue;
            return item;
          }
        }

        layersCfg = this.arrOperationallayers;
        if (layersCfg && layersCfg.length > 0) {
          for (var _i6 = 0; _i6 < layersCfg.length; _i6++) {
            var _item6 = layersCfg[_i6];
            if (_item6 == null || _item6.config[keyname] != key) continue;
            return _item6;
          }
        }
      }

      return null;
    }
    //获取当前显示的底图

  }, {
    key: "getBasemap",
    value: function getBasemap() {
      var layersCfg = this.arrBasemaps;
      if (layersCfg.length == 0) {
        if (this.viewer.baseLayerPicker) {
          return this.viewer.baseLayerPicker.viewModel.selectedImagery;
        }
        return;
      }

      for (var i = 0; i < layersCfg.length; i++) {
        var item = layersCfg[i];
        if (item.config.type == "group" && item.config.layers == null) continue;

        if (item._visible) {
          return item;
        }
      }
    }
    //根据config配置的id或name属性，更新显示指定的地图底图

  }, {
    key: "changeBasemap",
    value: function changeBasemap(idorname) {
      var layersCfg = this.arrBasemaps;
      if (layersCfg.length == 0) {
        if (this.viewer.baseLayerPicker) {
          var baseLayer = this.viewer.baseLayerPicker.viewModel;

          var sel;
          if (idorname) {
            var index;
            for (var i = 0; i < this.config.basemaps.length; i++) {
              var item = this.config.basemaps[i];
              if (item.type == "group" && item.layers == null) continue;

              if (idorname == item || idorname == item.name || idorname == item.id) {
                index = i;
                break;
              }
            }
            if (Cesium.defined(index)) {
              sel = baseLayer.imageryProviderViewModels[index];
            }
          }
          baseLayer.selectedImagery = sel;
        }
        return;
      }

      var basemap;
      for (var _i7 = 0; _i7 < layersCfg.length; _i7++) {
        var _item7 = layersCfg[_i7];
        if (_item7.config.type == "group" && _item7.config.layers == null) continue;

        if (idorname == _item7 || idorname == _item7.config.name || idorname == _item7.config.id) {
          _item7.setVisible(true);
          this.crs = _item7.config.crs; //坐标系

          basemap = _item7;
        } else {
          _item7.setVisible(false);
        }
      }
      return basemap;
    }
    //是否有地形数据

  }, {
    key: "hasTerrain",
    value: function hasTerrain() {
      if (this.terrainProvider == null) return false;
      return _layer.hasTerrain(this.viewer);
    }
    //更新地形，参数传入是否显示地形

  }, {
    key: "updateTerrainProvider",
    value: function updateTerrainProvider(isStkTerrain) {
      if (isStkTerrain) {
        if (this.terrainProvider == null) {
          var cfg = this.config.terrain;
          if (cfg && cfg.url) {
            if (this.config.serverURL) {
              cfg.url = cfg.url.replace("$serverURL$", this.config.serverURL);
            }
            cfg.url = cfg.url.replace("$hostname$", location.hostname).replace("$host$", location.host);
          }
          this.terrainProvider = _layer.getTerrainProvider(cfg);
        }
        this.viewer.terrainProvider = this.terrainProvider;
      } else {
        this.viewer.terrainProvider = _layer.getEllipsoidTerrain();
      }
    }

    //获取当前地图坐标系，值为gcj时表示是国测局偏移坐标

  }, {
    key: "getCrs",
    value: function getCrs() {
      return this.crs;
    }
    //在不同坐标系情况下，转换“目标坐标值”至“地图坐标系”一致的坐标

  }, {
    key: "point2map",
    value: function point2map(point) {
      var temp;
      switch (this.crs) {
        case "gcj":
          point = _util.clone(point);
          temp = pointconvert.wgs2gcj([point.x, point.y]);
          point.x = temp[0];
          point.y = temp[1];
          return point;
        case "bd":
        case "baidu":
          point = _util.clone(point);
          temp = pointconvert.wgs2bd([point.x, point.y]);
          point.x = temp[0];
          point.y = temp[1];
          return point;
        default:
          return point;
      }
    }
    //在不同坐标系情况下 ，获取地图上的坐标后，转为wgs标准坐标系坐标值

  }, {
    key: "point2wgs",
    value: function point2wgs(point) {
      var temp;
      switch (this.crs) {
        case "gcj":
          point = _util.clone(point);
          temp = pointconvert.gcj2wgs([point.x, point.y]);
          point.x = temp[0];
          point.y = temp[1];
          return point;
        case "bd":
        case "baidu":
          point = _util.clone(point);
          temp = pointconvert.bd2wgs([point.x, point.y]);
          point.x = temp[0];
          point.y = temp[1];
          return point;
        default:
          return point;
      }
    }

    //定位到 多个区域  顺序播放

  }, {
    key: "centerAtArr",
    value: function centerAtArr(arr, enfun) {
      this.cancelCenterAt();

      this.arrCenterTemp = arr;
      this._isCenterAtArr = true;
      this._centerAtArrItem(0, enfun);
    }
  }, {
    key: "_centerAtArrItem",
    value: function _centerAtArrItem(i, enfun) {
      var that = this;
      if (!this._isCenterAtArr || i < 0 || i >= this.arrCenterTemp.length) {
        this._isCenterAtArr = false;
        //daslog.log('centerAtArr视角切换全部结束');
        if (enfun) enfun();
        return;
      }
      var centeropt = this.arrCenterTemp[i];

      //daslog.log('centerAtArr开始视角切换，第' + i + '点');
      if (centeropt.onStart) centeropt.onStart();

      this.centerAt(centeropt, {
        duration: centeropt.duration,
        complete: function complete() {
          if (centeropt.onEnd) centeropt.onEnd();

          var stopTime = Cesium.defaultValue(centeropt.stop, 1);
          //daslog.log('centerAtArr第' + i + '点切换结束，将在此停留' + stopTime + '秒');

          setTimeout(function () {
            that._centerAtArrItem(++i, enfun);
          }, stopTime * 1000);
        },
        cancle: function cancle() {
          this._isCenterAtArr = false;
          if (enfun) enfun();
        }
      });
    }
  }, {
    key: "cancelCenterAt",
    value: function cancelCenterAt() {
      this._isCenterAtArr = false;
      this.viewer.camera.cancelFlight(); //取消飞行
    }
  }, {
    key: "centerAtHome",
    value: function centerAtHome(options) {
      this.centerAt(this.config.extent || this.config.center, options);
    }
    //地球定位至指定区域 ，options支持viewer.camera.flyTo所有参数

  }, {
    key: "centerAt",
    value: function centerAt(centeropt, options) {
      if (options == null) options = {};else if (_util.isNumber(options)) {
        options = {
          //兼容旧版本
          duration: options
        };
      }

      if (centeropt == null) {
        //让镜头飞行（动画）到配置默认区域
        options.isWgs84 = true;
        centeropt = this.config.extent || this.config.center;
      }
      if (centeropt == null) return;

      var optsClone = {};
      for (var key in options) {
        optsClone[key] = options[key];
      }

      if (centeropt.xmin && centeropt.xmax && centeropt.ymin && centeropt.ymax) {
        //使用extent配置，相机可视范围
        var xmin = centeropt.xmin;
        var xmax = centeropt.xmax;
        var ymin = centeropt.ymin;
        var ymax = centeropt.ymax;

        if (optsClone.isWgs84) {
          //坐标转换为wgs
          var pt1 = this.point2map({
            x: xmin,
            y: ymin
          });
          xmin = pt1.x;
          ymin = pt1.y;

          var pt2 = this.point2map({
            x: xmax,
            y: ymax
          });
          xmax = pt2.x;
          ymax = pt2.y;
        }

        //方法1：绑定范围 （存在区域在地形下的情况，极端示例在珠峰测试）
        // optsClone.destination = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);

        //方法2：(计算矩形边长+高度后定位)
        var centerx = (xmin + xmax) / 2;
        var centery = (ymin + ymax) / 2;
        //求矩形最大边的边长
        var recta = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
        var granularity = Math.max(recta.height, recta.width);
        var len = Cesium.Math.chordLength(granularity, this.viewer.scene.globe.ellipsoid.maximumRadius);
        if (Cesium.defined(options.minHeight) && len < options.minHeight) {
          len = options.minHeight;
        }
        if (Cesium.defined(options.maxHeight) && len > options.maxHeight) {
          len = options.maxHeight;
        }
        //求高度
        var height = Cesium.defaultValue(centeropt.height, 0);
        if (height == 0) {
          height = point.getSurfaceHeight(this.viewer.scene, Cesium.Cartesian3.fromDegrees(centerx, centery));
        }

        optsClone.destination = Cesium.Cartesian3.fromDegrees(centerx, centery, len + height); //经度、纬度、高度
        optsClone.orientation = {
          heading: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.heading, 0)), //绕垂直于地心的轴旋转
          pitch: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.pitch, -90)), //绕纬度线旋转
          roll: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.roll, 0)) //绕经度线旋转
        };
        //方法2   end

        this.viewer.camera.flyTo(optsClone);
      } else {
        //存在hpr，为相机定位的方式
        if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

        var _height = Cesium.defaultValue(optsClone.minz, 2500);
        if (this.viewer.camera.positionCartographic.height < _height) _height = this.viewer.camera.positionCartographic.height;
        if (centeropt.z != null && centeropt.z != 0) _height = centeropt.z;

        optsClone.destination = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, _height); //经度、纬度、高度
        optsClone.orientation = {
          heading: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.heading, 0)), //绕垂直于地心的轴旋转
          pitch: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.pitch, -90)), //绕纬度线旋转
          roll: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.roll, 0)) //绕经度线旋转
        };
        this.viewer.camera.flyTo(optsClone);
      }
    }
    //定位至目标点， options支持viewer.camera.flyToBoundingSphere所有参数

  }, {
    key: "centerPoint",
    value: function centerPoint(centeropt, options) {
      if (options == null) options = {};

      var optsClone = {};
      for (var key in options) {
        optsClone[key] = options[key];
      }

      //目标点位置
      if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

      var position;
      if (centeropt instanceof Cesium.Cartesian3) position = centeropt;else position = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, Cesium.defaultValue(centeropt.z, 0)); //经度、纬度、高度
      var radius = Cesium.defaultValue(options.radius, 1000);

      optsClone.offset = {
        heading: Cesium.defined(options.heading) ? Cesium.Math.toRadians(options.heading) : this.viewer.camera.heading,
        pitch: Cesium.defined(options.pitch) ? Cesium.Math.toRadians(options.pitch) : this.viewer.camera.pitch,
        range: radius
      };
      //
      this.viewer.camera.flyToBoundingSphere(new Cesium.BoundingSphere(position, 0), optsClone);
    }

    //视角飞行定位到entiy处

  }, {
    key: "flyTo",
    value: function flyTo(entity, opts) {
      if (!entity) return;

      opts = opts || {};
      opts.scale = Cesium.defaultValue(opts.scale, 0.5);

      if (entity.entities && entity.entities instanceof Cesium.EntityCollection) {
        entity = entity.entities.values;
      }

      if (_util.isArray(entity)) {
        if (entity.length == 0) return;

        if (entity.length == 1) {
          this.flyTo(entity[0], opts);
        } else {
          //entity是数组
          var extent = point.getExtent(entity, opts);
          if (extent.xmin == extent.xmax || extent.ymin == extent.ymax) {
            //说明是单个的点数据（也有可能重合的多个点）
            this.flyTo(entity[0], opts);
          } else if (extent.xmax - extent.xmin > 200) {
            //跨了180度线时
            this.viewer.flyTo(entity[0], opts);
          } else {
            //是矩形区域时
            this.centerAt(extent, opts);
          }
        }
      } else if (entity instanceof Cesium.Entity) {
        //点状数据时
        if (entity.position) {
          var position = point.getPositionValue(entity.position);
          this.centerPoint(position, opts);
        }
        //圆数据时
        else if (entity.ellipse) {
            var radius1 = entity.ellipse.semiMajorAxis.getValue(_util.currentTime());
            var radius2 = entity.ellipse.semiMinorAxis.getValue(_util.currentTime());

            opts.radius = Math.max(radius1, radius2) * 3 * (1 + opts.scale);

            var _position = point.getPositionValue(entity.position);
            this.centerPoint(_position, opts);
          } else {
            var _extent = point.getExtent(entity, opts);
            if (_extent.xmin == _extent.xmax || _extent.ymin == _extent.ymax) {
              //说明是单个的点数据（也有可能重合的多个点）
              var _position2 = {
                x: _extent.xmin,
                y: _extent.ymin
              };
              this.centerPoint(_position2, opts);
            } else if (_extent.xmax - _extent.xmin > 200) {
              //跨了180度线时
              this.viewer.flyTo(entity, opts);
            } else {
              //是矩形区域时
              this.centerAt(_extent, opts);
            }
          }
      } else {
        this.viewer.flyTo(entity, opts);
      }
    }

    //是否在调用了openFlyAnimation正在进行飞行动画

  }, {
    key: "isFlyAnimation",
    value: function isFlyAnimation() {
      return this._isFlyAnimation;
    }
    //开场动画，动画播放地球飞行定位指指定区域（默认为config.josn中配置的视域）

  }, {
    key: "openFlyAnimation",
    value: function openFlyAnimation(opts) {
      if (typeof opts === "function") {
        opts = { callback: opts };
      }
      opts = opts || {};

      var that = this;
      var viewer = this.viewer;

      var view = opts.center || point.getCameraView(viewer); //默认为原始视角

      this._isFlyAnimation = true;
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(-85.16, 13.71, 23000000.0)
      });
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, 23000000.0),
        duration: opts.duration1 || 2,
        easingFunction: opts.easingFunction1 || Cesium.EasingFunction.LINEAR_NONE,
        complete: function complete() {
          var z = Cesium.defaultValue(view.z, 90000);
          if (z < 200000 && view.pitch != -90) {
            z = z * 1.2 + 8000;
            viewer.camera.flyTo({
              destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, z),
              duration: opts.duration2,
              easingFunction: opts.easingFunction2,
              complete: function complete() {
                that.centerAt(view, {
                  duration: opts.duration3 || 2,
                  easingFunction: opts.easingFunction3,
                  complete: function complete() {
                    that._isFlyAnimation = false;
                    if (opts.callback) opts.callback();
                    if (that.openFlyAnimationEndFun) {
                      that.openFlyAnimationEndFun();
                      delete that.openFlyAnimationEndFun;
                    }
                  }
                });
              }
            });
          } else {
            that.centerAt(view, {
              duration: opts.duration3 || 2,
              easingFunction: opts.easingFunction3,
              complete: function complete() {
                that._isFlyAnimation = false;
                if (opts.callback) opts.callback();
                if (that.openFlyAnimationEndFun) {
                  that.openFlyAnimationEndFun();
                  delete that.openFlyAnimationEndFun;
                }
              }
            });
          }
        }
      });
    }
    //旋转地球

  }, {
    key: "rotateAnimation",
    value: function rotateAnimation(endfun, duration) {
      var viewer = this.viewer;

      var first = point.getCameraView(viewer); //默认为原始视角
      var duration3 = duration / 3;

      //动画 1/3
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(first.x + 120, first.y, first.z),
        orientation: {
          heading: Cesium.Math.toRadians(first.heading),
          pitch: Cesium.Math.toRadians(first.pitch),
          roll: Cesium.Math.toRadians(first.roll)
        },
        duration: duration3,
        easingFunction: Cesium.EasingFunction.LINEAR_NONE,
        complete: function complete() {
          //动画 2/3
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(first.x + 240, first.y, first.z),
            orientation: {
              heading: Cesium.Math.toRadians(first.heading),
              pitch: Cesium.Math.toRadians(first.pitch),
              roll: Cesium.Math.toRadians(first.roll)
            },
            duration: duration3,
            easingFunction: Cesium.EasingFunction.LINEAR_NONE,
            complete: function complete() {
              //动画 3/3
              viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(first.x, first.y, first.z),
                orientation: {
                  heading: Cesium.Math.toRadians(first.heading),
                  pitch: Cesium.Math.toRadians(first.pitch),
                  roll: Cesium.Math.toRadians(first.roll)
                },
                duration: duration3,
                easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                complete: function complete() {
                  if (endfun) endfun();
                }
              });
              //动画3/3 end
            }
          });
          //动画2/3 end
        }
      });
      //动画1/3 end
    }

    //添加“导航”控件

  }, {
    key: "_addNavigationWidget",
    value: function _addNavigationWidget(item) {
      if (Cesium.viewerCesiumNavigationMixin) {
        //兼容v1版本
        this.viewer.extend(Cesium.viewerCesiumNavigationMixin, {
          defaultResetView: Cesium.Rectangle.fromDegrees(110, 20, 120, 30),
          enableZoomControls: false
        });
      }

      if (Cesium.CesiumNavigation) {
        //当前版本
        var options = {};
        // 用于在使用重置导航重置地图视图时设置默认视图控制。接受的值是Cesium.Cartographic 和 Cesium.Rectangle.
        options.defaultResetView = Cesium.Rectangle.fromDegrees(110, 20, 120, 30);
        // 用于启用或禁用罗盘。true是启用罗盘，false是禁用罗盘。默认值为true。如果将选项设置为false，则罗盘将不会添加到地图中。
        options.enableCompass = true;
        // 用于启用或禁用缩放控件。true是启用，false是禁用。默认值为true。如果将选项设置为false，则缩放控件将不会添加到地图中。
        options.enableZoomControls = false;
        // 用于启用或禁用距离图例。true是启用，false是禁用。默认值为true。如果将选项设置为false，距离图例将不会添加到地图中。
        options.enableDistanceLegend = true;
        // 用于启用或禁用指南针外环。true是启用，false是禁用。默认值为true。如果将选项设置为false，则该环将可见但无效。
        options.enableCompassOuterRing = true;

        Cesium.CesiumNavigation(this.viewer, options);
      }

      //比例尺
      (0, _zepto.zepto)(".distance-legend").css({
        left: "-10px",
        bottom: "-1px",
        border: "none",
        background: "rgba(0, 0, 0, 0)"
      });

      if (item.legend) {
        var css = item.legend;
        //插件的默认值：right: 25px; bottom: 30px;
        if (Cesium.defined(css.top) && css.top != "auto") {
          css.bottom = "auto";
        }
        if (Cesium.defined(css.left) && css.left != "auto") {
          css.right = "auto";
        }

        (0, _zepto.zepto)(".distance-legend").css(css);
      } else {
        (0, _zepto.zepto)(".distance-legend").remove();
      }

      //导航球
      if (item.compass) {
        var _css = item.compass;
        //插件的默认值： top: 100px; right: 0;
        if (Cesium.defined(_css.bottom) && _css.bottom != "auto") {
          _css.top = "auto";
        }
        if (Cesium.defined(_css.left) && _css.left != "auto") {
          _css.right = "auto";
        }
        (0, _zepto.zepto)(".compass").css(_css);
      } else {
        (0, _zepto.zepto)(".compass").remove();
      }

      //zepto(".navigation-controls").css({
      //    "right": "5px",
      //    "bottom": "30px",
      //    "top": "auto"
      //});
      (0, _zepto.zepto)(".navigation-controls").remove();
    }
    //导出场景图片，截图

  }, {
    key: "expImage",
    value: function expImage(opts) {
      opts = opts || {};
      opts.download = Cesium.defaultValue(opts.download, true);
      opts.type = Cesium.defaultValue(opts.type, "image/jpeg");

      var width, height;
      var viewer = this.viewer;
      var callback = opts.callback || opts.calback;

      viewer.render();
      var imgdata = viewer.canvas.toDataURL(opts.type, opts.encoderOptions);

      if (Cesium.defined(opts.width) || Cesium.defined(opts.height)) {
        //指定了高或宽度后，图片压缩处理
        var image = new Image();
        image.onload = function () {
          //图片压缩处理

          if (Cesium.defined(opts.width)) {
            width = opts.width;
            height = opts.height || Math.round(width * viewer.canvas.height / viewer.canvas.width);
          } else {
            height = opts.height;
            width = Math.round(height * viewer.canvas.width / viewer.canvas.height);
          }

          var canvas, ctx;
          canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          ctx = canvas.getContext("2d");
          ctx.drawImage(image, 0, 0, width, height);
          var imgdataNew = canvas.toDataURL(opts.type, opts.encoderOptions);

          if (!opts.filename) {
            opts.filename = "场景出图_" + width + "x" + height;
          }
          if (opts.download) _util.downloadBase64Image(opts.filename, imgdataNew);
          if (callback) callback(imgdataNew, {
            width: width,
            height: height
          });
        };
        image.src = imgdata;
      } else {
        //高清原图
        height = viewer.canvas.height, width = viewer.canvas.width;

        if (!opts.filename) {
          opts.filename = "场景出图_" + width + "x" + height;
        }
        if (opts.download) _util.downloadBase64Image(opts.filename, imgdata);
        if (callback) callback(imgdata, {
          width: width,
          height: height
        });
      }
    }

    //销毁资源

  }, {
    key: "destroy",
    value: function destroy() {
      this.handler.destroy();
      this._tooltip.destroy();
      this._popup.destroy();

      if (this._keyboardRoam) {
        this._keyboardRoam.destroy();
        this._keyboardRoam = null;
      }

      if (this._contextmenu) {
        this._contextmenu.destroy();
        this._contextmenu = null;
      }

      if (this._location) {
        this._location.destroy();
        this._location = null;
      }
      if (this._mouseZoomStyle) {
        this._mouseZoomStyle.destroy();
        this._mouseZoomStyle = null;
      }

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "onlyPickModelPosition",
    get: function get() {
      return this.viewer.scene.onlyPickModelPosition;
    },
    set: function set(value) {
      this.viewer.scene.onlyPickModelPosition = value;
    }

    //单击事件(单个时，主要为了兼容历史版本或单次简单场景下使用)

  }, {
    key: "click",
    set: function set(value) {
      this.on(_DasClass2.eventType.click, value);
    }
  }, {
    key: "keyboardRoam",
    get: function get() {
      return this._keyboardRoam;
    }
  }, {
    key: "contextmenu",
    get: function get() {
      return this._contextmenu;
    }
  }, {
    key: "location",
    get: function get() {
      return this._location;
    }
  }, {
    key: "popup",
    get: function get() {
      return this._popup;
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this._tooltip;
    }
  }, {
    key: "mouseZoom",
    get: function get() {
      return this._mouseZoomStyle;
    }

    //右键菜单

  }, {
    key: "contextmenuItems",
    get: function get() {
      return this._contextmenuItems;
    },
    set: function set(val) {
      this._contextmenuItems = val;
    }
  }, {
    key: "defaultContextmenuItems",
    get: function get() {
      return this.config.contextmenuItems || (0, _defaultContextMenu.getDefaultContextMenu)(this.viewer);
    }

    //默认绑定的draw控件

  }, {
    key: "draw",
    get: function get() {
      if (this._drawControl == null) {
        this._drawControl = new _Draw.Draw(this.viewer, {
          hasEdit: false
        });
      }
      return this._drawControl;
    }

    //获取地图层级（概略）

  }, {
    key: "level",
    get: function get() {
      var height = this.viewer.camera.positionCartographic.height;
      if (height == this._prevCameraHeight) {
        return this._level;
      }
      this._level = _util.heightToZoom(height);
      this._prevCameraHeight = height;
      return this._level;
    }
  }]);

  return ViewerEx;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


ViewerEx.event = {
  click: _DasClass2.eventType.click,
  clickMap: _DasClass2.eventType.clickMap,
  mouseMove: _DasClass2.eventType.mouseMove
};

//绑定到Viewer上
Object.defineProperties(Cesium.Viewer.prototype, {
  das: {
    set: function set(value) {
      this._das = value;
    },
    get: function get() {
      if (!this._das) {
        this._das = new ViewerEx(this);
      }
      return this._das;
    }
  }
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultContextMenu = getDefaultContextMenu;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _tileset = __webpack_require__(32);

var tileset = _interopRequireWildcard(_tileset);

var _util2 = __webpack_require__(3);

var _util = _interopRequireWildcard(_util2);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//默认右键菜单
function getDefaultContextMenu(viewer) {
  var stages = viewer.scene.postProcessStages;
  var that = {};

  return [{
    text: "查看此处坐标",
    iconCls: "fa fa-info-circle",
    visible: function visible(e) {
      return Cesium.defined(e.position);
    },
    callback: function callback(e) {
      //经纬度
      var mpt = point.formatPosition(e.position);
      var inhtml = "\u7ECF\u5EA6\uFF1A" + mpt.x + ", \u7EAC\u5EA6\uFF1A" + mpt.y + ", \u9AD8\u7A0B\uFF1A" + mpt.z;
      _util.alert(inhtml, "位置信息");

      //打印方便测试
      var ptX = point.formatNum(e.position.x, 1); //笛卡尔
      var ptY = point.formatNum(e.position.y, 1);
      var ptZ = point.formatNum(e.position.z, 1);

      daslog.log("\u7ECF\u7EAC\u5EA6\uFF1A" + mpt.x + "," + mpt.y + "," + mpt.z + ", \u7B1B\u5361\u5C14\uFF1A" + ptX + "," + ptY + "," + ptZ);
    }
  }, {
    text: "查看当前视角",
    iconCls: "fa fa-camera-retro",
    callback: function callback(e) {
      var mpt = JSON.stringify(point.getCameraView(viewer));

      //打印方便测试， 说明：可配置到config.json中center参数使用，或调用viewer.das.centerAt(参数)方法
      daslog.log(mpt);

      _util.alert(mpt, "当前视角信息");
    }
  }, {
    text: "视角切换",
    iconCls: "fa fa-street-view",
    children: [{
      text: "绕此处环绕飞行",
      iconCls: "fa fa-retweet",
      visible: function visible(e) {
        return e.position && !point.windingPoint.isStart;
      },
      callback: function callback(e) {
        point.windingPoint.start(viewer, e.position);
      }
    }, {
      text: "关闭环绕飞行",
      iconCls: "fa fa-remove",
      visible: function visible(e) {
        return point.windingPoint.isStart;
      },
      callback: function callback(e) {
        point.windingPoint.stop();
      }
    }, {
      text: "移动到此处",
      iconCls: "fa fa-send-o",
      visible: function visible(e) {
        return Cesium.defined(e.position);
      },
      callback: function callback(e) {
        var cameraDistance = Cesium.Cartesian3.distance(e.position, viewer.camera.positionWC) * 0.1;

        viewer.das.centerPoint(e.position, {
          radius: cameraDistance, //距离目标点的距离
          maximumHeight: viewer.camera.positionCartographic.height
        });
      }
    }, {
      text: "第一视角站到此处",
      iconCls: "fa fa-male",
      visible: function visible(e) {
        return Cesium.defined(e.position);
      },
      callback: function callback(e) {
        viewer.camera.flyTo({
          destination: point.addPositionsHeight(e.position, 10), //升高10米
          orientation: {
            heading: viewer.camera.heading,
            pitch: 0.0,
            roll: 0.0
          },
          maximumHeight: viewer.camera.positionCartographic.height
        });
      }
    }, {
      text: "开启键盘漫游",
      iconCls: "fa fa-keyboard-o",
      visible: function visible(e) {
        return !viewer.das.keyboardRoam.enable;
      },
      callback: function callback(e) {
        viewer.das.keyboardRoam.enable = true;
      }
    }, {
      text: "关闭键盘漫游",
      iconCls: "fa fa-keyboard-o",
      visible: function visible(e) {
        return viewer.das.keyboardRoam.enable;
      },
      callback: function callback(e) {
        viewer.das.keyboardRoam.enable = false;
      }
    }, {
      text: "取消锁定",
      iconCls: "fa fa-unlock-alt",
      visible: function visible(e) {
        return viewer.trackedEntity != undefined;
      },
      callback: function callback(e) {
        viewer.trackedEntity = undefined;
      }
    }]
  }, {
    text: "三维模型",
    iconCls: "fa fa-building-o",
    visible: function visible(e) {
      var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
      return Cesium.defined(model);
    },
    children: [{
      text: "显示三角网",
      iconCls: "fa fa-connectdevelop",
      visible: function visible(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        return !model.debugWireframe;
      },
      callback: function callback(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        model.debugWireframe = true;
      }
    }, {
      text: "关闭三角网",
      iconCls: "fa fa-connectdevelop",
      visible: function visible(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        return model.debugWireframe;
      },
      callback: function callback(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        model.debugWireframe = false;
      }
    }, {
      text: "显示包围盒",
      iconCls: "fa fa-codepen",
      visible: function visible(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        return !model.debugShowBoundingVolume;
      },
      callback: function callback(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        model.debugShowBoundingVolume = true;
      }
    }, {
      text: "关闭包围盒",
      iconCls: "fa fa-codepen",
      visible: function visible(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        return model.debugShowBoundingVolume;
      },
      callback: function callback(e) {
        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
        model.debugShowBoundingVolume = false;
      }
    }]
  }, {
    text: "地形服务",
    iconCls: "fa fa-globe",
    visible: function visible(e) {
      return !Cesium.defined(e.target);
    },
    children: [{
      text: "开启地形",
      iconCls: "fa fa-medium",
      visible: function visible(e) {
        return !viewer.das.hasTerrain();
      },
      callback: function callback(e) {
        viewer.das.updateTerrainProvider(true);
      }
    }, {
      text: "关闭地形",
      iconCls: "fa fa-medium",
      visible: function visible(e) {
        return viewer.das.hasTerrain();
      },
      callback: function callback(e) {
        viewer.das.updateTerrainProvider(false);
      }
    }, {
      text: "显示三角网",
      iconCls: "fa fa-connectdevelop",
      visible: function visible(e) {
        return !viewer.scene.globe._surface.tileProvider._debug.wireframe;
      },
      callback: function callback(e) {
        viewer.scene.globe._surface.tileProvider._debug.wireframe = true;
      }
    }, {
      text: "关闭三角网",
      iconCls: "fa fa-connectdevelop",
      visible: function visible(e) {
        return viewer.scene.globe._surface.tileProvider._debug.wireframe;
      },
      callback: function callback(e) {
        viewer.scene.globe._surface.tileProvider._debug.wireframe = false;
      }
    }]
  }, {
    text: "图上标记",
    iconCls: "fa fa-eyedropper",
    children: [{
      text: "标记点",
      iconCls: "fa fa-map-marker",
      callback: function callback(e) {
        viewer.das.draw.startDraw({
          type: "point",
          style: {
            pixelSize: 12,
            color: "#3388ff"
          },
          success: function success(entity) {
            var positions = viewer.das.draw.getCoordinates(entity);
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(positions));
          }
        });
      }
    }, {
      text: "标记线",
      iconCls: "fa fa-reorder",
      callback: function callback(e) {
        viewer.das.draw.startDraw({
          type: "polyline",
          style: {
            color: "#55ff33",
            width: 3
          },
          success: function success(entity) {
            var positions = viewer.das.draw.getCoordinates(entity);
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(positions));
          }
        });
      }
    }, {
      text: "标记面",
      iconCls: "fa fa-medium",
      callback: function callback(e) {
        viewer.das.draw.startDraw({
          type: "polygon",
          style: {
            color: "#29cf34",
            opacity: 0.5,
            outline: true,
            outlineWidth: 2.0
          },
          success: function success(entity) {
            var positions = viewer.das.draw.getCoordinates(entity);
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(positions));
          }
        });
      }
    }, {
      text: "标记圆",
      iconCls: "fa fa-genderless",
      callback: function callback(e) {
        viewer.das.draw.startDraw({
          type: "circle",
          style: {
            color: "#ffff00",
            opacity: 0.6
          },
          success: function success(entity) {
            var positions = viewer.das.draw.getCoordinates(entity);
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(positions));
          }
        });
      }
    }, {
      text: "标记矩形",
      iconCls: "fa fa-retweet",
      callback: function callback(e) {
        viewer.das.draw.startDraw({
          type: "rectangle",
          style: {
            color: "#ffff00",
            opacity: 0.6
          },
          success: function success(entity) {
            var positions = viewer.das.draw.getCoordinates(entity);
            // eslint-disable-next-line no-console
            console.log(JSON.stringify(positions));
          }
        });
      }
    }, {
      text: "允许编辑",
      iconCls: "fa fa-pencil",
      visible: function visible(e) {
        return !viewer.das.draw._hasEdit;
      },
      callback: function callback(e) {
        viewer.das.draw.hasEdit(true);
      }
    }, {
      text: "禁止编辑",
      iconCls: "fa fa-pencil-square",
      visible: function visible(e) {
        return viewer.das.draw._hasEdit;
      },
      callback: function callback(e) {
        viewer.das.draw.hasEdit(false);
      }
    }, {
      text: "导出GeoJSON",
      iconCls: "fa fa-file-text-o",
      visible: function visible(e) {
        return viewer.das.draw.hasDraw();
      },
      callback: function callback(e) {
        _util.downloadFile("图上标记.json", JSON.stringify(viewer.das.draw.toGeoJSON()));
      }
    }, {
      text: "清除所有标记",
      iconCls: "fa fa-trash-o",
      visible: function visible(e) {
        return viewer.das.draw.hasDraw();
      },
      callback: function callback(e) {
        viewer.das.draw.clearDraw();
      }
    }]
  }, {
    text: "特效效果",
    iconCls: "fa fa-rss",
    children: [{
      text: "开启泛光",
      iconCls: "fa fa-ticket",
      visible: function visible(e) {
        return !viewer.scene.postProcessStages.bloom.enabled;
      },
      callback: function callback(e) {
        //加泛光  （参考官方示例: bloom）
        var bloom = viewer.scene.postProcessStages.bloom;
        if (!that.bloom) {
          bloom.enabled = false;
          bloom.uniforms.glowOnly = false;
          bloom.uniforms.contrast = 128;
          bloom.uniforms.brightness = -0.3;
          bloom.uniforms.delta = 1.0;
          bloom.uniforms.sigma = 3.78;
          bloom.uniforms.stepSize = 5.0;

          that.bloom = true;
        }
        bloom.enabled = true;
      }
    }, {
      text: "关闭泛光",
      iconCls: "fa fa-ticket",
      visible: function visible(e) {
        return viewer.scene.postProcessStages.bloom.enabled;
      },
      callback: function callback(e) {
        viewer.scene.postProcessStages.bloom.enabled = false;
      }
    }, {
      text: "开启亮度",
      iconCls: "fa fa-trello",
      visible: function visible(e) {
        return !that.BrightnessStage;
      },
      callback: function callback(e) {
        if (!that.BrightnessStage) {
          that.BrightnessStage = Cesium.PostProcessStageLibrary.createBrightnessStage();
          stages.add(that.BrightnessStage);

          that.BrightnessStage.uniforms.brightness = 2.0;
        }
        that.BrightnessStage.enabled = true;
      }
    }, {
      text: "关闭亮度",
      iconCls: "fa fa-trello",
      visible: function visible(e) {
        return that.BrightnessStage;
      },
      callback: function callback(e) {
        if (that.BrightnessStage) {
          stages.remove(that.BrightnessStage);
          that.BrightnessStage = undefined;
        }
      }
    }, {
      text: "开启夜视",
      iconCls: "fa fa-dashboard",
      visible: function visible(e) {
        return !that.NightVisionStage;
      },
      callback: function callback(e) {
        if (!that.NightVisionStage) {
          that.NightVisionStage = Cesium.PostProcessStageLibrary.createNightVisionStage();
          stages.add(that.NightVisionStage);
        }
        that.NightVisionStage.enabled = true;
      }
    }, {
      text: "关闭夜视",
      iconCls: "fa fa-dashboard",
      visible: function visible(e) {
        return that.NightVisionStage;
      },
      callback: function callback(e) {
        if (that.NightVisionStage) {
          stages.remove(that.NightVisionStage);
          that.NightVisionStage = undefined;
        }
      }
    }, {
      text: "开启黑白",
      iconCls: "fa fa-star-half-full",
      visible: function visible(e) {
        return !that.BlackAndWhiteStage;
      },
      callback: function callback(e) {
        if (!that.BlackAndWhiteStage) {
          that.BlackAndWhiteStage = Cesium.PostProcessStageLibrary.createBlackAndWhiteStage();
          stages.add(that.BlackAndWhiteStage);
        }
        that.BlackAndWhiteStage.enabled = true;
      }
    }, {
      text: "关闭黑白",
      iconCls: "fa fa-star-half-full",
      visible: function visible(e) {
        return that.BlackAndWhiteStage;
      },
      callback: function callback(e) {
        if (that.BlackAndWhiteStage) {
          stages.remove(that.BlackAndWhiteStage);
          that.BlackAndWhiteStage = undefined;
        }
      }
    }, {
      text: "开启马赛克",
      iconCls: "fa fa-delicious",
      visible: function visible(e) {
        return !that.MosaicStage;
      },
      callback: function callback(e) {
        if (!that.MosaicStage) {
          that.MosaicStage = new Cesium.PostProcessStage({
            fragmentShader: "uniform sampler2D colorTexture; \n                                varying vec2 v_textureCoordinates; \n                                const int KERNEL_WIDTH=16; \n                                void main(void) \n                                { \n                                    vec2 step = 1.0 / czm_viewport.zw; \n                                    vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step); \n                                    vec3 averageValue = vec3(0.0); \n                                    for (int i = 0; i < KERNEL_WIDTH; i++) \n                                    { \n                                        for (int j = 0; j < KERNEL_WIDTH; j++) \n                                        { \n                                            averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb; \n                                        } \n                                    } \n                                    averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH); \n                                    gl_FragColor = vec4(averageValue, 1.0); \n                                } "
          });
          stages.add(that.MosaicStage);
        }
        that.MosaicStage.enabled = true;
      }
    }, {
      text: "关闭马赛克",
      iconCls: "fa fa-delicious",
      visible: function visible(e) {
        return that.MosaicStage;
      },
      callback: function callback(e) {
        if (that.MosaicStage) {
          stages.remove(that.MosaicStage);
          that.MosaicStage = undefined;
        }
      }
    }, {
      text: "开启景深",
      iconCls: "fa fa-simplybuilt",
      visible: function visible(e) {
        return !that.DepthOfFieldStage;
      },
      callback: function callback(e) {
        if (!that.DepthOfFieldStage) {
          that.DepthOfFieldStage = Cesium.PostProcessStageLibrary.createDepthOfFieldStage();
          stages.add(that.DepthOfFieldStage);

          var uniforms = that.DepthOfFieldStage.uniforms;
          uniforms.focalDistance = 87; //焦距
          uniforms.delta = 1;
          uniforms.sigma = 3.78;
          uniforms.stepSize = 2.46; //步长
        }
        that.DepthOfFieldStage.enabled = true;
      }
    }, {
      text: "关闭景深",
      iconCls: "fa fa-simplybuilt",
      visible: function visible(e) {
        return that.DepthOfFieldStage;
      },
      callback: function callback(e) {
        if (that.DepthOfFieldStage) {
          stages.remove(that.DepthOfFieldStage);
          that.DepthOfFieldStage = undefined;
        }
      }
    }]
  }, {
    text: "场景设置",
    iconCls: "fa fa-gear",
    children: [{
      text: "开启深度监测",
      iconCls: "fa fa-eye-slash",
      visible: function visible(e) {
        return !viewer.scene.globe.depthTestAgainstTerrain;
      },
      callback: function callback(e) {
        viewer.scene.globe.depthTestAgainstTerrain = true;
      }
    }, {
      text: "关闭深度监测",
      iconCls: "fa fa-eye",
      visible: function visible(e) {
        return viewer.scene.globe.depthTestAgainstTerrain;
      },
      callback: function callback(e) {
        viewer.scene.globe.depthTestAgainstTerrain = false;
      }
    }, {
      text: "显示星空背景",
      iconCls: "fa fa-moon-o",
      visible: function visible(e) {
        return !viewer.scene.skyBox.show;
      },
      callback: function callback(e) {
        viewer.scene.skyBox.show = true; //天空盒
        viewer.scene.moon.show = true; //太阳
        viewer.scene.sun.show = true; //月亮
      }
    }, {
      text: "关闭星空背景",
      iconCls: "fa fa-moon-o",
      visible: function visible(e) {
        return viewer.scene.skyBox.show;
      },
      callback: function callback(e) {
        viewer.scene.skyBox.show = false; //天空盒
        viewer.scene.moon.show = false; //太阳
        viewer.scene.sun.show = false; //月亮
      }
    }, {
      text: "开启日照阴影",
      iconCls: "fa fa-sun-o",
      visible: function visible(e) {
        return !viewer.shadows;
      },
      callback: function callback(e) {
        viewer.shadows = true;
        viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
        viewer.scene.globe.enableLighting = true;
      }
    }, {
      text: "关闭日照阴影",
      iconCls: "fa fa-sun-o",
      visible: function visible(e) {
        return viewer.shadows;
      },
      callback: function callback(e) {
        viewer.shadows = false;
        viewer.terrainShadows = Cesium.ShadowMode.RECEIVE_ONLY;
        viewer.scene.globe.enableLighting = false;
      }
    }, {
      text: "开启大气渲染",
      iconCls: "fa fa-soundcloud",
      visible: function visible(e) {
        return !viewer.scene.skyAtmosphere.show;
      },
      callback: function callback(e) {
        viewer.scene.skyAtmosphere.show = true;
        viewer.scene.globe.showGroundAtmosphere = true;
      }
    }, {
      text: "关闭大气渲染",
      iconCls: "fa fa-soundcloud",
      visible: function visible(e) {
        return viewer.scene.skyAtmosphere.show;
      },
      callback: function callback(e) {
        viewer.scene.skyAtmosphere.show = false;
        viewer.scene.globe.showGroundAtmosphere = false;
      }
    }, {
      text: "场景截图",
      iconCls: "fa fa-download",
      callback: function callback(e) {
        viewer.das.expImage();
      }
    }]
  }];
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureAngle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(18);

var measureUtil = _interopRequireWildcard(_measure);

var _matrix = __webpack_require__(16);

var _Attr = __webpack_require__(13);

var _Attr2 = __webpack_require__(17);

var _MeasureBase2 = __webpack_require__(29);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureAngle = exports.MeasureAngle = function (_MeasureBase) {
  _inherits(MeasureAngle, _MeasureBase);

  //========== 构造方法 ==========
  function MeasureAngle(opts, target) {
    _classCallCheck(this, MeasureAngle);

    var _this = _possibleConstructorReturn(this, (MeasureAngle.__proto__ || Object.getPrototypeOf(MeasureAngle)).call(this, opts, target));

    _this.totalLable = null; //角度label
    _this.exLine = null; //辅助线
    return _this;
  }

  _createClass(MeasureAngle, [{
    key: "clearLastNoEnd",


    //清除未完成的数据
    value: function clearLastNoEnd() {
      if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
      this.totalLable = null;

      if (this.exLine != null) this.dataSource.entities.remove(this.exLine);
      this.exLine = null;
    }
    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var entityattr = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: false
      });

      this.totalLable = this.dataSource.entities.add({
        label: entityattr,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.totalLable.showText = function (unit) {
        var lenstr = util.formatLength(this.attribute.valueLen, unit);
        this.label.text = "角度:" + this.attribute.value + "°\n距离:" + lenstr;
        return lenstr;
      };

      return this.drawControl.startDraw({
        type: "polyline",
        config: { maxPointNum: 2 },
        style: _extends({
          lineType: "arrow",
          color: "#ebe967",
          width: 9,
          clampToGround: true
        }, options.style)
      });
    }
    //绘制增加一个点后，显示该分段的长度

  }, {
    key: "showAddPointLength",
    value: function showAddPointLength(entity) {
      this.showMoveDrawing(entity); //兼容手机端
    }
    //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      if (this.exLine) {
        this.dataSource.entities.remove(this.exLine);
        this.exLine = null;
      }
      if (this.totalLable) this.totalLable.label.show = false;
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 2) {
        this.totalLable.label.show = false;
        return;
      }

      //求长度
      var len = Cesium.Cartesian3.distance(positions[0], positions[1]);

      //求方位角
      var bearing = measureUtil.getAngle(positions[0], positions[1]);

      //求参考点
      var new_position = (0, _matrix.getRotateCenterPoint)(positions[0], positions[1], -bearing);
      this.updateExLine([positions[0], new_position], entity); //参考线

      //显示文本
      this.totalLable.attribute.value = bearing;
      this.totalLable.attribute.valueLen = len;

      var lenstr = this.totalLable.showText(this.options.unit);

      this.totalLable.position = positions[1];
      this.totalLable.label.show = true;

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: bearing,
        label: lenstr,
        length: len
      });
    }
  }, {
    key: "updateExLine",
    value: function updateExLine(positions, entity) {
      if (this.exLine) {
        this.exLine._positions = positions;
      } else {
        var entityattr = (0, _Attr2.style2Entity)(this.options.styleEx, {
          positions: new Cesium.CallbackProperty(function (time) {
            return exLine._positions;
          }, false),
          width: 3,
          clampToGround: true,
          material: new Cesium.PolylineDashMaterialProperty({
            color: Cesium.Color.RED
          })
        });

        var exLine = this.dataSource.entities.add({
          polyline: entityattr
        });
        exLine._positions = positions;
        exLine.target = entity;
        this.bindDeleteContextmenu(exLine);

        this.exLine = exLine;
      }
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      entity._totalLable = this.totalLable;
      this.totalLable = null;

      entity.arrEntityEx = [this.exLine];

      this.target.fire(_DasClass.eventType.end, {
        mtype: this.type,
        entity: entity,
        value: entity._totalLable.attribute.value
      });
    }

    //编辑修改后

  }, {
    key: "updateForEditMouseMove",
    value: function updateForEditMouseMove(entity) {
      this.updateForEdit(entity);
    }
  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      this.totalLable = entity._totalLable;
      this.exLine = entity.arrEntityEx[0];

      this.showMoveDrawing(entity);

      this.totalLable = null;
      this.exLine = null;
    }
  }, {
    key: "type",
    get: function get() {
      return "angle";
    }
  }]);

  return MeasureAngle;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureAreaSurface = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _measure = __webpack_require__(18);

var measureUtil = _interopRequireWildcard(_measure);

var _point = __webpack_require__(2);

var _MeasureArea2 = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//贴地线
var MeasureAreaSurface = exports.MeasureAreaSurface = function (_MeasureArea) {
  _inherits(MeasureAreaSurface, _MeasureArea);

  function MeasureAreaSurface() {
    _classCallCheck(this, MeasureAreaSurface);

    return _possibleConstructorReturn(this, (MeasureAreaSurface.__proto__ || Object.getPrototypeOf(MeasureAreaSurface)).apply(this, arguments));
  }

  _createClass(MeasureAreaSurface, [{
    key: "_startDraw",

    //开始绘制
    value: function _startDraw(options) {
      options.style.clampToGround = true;

      return _get(MeasureAreaSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureAreaSurface.prototype), "_startDraw", this).call(this, options);
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      // super.showDrawEnd(entity);
      if (entity.polygon == null) return;

      entity._totalLable = this.totalLable;
      this.totalLable = null;

      this.updateAreaForTerrain(entity);
    }
    //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      _get(MeasureAreaSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureAreaSurface.prototype), "updateForEdit", this).call(this, entity);
      this.updateAreaForTerrain(entity);
    }
    //计算贴地面

  }, {
    key: "updateAreaForTerrain",
    value: function updateAreaForTerrain(entity) {
      var _this2 = this;

      var that = this;

      //更新lable等
      var totalLable = entity._totalLable;
      var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;
      var thisCenter = (0, _point.getPositionValue)(totalLable.position);

      var positions = this.drawControl.getPositions(entity);

      this.target.fire(_DasClass.eventType.start, {
        mtype: this.type
      });

      //贴地总面积
      measureUtil.getClampArea(positions, {
        scene: this.viewer.scene,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        asyn: true, //异步求准确的
        callback: function callback(area, resultInter) {
          // if (that.options.onInterEnd)
          //     that.options.onInterEnd(resultInter);

          totalLable.position = (0, _point.setPositionsHeight)(thisCenter, resultInter.maxHeight); //更新lable高度

          totalLable.attribute.value = area;
          var areastr = totalLable.showText(unit);

          _this2.target.fire(_DasClass.eventType.change, {
            mtype: _this2.type,
            value: area,
            label: areastr
          });
          _this2.target.fire(_DasClass.eventType.end, _extends({}, resultInter, {
            mtype: _this2.type,
            entity: entity,
            value: area
          }));
        }
      });
    }
  }, {
    key: "type",
    get: function get() {
      return "areaSurface";
    }
  }]);

  return MeasureAreaSurface;
}(_MeasureArea2.MeasureArea);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureHeightTriangle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _Attr = __webpack_require__(13);

var _Attr2 = __webpack_require__(17);

var _MeasureHeight2 = __webpack_require__(50);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureHeightTriangle = exports.MeasureHeightTriangle = function (_MeasureHeight) {
  _inherits(MeasureHeightTriangle, _MeasureHeight);

  //========== 构造方法 ==========
  function MeasureHeightTriangle(opts, target) {
    _classCallCheck(this, MeasureHeightTriangle);

    var _this = _possibleConstructorReturn(this, (MeasureHeightTriangle.__proto__ || Object.getPrototypeOf(MeasureHeightTriangle)).call(this, opts, target));

    _this.totalLable = null; //高度差label
    _this.xLable = null; //空间距离label
    _this.hLable = null; //水平距离label
    return _this;
  }

  _createClass(MeasureHeightTriangle, [{
    key: "clearLastNoEnd",


    //清除未完成的数据
    value: function clearLastNoEnd() {
      if (this.totalLable != null) this.dataSource.entities.remove(this.totalLable);
      if (this.xLable != null) this.dataSource.entities.remove(this.xLable);
      if (this.hLable != null) this.dataSource.entities.remove(this.hLable);

      this.totalLable = null;
      this.xLable = null;
      this.hLable = null;
    }
    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var entityattr2 = (0, _Attr.style2Entity)(this.labelStyle, {
        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        show: false
      });
      entityattr2.pixelOffset = new Cesium.Cartesian2(0, 0);
      this.xLable = this.dataSource.entities.add({
        label: entityattr2,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.xLable.showText = function (unit) {
        var heightstr = util.formatLength(this.attribute.value, unit);
        this.label.text = "空间距离:" + heightstr;
        return heightstr;
      };

      this.hLable = this.dataSource.entities.add({
        label: entityattr2,
        _noMousePosition: true,
        attribute: {
          unit: options.unit,
          type: options.type
        }
      });
      this.hLable.showText = function (unit) {
        var heightstr = util.formatLength(this.attribute.value, unit);
        this.label.text = "水平距离:" + heightstr;
        return heightstr;
      };

      return _get(MeasureHeightTriangle.prototype.__proto__ || Object.getPrototypeOf(MeasureHeightTriangle.prototype), "_startDraw", this).call(this, options);
    }
    //绘制中删除了最后一个点

  }, {
    key: "showRemoveLastPointLength",
    value: function showRemoveLastPointLength(e) {
      if (this.totalLable) this.totalLable.label.show = false;
      if (this.hLable) this.hLable.label.show = false;
      if (this.xLable) this.xLable.label.show = false;
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 2) {
        this.showRemoveLastPointLength();
        return;
      }

      var carto1 = Cesium.Cartographic.fromCartesian(positions[0]);
      var height1 = carto1.height;
      var carto2 = Cesium.Cartographic.fromCartesian(positions[1]);
      var height2 = carto2.height;

      var bottomPosition; //三角底部点
      var zPosition; //三角底部点 对应的高处的点
      var topPosion; //三角的顶部点

      if (height1 > height2) {
        zPosition = Cesium.Cartesian3.fromRadians(carto2.longitude, carto2.latitude, height1);
        topPosion = positions[0];
        bottomPosition = positions[1];
      } else {
        zPosition = Cesium.Cartesian3.fromRadians(carto1.longitude, carto1.latitude, height2);
        topPosion = positions[1];
        bottomPosition = positions[0];
      }

      //显示三角行 线
      this.updateExLine([bottomPosition, zPosition, topPosion, bottomPosition], entity); //参考线

      //[垂直方向]高度差
      var height = Math.abs(height2 - height1);
      var midPoint = Cesium.Cartesian3.midpoint(zPosition, bottomPosition, new Cesium.Cartesian3());
      this.updateHeightLabel(this.totalLable, midPoint, height);

      //[水平方向]水平距离
      var distanceSP = Cesium.Cartesian3.distance(zPosition, topPosion);
      var midPointSP = Cesium.Cartesian3.midpoint(zPosition, topPosion, new Cesium.Cartesian3());
      this.updateHeightLabel(this.hLable, midPointSP, distanceSP);

      //空间距离长度
      var distance = Cesium.Cartesian3.distance(positions[0], positions[1]);
      var midXPoint = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
      this.updateHeightLabel(this.xLable, midXPoint, distance);

      this.target.fire(_DasClass.eventType.change, {
        mtype: this.type,
        value: height, //高度差
        distance: distance, //空间长度
        distanceSP: distanceSP //水平距离
      });
    }
  }, {
    key: "updateHeightLabel",
    value: function updateHeightLabel(currentLabel, position, value) {
      if (currentLabel == null) return;

      currentLabel.attribute.value = value;
      currentLabel.showText(this.options.unit);
      currentLabel.position = position; //位置
      currentLabel.label.show = true;
    }
  }, {
    key: "updateExLine",
    value: function updateExLine(positions, entity) {
      if (this.exLine) {
        this.exLine._positions = positions;
      } else {
        var entityattr = (0, _Attr2.style2Entity)(_extends({
          positions: new Cesium.CallbackProperty(function (time) {
            return exLine._positions;
          }, false),
          lineType: "glow",
          color: "#ebe12c",
          width: 9,
          glowPower: 0.1
        }, this.options.style));

        var exLine = this.dataSource.entities.add({
          polyline: entityattr
        });
        exLine._positions = positions;

        exLine.target = entity;
        this.bindDeleteContextmenu(exLine);

        this.exLine = exLine;
      }
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      entity.arrEntityEx = [this.totalLable, this.hLable, this.xLable, this.exLine];

      this.target.fire(_DasClass.eventType.end, {
        mtype: this.type,
        entity: entity,
        value: this.totalLable.attribute.value
      });

      this.totalLable = null;
      this.hLable = null;
      this.xLable = null;
      this.exLine = null;
    }

    //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      this.totalLable = entity.arrEntityEx[0];
      this.hLable = entity.arrEntityEx[1];
      this.xLable = entity.arrEntityEx[2];
      this.exLine = entity.arrEntityEx[3];

      this.showMoveDrawing(entity);

      this.totalLable = null;
      this.hLable = null;
      this.xLable = null;
      this.exLine = null;
    }
  }, {
    key: "type",
    get: function get() {
      return "heightTriangle";
    }
  }]);

  return MeasureHeightTriangle;
}(_MeasureHeight2.MeasureHeight);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureLengthSection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _polyline = __webpack_require__(23);

var _MeasureLength2 = __webpack_require__(38);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasureLengthSection = exports.MeasureLengthSection = function (_MeasureLength) {
  _inherits(MeasureLengthSection, _MeasureLength);

  function MeasureLengthSection() {
    _classCallCheck(this, MeasureLengthSection);

    return _possibleConstructorReturn(this, (MeasureLengthSection.__proto__ || Object.getPrototypeOf(MeasureLengthSection)).apply(this, arguments));
  }

  _createClass(MeasureLengthSection, [{
    key: "_startDraw",

    //开始绘制
    value: function _startDraw(options) {
      options.style.clampToGround = true;
      options.splitNum = Cesium.defaultValue(options.splitNum, 200);

      return _get(MeasureLengthSection.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSection.prototype), "_startDraw", this).call(this, options);
    }

    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      _get(MeasureLengthSection.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSection.prototype), "showDrawEnd", this).call(this, entity);
      this.updateSectionForTerrain(entity);
    }

    //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      _get(MeasureLengthSection.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSection.prototype), "updateForEdit", this).call(this, entity);
      this.updateSectionForTerrain(entity);
    }

    //计算剖面

  }, {
    key: "updateSectionForTerrain",
    value: function updateSectionForTerrain(entity) {
      var _this2 = this;

      var positions = this.drawControl.getPositions(entity);
      if (positions.length < 2) return;

      var arrLables = entity.arrEntityEx;
      var totalLable = entity._totalLable;
      var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

      this.target.fire(_DasClass.eventType.start, {
        mtype: this.type
      });

      var all_distance = 0;
      var arrLen = [];
      var arrHB = [];
      var arrLX = [];
      var arrPoint = [];
      // var positionsNew = [];

      var that = this;
      (0, _polyline.computeStepSurfaceLine)({
        viewer: this.viewer,
        positions: positions,
        splitNum: that.options.splitNum,
        has3dtiles: that.options.has3dtiles,
        //计算每个分段后的回调方法
        endItem: function endItem(raisedPositions, noHeight, index) {
          var h1 = Cesium.Cartographic.fromCartesian(positions[index]).height;
          var h2 = Cesium.Cartographic.fromCartesian(positions[index + 1]).height;
          var hstep = (h2 - h1) / raisedPositions.length;

          var this_distance = 0;
          for (var i = 0; i < raisedPositions.length; i++) {
            //长度
            if (i != 0) {
              var templen = Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              all_distance += templen;
              this_distance += templen;
            }
            arrLen.push(Number(all_distance.toFixed(1)));

            //海拔高度
            var point = (0, _point.formatPosition)(raisedPositions[i]);
            arrHB.push(point.z);
            arrPoint.push(point);

            //路线高度
            var fxgd = Number((h1 + hstep * i).toFixed(1));
            arrLX.push(fxgd);
          }

          index++;
          var thisLabel = arrLables[index];
          if (thisLabel) {
            thisLabel.attribute.value = all_distance;
            thisLabel.attribute.valueFD = this_distance;
            thisLabel.showText(unit);
          } else if (index == positions.length - 1 && totalLable) {
            //最后一个
            totalLable.attribute.value = all_distance;
            totalLable.attribute.valueFD = this_distance;
            totalLable.showText(unit);
          }
        },
        //计算全部完成的回调方法
        end: function end() {
          var distancestr = util.formatLength(all_distance, unit);
          var result = {
            mtype: _this2.type,
            entity: entity,
            value: all_distance,
            label: distancestr,

            distancestr: distancestr,
            distance: all_distance,
            arrLen: arrLen,
            arrLX: arrLX,
            arrHB: arrHB,
            arrPoint: arrPoint
          };

          _this2.target.fire(_DasClass.eventType.change, result);
          _this2.target.fire(_DasClass.eventType.end, result);
        }
      });
    }
  }, {
    key: "type",
    get: function get() {
      return "section";
    }
  }]);

  return MeasureLengthSection;
}(_MeasureLength2.MeasureLength);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureLengthSurface = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _measure = __webpack_require__(18);

var measureUtil = _interopRequireWildcard(_measure);

var _MeasureLength2 = __webpack_require__(38);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//贴地线
var MeasureLengthSurface = exports.MeasureLengthSurface = function (_MeasureLength) {
  _inherits(MeasureLengthSurface, _MeasureLength);

  function MeasureLengthSurface() {
    _classCallCheck(this, MeasureLengthSurface);

    return _possibleConstructorReturn(this, (MeasureLengthSurface.__proto__ || Object.getPrototypeOf(MeasureLengthSurface)).apply(this, arguments));
  }

  _createClass(MeasureLengthSurface, [{
    key: "_startDraw",

    //开始绘制
    value: function _startDraw(options) {
      options.style.clampToGround = true;

      return _get(MeasureLengthSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSurface.prototype), "_startDraw", this).call(this, options);
    }

    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      _get(MeasureLengthSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSurface.prototype), "showDrawEnd", this).call(this, entity);
      this.updateLengthForTerrain(entity);
    }
    //编辑修改了线

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      _get(MeasureLengthSurface.prototype.__proto__ || Object.getPrototypeOf(MeasureLengthSurface.prototype), "updateForEdit", this).call(this, entity);
      this.updateLengthForTerrain(entity);
    }
    //计算贴地线

  }, {
    key: "updateLengthForTerrain",
    value: function updateLengthForTerrain(entity) {
      var that = this;

      var positions = this.drawControl.getPositions(entity);
      var arrLables = entity.arrEntityEx;
      var totalLable = entity._totalLable;
      var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

      this.target.fire(_DasClass.eventType.start, {
        mtype: this.type
      });

      //求贴地线长度
      measureUtil.getClampLength(positions, {
        scene: this.viewer.scene,
        splitNum: that.options.splitNum,
        has3dtiles: that.options.has3dtiles,
        disTerrainScale: that.disTerrainScale, //求高度失败，概略估算值
        //计算每个分段后的回调方法
        endItem: function endItem(result) {
          var index = result.index;
          var all_distance = result.all_distance;
          var distance = result.distance;

          index++;
          var thisLabel = arrLables[index];
          if (thisLabel) {
            thisLabel.attribute.value = all_distance;
            thisLabel.attribute.valueFD = distance;
            thisLabel.showText(unit);
          } else if (index == positions.length - 1 && totalLable) {
            //最后一个
            totalLable.attribute.value = all_distance;
            totalLable.attribute.valueFD = distance;
            totalLable.showText(unit);
          }
        },
        //计算全部完成的回调方法
        callback: function callback(all_distance) {
          var distancestr = util.formatLength(all_distance, unit);
          var result = {
            mtype: that.type,
            entity: entity,
            value: all_distance,
            label: distancestr
          };
          that.target.fire(_DasClass.eventType.change, result);
          that.target.fire(_DasClass.eventType.end, result);
        }
      });
    }
  }, {
    key: "type",
    get: function get() {
      return "lengthSurface";
    }
  }]);

  return MeasureLengthSurface;
}(_MeasureLength2.MeasureLength);

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasurePoint = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _point = __webpack_require__(2);

var _MeasureBase2 = __webpack_require__(29);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MeasurePoint = exports.MeasurePoint = function (_MeasureBase) {
  _inherits(MeasurePoint, _MeasureBase);

  //========== 构造方法 ==========
  function MeasurePoint(opts, target) {
    _classCallCheck(this, MeasurePoint);

    var _this = _possibleConstructorReturn(this, (MeasurePoint.__proto__ || Object.getPrototypeOf(MeasurePoint)).call(this, opts, target));

    _this.totalLable = null; //角度label
    return _this;
  }

  _createClass(MeasurePoint, [{
    key: "clearLastNoEnd",

    //清除未完成的数据
    value: function clearLastNoEnd() {
      this.viewer.das.popup.close();
    }
    //开始绘制

  }, {
    key: "_startDraw",
    value: function _startDraw(options) {
      var entity = this.drawControl.startDraw({
        type: "point",
        style: _extends({
          visibleDepth: false
        }, options.style)
      });
      entity.popup = {
        html: function html(entity) {
          var position = (0, _point.getPositionValue)(entity.position);
          var point = (0, _point.formatPosition)(position);
          var x2 = util.formatDegree(point.x);
          var y2 = util.formatDegree(point.y);

          return "<div class=\"das-popup-titile\">\u5750\u6807\u6D4B\u91CF</div>\n                            <div class=\"das-popup-content\">\n                                <div><label>\u7ECF\u5EA6</label>" + point.x + "&nbsp;&nbsp;" + x2 + "</div>\n                                <div><label>\u7EAC\u5EA6</label>" + point.y + "&nbsp;&nbsp;&nbsp;&nbsp;" + y2 + "</div>\n                                <div><label>\u6D77\u62D4</label>" + point.z + "\u7C73</div>\n                            </div>";
        },
        anchor: [0, -15]
      };
      return entity;
    }
    //绘制过程移动中，动态显示长度信息

  }, {
    key: "showMoveDrawing",
    value: function showMoveDrawing(entity) {
      this.viewer.das.popup.show(entity);
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      this.viewer.das.popup.show(entity);

      this.target.fire(_DasClass.eventType.end, {
        mtype: this.type,
        entity: entity
        // position: position,
        // point: point,
      });
    }

    //编辑修改后

  }, {
    key: "updateForEdit",
    value: function updateForEdit(entity) {
      this.viewer.das.popup.show(entity);
    }
  }, {
    key: "type",
    get: function get() {
      return "point";
    }
  }]);

  return MeasurePoint;
}(_MeasureBase2.MeasureBase);

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureVolume = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _polygon = __webpack_require__(10);

var _Attr = __webpack_require__(13);

var _Attr2 = __webpack_require__(21);

var _index = __webpack_require__(22);

var _MeasureArea2 = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//体积测量（方量）
var MeasureVolume = exports.MeasureVolume = function (_MeasureArea) {
  _inherits(MeasureVolume, _MeasureArea);

  function MeasureVolume(opts, target) {
    _classCallCheck(this, MeasureVolume);

    //高度文本样式
    var _this = _possibleConstructorReturn(this, (MeasureVolume.__proto__ || Object.getPrototypeOf(MeasureVolume)).call(this, opts, target));

    _this.labelHeightStyle = _extends({}, _this.labelStyle, {
      font_size: 15,
      background: false
    });
    if (Cesium.defined(opts.labelHeight)) {
      _this.labelHeightStyle = _extends({}, _this.labelHeightStyle, opts.labelHeight);
    }

    //面的样式
    _this.polygonStyle = (0, _index.getDefStyle)("polygon", {
      color: "#00fff2",
      opacity: 0.4
    });
    if (Cesium.defined(opts.polygon)) {
      _this.polygonStyle = _extends({}, _this.polygonStyle, opts.polygon);
    }

    //基准面的样式
    _this.polygonJzmStyle = (0, _index.getDefStyle)("polygon", {
      color: "#00ff00",
      opacity: 0.3
    });
    if (Cesium.defined(opts.polygonJzm)) {
      _this.polygonJzmStyle = _extends({}, _this.polygonJzmStyle, opts.polygonJzm);
    }

    _this.heightLabel = Cesium.defaultValue(opts.heightLabel, true);
    _this.offsetLabel = Cesium.defaultValue(opts.offsetLabel, false);

    _this._last_depthTestAgainstTerrain = _this.viewer.scene.globe.depthTestAgainstTerrain;
    _this._hasFX = false;
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(MeasureVolume, [{
    key: "_startDraw",


    //开始绘制
    value: function _startDraw(options) {
      this.clear();
      options.style = this.polygonStyle || options.style;
      return _get(MeasureVolume.prototype.__proto__ || Object.getPrototypeOf(MeasureVolume.prototype), "_startDraw", this).call(this, options);
    }
    //绘制完成后

  }, {
    key: "showDrawEnd",
    value: function showDrawEnd(entity) {
      var _this2 = this;

      if (entity.polygon == null) return;

      this.totalLable.label.text = "正在计算体积…";

      var positions = this.drawControl.getPositions(entity);
      setTimeout(function () {
        _this2.calcVolume(positions, function () {
          _this2.drawControl.deleteEntity(entity);
        });
      }, 500);
    }
    //外部使用，直接传positons方式

  }, {
    key: "start",
    value: function start(positions, options) {
      this.options = options;
      this.calcVolume(positions);
    }
    //计算贴地面

  }, {
    key: "calcVolume",
    value: function calcVolume(positions, _callback) {
      var _this3 = this;

      this.target.fire(_DasClass.eventType.start, {
        mtype: this.type,
        positions: positions
      });

      this._hasFX = true;

      //计算体积
      var result = (0, _polygon.interPolygon)(_extends({
        positions: positions,
        scene: this.viewer.scene,
        asyn: true
      }, this.options, {
        callback: function callback(interPolygonObj) {
          if (_callback) _callback();

          if (!_this3._hasFX) return;
          _this3.showVolume(positions, interPolygonObj);
        }
      }));

      if (result._has3dtiles) {
        this.viewer.scene.globe.depthTestAgainstTerrain = false;
      } else {
        this.viewer.scene.globe.depthTestAgainstTerrain = true;
      }
    }
  }, {
    key: "showVolume",
    value: function showVolume(positions, interPolygonObj) {
      var _this4 = this;

      this.interPolygonObj = (0, _polygon.updateVolumeByMinHeight)(interPolygonObj);
      this._maxHeight = this.interPolygonObj.maxHeight;
      this._minHeight = this.interPolygonObj.minHeight;
      this._jzmHeight = this.interPolygonObj.minHeight;

      var fillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);

      // 显示基准面
      var entityattr = (0, _Attr2.style2Entity)(this.polygonJzmStyle, {
        hierarchy: new Cesium.PolygonHierarchy(positions),
        height: new Cesium.CallbackProperty(function (time, result) {
          return _this4.height;
        }, false)
      });
      delete entityattr.perPositionHeight;
      this.dataSource.entities.add({
        polygon: entityattr
      });

      // 显示立体边界
      delete this.polygonStyle.clampToGround;
      var entityattr3 = (0, _Attr2.style2Entity)(this.polygonStyle, {
        hierarchy: new Cesium.PolygonHierarchy(positions),
        height: new Cesium.CallbackProperty(function (time, result) {
          return _this4.minHeight;
        }, false),
        extrudedHeight: new Cesium.CallbackProperty(function (time, result) {
          return _this4.maxHeight;
        }, false),
        closeTop: false,
        closeBottom: true
      });
      this.dataSource.entities.add({
        polygon: entityattr3
      });

      //显示各点的贴地高度文本
      if (this.heightLabel) this.showPointHeightLabel(positions, this.interPolygonObj.minHeight);

      //显示计算结果文本
      if (!this.totalLable) {
        var entityattr2 = (0, _Attr.style2Entity)(this.labelStyle, {
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          show: false
        });
        this.totalLable = this.dataSource.entities.add({
          label: entityattr2,
          _noMousePosition: true,
          attribute: {}
        });
      }
      this.totalLable.attribute.value = fillV;
      this.totalLable.showText = function (unit) {
        var fillV = this.attribute.value;
        var fillText = "";
        if (fillV.fillVolume > 0) {
          fillText += "填方体积：" + formatNum(fillV.fillVolume) + "立方米\n";
        }
        if (fillV.digVolume > 0) {
          fillText += "挖方体积：" + formatNum(fillV.digVolume) + "立方米\n";
        }
        fillText += "横切面积：" + (0, _util.formatArea)(fillV.totalArea);

        this.label.text = fillText;
        return fillText;
      };
      this.totalLable.showText();
      this.totalLable.position = (0, _point.centerOfMass)(positions, this.interPolygonObj.maxHeight); //求中心点

      fillV.mtype = this.type;
      this.target.fire(_DasClass.eventType.change, fillV);
      this.target.fire(_DasClass.eventType.end, fillV);
    }

    //显示各点的贴地高度文本

  }, {
    key: "showPointHeightLabel",
    value: function showPointHeightLabel(positions, minHeight) {
      var that = this;

      var arrLable = [];
      for (var i = 0; i < positions.length; i++) {
        var height = Math.max((0, _point.getSurfaceHeight)(this.viewer.scene, positions[i]), minHeight);

        var cartographic = Cesium.Cartographic.fromCartesian(positions[i]);
        var position = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height);

        //各点的文本
        var entityattr = (0, _Attr.style2Entity)(this.labelHeightStyle, {
          horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM
        });
        var label = this.dataSource.entities.add({
          position: position,
          label: entityattr,
          attribute: { value: height }
        });
        // label.attribute.value = height;
        label.showText = function (unit) {
          var height = this.attribute.value;
          var text = "海拔：" + height.toFixed(2) + "米";

          if (that.offsetLabel) {
            var offset = height - that.height;
            if (offset > 0) text += "\n高度：" + offset.toFixed(2) + "米(面上)";else text += "\n高度：" + Math.abs(offset).toFixed(2) + "米(面下)";
          }

          this.label.text = text;
          return text;
        };
        label.showText();
        arrLable.push(label);
      }
      this.arrLables = arrLable;
    }
  }, {
    key: "selecteHeight",
    value: function selecteHeight(callback) {
      //拾取高度
      var that = this;
      this.drawControl.startDraw({
        type: "point",
        style: {
          color: "#00fff2"
        },
        success: function success(entity) {
          if (!entity.point) return;

          var pos = entity._position._value;
          var height = Cesium.Cartographic.fromCartesian(pos).height;
          that.height = height;

          that.drawControl.deleteEntity(entity);

          if (callback) callback(height);
        }
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      delete this.interPolygonObj;
      delete this._maxHeight;
      delete this._minHeight;
      delete this._jzmHeight;

      delete this.totalLable;
      delete this.arrLables;

      _get(MeasureVolume.prototype.__proto__ || Object.getPrototypeOf(MeasureVolume.prototype), "clear", this).call(this);
      this._hasFX = false;
    }
  }, {
    key: "type",
    get: function get() {
      return "volume";
    }

    //面内的最高地表高度

  }, {
    key: "polygonMaxHeight",
    get: function get() {
      if (this.interPolygonObj) return this.interPolygonObj.maxHeight;else return this.maxHeight;
    }

    //高度

  }, {
    key: "height",
    get: function get() {
      return this._jzmHeight;
    },
    set: function set(val) {
      this._jzmHeight = val;
      if (val > this.maxHeight) this.maxHeight = val;
      if (val < this.minHeight) this.minHeight = val;

      if (!this._hasFX) return;

      var newFillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);
      this.totalLable.attribute.value = newFillV;
      this.totalLable.showText();

      if (this.arrLables) {
        for (var i = 0; i < this.arrLables.length; i++) {
          this.arrLables[i].showText();
        }
      }
      this.target.fire(_DasClass.eventType.change, _extends({
        mtype: this.type
      }, newFillV));
    }
  }, {
    key: "minHeight",
    get: function get() {
      return this._minHeight;
    },
    set: function set(val) {
      this._minHeight = val;

      if (!this._hasFX) return;

      if (this.interPolygonObj) {
        this.interPolygonObj.minHeight = val;
        this.interPolygonObj = (0, _polygon.updateVolumeByMinHeight)(this.interPolygonObj);
      }
      var newFillV = (0, _polygon.updateVolume)(this.interPolygonObj, this.height);
      this.totalLable.attribute.value = newFillV;
      this.totalLable.showText();

      this.target.fire(_DasClass.eventType.change, _extends({
        mtype: this.type
      }, newFillV));
    }
  }, {
    key: "maxHeight",
    get: function get() {
      return this._maxHeight;
    },
    set: function set(val) {
      this._maxHeight = val;
    }
  }]);

  return MeasureVolume;
}(_MeasureArea2.MeasureArea);

//格式化数值


function formatNum(num) {
  if (num > 10000) {
    return (num / 10000).toFixed(2) + "万";
  }
  return num.toFixed(2);
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomPlaneGeometry = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CustomPlaneGeometry = exports.CustomPlaneGeometry = function () {
  function CustomPlaneGeometry(options) {
    _classCallCheck(this, CustomPlaneGeometry);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    var vertexFormat = new Cesium.VertexFormat({
      st: true,
      position: true,
      bitangent: false,
      normal: false,
      color: false,
      tangent: false
    });
    this._pos_arr = Cesium.clone(options.pos_arr);
    this._vertexFormat = vertexFormat;
    var Rect = new Cesium.BoundingRectangle();
    this._SERectangle = Cesium.BoundingRectangle.fromPoints(this._pos_arr, Rect);
    this._workerName = "createCustomPlaneGeometry";
  }

  /**
   * Computes the geometric representation of a plane, including its vertices, and a bounding sphere.
   *
   * @param {CustomPlaneGeometry} CustomPlaneGeometry A description of the plane.
   * @returns {Geometry|undefined} The computed vertices and indices.
   */


  _createClass(CustomPlaneGeometry, [{
    key: "createGeometry",
    value: function createGeometry(geometry) {
      var vertexFormat = geometry._vertexFormat;
      var SERectangle = geometry._SERectangle;
      var pos_arr = geometry._pos_arr;
      var attributes = new Cesium.GeometryAttributes();
      var indices;
      var positions;
      var poslen = pos_arr.length;
      if (Cesium.defined(vertexFormat.position)) {
        // 4 corner points.  Duplicated 3 times each for each incident edge/face.
        positions = new Float64Array(poslen * 3);

        for (var i = 0; i < poslen; i++) {
          positions[i % poslen * 3 + 0] = pos_arr[i].x;
          positions[i % poslen * 3 + 1] = pos_arr[i].y;
          positions[i % poslen * 3 + 2] = pos_arr[i].z;
        }

        attributes.position = new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: positions
        });

        if (Cesium.defined(vertexFormat.st)) {
          var texCoords = new Float32Array(poslen * 2);
          // var oX = SERectangle.x - SERectangle.width;
          // var oY = SERectangle.y - SERectangle.height;
          var oX = SERectangle.x;
          var oY = SERectangle.y;
          for (var _i = 0; _i < poslen; _i++) {
            texCoords[_i * 2 + 0] = Math.abs((positions[_i * 3 + 0] - oX) / SERectangle.width);
            texCoords[_i * 2 + 1] = Math.abs((positions[_i * 3 + 1] - oY) / SERectangle.height);
          }
          attributes.st = new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: texCoords
          });
        }

        indices = new Uint16Array((poslen - 2) * 3);

        for (var _i2 = 1; _i2 < poslen - 1; _i2++) {
          indices[(_i2 - 1) * 3 + 0] = 0;
          indices[(_i2 - 1) * 3 + 1] = _i2;
          indices[(_i2 - 1) * 3 + 2] = _i2 + 1;
        }
      }

      return new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLE_FAN,
        boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, Math.sqrt(2.0))
      });
    }
  }]);

  return CustomPlaneGeometry;
}();

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WellNoBottom = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WellNoBottom = exports.WellNoBottom = function () {
  function WellNoBottom(options) {
    _classCallCheck(this, WellNoBottom);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    var min = options.minimumArr;
    var max = options.maximumArr;
    Cesium.Check.defined("dingmian", max);
    Cesium.Check.defined("dimianmian", min);

    Cesium.Check.typeOf.number.greaterThanOrEquals("dingmian.length", max.length, 3);
    Cesium.Check.typeOf.number.greaterThanOrEquals("dimian.length", min.length, 3);

    var vertexFormat = new Cesium.VertexFormat({
      st: true,
      position: true,
      bitangent: false,
      normal: false,
      color: false,
      tangent: false
    });

    this._minimumArr = Cesium.clone(min);
    this._maximumArr = Cesium.clone(max);
    this._vertexFormat = vertexFormat;
    this._workerName = "createWellNoBottom";
  }

  _createClass(WellNoBottom, [{
    key: "createGeometry",
    value: function createGeometry(WellNoBottom, that) {
      var min = WellNoBottom._minimumArr;
      var max = WellNoBottom._maximumArr;
      var vertexFormat = WellNoBottom._vertexFormat;

      var attributes = new Cesium.GeometryAttributes();
      var indices;
      var positions;
      if (Cesium.defined(vertexFormat.position) && Cesium.defined(vertexFormat.st)) {
        if (Cesium.defined(vertexFormat.position)) {
          // 8 corner points.  Duplicated 3 times each for each incident edge/face.
          positions = new Float64Array(max.length * 4 * 3);

          for (var i = 0; i < max.length; i++) {
            if (i == max.length - 1) {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;

              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;

              positions[i * 12 + 9] = min[0].x;
              positions[i * 12 + 10] = min[0].y;
              positions[i * 12 + 11] = min[0].z;

              positions[i * 12 + 6] = max[0].x;
              positions[i * 12 + 7] = max[0].y;
              positions[i * 12 + 8] = max[0].z;

              // positions.push(max[i].x,max[i].y,max[i].z);
              // positions.push(min[i].x,min[i].y,min[i].z);
              // positions.push(min[0].x,min[0].y,min[0].z);
              // positions.push(max[0].x,max[0].y,max[0].z);
            } else {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;

              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;

              positions[i * 12 + 9] = min[i + 1].x;
              positions[i * 12 + 10] = min[i + 1].y;
              positions[i * 12 + 11] = min[i + 1].z;

              positions[i * 12 + 6] = max[i + 1].x;
              positions[i * 12 + 7] = max[i + 1].y;
              positions[i * 12 + 8] = max[i + 1].z;

              // positions.push(max[i].x,max[i].y,max[i].z);
              // positions.push(min[i].x,min[i].y,min[i].z);
              // positions.push(min[i+1].x,min[i+1].y,min[i+1].z);
              // positions.push(max[i+1].x,max[i+1].y,max[i+1].z);
            }
          }

          attributes.position = new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          });
        }

        var top_heights = that.top_heights;
        var maxHeight = that.maxHeight || 0;
        var splitNum = that.splitNum;

        if (Cesium.defined(vertexFormat.st)) {
          var texCoords = new Float32Array(max.length * 4 * 2);
          var maxLen = max.length;
          for (var _i = 0; _i < max.length; _i++) {
            var currX = _i / maxLen;
            var currMaxHeight = top_heights && top_heights[_i] || 0;
            var currY = (currMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);
            var nextIndex = _i + 1;
            // if (i == max.length - 1) {
            //     nextIndex = 0;
            // }
            var nextMaxHeight = top_heights && top_heights[nextIndex] || 0;
            var nextX = nextIndex / maxLen;
            var nextY = (nextMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);

            texCoords[_i * 8 + 0] = currX;
            texCoords[_i * 8 + 1] = currY - 0.0;
            texCoords[_i * 8 + 2] = currX;
            texCoords[_i * 8 + 3] = currY - currY;
            texCoords[_i * 8 + 4] = nextX;
            texCoords[_i * 8 + 5] = nextY - 0.0;
            texCoords[_i * 8 + 6] = nextX;
            texCoords[_i * 8 + 7] = nextY - nextY;

            // texCoords[i*8 + 0]  = 0.0;
            // texCoords[i*8 + 1]  = 0.0;
            // texCoords[i*8 + 2]  = 0.0;
            // texCoords[i*8 + 3]  = 1.0;
            // texCoords[i*8 + 4]  = 1.0;
            // texCoords[i*8 + 5]  = 0.0;
            // texCoords[i*8 + 6]  = 1.0;
            // texCoords[i*8 + 7]  = 1.0;
          }

          attributes.st = new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: texCoords
          });
        }

        // 12 triangles:  6 faces, 2 triangles each.
        indices = new Uint16Array(max.length * 2 * 3);
        var min_pos = new Cesium.Cartesian3(9999999999999, 9999999999999, 9999999999999);
        var max_pos = new Cesium.Cartesian3(-9999999999999, -9999999999999, -9999999999999);
        for (var _i2 = 0; _i2 < max.length; _i2++) {
          indices[_i2 * 6 + 0] = 4 * _i2 + 0;
          indices[_i2 * 6 + 1] = 4 * _i2 + 1;
          indices[_i2 * 6 + 2] = 4 * _i2 + 2;
          indices[_i2 * 6 + 3] = 4 * _i2 + 1;
          indices[_i2 * 6 + 4] = 4 * _i2 + 2;
          indices[_i2 * 6 + 5] = 4 * _i2 + 3;

          if (max[_i2].x >= max_pos.x && max[_i2].y >= max_pos.y && max[_i2].z >= max_pos.z) {
            max_pos = max[_i2];
          }
          if (min[_i2].x <= min_pos.x && min[_i2].y <= min_pos.y && min[_i2].z <= min_pos.z) {
            min_pos = min[_i2];
          }
        }
      }

      var diff = Cesium.Cartesian3.subtract(max_pos, min_pos, new Cesium.Cartesian3());
      var radius = Cesium.Cartesian3.magnitude(diff) * 0.5;

      return new Cesium.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, radius)
      });
    }
  }]);

  return WellNoBottom;
}();

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RectangularSensorGraphics = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function RectangularSensorGraphics(options) {
  this._show = undefined;
  this._radius = undefined;
  this._xHalfAngle = undefined;
  this._yHalfAngle = undefined;
  this._lineColor = undefined;
  this._showSectorLines = undefined;
  this._showSectorSegmentLines = undefined;
  this._showLateralSurfaces = undefined;
  this._material = undefined;
  this._showDomeSurfaces = undefined;
  this._showDomeLines = undefined;
  this._showIntersection = undefined;
  this._intersectionColor = undefined;
  this._intersectionWidth = undefined;
  this._showThroughEllipsoid = undefined;
  this._gaze = undefined;
  this._showScanPlane = undefined;
  this._scanPlaneColor = undefined;
  this._scanPlaneMode = undefined;
  this._scanPlaneRate = undefined;
  this._definitionChanged = new Cesium.Event();
  this.merge(Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT));
}

Object.defineProperties(RectangularSensorGraphics.prototype, {
  definitionChanged: {
    get: function get() {
      return this._definitionChanged;
    }
  },

  show: Cesium.createPropertyDescriptor("show"),
  radius: Cesium.createPropertyDescriptor("radius"),
  xHalfAngle: Cesium.createPropertyDescriptor("xHalfAngle"),
  yHalfAngle: Cesium.createPropertyDescriptor("yHalfAngle"),
  lineColor: Cesium.createPropertyDescriptor("lineColor"),
  showSectorLines: Cesium.createPropertyDescriptor("showSectorLines"),
  showSectorSegmentLines: Cesium.createPropertyDescriptor("showSectorSegmentLines"),
  showLateralSurfaces: Cesium.createPropertyDescriptor("showLateralSurfaces"),
  material: Cesium.createMaterialPropertyDescriptor("material"),
  showDomeSurfaces: Cesium.createPropertyDescriptor("showDomeSurfaces"),
  showDomeLines: Cesium.createPropertyDescriptor("showDomeLines"),
  showIntersection: Cesium.createPropertyDescriptor("showIntersection"),
  intersectionColor: Cesium.createPropertyDescriptor("intersectionColor"),
  intersectionWidth: Cesium.createPropertyDescriptor("intersectionWidth"),
  showThroughEllipsoid: Cesium.createPropertyDescriptor("showThroughEllipsoid"),
  gaze: Cesium.createPropertyDescriptor("gaze"),
  showScanPlane: Cesium.createPropertyDescriptor("showScanPlane"),
  scanPlaneColor: Cesium.createPropertyDescriptor("scanPlaneColor"),
  scanPlaneMode: Cesium.createPropertyDescriptor("scanPlaneMode"),
  scanPlaneRate: Cesium.createPropertyDescriptor("scanPlaneRate")
});

RectangularSensorGraphics.prototype.clone = function (result) {
  if (!Cesium.defined(result)) {
    result = new RectangularSensorGraphics();
  }

  result.show = this.show;
  result.radius = this.radius;
  result.xHalfAngle = this.xHalfAngle;
  result.yHalfAngle = this.yHalfAngle;
  result.lineColor = this.lineColor;
  result.showSectorLines = this.showSectorLines;
  result.showSectorSegmentLines = this.showSectorSegmentLines;
  result.showLateralSurfaces = this.showLateralSurfaces;
  result.material = this.material;
  result.showDomeSurfaces = this.showDomeSurfaces;
  result.showDomeLines = this.showDomeLines;
  result.showIntersection = this.showIntersection;
  result.intersectionColor = this.intersectionColor;
  result.intersectionWidth = this.intersectionWidth;
  result.showThroughEllipsoid = this.showThroughEllipsoid;
  result.gaze = this.gaze;
  result.showScanPlane = this.showScanPlane;
  result.scanPlaneColor = this.scanPlaneColor;
  result.scanPlaneMode = this.scanPlaneMode;
  result.scanPlaneRate = this.scanPlaneRate;

  return result;
};

RectangularSensorGraphics.prototype.merge = function (source) {
  if (!Cesium.defined(source)) {
    throw new Cesium.DeveloperError("source is required.");
  }
  this.slice = Cesium.defaultValue(this.slice, source.slice);
  this.show = Cesium.defaultValue(this.show, source.show);
  this.radius = Cesium.defaultValue(this.radius, source.radius);
  this.xHalfAngle = Cesium.defaultValue(this.xHalfAngle, source.xHalfAngle);
  this.yHalfAngle = Cesium.defaultValue(this.yHalfAngle, source.yHalfAngle);
  this.lineColor = Cesium.defaultValue(this.lineColor, source.lineColor);
  this.showSectorLines = Cesium.defaultValue(this.showSectorLines, source.showSectorLines);
  this.showSectorSegmentLines = Cesium.defaultValue(this.showSectorSegmentLines, source.showSectorSegmentLines);
  this.showLateralSurfaces = Cesium.defaultValue(this.showLateralSurfaces, source.showLateralSurfaces);
  this.material = Cesium.defaultValue(this.material, source.material);
  this.showDomeSurfaces = Cesium.defaultValue(this.showDomeSurfaces, source.showDomeSurfaces);
  this.showDomeLines = Cesium.defaultValue(this.showDomeLines, source.showDomeLines);
  this.showIntersection = Cesium.defaultValue(this.showIntersection, source.showIntersection);
  this.intersectionColor = Cesium.defaultValue(this.intersectionColor, source.intersectionColor);
  this.intersectionWidth = Cesium.defaultValue(this.intersectionWidth, source.intersectionWidth);
  this.showThroughEllipsoid = Cesium.defaultValue(this.showThroughEllipsoid, source.showThroughEllipsoid);
  this.gaze = Cesium.defaultValue(this.gaze, source.gaze);
  this.showScanPlane = Cesium.defaultValue(this.showScanPlane, source.showScanPlane);
  this.scanPlaneColor = Cesium.defaultValue(this.scanPlaneColor, source.scanPlaneColor);
  this.scanPlaneMode = Cesium.defaultValue(this.scanPlaneMode, source.scanPlaneMode);
  this.scanPlaneRate = Cesium.defaultValue(this.scanPlaneRate, source.scanPlaneRate);
};

exports.RectangularSensorGraphics = RectangularSensorGraphics;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesClipPlan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _measure = __webpack_require__(18);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//模型剖切(平面)类
var TilesClipPlan = exports.TilesClipPlan = function () {
  //========== 构造方法 ==========
  function TilesClipPlan(options, oldparam) {
    _classCallCheck(this, TilesClipPlan);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (oldparam) {
      oldparam.tileset = options;
      options = oldparam;
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    this.options = options;

    if (options.tileset) this._tileset = options.tileset;else if (options.entity) this._tileset = options.entity;

    if (options.type) {
      this.type = options.type;
    }
    if (options.positions) {
      this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);
      this.positions = options.positions;
    }
    if (Cesium.defined(options.distance)) {
      this.distance = options.distance;
    }
    if (Cesium.defined(options.height)) {
      this.distance = options.height;
    }
  }

  //========== 对外属性 ==========


  _createClass(TilesClipPlan, [{
    key: "clipByType",


    //========== 方法 ==========

    //根据类型 创建裁剪面
    value: function clipByType(type, opts) {
      //裁剪面
      var planes;
      switch (type) {
        case TilesClipPlan.Type.Z:
          //水平切底部
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, 1), 1) //z水平面
          ];
          break;
        case TilesClipPlan.Type.ZR:
          //水平切顶部
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, -1), 1) //z水平面
          ];
          break;

        case TilesClipPlan.Type.X:
          //东西方向切1
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(1, 0, 0), 1) //x垂直面
          ];
          break;
        case TilesClipPlan.Type.XR:
          //东西方向切2
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(-1, 0, 0), 1) //x垂直面
          ];
          break;

        case TilesClipPlan.Type.Y:
          //南北方向切1
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 1, 0), 1) //y垂直面
          ];
          break;
        case TilesClipPlan.Type.YR:
          //南北方向切2
          planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, -1, 0), 1) //y垂直面
          ];
          break;
      }

      this.setPlanes(planes, opts);
    }

    //更新裁剪距离(全部)

  }, {
    key: "updateAllDistance",
    value: function updateAllDistance(val) {
      if (this.clippingPlanes == null) return;

      for (var i = 0; i < this.clippingPlanes.length; i++) {
        var plane = this.clippingPlanes.get(i);
        plane.distance = val;
      }
    }

    //更新裁剪距离

  }, {
    key: "updateDistance",
    value: function updateDistance(val) {
      if (this.clippingPlanes == null) return;

      var len = this.clippingPlanes.length;
      if (len == 0) return;

      var plane = this.clippingPlanes.get(len - 1);
      plane.distance = val;
    }

    //根据坐标 创建裁剪面

  }, {
    key: "clipByPoints",
    value: function clipByPoints(points, opts) {
      opts = opts || {};
      opts.unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切

      if (points.length < 2) return;

      var planes = [];
      if (points.length == 2) {
        //线
        planes = [this._createPlaneByLine(points[0], points[1])];
      } else {
        //面

        //是否顺时针
        var startAngle = (0, _measure.getAngle)(points[0], points[1]);
        var endAngle = (0, _measure.getAngle)(points[0], points[2]);
        var direction = startAngle < endAngle;
        if (opts.unionClippingRegions) direction = !direction;

        var plan;
        for (var i = 0, len = points.length; i < len; ++i) {
          var nextIndex = (i + 1) % len;

          if (direction) plan = this._createPlaneByLine(points[nextIndex], points[i]);else plan = this._createPlaneByLine(points[i], points[nextIndex]);

          planes.push(plan);
        }

        var clipHeight = Cesium.defaultValue(opts.height, this.distance);
        if (Cesium.defined(clipHeight)) {
          plan = new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, -1), clipHeight); //底面
          planes.push(plan);
        }
      }

      this.setPlanes(planes, opts);
    }
  }, {
    key: "_createPlaneByLine",
    value: function _createPlaneByLine(p1, p2) {
      // 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象
      var p1C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p1, new Cesium.Cartesian3(0, 0, 0));
      var p2C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p2, new Cesium.Cartesian3(0, 0, 0));

      // 定义一个垂直向上的向量up
      var up = new Cesium.Cartesian3(0, 0, 10);
      //  right 实际上就是由p1指向p2的向量
      var right = Cesium.Cartesian3.subtract(p2C3, p1C3, new Cesium.Cartesian3());

      // 计算normal， right叉乘up，得到平面法向量，这个法向量指向right的右侧
      var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
      normal = Cesium.Cartesian3.normalize(normal, normal);

      //由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane
      var planeTmp = Cesium.Plane.fromPointNormal(p1C3, normal);
      return Cesium.ClippingPlane.fromPlane(planeTmp);
    }
  }, {
    key: "getInverseTransform",
    value: function getInverseTransform() {
      if (!this._inverseTransform) {
        var transform = void 0;
        var tmp = this._tileset.root.transform;
        if (tmp && tmp.equals(Cesium.Matrix4.IDENTITY) || !tmp) {
          // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
          transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform = Cesium.Matrix4.fromArray(this._tileset.root.transform);
        }
        this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
      }
      return this._inverseTransform;
    }
  }, {
    key: "setPlanes",
    value: function setPlanes(planes, opts) {
      opts = opts || {};

      this.clear();
      if (!planes) return;

      var clippingPlanes = new Cesium.ClippingPlaneCollection({
        // modelMatrix : Cesium.Transforms.eastNorthUpToFixedFrame(position),
        planes: planes,
        edgeWidth: Cesium.defaultValue(opts.edgeWidth, 0.0),
        edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
        unionClippingRegions: Cesium.defaultValue(opts.unionClippingRegions, false)
      });
      this.clippingPlanes = clippingPlanes;
      this._tileset.clippingPlanes = clippingPlanes;
    }

    //清除裁剪面

  }, {
    key: "clear",
    value: function clear() {
      if (this._tileset.clippingPlanes) {
        this._tileset.clippingPlanes.enabled = false;
        this._tileset.clippingPlanes.removeAll();
        // if (!this._tileset.clippingPlanes.isDestroyed())
        //     this._tileset.clippingPlanes.destroy();
        this._tileset.clippingPlanes = undefined;
      }

      if (this.clippingPlanes) {
        delete this.clippingPlanes;
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "tileset",
    get: function get() {
      return this._tileset;
    },
    set: function set(val) {
      this._tileset = val;
      this._inverseTransform = null;
    }

    //裁剪面

  }, {
    key: "planes",
    get: function get() {
      return this.clippingPlanes;
    }
  }, {
    key: "inverseTransform",
    get: function get() {
      return this.getInverseTransform();
    }

    //裁剪距离

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    },
    set: function set(val) {
      this._distance = val;
      this.updateDistance(val);
    }

    //裁剪类型

  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      this._type = val;

      this.clipByType(val);
    }

    //裁剪类型

  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = val;

      this.clipByPoints(val, { unionClippingRegions: this._clipOutSide });
    }
  }]);

  return TilesClipPlan;
}();

/**
 * 裁剪模型 类型 枚举
 *@enum {Number}
 */


TilesClipPlan.Type = {
  /** z水平面,水平切底部 */
  Z: 1,
  /** z水平面，水平切顶部 */
  ZR: 2,
  /** x垂直面,水平切底部 */
  X: 3,
  /** x垂直面,东西方向切 */
  XR: 4,
  /** y垂直面, 南北方向切 */
  Y: 5,
  /** y垂直面，南北方向切*/
  YR: 6
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseFlyLine = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(16);

var _index = __webpack_require__(22);

var drawAttr = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//飞行路线管理类 基类
var BaseFlyLine = exports.BaseFlyLine = function (_DasClass) {
  _inherits(BaseFlyLine, _DasClass);

  //========== 构造方法 ==========
  function BaseFlyLine(viewer, options) {
    _classCallCheck(this, BaseFlyLine);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (BaseFlyLine.__proto__ || Object.getPrototypeOf(BaseFlyLine)).call(this, options));

    if (options.onStep) {
      var onStepfun = options.onStep;
      delete options.onStep;
      _this.on(_DasClass2.eventType.endItem, function (e) {
        onStepfun(e.index, e.counts);
      });
    }
    if ((0, _util.isObject)(options.shadow) && options.shadow.show) {
      //兼容v1版本shadow
      options.shadow = [options.shadow];
    }
    _this.toGeoJSON = _this.toJSON;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = viewer;
    _this.options = options; //属性
    _this._mergeDefVal(); //合并默认值

    _this.id = options.id || 0;
    _this.name = options.name || "";
    _this._popup = options.popup;
    _this._tooltip = options.tooltip;
    _this._fixedFrameTransform = Cesium.defaultValue(options.fixedFrameTransform, Cesium.Transforms.eastNorthUpToFixedFrame); //参考系

    _this.positions = [];
    _this.times = [];

    _this.init();
    return _this;
  }

  //========== 对外属性 ==========


  _createClass(BaseFlyLine, [{
    key: "_mergeDefVal",
    value: function _mergeDefVal() {
      for (var key in this.defConfig) {
        var val = this.defConfig[key];

        if (this.options.hasOwnProperty(key) && _typeof(this.options[key]) === "object") {
          for (var key2 in val) {
            if (!this.options[key].hasOwnProperty(key2)) this.options[key][key2] = val[key2];
          }
        } else {
          if (!Cesium.defined(this.options[key])) this.options[key] = val;
        }
      }
    }

    //提示框

  }, {
    key: "init",


    //========== 方法 ==========
    value: function init() {}
  }, {
    key: "_createEntity",
    value: function _createEntity() {
      var _this2 = this;

      var entityAttr = {
        name: this.name,
        position: new Cesium.CallbackProperty(function (time) {
          return _this2.position;
        }, false),
        orientation: this.velocityOrientation,
        point: {
          //必须有对象，否则viewer.trackedEntity无法跟随(无model时使用)
          show: !(this.options.model && this.options.model.show),
          color: Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.01),
          pixelSize: 1
          // show: false
        } };

      if (this.options.label && this.options.label.show) {
        this.options.label.text = this.options.label.text || this.name;
        entityAttr.label = drawAttr.label.style2Entity(this.options.label, null, this);
      }
      if (this.options.billboard && this.options.billboard.show) {
        entityAttr.billboard = drawAttr.billboard.style2Entity(this.options.billboard);
      }
      if (this.options.point && this.options.point.show) {
        entityAttr.point = drawAttr.point.style2Entity(this.options.point);
      }
      if (this.options.model && this.options.model.show) {
        entityAttr.model = drawAttr.model.style2Entity(this.options.model);
      }
      if (this.options.path && this.options.path.show) {
        var pathAttr = drawAttr.polyline.style2Entity(this.options.path);
        if (!pathAttr.isAll) {
          pathAttr.leadTime = 0; //只显示飞过的路线
          pathAttr.trailTime = this.alltimes * 10;
        }
        entityAttr.path = pathAttr;
        entityAttr.position = this.property; //path时需要为直接property
      }
      if (this.options.circle && this.options.circle.show) {
        entityAttr.ellipse = drawAttr.circle.style2Entity(this.options.circle);
      }
      this.entity = this.viewer.entities.add(new Cesium.Entity(entityAttr));

      this.entity.eventTarget = this;
      if (this.popup) this.entity.popup = this.popup;
      if (this.tooltip) this.entity.tooltip = this.tooltip;
    }
  }, {
    key: "updateConfig",
    value: function updateConfig(params) {
      return this.updateStyle(params);
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(params) {
      if (!this.options) return;
      for (var i in params) {
        if (_typeof(params[i]) === "object" && this.options[i]) {
          for (var key2 in params[i]) {
            this.options[i][key2] = params[i][key2];
          }
        } else {
          this.options[i] = params[i];
        }
      }
    }
  }, {
    key: "updateAngle",
    value: function updateAngle(isAuto, opts) {
      if (isAuto) {
        this.entity.orientation = this.velocityOrientation; //基于移动位置自动计算方位

        this._heading = null;
        this._pitch = null;
        this._roll = null;
      } else {
        opts = opts || {};

        var position = this.position; //当前点
        var _orientation = this.orientation; //获取当前角度
        if (!position || !_orientation) return null;

        var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);

        //重新赋值新角度
        var heading = autoHpr.heading;
        var pitch = Cesium.Math.toRadians(Number(opts.pitch || 0.0));
        var roll = Cesium.Math.toRadians(Number(opts.roll || 0.0));

        this._heading = heading;
        this._pitch = pitch;
        this._roll = roll;

        this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, new Cesium.HeadingPitchRoll(heading, pitch, roll), this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
      }
    }

    //获取已飞行完成的点的位置
    //JulianDate.compare(left, right), 如果left小于right，则为负值；如果left大于right，则为正值；如果left和right相等，则为零。

  }, {
    key: "getCurrIndex",
    value: function getCurrIndex() {
      var lineLength = this.times.length - 1;
      if (lineLength < 0) return -1;

      if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, this.times[0]) <= 0) {
        this._flyok_point_index = 0;
      }
      if (this._flyok_point_index < 0 || this._flyok_point_index >= lineLength) this._flyok_point_index = 0;

      for (var i = this._flyok_point_index; i <= lineLength; i++) {
        var time = this.times[i];
        if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, time) <= 0) {
          return i - 1;
        }
      }
      for (var _i = 0; _i <= lineLength; _i++) {
        var _time = this.times[_i];
        if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, _time) <= 0) {
          return _i - 1;
        }
      }
      return lineLength;
    }

    //锁定视角计算

  }, {
    key: "getModelMatrix",
    value: function getModelMatrix() {
      var matrix4 = new Cesium.Matrix4();
      var matrix3Scratch = new Cesium.Matrix3();

      var position = this.position;
      if (!Cesium.defined(position)) {
        return undefined;
      }
      var result;
      var orientation = this.orientation;
      if (!Cesium.defined(orientation)) {
        result = this._fixedFrameTransform(position, undefined, matrix4);
      } else {
        result = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4);
      }
      return result;
    }

    //加投影等额外的entity对象

  }, {
    key: "_addArrShading",
    value: function _addArrShading() {
      this.arrShowingEntity = [];
      for (var i = 0, len = this.options.shadow.length; i < len; i++) {
        var item = this.options.shadow[i];
        if (!item.show) continue;
        this.addShading(item);
      }
    }
  }, {
    key: "_updateArrShading",
    value: function _updateArrShading(position) {
      for (var i = 0, len = this.options.shadow.length; i < len; i++) {
        var item = this.options.shadow[i];
        if (!item.show) continue;
        var positions = void 0;
        switch (item.type) {
          case "wall":
            positions = this.positions.slice(0, this._flyok_point_index + 1);
            positions.push(position);
            this.updateWallShading(positions);
            break;
          case "polyline":
            positions = this.positions.slice(0, this._flyok_point_index + 1);
            positions.push(position);
            if (item.maxDistance) this._passed_positions = (0, _point.sliceByMaxDistance)(positions, item.maxDistance);else this._passed_positions = positions;
            break;
          case "polyline-going":
            positions = [position].concat(this.positions.slice(this._flyok_point_index + 1));
            this._going_positions = positions;
            break;
        }
      }
    }

    //添加单个投影

  }, {
    key: "addShading",
    value: function addShading(item) {
      var entity;
      switch (item.type) {
        case "wall":
          entity = this.addWallShading(item);
          break;
        case "cylinder":
          entity = this.addCylinderShading(item);
          break;
        case "circle":
          entity = this.addCircleShading(item);
          break;
        case "polyline":
        case "polyline-going":
          entity = this.addPolylineShading(item);
          break;
        default:
          daslog.warn("存在未标识type的无效shadow配置", item);
          break;
      }
      if (entity) {
        entity.data = item;
        this.arrShowingEntity.push(entity);
      }
    }

    //移除单个投影

  }, {
    key: "removeShading",
    value: function removeShading(entity) {
      if (entity == null) {
        if (this.arrShowingEntity.length == 0) return;
        //为空时，默认删除最后一个。
        var index = this.arrShowingEntity.length - 1;
        this.viewer.entities.remove(this.arrShowingEntity[index]);
        this.arrShowingEntity.splice(index, 1);
      } else if ((0, _util.isString)(entity)) {
        //删除指定类型的
        for (var i = 0, len = this.arrShowingEntity.length; i < len; i++) {
          if (this.arrShowingEntity[i].data.type == entity) {
            this.viewer.entities.remove(this.arrShowingEntity[i]);
            this.arrShowingEntity.splice(i, 1);
            break;
          }
        }
        return;
      } else {
        //删除传入的entity
        this.viewer.entities.remove(entity);
        if (this.arrShowingEntity) {
          for (var _i2 = 0, _len = this.arrShowingEntity.length; _i2 < _len; _i2++) {
            if (this.arrShowingEntity[_i2] == entity) {
              this.arrShowingEntity.splice(_i2, 1);
              break;
            }
          }
        }
      }
    }

    //垂直线立体投影

  }, {
    key: "addWallShading",
    value: function addWallShading(options) {
      this._wall_positions = [];
      this._wall_minimumHeights = [];
      this._wall_maximumHeights = [];

      options = _extends({ color: "#00ff00", outline: false, opacity: 0.3 }, options);

      var that = this;
      var wallattr = drawAttr.wall.style2Entity(options);
      wallattr.minimumHeights = new Cesium.CallbackProperty(function (time) {
        return that._wall_minimumHeights;
      }, false);
      wallattr.maximumHeights = new Cesium.CallbackProperty(function (time) {
        return that._wall_maximumHeights;
      }, false);
      wallattr.positions = new Cesium.CallbackProperty(function (time) {
        return that._wall_positions;
      }, false);

      var wallEntity = this.viewer.entities.add(new Cesium.Entity({
        wall: wallattr
      }));
      return wallEntity;
    }
  }, {
    key: "updateWallShading",
    value: function updateWallShading(positions) {
      var newposition = [];
      var minimumHeights = [];
      var maximumHeights = [];
      for (var i = 0; i < positions.length; i++) {
        var point = positions[i].clone();
        if (!point) continue;

        newposition.push(point);
        var carto = Cesium.Cartographic.fromCartesian(point);
        minimumHeights.push(0);
        maximumHeights.push(carto.height);
      }
      this._wall_positions = newposition;
      this._wall_minimumHeights = minimumHeights;
      this._wall_maximumHeights = maximumHeights;
    }

    //圆锥立体 投影

  }, {
    key: "addCylinderShading",
    value: function addCylinderShading(options) {
      var bottomRadiusNow = 100;
      var lengthNow = 100;

      var that = this;

      options = _extends({ color: "#00ff00", outline: false, opacity: 0.3 }, options);

      var wallattr = drawAttr.wall.style2Entity(options); //主要是颜色值等属性
      wallattr.length = new Cesium.CallbackProperty(function (time) {
        return lengthNow;
      }, false);
      wallattr.topRadius = 0;
      wallattr.bottomRadius = new Cesium.CallbackProperty(function (time) {
        return bottomRadiusNow;
      }, false);
      wallattr.numberOfVerticalLines = 0;

      var cylinderEntity = this.viewer.entities.add(new Cesium.Entity({
        position: new Cesium.CallbackProperty(function (time) {
          var position = that.position;
          if (!position) return null;
          var car = Cesium.Cartographic.fromCartesian(position);
          var newPoint = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height / 2);

          lengthNow = car.height;
          bottomRadiusNow = lengthNow * 0.3; //地面圆半径

          return newPoint;
        }, false),
        cylinder: wallattr
      }));
      return cylinderEntity;
    }

    //扩散圆 投影

  }, {
    key: "addCircleShading",
    value: function addCircleShading(options) {
      var attr = drawAttr.circle.style2Entity(options);

      var entity = this.viewer.entities.add(new Cesium.Entity({
        position: this.property,
        ellipse: attr
      }));
      return entity;
    }

    //polyline路线 投影

  }, {
    key: "addPolylineShading",
    value: function addPolylineShading(options) {
      var that = this;
      var attr = drawAttr.polyline.style2Entity(options);
      attr.positions = new Cesium.CallbackProperty(function (time) {
        if (options.type == "polyline-going") return that._going_positions;else return that._passed_positions;
      }, false);

      var entity = this.viewer.entities.add(new Cesium.Entity({
        polyline: attr
      }));
      return entity;
    }

    //视角定位[路线范围]

  }, {
    key: "centerAt",
    value: function centerAt(opts) {
      opts = opts || {};

      var rectangle = (0, _point.getRectangle)(this.positions);
      this.viewer.camera.flyTo({
        duration: Cesium.defaultValue(opts.duration, 0),
        destination: rectangle
      });
      return rectangle;
    }

    //视角定位[目标点]

  }, {
    key: "flyTo",
    value: function flyTo(opts) {
      var _this3 = this;

      opts = opts || {};

      var viewer = this.viewer;
      var position = this.position;
      if (!position) return;

      if (this.viewer.scene.mode == Cesium.SceneMode.SCENE3D) {
        this.viewer.clock.shouldAnimate = false;
        setTimeout(function () {
          var heading = Cesium.Math.toDegrees(_this3.hdr.heading) + Cesium.defaultValue(opts.heading, 0);

          viewer.das.centerPoint(position, {
            radius: Cesium.defaultValue(opts.radius, Cesium.defaultValue(opts.distance, 500)), //距离目标点的距离
            heading: heading,
            pitch: Cesium.defaultValue(opts.pitch, -50),
            duration: 0.1,
            complete: function complete() {
              viewer.clock.shouldAnimate = true;
            }
          });
        }, 500);
      } else {
        //二维模式下
        if (this.entity) this.viewer.flyTo(this.entity);
      }
    }

    //暂停

  }, {
    key: "pause",
    value: function pause() {
      this.viewer.clock.shouldAnimate = false;
    }
    //继续

  }, {
    key: "proceed",
    value: function proceed() {
      this.viewer.clock.shouldAnimate = true;
    }
  }, {
    key: "toCZML",
    value: function toCZML() {
      //时间
      var currentTime = this.times[0].toString();
      var stopTime = this.times[this.times.length - 1].toString();

      //路径位置点
      var cartographicDegrees = [];
      for (var i = 0, length = this.positions.length; i < length; i++) {
        var item = (0, _point.formatPosition)(this.positions[i]);
        var second = i == 0 ? 0 : Cesium.JulianDate.secondsDifference(this.times[i], this.times[i - 1]);

        cartographicDegrees.push(second);
        cartographicDegrees.push(item.x);
        cartographicDegrees.push(item.y);
        cartographicDegrees.push(item.z);
      }

      var czmlLine = {
        id: this.name,
        description: this.options.remark,
        availability: currentTime + "/" + stopTime,
        orientation: {
          //方向
          velocityReference: "#position"
        },
        position: {
          //位置
          epoch: currentTime,
          cartographicDegrees: cartographicDegrees
        }
      };
      if (this.options.interpolation) {
        czmlLine.position.interpolationAlgorithm = "LAGRANGE"; //插值时使用的插值算法,有效值为“LINEAR”，“LAGRANGE”和“HERMITE”。
        czmlLine.position.interpolationDegree = this.options.interpolationDegree || 2; //插值时使用的插值程度。
      }

      if (this.options.label.show) {
        //是否显示注记
        czmlLine.label = {
          show: true,
          outlineWidth: 2,
          text: this.name,
          font: "12pt 微软雅黑 Console",
          outlineColor: { rgba: [0, 0, 0, 255] },
          horizontalOrigin: "LEFT",
          fillColor: { rgba: [213, 255, 0, 255] }
        };
      }
      if (this.options.path.show) {
        //是否显示路线
        czmlLine.path = {
          //路线
          show: true,
          material: { solidColor: { color: { rgba: [255, 0, 0, 255] } } },
          width: 5,
          resolution: 1,
          leadTime: 0,
          trailTime: this.alltimes
        };
      }
      //漫游对象(模型)
      if (this.options.model.show) {
        //是否显示模型
        czmlLine.model = this.options.model;
      }

      var czml = [{
        version: "1.0",
        id: "document",
        clock: {
          interval: currentTime + "/" + stopTime,
          currentTime: currentTime,
          multiplier: 1
        }
      }, czmlLine];
      return czml;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.viewer.trackedEntity == this.entity) {
        this.viewer.trackedEntity = undefined;
      }
      if (this.entity) {
        this.viewer.entities.remove(this.entity);
        delete this.entity;
      }
      if (this.arrShowingEntity) {
        for (var i = 0, len = this.arrShowingEntity.length; i < len; i++) {
          this.viewer.entities.remove(this.arrShowingEntity[i]);
        }
        delete this.arrShowingEntity;
      }

      this.stop();
      _get(BaseFlyLine.prototype.__proto__ || Object.getPrototypeOf(BaseFlyLine.prototype), "destroy", this).call(this);
    }
  }, {
    key: "data",
    get: function get() {
      return this.options;
    },
    set: function set(item) {
      for (var key in item) {
        this.options[key] = item[key];
      }
    }

    //参数默认值

  }, {
    key: "defConfig",
    get: function get() {
      return {
        model: { show: false, scale: 1, minimumPixelSize: 50 },
        label: {
          show: false,
          color: "#ffffff",
          opacity: 1,
          font_family: "楷体",
          font_size: 20,
          border: true,
          border_color: "#000000",
          border_width: 3,
          background: false,
          hasPixelOffset: true,
          pixelOffsetX: 30,
          pixelOffsetY: -30,
          scaleByDistance: true,
          scaleByDistance_far: 10000000,
          scaleByDistance_farValue: 0.4,
          scaleByDistance_near: 5000,
          scaleByDistance_nearValue: 1
        },
        path: {
          show: false,
          lineType: "solid",
          color: "#3388ff",
          opacity: 0.5,
          width: 1,
          outline: false,
          outlineColor: "#ffffff",
          outlineWidth: 2
        },
        camera: { type: "", followedX: 50, followedZ: 10 },
        showGroundHeight: false
      };
    }
  }, {
    key: "popup",
    get: function get() {
      return this._popup;
    },
    set: function set(value) {
      this._popup = value;
      if (this.entity) this.entity.popup = value;
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this._tooltip;
    },
    set: function set(value) {
      this._tooltip = value;
      if (this.entity) this.entity.tooltip = value;
    }

    //已经飞行过的点index

  }, {
    key: "indexForFlyOK",
    get: function get() {
      return this._flyok_point_index;
    }

    // 当前点

  }, {
    key: "position",
    get: function get() {
      var position = Cesium.Property.getValueOrUndefined(this.property, this.viewer.clock.currentTime, new Cesium.Cartesian3());
      // if (!position && this.positions && this.positions.length > 0) {
      //   position = this.positions[this.positions.length - 1];
      // }
      if (!position && this._lastItem) {
        position = this._lastItem.position;
      }
      return position;
    }

    //无坐标时的最后一个位置及信息

  }, {
    key: "lastItem",
    get: function get() {
      return this._lastItem;
    },
    set: function set(value) {
      this._lastItem = value;
    }

    // 获取当前角度

  }, {
    key: "orientation",
    get: function get() {
      var _orientation = Cesium.Property.getValueOrUndefined(this.velocityOrientation, this.viewer.clock.currentTime, new Cesium.Quaternion());
      return _orientation;
    }

    // 获取当前hdr角度

  }, {
    key: "hdr",
    get: function get() {
      var position = this.position; //当前点
      var _orientation = this.orientation; //获取当前角度
      if (!position || !_orientation) return null;

      var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
      return autoHpr;
    }

    // 获取当前矩阵

  }, {
    key: "matrix",
    get: function get() {
      return this.getModelMatrix();
    }
  }, {
    key: "heading",
    get: function get() {
      if (!Cesium.defined(this._heading)) {
        var hdr = this.hdr;
        if (hdr) return hdr.heading;else return null;
      }
      return this._heading;
    }
  }, {
    key: "pitch",
    get: function get() {
      if (!Cesium.defined(this._pitch)) {
        var hdr = this.hdr;
        if (hdr) return hdr.pitch;else return null;
      }
      return this._pitch;
    },
    set: function set(val) {
      this._pitch = val;
      this.updateAngle(false, { pitch: this._pitch, roll: this._roll });
    }
  }, {
    key: "roll",
    get: function get() {
      if (!Cesium.defined(this._roll)) {
        var hdr = this.hdr;
        if (hdr) return hdr.roll;else return null;
      }
      return this._roll;
    },
    set: function set(val) {
      this._roll = val;
      this.updateAngle(false, { pitch: this._pitch, roll: this._roll });
    }

    //求射线与地球相交点

  }, {
    key: "groundPosition",
    get: function get() {
      return (0, _matrix.getRayEarthPositionByMatrix)(this.matrix, true, this.viewer.scene.globe.ellipsoid);
    }
  }]);

  return BaseFlyLine;
}(_DasClass2.DasClass);

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.style2Entity = style2Entity;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//div点 类
var DivPoint = exports.DivPoint = function (_DasClass) {
  _inherits(DivPoint, _DasClass);

  //========== 构造方法 ==========
  function DivPoint(viewer, options) {
    _classCallCheck(this, DivPoint);

    var _this = _possibleConstructorReturn(this, (DivPoint.__proto__ || Object.getPrototypeOf(DivPoint)).call(this, options));

    _this.viewer = viewer;
    _this.options = options;

    _this.position = options.position;

    //兼容历史写法
    if (options.visibleDistanceMin || options.visibleDistanceMax) {
      options.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(options.visibleDistanceMin || 0, options.visibleDistanceMax || 100000);
    }
    //兼容直接传入单击回调方法，适合简单场景下使用。
    if (options.click) {
      _this.on(_DasClass2.eventType.click, options.click);
    }

    _this.heightReference = Cesium.defaultValue(options.heightReference, Cesium.HeightReference.NONE);
    if (options.clampToGround) {
      _this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
    }

    _this.distanceDisplayCondition = options.distanceDisplayCondition; //按视距距离显示
    _this.scaleByDistance = _this.options.scaleByDistance;
    _this.horizontalOrigin = _this.options.horizontalOrigin;
    _this.verticalOrigin = _this.options.verticalOrigin;

    _this._depthTest = Cesium.defaultValue(options.depthTest, true);
    _this.css_transform_origin = Cesium.defaultValue(_this.options.css_transform_origin, "left bottom 0");

    //添加html
    if (options.html) {
      _this._dom = (0, _zepto.zepto)("<div>" + options.html + "</div>");

      if (Cesium.defaultValue(options.oldver, false)) {
        //兼容老版本,但不支持html动态修改
        _this._dom = (0, _zepto.zepto)(options.html);
      }

      _this._dom.css({
        position: "absolute",
        left: "0",
        top: "0"
      });
      _this._dom.appendTo("#" + viewer._container.id);
    } else if (options.dom) {
      _this._dom = (0, _zepto.zepto)(options.dom);
    }

    _this.visible = Cesium.defaultValue(options.visible, true);
    _this.stopPropagation = Cesium.defaultValue(options.stopPropagation, true);

    _this._dom.on("click", function (e) {
      if (_this.stopPropagation) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      }

      if (_this.options.popup) _this.viewer.das.popup.show(_this.options, _this.position);else _this.viewer.das.popup.close();

      e.data = _this.options;
      e.sourceTarget = _this;
      _this.fire(_DasClass2.eventType.click, e);
    });

    _this._dom.on("mousemove", function (e) {
      if (_this.stopPropagation) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      }
      _this.viewer.das.tooltip.show(_this.options, _this.position);

      e.data = _this.options;
      e.sourceTarget = _this;
      _this.fire(_DasClass2.eventType.mouseOver, e);
    });
    _this._dom.on("mouseout", function (e) {
      if (_this.stopPropagation) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      }
      _this.viewer.das.tooltip.close();

      e.data = _this.options;
      e.sourceTarget = _this;
      _this.fire(_DasClass2.eventType.mouseOut, e);
    });
    _this.enable = Cesium.defaultValue(options.enable, _this.getEnableByEvent());

    //移动事件
    viewer.scene.postRender.addEventListener(_this.updateViewPoint, _this);
    return _this;
  }

  //========== 对外属性 ==========


  _createClass(DivPoint, [{
    key: "getEnableByEvent",


    //========== 方法 ==========
    value: function getEnableByEvent() {
      if (this.options.popup) return true;
      if (this.options.tooltip) return true;

      if (this.hasEvent(_DasClass2.eventType.click)) return true;
      if (this.hasEvent(_DasClass2.eventType.mouseOver)) return true;
      if (this.hasEvent(_DasClass2.eventType.mouseOut)) return true;

      return false;
    }
  }, {
    key: "updateViewPoint",
    value: function updateViewPoint() {
      if (!this._visible) return false;

      var scene = this.viewer.scene;
      var camera = this.viewer.camera;

      var _position;
      if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
        _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position));
      } else if (this.heightReference == Cesium.HeightReference.RELATIVE_TO_GROUND) {
        _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position), {
          relativeHeight: true
        });
      } else {
        _position = (0, _point.getPositionValue)(this.position);
      }

      if (!Cesium.defined(_position)) {
        this.close();
        return false;
      }

      //如果视角和位置都没有变化，直接返回
      var _thiscache = _position.x + "=" + _position.y + "-" + _position.z + "-" + camera.positionWC.x + "=" + camera.positionWC.y + "-" + camera.positionWC.z + "-" + camera.heading + "-" + camera.pitch + "-" + camera.roll;
      if (_thiscache == this._camera_cache) {
        return true;
      }
      this._camera_cache = _thiscache;
      //如果视角和位置都没有变化，直接返回

      var point = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, _position);

      var camera_distance;
      if (scene.mode === Cesium.SceneMode.SCENE3D) camera_distance = Cesium.Cartesian3.distance(_position, camera.positionWC);else camera_distance = camera.positionCartographic.height;

      if (point == null || this.distanceDisplayCondition && (this.distanceDisplayCondition.near > camera_distance || this.distanceDisplayCondition.far < camera_distance)) {
        if (this._dom.css("display") == "block") {
          //如果node是显示则隐藏
          this.close();
        }
        return false;
      }

      //判断是否在球的背面
      if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
        //三维模式下
        var occluder = new Cesium.EllipsoidalOccluder(scene.globe.ellipsoid, scene.camera.positionWC);
        var visible = occluder.isPointVisible(_position); //地球椭球体背面判断处理
        //visible为true说明点在球的正面，否则点在球的背面。
        //需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true
        if (!visible) {
          if (this._dom.css("display") == "block") {
            //如果node是显示则隐藏
            this.close();
          }
          return false;
        }

        //地形和模型遮挡时的检测处理
        // if (scene.globe.depthTestAgainstTerrain) {
        //     var testPosition = scene.pickPosition(point)
        //     if (testPosition && Math.abs(_position.x - testPosition.x) > 10
        //         && Math.abs(_position.y - testPosition.y) > 10
        //         && Math.abs(_position.z - testPosition.z) > 10) {
        //         if (this._dom.css("display") == "block") {//如果node是显示则隐藏
        //             this.close();
        //         }
        //         return false;
        //     }
        // }
      }
      //判断是否在球的背面

      if (this._dom.css("display") != "block") {
        //如果node是隐藏的则显示node元素
        this._camera_cache = null;
        this._dom.show();
      }

      //求xy位置
      var height = this._dom.height(); //需要是显示状态，才有值
      var width = this._dom.width();

      var x;
      var y;
      if (this.options.anchor) {
        x = point.x + this.options.anchor[0];
        y = point.y - height + this.options.anchor[1];
      } else {
        switch (this.horizontalOrigin) {
          default:
          case "LEFT":
          case Cesium.HorizontalOrigin.LEFT:
            x = point.x;
            break;
          case "CENTER":
          case Cesium.HorizontalOrigin.CENTER:
            x = point.x - width / 2;
            break;
          case "RIGHT":
          case Cesium.HorizontalOrigin.RIGHT:
            x = point.x - width;
            break;
        }
        switch (this.verticalOrigin) {
          case "TOP":
          case Cesium.VerticalOrigin.TOP:
            y = point.y;
            break;
          case "CENTER":
          case Cesium.VerticalOrigin.CENTER:
            y = point.y - height / 2;
            break;
          default:
          case "BOTTOM":
          case Cesium.VerticalOrigin.BOTTOM:
            y = point.y - height;
            break;
        }
      }

      //求缩放比例
      var scale = 1;
      if (this.scaleByDistance) {
        var sc = this.scaleByDistance; //Cesium.NearFarScalar
        if (camera_distance <= sc.near) {
          scale = sc.nearValue;
        } else if (camera_distance > sc.near && camera_distance < sc.far) {
          // near 10000, nearValue  1.0,, far 100000, farValue  0.1
          scale = sc.nearValue + (sc.farValue - sc.nearValue) * (camera_distance - sc.near) / (sc.far - sc.near);
        } else {
          scale = sc.farValue;
        }
      }

      var css_transform = "matrix(" + scale + ",0,0," + scale + "," + x + "," + y + ")";

      this._dom.css({
        transform: css_transform,
        "transform-origin": this.css_transform_origin,
        "-ms-transform": css_transform /* IE 9 */
        , "-ms-transform-origin": this.css_transform_origin,
        "-webkit-transform": css_transform /* Safari 和 Chrome */
        , "-webkit-transform-origin": this.css_transform_origin,
        "-moz-transform": css_transform /* Firefox */
        , "-moz-transform-origin": this.css_transform_origin,
        "-o-transform": css_transform /* Opera */
        , "-o-transform-origin": this.css_transform_origin
      });

      if (this.options.postRender) {
        //回调方法
        this.options.postRender({
          x: x,
          y: y,
          height: height,
          width: width,
          distance: camera_distance
        });
      }
    }
  }, {
    key: "setVisible",
    value: function setVisible(val) {
      this._visible = val;
      if (!this._dom) return;
      if (val) this._dom.show();else this.close();
    }
  }, {
    key: "showPopup",
    value: function showPopup() {
      if (this.options.popup) this.viewer.das.popup.show(this.options, this.position);
    }
  }, {
    key: "closePopup",
    value: function closePopup() {
      this.viewer.das.popup.close();
    }
  }, {
    key: "close",
    value: function close() {
      this._dom.hide();
      this._camera_cache = null;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.postRender.removeEventListener(this.updateViewPoint, this);

      this._dom.off("click");
      this._dom.off("mousemove");
      this._dom.off("mouseout");

      this._dom.remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "dom",
    get: function get() {
      return this._dom;
    }

    //是否显示

  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(val) {
      this._camera_cache = null;
      this._visible = val;
      this.setVisible(val);
    }
  }, {
    key: "enable",
    set: function set(value) {
      if (value) {
        this._dom.css({
          "pointer-events": "all"
        });
      } else {
        /*加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件*/
        this._dom.css({
          "pointer-events": "none"
        });
      }
    }

    //是否打开深度判断（true时判断是否在球背面）

  }, {
    key: "depthTest",
    get: function get() {
      return this._depthTest;
    },
    set: function set(value) {
      this._camera_cache = null;
      this._depthTest = value;
    }
  }, {
    key: "clampToGround",
    get: function get() {
      return this.options.clampToGround;
    },
    set: function set(value) {
      this.options.clampToGround = value;
      if (value) this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else this.heightReference = Cesium.HeightReference.NONE;
    }
  }, {
    key: "html",
    get: function get() {
      return this._dom.html();
    },
    set: function set(value) {
      this._camera_cache = null;
      this._dom.html(value);
    }
  }, {
    key: "popup",
    get: function get() {
      return this.options.popup;
    },
    set: function set(value) {
      this.options.popup = value;
      this.enable = this.getEnableByEvent();
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this.options.tooltip;
    },
    set: function set(value) {
      this.options.tooltip = value;
      this.enable = this.getEnableByEvent();
    }
  }]);

  return DivPoint;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


DivPoint.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

//属性赋值到divpoint
function style2Entity(style) {
  style = style || {};

  var entityattr = {};

  //Style赋值值Entity
  for (var key in style) {
    var value = style[key];
    switch (key) {
      default:
        //直接赋值
        entityattr[key] = value;
        break;
      case "scaleByDistance_near": //跳过扩展其他属性的参数
      case "scaleByDistance_nearValue":
      case "scaleByDistance_far":
      case "scaleByDistance_farValue":
      case "distanceDisplayCondition_far":
      case "distanceDisplayCondition_near":
        break;
      case "scaleByDistance":
        //是否按视距缩放
        if (value) {
          entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
        } else {
          entityattr.scaleByDistance = undefined;
        }
        break;
      case "distanceDisplayCondition":
        //是否按视距显示
        if (value) {
          if (value instanceof Cesium.DistanceDisplayCondition) {
            entityattr.distanceDisplayCondition = value;
          } else {
            entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
          }
        } else {
          entityattr.distanceDisplayCondition = undefined;
        }
        break;
      case "clampToGround":
        //贴地
        if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;else entityattr.heightReference = Cesium.HeightReference.NONE;
        break;
      case "heightReference":
        switch (value) {
          case "NONE":
            entityattr.heightReference = Cesium.HeightReference.NONE;
            break;
          case "CLAMP_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            break;
          case "RELATIVE_TO_GROUND":
            entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
            break;
          default:
            entityattr.heightReference = value;
            break;
        }
        break;
      case "horizontalOrigin":
        switch (value) {
          case "CENTER":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
            break;
          case "LEFT":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
            break;
          case "RIGHT":
            entityattr.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
            break;
          default:
            entityattr.horizontalOrigin = value;
            break;
        }
        break;
      case "verticalOrigin":
        switch (value) {
          case "CENTER":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.CENTER;
            break;
          case "TOP":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.TOP;
            break;
          case "BOTTOM":
            entityattr.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
            break;
          default:
            entityattr.verticalOrigin = value;
            break;
        }
        break;
    }
  }

  return entityattr;
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RectangularSensorPrimitive = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _RectangularSensorVS = __webpack_require__(211);

var _RectangularSensorVS2 = _interopRequireDefault(_RectangularSensorVS);

var _RectangularSensorFS = __webpack_require__(212);

var _RectangularSensorFS2 = _interopRequireDefault(_RectangularSensorFS);

var _RectangularSensor = __webpack_require__(213);

var _RectangularSensor2 = _interopRequireDefault(_RectangularSensor);

var _RectangularSensorScanPlaneFS = __webpack_require__(214);

var _RectangularSensorScanPlaneFS2 = _interopRequireDefault(_RectangularSensorScanPlaneFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var BoundingSphere = Cesium.BoundingSphere;
var Cartesian3 = Cesium.Cartesian3;
var Color = Cesium.Color;
var combine = Cesium.combine;
var ComponentDatatype = Cesium.ComponentDatatype;
var defaultValue = Cesium.defaultValue;
var defined = Cesium.defined;
var DeveloperError = Cesium.DeveloperError;
var Matrix4 = Cesium.Matrix4;
var PrimitiveType = Cesium.PrimitiveType;
var Buffer = Cesium.Buffer;
var BufferUsage = Cesium.BufferUsage;
var DrawCommand = Cesium.DrawCommand;
var Pass = Cesium.Pass;
var RenderState = Cesium.RenderState;
var ShaderProgram = Cesium.ShaderProgram;
var ShaderSource = Cesium.ShaderSource;
var VertexArray = Cesium.VertexArray;
var BlendingState = Cesium.BlendingState;
var CullFace = Cesium.CullFace;
var Material = Cesium.Material;
var SceneMode = Cesium.SceneMode;
var VertexFormat = Cesium.VertexFormat;
var CesiumMath = Cesium.Math;
var Matrix3 = Cesium.Matrix3;
var JulianDate = Cesium.JulianDate;

// var BoxGeometry = Cesium.BoxGeometry;
// var EllipsoidGeometry = Cesium.EllipsoidGeometry;

var sin = Math.sin;
var cos = Math.cos;
var tan = Math.tan;
var atan = Math.atan;
var asin = Math.asin;

var attributeLocations = {
  position: 0,
  normal: 1
};

function RectangularSensorPrimitive(options) {
  var self = this;

  options = defaultValue(options, defaultValue.EMPTY_OBJECT);

  /**
   * 是否显示
   */
  this.show = defaultValue(options.show, true);

  /**
   * 切分程度
   */
  this.slice = defaultValue(options.slice, 32);

  /**
   * 传感器的模型矩阵
   */
  this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4());
  this._modelMatrix = new Matrix4();
  this._computedModelMatrix = new Matrix4();
  this._computedScanPlaneModelMatrix = new Matrix4();

  /**
   * 传感器的半径
   */
  this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
  this._radius = undefined;

  /**
   * 传感器水平半角
   */
  this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
  this._xHalfAngle = undefined;

  /**
   * 传感器垂直半角
   */
  this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
  this._yHalfAngle = undefined;

  /**
   * 线的颜色
   */
  this.lineColor = defaultValue(options.lineColor, Color.WHITE);

  /**
   * 是否显示扇面的线
   */
  this.showSectorLines = defaultValue(options.showSectorLines, true);

  /**
   * 是否显示扇面和圆顶面连接的线
   */
  this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);

  /**
   * 是否显示侧面
   */
  this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);

  /**
   * 目前用的统一材质
   * @type {Material}
   */
  this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
  this._material = undefined;
  this._translucent = undefined;

  /**
   * 侧面材质
   * @type {Material}
   */
  this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
  this._lateralSurfaceMaterial = undefined;
  this._lateralSurfaceTranslucent = undefined;

  /**
   * 是否显示圆顶表面
   */
  this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);

  /**
   * 圆顶表面材质
   * @type {Material}
   */
  this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
  this._domeSurfaceMaterial = undefined;

  /**
   * 是否显示圆顶面线
   */
  this.showDomeLines = defaultValue(options.showDomeLines, true);

  /**
   * 是否显示与地球相交的线
   */
  this.showIntersection = defaultValue(options.showIntersection, true);

  /**
   * 与地球相交的线的颜色
   */
  this.intersectionColor = defaultValue(options.intersectionColor, Color.WHITE);

  /**
   * 与地球相交的线的宽度（像素）
   */
  this.intersectionWidth = defaultValue(options.intersectionWidth, 5.0);

  /**
   * 是否穿过地球
   */
  this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
  this._showThroughEllipsoid = undefined;

  /**
   * 是否显示扫描面
   */
  this.showScanPlane = defaultValue(options.showScanPlane, true);

  /**
   * 扫描面颜色
   */
  this.scanPlaneColor = defaultValue(options.scanPlaneColor, Color.WHITE);

  /**
   * 扫描面模式 垂直vertical/水平horizontal
   */
  this.scanPlaneMode = defaultValue(options.scanPlaneMode, "horizontal");

  /**
   * 扫描速率
   */
  this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);

  this._scanePlaneXHalfAngle = 0;
  this._scanePlaneYHalfAngle = 0;

  //时间计算的起点
  this._time = JulianDate.now();

  this._boundingSphere = new BoundingSphere();
  this._boundingSphereWC = new BoundingSphere();

  //扇面 sector
  this._sectorFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorVA = undefined;

  //扇面边线 sectorLine
  this._sectorLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorLineVA = undefined;

  //扇面分割线 sectorSegmentLine
  this._sectorSegmentLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._sectorSegmentLineVA = undefined;

  //弧面 dome
  this._domeFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeVA = undefined;

  //弧面线 domeLine
  this._domeLineCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.LINES,
    boundingVolume: this._boundingSphereWC
  });
  this._domeLineVA = undefined;

  //扫描面 scanPlane/scanRadial
  this._scanPlaneFrontCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });
  this._scanPlaneBackCommand = new DrawCommand({
    owner: this,
    primitiveType: PrimitiveType.TRIANGLES,
    boundingVolume: this._boundingSphereWC
  });

  this._scanRadialCommand = undefined;

  this._colorCommands = [];

  this._frontFaceRS = undefined;
  this._backFaceRS = undefined;
  this._sp = undefined;

  this._uniforms = {
    u_type: function u_type() {
      return 0; //面
    },
    u_xHalfAngle: function u_xHalfAngle() {
      return self.xHalfAngle;
    },
    u_yHalfAngle: function u_yHalfAngle() {
      return self.yHalfAngle;
    },
    u_radius: function u_radius() {
      return self.radius;
    },
    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
      return self.showThroughEllipsoid;
    },
    u_showIntersection: function u_showIntersection() {
      return self.showIntersection;
    },
    u_intersectionColor: function u_intersectionColor() {
      return self.intersectionColor;
    },
    u_intersectionWidth: function u_intersectionWidth() {
      return self.intersectionWidth;
    },
    u_normalDirection: function u_normalDirection() {
      return 1.0;
    },
    u_lineColor: function u_lineColor() {
      return self.lineColor;
    }
  };

  this._scanUniforms = {
    u_xHalfAngle: function u_xHalfAngle() {
      return self._scanePlaneXHalfAngle;
    },
    u_yHalfAngle: function u_yHalfAngle() {
      return self._scanePlaneYHalfAngle;
    },
    u_radius: function u_radius() {
      return self.radius;
    },
    u_color: function u_color() {
      return self.scanPlaneColor;
    },
    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
      return self.showThroughEllipsoid;
    },
    u_showIntersection: function u_showIntersection() {
      return self.showIntersection;
    },
    u_intersectionColor: function u_intersectionColor() {
      return self.intersectionColor;
    },
    u_intersectionWidth: function u_intersectionWidth() {
      return self.intersectionWidth;
    },
    u_normalDirection: function u_normalDirection() {
      return 1.0;
    },
    u_lineColor: function u_lineColor() {
      return self.lineColor;
    }
  };
}

RectangularSensorPrimitive.prototype.update = function (frameState) {
  var mode = frameState.mode;
  if (!this.show || mode !== SceneMode.SCENE3D) {
    return;
  }
  var createVS = false;
  var createRS = false;
  var createSP = false;

  var xHalfAngle = this.xHalfAngle;
  var yHalfAngle = this.yHalfAngle;

  if (xHalfAngle < 0.0 || yHalfAngle < 0.0) {
    throw new DeveloperError("halfAngle must be greater than or equal to zero.");
  }
  if (xHalfAngle == 0.0 || yHalfAngle == 0.0) {
    return;
  }
  if (this._xHalfAngle !== xHalfAngle || this._yHalfAngle !== yHalfAngle) {
    this._xHalfAngle = xHalfAngle;
    this._yHalfAngle = yHalfAngle;
    createVS = true;
  }

  var radius = this.radius;
  if (radius < 0.0) {
    throw new DeveloperError("this.radius must be greater than or equal to zero.");
  }
  var radiusChanged = false;
  if (this._radius !== radius) {
    radiusChanged = true;
    this._radius = radius;
    this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
  }

  var modelMatrixChanged = !Matrix4.equals(this.modelMatrix, this._modelMatrix);
  if (modelMatrixChanged || radiusChanged) {
    Matrix4.clone(this.modelMatrix, this._modelMatrix);
    Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
    BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
  }

  var showThroughEllipsoid = this.showThroughEllipsoid;
  if (this._showThroughEllipsoid !== this.showThroughEllipsoid) {
    this._showThroughEllipsoid = showThroughEllipsoid;
    createRS = true;
  }

  var material = this.material;
  if (this._material !== material) {
    this._material = material;
    createRS = true;
    createSP = true;
  }
  var translucent = material.isTranslucent();
  if (this._translucent !== translucent) {
    this._translucent = translucent;
    createRS = true;
  }

  if (this.showScanPlane) {
    var time = frameState.time;
    var timeDiff = JulianDate.secondsDifference(time, this._time);
    if (timeDiff < 0) {
      this._time = JulianDate.clone(time, this._time);
    }
    var percentage = Math.max(timeDiff % this.scanPlaneRate / this.scanPlaneRate, 0);
    var angle;

    if (this.scanPlaneMode == "horizontal") {
      angle = 2 * yHalfAngle * percentage - yHalfAngle;
      var cosYHalfAngle = cos(angle);
      var tanXHalfAngle = tan(xHalfAngle);

      var maxX = atan(cosYHalfAngle * tanXHalfAngle);
      this._scanePlaneXHalfAngle = maxX;
      this._scanePlaneYHalfAngle = angle;
      Cesium.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
    } else {
      angle = 2 * xHalfAngle * percentage - xHalfAngle;
      var tanYHalfAngle = tan(yHalfAngle);
      var cosXHalfAngle = cos(angle);

      var maxY = atan(cosXHalfAngle * tanYHalfAngle);
      this._scanePlaneXHalfAngle = angle;
      this._scanePlaneYHalfAngle = maxY;
      Cesium.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
    }

    Cesium.Matrix4.multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
    Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
  }

  if (createVS) {
    createVertexArray(this, frameState);
  }
  if (createRS) {
    createRenderState(this, showThroughEllipsoid, translucent);
  }
  if (createSP) {
    createShaderProgram(this, frameState, material);
  }
  if (createRS || createSP) {
    createCommands(this, translucent);
  }

  var commandList = frameState.commandList;
  var passes = frameState.passes;
  var colorCommands = this._colorCommands;
  if (passes.render) {
    for (var i = 0, len = colorCommands.length; i < len; i++) {
      var colorCommand = colorCommands[i];
      commandList.push(colorCommand);
    }
  }
};

var matrix3Scratch = new Matrix3();
var nScratch = new Cartesian3();

//region -- VertexArray --

/**
 * 计算zoy面和zoy面单位扇形位置
 * @param primitive
 * @returns {{zoy: Array, zox: Array}}
 */
function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
  var slice = primitive.slice;

  //以中心为角度
  var cosYHalfAngle = cos(yHalfAngle);
  var tanYHalfAngle = tan(yHalfAngle);
  var cosXHalfAngle = cos(xHalfAngle);
  var tanXHalfAngle = tan(xHalfAngle);

  var maxY = atan(cosXHalfAngle * tanYHalfAngle);
  var maxX = atan(cosYHalfAngle * tanXHalfAngle);

  //ZOY面单位圆
  var zoy = [];
  for (var i = 0; i < slice; i++) {
    var phi = 2 * maxY * i / (slice - 1) - maxY;
    zoy.push(new Cartesian3(0, sin(phi), cos(phi)));
  }
  //zox面单位圆
  var zox = [];
  for (var _i = 0; _i < slice; _i++) {
    var _phi = 2 * maxX * _i / (slice - 1) - maxX;
    zox.push(new Cartesian3(sin(_phi), 0, cos(_phi)));
  }

  return {
    zoy: zoy,
    zox: zox
  };
}

/**
 * 计算扇面的位置
 * @param unitPosition
 * @returns {Array}
 */
function computeSectorPositions(primitive, unitPosition) {
  var xHalfAngle = primitive.xHalfAngle,
      yHalfAngle = primitive.yHalfAngle,
      zoy = unitPosition.zoy,
      zox = unitPosition.zox;
  var positions = [];

  //zoy面沿y轴逆时针转xHalfAngle
  var matrix3 = Matrix3.fromRotationY(xHalfAngle, matrix3Scratch);
  positions.push(zoy.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
  }));
  //zox面沿x轴顺时针转yHalfAngle
  matrix3 = Matrix3.fromRotationX(-yHalfAngle, matrix3Scratch);
  positions.push(zox.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
  }).reverse());
  //zoy面沿y轴顺时针转xHalfAngle
  matrix3 = Matrix3.fromRotationY(-xHalfAngle, matrix3Scratch);
  positions.push(zoy.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
  }).reverse());
  //zox面沿x轴逆时针转yHalfAngle
  matrix3 = Matrix3.fromRotationX(yHalfAngle, matrix3Scratch);
  positions.push(zox.map(function (p) {
    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
  }));
  return positions;
}

/**
 * 创建扇面顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorVertexArray(context, positions) {
  var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
  var vertices = new Float32Array(2 * 3 * 3 * planeLength);

  var k = 0;
  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];
    var n = Cartesian3.normalize(Cartesian3.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);
    for (var j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;

      vertices[k++] = planePositions[j].x;
      vertices[k++] = planePositions[j].y;
      vertices[k++] = planePositions[j].z;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;

      vertices[k++] = planePositions[j + 1].x;
      vertices[k++] = planePositions[j + 1].y;
      vertices[k++] = planePositions[j + 1].z;
      vertices[k++] = -n.x;
      vertices[k++] = -n.y;
      vertices[k++] = -n.z;
    }
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });

  var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

  var attributes = [{
    index: attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }, {
    index: attributeLocations.normal,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
    strideInBytes: stride
  }];

  return new VertexArray({
    context: context,
    attributes: attributes
  });
}

/**
 * 创建扇面边线顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorLineVertexArray(context, positions) {
  var planeLength = positions.length;
  var vertices = new Float32Array(3 * 3 * planeLength);

  var k = 0;
  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;

    vertices[k++] = planePositions[0].x;
    vertices[k++] = planePositions[0].y;
    vertices[k++] = planePositions[0].z;
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });

  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

  var attributes = [{
    index: attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];

  return new VertexArray({
    context: context,
    attributes: attributes
  });
}

/**
 * 创建扇面圆顶面连接线顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createSectorSegmentLineVertexArray(context, positions) {
  var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
  var vertices = new Float32Array(3 * 3 * planeLength);

  var k = 0;
  for (var i = 0, len = positions.length; i < len; i++) {
    var planePositions = positions[i];

    for (var j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
      vertices[k++] = planePositions[j].x;
      vertices[k++] = planePositions[j].y;
      vertices[k++] = planePositions[j].z;

      vertices[k++] = planePositions[j + 1].x;
      vertices[k++] = planePositions[j + 1].y;
      vertices[k++] = planePositions[j + 1].z;
    }
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });

  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

  var attributes = [{
    index: attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];

  return new VertexArray({
    context: context,
    attributes: attributes
  });
}

/**
 * 创建圆顶面顶点
 * @param context
 */
function createDomeVertexArray(context) {
  var geometry = Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
    vertexFormat: VertexFormat.POSITION_ONLY,
    stackPartitions: 32,
    slicePartitions: 32
  }));

  var vertexArray = VertexArray.fromGeometry({
    context: context,
    geometry: geometry,
    attributeLocations: attributeLocations,
    bufferUsage: BufferUsage.STATIC_DRAW,
    interleave: false
  });
  return vertexArray;
}

/**
 * 创建圆顶面连线顶点
 * @param context
 */
function createDomeLineVertexArray(context) {
  var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(new Cesium.EllipsoidOutlineGeometry({
    vertexFormat: VertexFormat.POSITION_ONLY,
    stackPartitions: 32,
    slicePartitions: 32
  }));

  var vertexArray = VertexArray.fromGeometry({
    context: context,
    geometry: geometry,
    attributeLocations: attributeLocations,
    bufferUsage: BufferUsage.STATIC_DRAW,
    interleave: false
  });
  return vertexArray;
}

/**
 * 创建扫描面顶点
 * @param context
 * @param positions
 * @returns {*}
 */
function createScanPlaneVertexArray(context, positions) {
  var planeLength = positions.length - 1;
  var vertices = new Float32Array(3 * 3 * planeLength);

  var k = 0;
  for (var i = 0; i < planeLength; i++) {
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;
    vertices[k++] = 0.0;

    vertices[k++] = positions[i].x;
    vertices[k++] = positions[i].y;
    vertices[k++] = positions[i].z;

    vertices[k++] = positions[i + 1].x;
    vertices[k++] = positions[i + 1].y;
    vertices[k++] = positions[i + 1].z;
  }

  var vertexBuffer = Buffer.createVertexBuffer({
    context: context,
    typedArray: vertices,
    usage: BufferUsage.STATIC_DRAW
  });

  var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

  var attributes = [{
    index: attributeLocations.position,
    vertexBuffer: vertexBuffer,
    componentsPerAttribute: 3,
    componentDatatype: ComponentDatatype.FLOAT,
    offsetInBytes: 0,
    strideInBytes: stride
  }];

  return new VertexArray({
    context: context,
    attributes: attributes
  });
}

function createVertexArray(primitive, frameState) {
  var context = frameState.context;

  var unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
  var positions = computeSectorPositions(primitive, unitSectorPositions);

  //显示扇面
  if (primitive.showLateralSurfaces) {
    primitive._sectorVA = createSectorVertexArray(context, positions);
  }

  //显示扇面线
  if (primitive.showSectorLines) {
    primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
  }

  //显示扇面圆顶面的交线
  if (primitive.showSectorSegmentLines) {
    primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
  }

  //显示弧面
  if (primitive.showDomeSurfaces) {
    primitive._domeVA = createDomeVertexArray(context);
  }

  //显示弧面线
  if (primitive.showDomeLines) {
    primitive._domeLineVA = createDomeLineVertexArray(context);
  }

  //显示扫描面
  if (primitive.showScanPlane) {
    if (primitive.scanPlaneMode == "horizontal") {
      var unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath.PI_OVER_TWO, 0);
      primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
    } else {
      var _unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath.PI_OVER_TWO);
      primitive._scanPlaneVA = createScanPlaneVertexArray(context, _unitScanPlanePositions.zoy);
    }
  }
}

//endregion

//region -- ShaderProgram --

function createCommonShaderProgram(primitive, frameState, material) {
  var context = frameState.context;

  var vs = _RectangularSensorVS2.default;
  var fs = new ShaderSource({
    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default]
  });

  primitive._sp = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._sp,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: attributeLocations
  });

  var pickFS = new ShaderSource({
    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default],
    pickColorQualifier: "uniform"
  });

  primitive._pickSP = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._pickSP,
    vertexShaderSource: vs,
    fragmentShaderSource: pickFS,
    attributeLocations: attributeLocations
  });
}

function createScanPlaneShaderProgram(primitive, frameState, material) {
  var context = frameState.context;

  var vs = _RectangularSensorVS2.default;
  var fs = new ShaderSource({
    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorScanPlaneFS2.default]
  });

  primitive._scanePlaneSP = ShaderProgram.replaceCache({
    context: context,
    shaderProgram: primitive._scanePlaneSP,
    vertexShaderSource: vs,
    fragmentShaderSource: fs,
    attributeLocations: attributeLocations
  });
}

function createShaderProgram(primitive, frameState, material) {
  createCommonShaderProgram(primitive, frameState, material);

  if (primitive.showScanPlane) {
    createScanPlaneShaderProgram(primitive, frameState, material);
  }
}

//endregion

//region -- RenderState --

function createRenderState(primitive, showThroughEllipsoid, translucent) {
  if (translucent) {
    primitive._frontFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND,
      cull: {
        enabled: true,
        face: CullFace.BACK
      }
    });

    primitive._backFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND,
      cull: {
        enabled: true,
        face: CullFace.FRONT
      }
    });

    primitive._pickRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: false,
      blending: BlendingState.ALPHA_BLEND
    });
  } else {
    primitive._frontFaceRS = RenderState.fromCache({
      depthTest: {
        enabled: !showThroughEllipsoid
      },
      depthMask: true
    });

    primitive._pickRS = RenderState.fromCache({
      depthTest: {
        enabled: true
      },
      depthMask: true
    });
  }
}

//endregion

//region -- Command --

function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
  if (translucent && backCommand) {
    backCommand.vertexArray = va;
    backCommand.renderState = backFaceRS;
    backCommand.shaderProgram = sp;
    backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
    backCommand.uniformMap.u_normalDirection = function () {
      return -1.0;
    };
    backCommand.pass = pass;
    backCommand.modelMatrix = modelMatrix;
    primitive._colorCommands.push(backCommand);
  }

  frontCommand.vertexArray = va;
  frontCommand.renderState = frontFaceRS;
  frontCommand.shaderProgram = sp;
  frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
  if (isLine) {
    frontCommand.uniformMap.u_type = function () {
      return 1;
    };
  }
  frontCommand.pass = pass;
  frontCommand.modelMatrix = modelMatrix;
  primitive._colorCommands.push(frontCommand);
}

function createCommands(primitive, translucent) {
  primitive._colorCommands.length = 0;

  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;

  //显示扇面
  if (primitive.showLateralSurfaces) {
    createCommand(primitive, primitive._sectorFrontCommand, primitive._sectorBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
  }
  //显示扇面线
  if (primitive.showSectorLines) {
    createCommand(primitive, primitive._sectorLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  }
  //显示扇面交接线
  if (primitive.showSectorSegmentLines) {
    createCommand(primitive, primitive._sectorSegmentLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorSegmentLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  }
  //显示弧面
  if (primitive.showDomeSurfaces) {
    createCommand(primitive, primitive._domeFrontCommand, primitive._domeBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
  }
  //显示弧面线
  if (primitive.showDomeLines) {
    createCommand(primitive, primitive._domeLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
  }
  //显示扫描面
  if (primitive.showScanPlane) {
    createCommand(primitive, primitive._scanPlaneFrontCommand, primitive._scanPlaneBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._scanePlaneSP, primitive._scanPlaneVA, primitive._scanUniforms, primitive._computedScanPlaneModelMatrix, translucent, pass);
  }
}

//endregion

exports.RectangularSensorPrimitive = RectangularSensorPrimitive;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EffectCollection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //效果响应


var EffectCollection = exports.EffectCollection = function (_DasClass) {
    _inherits(EffectCollection, _DasClass);

    function EffectCollection(options) {
        _classCallCheck(this, EffectCollection);

        var _this = _possibleConstructorReturn(this, (EffectCollection.__proto__ || Object.getPrototypeOf(EffectCollection)).call(this, options));

        _this._name = Cesium.defaultValue(options.name, "");
        _this._viewer = options.viewer;
        _this._effects = [];
        return _this;
    }

    _createClass(EffectCollection, [{
        key: "add",
        value: function add(e) {
            if (e._add) {
                e = e._add(this._viewer);
                this._effects.push(e);
                return e;
            }
        }
    }, {
        key: "get",
        value: function get(e) {
            return this._effects[e];
        }
    }, {
        key: "remove",
        value: function remove(e) {
            var t = false,
                n = this._effects.indexOf(e);
            return e._remove && (t = e._remove(this._viewer)), -1 < n && this._effects.splice(n, 1), t;
        }
    }, {
        key: "removeAll",
        value: function removeAll() {
            for (; 0 < this._effects.length;) {
                this.remove(this._effects[0]);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (; 0 < this._effects.length;) {
                this.remove(this._effects[0]);
            }return Cesium.destroyObject(this);
        }
    }]);

    return EffectCollection;
}(_DasClass2.DasClass);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(93);

__webpack_require__(94);

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _version = __webpack_require__(52);

var ver = _interopRequireWildcard(_version);

__webpack_require__(95);

__webpack_require__(96);

var _Cesium3DTilesetEx = __webpack_require__(97);

var _ViewerEx = __webpack_require__(75);

var _DasClass = __webpack_require__(1);

var _widgetManager = __webpack_require__(48);

var widget = _interopRequireWildcard(_widgetManager);

var _ES5BaseWidget = __webpack_require__(143);

var _BaseWidget = __webpack_require__(145);

var _map = __webpack_require__(146);

var _layer = __webpack_require__(24);

var layer = _interopRequireWildcard(_layer);

var _FloodByEntity = __webpack_require__(149);

var _FloodByTerrain = __webpack_require__(150);

var _Measure = __webpack_require__(151);

var _MeasureAngle = __webpack_require__(77);

var _MeasureArea = __webpack_require__(37);

var _MeasureAreaSurface = __webpack_require__(78);

var _MeasureHeight = __webpack_require__(50);

var _MeasureHeightTriangle = __webpack_require__(79);

var _MeasureLength = __webpack_require__(38);

var _MeasureLengthSection = __webpack_require__(80);

var _MeasureLengthSurface = __webpack_require__(81);

var _MeasurePoint = __webpack_require__(82);

var _MeasureVolume = __webpack_require__(83);

var _Skyline = __webpack_require__(152);

var _SkylineAnalyse = __webpack_require__(154);

var _TerrainClip = __webpack_require__(156);

var _newTerrainClip = __webpack_require__(157);

var _TerrainClipPlan = __webpack_require__(159);

var _Underground = __webpack_require__(160);

var _ViewShed3D = __webpack_require__(161);

var _Sightline = __webpack_require__(163);

var _CutFillAnalysis = __webpack_require__(164);

var _ContourLine = __webpack_require__(166);

var _Slope = __webpack_require__(61);

var _ShadowAnalyse = __webpack_require__(167);

var _ProfileAnalysis = __webpack_require__(170);

var _MixedOcclusion = __webpack_require__(171);

var _TilesClipPlan = __webpack_require__(87);

var _TilesClip = __webpack_require__(173);

var _TilesFlat = __webpack_require__(176);

var _TilesFlood = __webpack_require__(177);

var _GltfClipPlan = __webpack_require__(178);

var _FlyLine = __webpack_require__(179);

var _DynamicFlyLine = __webpack_require__(180);

var _FirstPersonRoam = __webpack_require__(181);

var _StreetCameraController = __webpack_require__(182);

var _CameraViewController = __webpack_require__(183);

var _MouseOperationController = __webpack_require__(184);

var _Draw = __webpack_require__(6);

var _index = __webpack_require__(22);

var Attr = _interopRequireWildcard(_index);

var _Tooltip = __webpack_require__(8);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Edit = __webpack_require__(26);

var _Edit2 = __webpack_require__(68);

var _Edit3 = __webpack_require__(64);

var _Edit4 = __webpack_require__(62);

var _Edit5 = __webpack_require__(71);

var _Edit6 = __webpack_require__(60);

var _Edit7 = __webpack_require__(28);

var _Edit8 = __webpack_require__(12);

var _Edit9 = __webpack_require__(27);

var _Edit10 = __webpack_require__(63);

var _Edit11 = __webpack_require__(67);

var _Edit12 = __webpack_require__(72);

var _Edit13 = __webpack_require__(74);

var _Edit14 = __webpack_require__(73);

var _PlotUtil = __webpack_require__(9);

__webpack_require__(185);

__webpack_require__(187);

__webpack_require__(189);

__webpack_require__(191);

__webpack_require__(193);

__webpack_require__(195);

__webpack_require__(197);

__webpack_require__(199);

__webpack_require__(201);

__webpack_require__(203);

__webpack_require__(205);

__webpack_require__(206);

__webpack_require__(207);

__webpack_require__(208);

__webpack_require__(209);

__webpack_require__(210);

var _RectangularSensorPrimitive = __webpack_require__(90);

var _RectangularSensorGraphics = __webpack_require__(86);

var _RectangularSensorVisualizer = __webpack_require__(215);

var _DivPoint = __webpack_require__(89);

var _DynamicRiver = __webpack_require__(216);

var _water = __webpack_require__(59);

var water = _interopRequireWildcard(_water);

var _DasWater = __webpack_require__(220);

var _DasWater2 = __webpack_require__(222);

var _ParticleSystemEx = __webpack_require__(226);

var _PointLight = __webpack_require__(227);

var _SpotLight = __webpack_require__(228);

var _FlatBillboard = __webpack_require__(229);

var _FlatImage = __webpack_require__(232);

var _ConeGlow = __webpack_require__(234);

var _DiffuseWallGlow = __webpack_require__(239);

var _ScrollWallGlow = __webpack_require__(242);

var _FogEffect = __webpack_require__(247);

var _InvertedScene = __webpack_require__(249);

var _SnowCover = __webpack_require__(251);

var _ColorCorrection = __webpack_require__(253);

var _DivMask = __webpack_require__(254);

var _HighlightBoundary = __webpack_require__(255);

var _material = __webpack_require__(256);

var material = _interopRequireWildcard(_material);

var _TextMaterial = __webpack_require__(270);

var _CylinderWaveMaterial = __webpack_require__(271);

var _CircleScanMaterialProperty = __webpack_require__(272);

var _CircleWaveMaterialProperty = __webpack_require__(54);

var _ScanLineMaterialProperty = __webpack_require__(273);

var _LineFlowMaterialProperty = __webpack_require__(40);

var _ODLineMaterialProperty = __webpack_require__(274);

var _TextMaterialProperty = __webpack_require__(275);

var _WaterMaterialProperty = __webpack_require__(276);

var _Rain = __webpack_require__(277);

var _Rain2 = _interopRequireDefault(_Rain);

var _Snow = __webpack_require__(278);

var _Snow2 = _interopRequireDefault(_Snow);

var _ZoomNavigation = __webpack_require__(279);

var _matrix = __webpack_require__(16);

var matrix = _interopRequireWildcard(_matrix);

var _model = __webpack_require__(280);

var model = _interopRequireWildcard(_model);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _polygon = __webpack_require__(10);

var polygon = _interopRequireWildcard(_polygon);

var _polyline = __webpack_require__(23);

var polyline = _interopRequireWildcard(_polyline);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _token = __webpack_require__(30);

var token = _interopRequireWildcard(_token);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _config2Entity = __webpack_require__(31);

var _defaultContextMenu = __webpack_require__(76);

var _measure = __webpack_require__(18);

var measure = _interopRequireWildcard(_measure);

var _tileset = __webpack_require__(32);

var tileset = _interopRequireWildcard(_tileset);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _Video3D = __webpack_require__(281);

var _Video2D = __webpack_require__(283);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Cesium = Cesium; //方便vue等技术栈直接使用

//===========框架基本信息=========


exports.name = "云端地球 DasEarth";
exports.website = "https://www.daspatial.com/";
exports.author = "大势智慧";
exports.version = ver.version;
exports.update = ver.update;

//=============Cesium原生对象做的外挂扩展=====================

exports.Cesium3DTilesetEx = _Cesium3DTilesetEx.Cesium3DTilesetEx;

exports.ViewerEx = _ViewerEx.ViewerEx;

//=============基础类=====================

exports.DasClass = _DasClass.DasClass;
exports.event = _DasClass.eventType;

//=============widget=====================

exports.widget = widget;

exports.widget.ES5BaseWidget = _ES5BaseWidget.ES5BaseWidget;

exports.widget.BaseWidget = _BaseWidget.BaseWidget;
exports.widget.BaseWidget.extend = function (obj) {
  //兼容v2.2之前的老版本的使用
  return _ES5BaseWidget.ES5BaseWidget.extend(obj);
};

//=============三维框架类=====================

exports.createMap = _map.createMap;

exports.layer = layer;

//=====================分析相关=====================
exports.analysi = {};

//淹没分析（polygon矢量面抬高）

exports.analysi.FloodByEntity = _FloodByEntity.FloodByEntity;

//淹没分析 （基于terrain地形）

exports.analysi.FloodByTerrain = _FloodByTerrain.FloodByTerrain;

//量算（长度、面积、角度等）

exports.analysi.Measure = _Measure.Measure;

exports.analysi.MeasureAngle = _MeasureAngle.MeasureAngle;

exports.analysi.MeasureArea = _MeasureArea.MeasureArea;

exports.analysi.MeasureAreaSurface = _MeasureAreaSurface.MeasureAreaSurface;

exports.analysi.MeasureHeight = _MeasureHeight.MeasureHeight;

exports.analysi.MeasureHeightTriangle = _MeasureHeightTriangle.MeasureHeightTriangle;

exports.analysi.MeasureLength = _MeasureLength.MeasureLength;

exports.analysi.MeasureLengthSection = _MeasureLengthSection.MeasureLengthSection;

exports.analysi.MeasureLengthSurface = _MeasureLengthSurface.MeasureLengthSurface;

exports.analysi.MeasurePoint = _MeasurePoint.MeasurePoint;

exports.analysi.MeasureVolume = _MeasureVolume.MeasureVolume; //方量分析

//天际线 描边

exports.analysi.Skyline = _Skyline.Skyline;
//天际线分析

exports.analysi.SkylineAnalyse = _SkylineAnalyse.SkylineAnalyse;

//地形开挖 类 (基于地形)

exports.analysi.TerrainClip = _TerrainClip.TerrainClip;

exports.analysi.newTerrainClip = _newTerrainClip.newTerrainClip;

//地形开挖 类（平面 Plan原生）

exports.analysi.TerrainClipPlan = _TerrainClipPlan.TerrainClipPlan;

//地下模式

exports.analysi.Underground = _Underground.Underground;

//可视域分析

exports.analysi.ViewShed3D = _ViewShed3D.ViewShed3D;

//通视分析

exports.analysi.Sightline = _Sightline.Sightline;

//体积测量分析

exports.analysi.CutFillAnalysis = _CutFillAnalysis.CutFillAnalysis;

//等高线

exports.analysi.ContourLine = _ContourLine.ContourLine;

//坡度坡向

exports.analysi.Slope = _Slope.Slope;

//阴影率分析

exports.analysi.ShadowAnalyse = _ShadowAnalyse.ShadowAnalyse;

//剖面分析

exports.analysi.ProfileAnalysis = _ProfileAnalysis.ProfileAnalysis;

//=====================3dtiles模型 分析相关  =====================
exports.tiles = {};

//混合遮挡

exports.tiles.MixedOcclusion = _MixedOcclusion.MixedOcclusion;

//模型裁剪（平面 Plan原生）

exports.tiles.TilesClipPlan = _TilesClipPlan.TilesClipPlan;

//模型 裁剪（单个、对数据有要求）

exports.tiles.TilesClip = _TilesClip.TilesClip;

//模型 压平分析 （单个、对数据有要求）

exports.tiles.TilesFlat = _TilesFlat.TilesFlat;

//模型 淹没分析（单个、对数据有要求）

exports.tiles.TilesFlood = _TilesFlood.TilesFlood;

//gltf模型 裁剪

exports.GltfClipPlan = _GltfClipPlan.GltfClipPlan;

//=====================相机 视角 相关=====================

exports.FlyLine = _FlyLine.FlyLine;

exports.DynamicFlyLine = _DynamicFlyLine.DynamicFlyLine;

// import { KeyboardType } from "./das/camera/KeyboardRoam";
// exports.KeyboardType = KeyboardType;

exports.FirstPersonRoam = _FirstPersonRoam.FirstPersonRoam;

exports.StreetCameraController = _StreetCameraController.StreetCameraController;

exports.CameraViewController = _CameraViewController.CameraViewController;

;
exports.MouseOperationController = _MouseOperationController.MouseOperationController;

//=====================Draw标绘=====================

exports.Draw = _Draw.Draw;

exports.draw = {};
exports.draw.register = _Draw.register;

exports.draw.attr = Attr;

exports.draw.tooltip = _Tooltip.message;

exports.draw.dragger = draggerCtl;

exports.DrawEdit = {};

exports.DrawEdit.Base = _Edit.EditBase;

exports.DrawEdit.Circle = _Edit2.EditCircle;

exports.DrawEdit.Corridor = _Edit3.EditCorridor;

exports.DrawEdit.Curve = _Edit4.EditCurve;

exports.DrawEdit.Ellipsoid = _Edit5.EditEllipsoid;

exports.DrawEdit.Point = _Edit6.EditPoint;

exports.DrawEdit.Polygon = _Edit7.EditPolygon;

exports.DrawEdit.PolygonEx = _Edit8.EditPolygonEx;

exports.DrawEdit.Polyline = _Edit9.EditPolyline;

exports.DrawEdit.PolylineVolume = _Edit10.EditPolylineVolume;

exports.DrawEdit.Rectangle = _Edit11.EditRectangle;

exports.DrawEdit.Wall = _Edit12.EditWall;

exports.DrawEdit.Box = _Edit13.EditBox;

exports.DrawEdit.Plane = _Edit14.EditPlane;

//Draw标绘 扩展部分，下面也可以单独插件的方式另外打包

exports.draw.plotUtil = _PlotUtil.plotUtil;

//=====================扩展的矢量对象=====================
//相控阵雷达

exports.RectangularSensorPrimitive = _RectangularSensorPrimitive.RectangularSensorPrimitive;
exports.RectangularSensorGraphics = _RectangularSensorGraphics.RectangularSensorGraphics;
exports.RectangularSensorVisualizer = _RectangularSensorVisualizer.RectangularSensorVisualizer;

//div点

exports.DivPoint = _DivPoint.DivPoint;

//动态河流、公路

exports.DynamicRiver = _DynamicRiver.DynamicRiver;

//水域 相关效果

exports.water = water;

//镜面反射水

exports.DasWater = _DasWater.DasWater;

//镜面反射水2

exports.DasWater2 = _DasWater2.DasWater2;

//粒子效果封装

exports.ParticleSystemEx = _ParticleSystemEx.ParticleSystemEx;

//点光源

exports.PointLight = _PointLight.PointLight;

//聚光灯

exports.SpotLight = _SpotLight.SpotLight;

//平放的图标

exports.FlatBillboard = _FlatBillboard.FlatBillboard;

//平放的图片（随地图缩放）

exports.FlatImage = _FlatImage.FlatImage;

//光柱椎体

exports.ConeGlow = _ConeGlow.ConeGlow;

//立体面(或圆)散射围墙效果

exports.DiffuseWallGlow = _DiffuseWallGlow.DiffuseWallGlow;

//走马灯围墙效果

exports.ScrollWallGlow = _ScrollWallGlow.ScrollWallGlow;

//=====================场景特效=====================
exports.scene = {};

//雾特效

exports.scene.FogEffect = _FogEffect.FogEffect;

//场景倒影

exports.scene.InvertedScene = _InvertedScene.InvertedScene;

//雾覆盖 效果

exports.scene.SnowCover = _SnowCover.SnowCover;

//颜色校正效果

exports.scene.ColorCorrection = _ColorCorrection.ColorCorrection;

//界面蒙版

exports.scene.DivMask = _DivMask.DivMask;

//高亮边界

exports.scene.HighlightBoundary = _HighlightBoundary.HighlightBoundary;

//=====================material材质=====================

exports.material = material;

//文本文字  primitive材质

exports.material.TextMaterial = _TextMaterial.TextMaterial;

//圆锥扩散波纹效果 primitive材质

exports.material.CylinderWaveMaterial = _CylinderWaveMaterial.CylinderWaveMaterial;

//圆扫描效果 材质

exports.material.CircleScanMaterialProperty = _CircleScanMaterialProperty.CircleScanMaterialProperty;

//圆扩散波纹效果  材质

exports.material.CircleWaveMaterialProperty = _CircleWaveMaterialProperty.CircleWaveMaterialProperty;

//扫描线放大效果 材质

exports.material.ScanLineMaterialProperty = _ScanLineMaterialProperty.ScanLineMaterialProperty;

//动态线、墙  材质

exports.material.LineFlowMaterialProperty = _LineFlowMaterialProperty.LineFlowMaterialProperty;

//OD线

exports.material.ODLineMaterialProperty = _ODLineMaterialProperty.ODLineMaterialProperty;

//文本文字  entity材质

exports.material.TextMaterialProperty = _TextMaterialProperty.TextMaterialProperty;

exports.material.WaterMaterialProperty = _WaterMaterialProperty.WaterMaterialProperty;

//=====================Shader特效=====================
exports.shader = {};
//雨雪 着色器

exports.shader.rain = _Rain2.default;

exports.shader.snow = _Snow2.default;

//===================== tool =====================

exports.ZoomNavigation = _ZoomNavigation.ZoomNavigation;

//===================== util =====================

exports.matrix = matrix;

exports.model = model;

exports.point = point;

exports.polygon = polygon;

exports.polyline = polyline;

exports.pointconvert = pointconvert;

exports.token = token;

exports.util = util;

exports.util.config2Entity = _config2Entity.config2Entity;

exports.util.getDefaultContextMenu = _defaultContextMenu.getDefaultContextMenu;

exports.measure = measure;

exports.tileset = tileset;

exports.log = daslog;

//=====================视频融合 相关  =====================
exports.video = {};

//视频融合（投射3D，贴物体表面）

exports.video.Video3D = _Video3D.Video3D;

//视频融合（投射2D平面）

exports.video.Video2D = _Video2D.Video2D;

//打印信息
util.printVersion();

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bindEvent = bindEvent;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//绑定事件监听方法到Cesium原生对象上
function bindEvent(className) {
  Object.defineProperties(Cesium[className].prototype, {
    eventTarget: {
      set: function set(value) {
        this._eventTarget = value;
      },
      get: function get() {
        if (!this._eventTarget) {
          this._eventTarget = new _DasClass.DasClass();
        }
        return this._eventTarget;
      }
    }
  });
  Cesium[className].prototype.on = function (types, fn, context) {
    return this.eventTarget.on(types, fn, context);
  };
  Cesium[className].prototype.off = function (types, fn, context) {
    return this.eventTarget.off(types, fn, context);
  };
  Cesium[className].prototype.fire = function (type, data, propagate) {
    return this.eventTarget.fire(type, data, propagate);
  };
  Cesium[className].prototype.once = function (types, fn, context) {
    return this.eventTarget.once(types, fn, context);
  };
  Cesium[className].prototype.listens = function (type, propagate) {
    return this.eventTarget.listens(type, propagate);
  };

  Cesium[className].event = {
    click: _DasClass.eventType.click,
    mouseOver: _DasClass.eventType.mouseOver,
    mouseOut: _DasClass.eventType.mouseOut
  };
}

bindEvent("Entity");
bindEvent("Cesium3DTileset");
bindEvent("Primitive");
bindEvent("GroundPrimitive");
bindEvent("GroundPolylinePrimitive");

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//绑定到Entity上
Object.defineProperties(Cesium.EntityCluster.prototype, {
  circleImageRadius: {
    set: function set(value) {
      this._circleImageRadius = value;
      this._circleImageRadius2 = value - 5;
    },
    get: function get() {
      if (!this._circleImageRadius) {
        this._circleImageRadius = 28;
      }
      return this._circleImageRadius;
    }
  },
  circleImageRadius2: {
    set: function set(value) {
      this._circleImageRadius2 = value;
    },
    get: function get() {
      if (!this._circleImageRadius2) {
        this._circleImageRadius2 = 23;
      }
      return this._circleImageRadius2;
    }
  },
  circleImage: {
    set: function set(value) {
      this._circleImage = value;
    },
    get: function get() {
      if (!this._circleImage) {
        this._circleImage = {};
      }
      return this._circleImage;
    }
  }
});

//生产聚合圆形图标 base64格式
Cesium.EntityCluster.prototype.getCircleImage = function (count) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!this.circleImage[count]) {
    var clr;
    var clr2;
    if (options.color) {
      clr = options.color;
      clr2 = options.color2;
    } else {
      if (count < 10) {
        clr = "rgba(181, 226, 140, 0.6)";
        clr2 = "rgba(110, 204, 57, 0.5)";
      } else if (count < 100) {
        clr = "rgba(241, 211, 87, 0.6)";
        clr2 = "rgba(240, 194, 12, 0.5)";
      } else {
        clr = "rgba(253, 156, 115, 0.6)";
        clr2 = "rgba(241, 128, 23, 0.5)";
      }
    }

    var thisSize = this.circleImageRadius * 2;

    var circleCanvas = document.createElement("canvas");
    circleCanvas.width = thisSize;
    circleCanvas.height = thisSize;
    var circleCtx = circleCanvas.getContext("2d");

    circleCtx.fillStyle = "#ffffff00";
    circleCtx.globalAlpha = 0.0;
    circleCtx.fillRect(0, 0, thisSize, thisSize);

    //圆形底色 (外圈)
    if (clr) {
      circleCtx.globalAlpha = 1.0;
      circleCtx.beginPath();
      circleCtx.arc(this.circleImageRadius, this.circleImageRadius, this.circleImageRadius, 0, Math.PI * 2, true);
      circleCtx.closePath();
      circleCtx.fillStyle = clr;
      circleCtx.fill();
    }

    //圆形底色(内圈)
    if (clr2) {
      circleCtx.globalAlpha = 1.0;
      circleCtx.beginPath();
      circleCtx.arc(this.circleImageRadius, this.circleImageRadius, this.circleImageRadius2, 0, Math.PI * 2, true);
      circleCtx.closePath();
      circleCtx.fillStyle = clr2;
      circleCtx.fill();
    }

    //数字文字
    circleCtx.font = options.font || this.circleImageRadius2 * 0.9 + "px bold normal"; // 设置字体
    circleCtx.fillStyle = options.fontColor || "#ffffff"; // 设置颜色
    circleCtx.textAlign = "center"; // 设置水平对齐方式
    circleCtx.textBaseline = "middle"; // 设置垂直对齐方式
    circleCtx.fillText(count, this.circleImageRadius, this.circleImageRadius); // 绘制文字（参数：要写的字，x坐标，y坐标）

    this.circleImage[count] = circleCanvas.toDataURL();
  }
  return this.circleImage[count];
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cesium3DTilesetEx = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//Viewer扩展
var Cesium3DTilesetEx = exports.Cesium3DTilesetEx = function (_DasClass) {
  _inherits(Cesium3DTilesetEx, _DasClass);

  //========== 构造方法 ==========
  function Cesium3DTilesetEx(tileset, options) {
    _classCallCheck(this, Cesium3DTilesetEx);

    var _this = _possibleConstructorReturn(this, (Cesium3DTilesetEx.__proto__ || Object.getPrototypeOf(Cesium3DTilesetEx)).call(this, options));

    _this.options = (0, _util.clone)(options || {});
    _this.orginCenter = { x: 0, y: 0, z: 0 }; //原始的中心点位置
    _this.orginRotation = { x: 0, y: 0, z: 0 }; //原始的旋转角度

    tileset._loadOk = false;
    tileset.readyPromise.then(function (tileset) {
      _this._initData(tileset);
      tileset._loadOk = true;
    });
    return _this;
  }
  //========== 对外属性 ==========
  //透明度


  _createClass(Cesium3DTilesetEx, [{
    key: "_initData",


    //========== 方法 ==========

    //记录一些原始值
    value: function _initData(tileset) {
      this.tileset = tileset;

      //记录模型原始的中心点
      this.orginPosition = Cesium.clone(this.tileset.boundingSphere.center);

      //是否存在世界矩阵 _root.transform
      this.transform = Cesium.defaultValue(this.options.transform, tileset._root && tileset._root.transform);

      if (this.transform) {
        //原始矩阵
        this.orginMatrix = Cesium.Matrix4.inverse(Cesium.Matrix4.fromArray(tileset._root.transform), new Cesium.Matrix4());

        //获取transform中的中心点
        var matrix = Cesium.Matrix4.fromArray(this.tileset._root.transform);
        var position = Cesium.Matrix4.getTranslation(matrix, new Cesium.Cartesian3());
        if (Cesium.defined(position) && Cesium.Cartographic.fromCartesian(position)) {
          this.orginPosition = position;

          //计算 orginRotation
          //取旋转矩阵
          var rotmat = Cesium.Matrix4.getMatrix3(matrix, new Cesium.Matrix3());
          //默认的旋转矩阵
          var defrotmat = Cesium.Matrix4.getMatrix3(Cesium.Transforms.eastNorthUpToFixedFrame(position), new Cesium.Matrix3());

          //计算rotmat 的x轴，在defrotmat 上 旋转
          var xaxis = Cesium.Matrix3.getColumn(defrotmat, 0, new Cesium.Cartesian3());
          var yaxis = Cesium.Matrix3.getColumn(defrotmat, 1, new Cesium.Cartesian3());
          var zaxis = Cesium.Matrix3.getColumn(defrotmat, 2, new Cesium.Cartesian3());

          var dir = Cesium.Matrix3.getColumn(rotmat, 0, new Cesium.Cartesian3());

          dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
          dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
          dir = Cesium.Cartesian3.normalize(dir, dir);

          var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

          var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);

          if (ay > Math.PI * 0.5) {
            heading = 2 * Math.PI - heading;
          }
          //原始的旋转角度
          this.orginRotation = {
            x: 0,
            y: 0,
            z: Number(Cesium.Math.toDegrees(heading).toFixed(1))
          };
        } else {
          this.transform = false;
        }
      }
      this.orginCenter = (0, _point.formatPosition)(this.orginPosition);

      //打印下
      daslog.log((this.options.name || "") + " 模型中心为:" + JSON.stringify(this.orginCenter));

      //================设置相关配置参数===============

      //高度自动贴地处理
      if (this.options.offset) {
        if (this.options.offset.z == "auto" || this.options.offset.z == "-height") {
          this.clampToGround();
        }
      }

      //透明度
      if (Cesium.defined(this.options.opacity)) {
        this.opacity = this.options.opacity;
      }

      //设置style
      if (Cesium.defined(this.options.style)) {
        this.tileset.style = new Cesium.Cesium3DTileStyle(this.options.style);
      }

      if (this.transform) {
        this.updateMatrix();
      } else {
        this.updateMatrix2();
      }
      this.fire(_DasClass2.eventType.load, { sourceTarget: tileset });
    }

    //自动贴地处理(因为模型中心位置不一定于地形匹配，此方法不是唯一准确的)

  }, {
    key: "clampToGround",
    value: function clampToGround(viewer, offset) {
      var _this2 = this;

      offset = Cesium.defaultValue(offset, 1); //偏移点高度
      if (viewer && viewer.das.hasTerrain()) {
        //有地形时
        (0, _point.getSurfaceTerrainHeight)(viewer.scene, this.orginCenter, {
          asyn: true, //是否异步求准确高度
          callback: function callback(newHeight, cartOld) {
            if (newHeight == null) return;
            _this2.height = newHeight - _this2.orginCenter.z + offset;
          }
        });
      } else {
        //无地形时
        this.height = -this.orginCenter.z + offset;
      }
    }

    //重新计算当前矩阵

  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      if (!this.tileset || !this.transform) return;

      var matrix = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);

      //旋转
      if (this.options.rotation) {
        var mx = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(this.options.rotation.x || 0));
        var my = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(this.options.rotation.y || 0));
        var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(this.options.rotation.z || 0));
        var rotationX = Cesium.Matrix4.fromRotationTranslation(mx);
        var rotationY = Cesium.Matrix4.fromRotationTranslation(my);
        var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
        //矩阵相乘
        Cesium.Matrix4.multiply(matrix, rotationX, matrix);
        Cesium.Matrix4.multiply(matrix, rotationY, matrix);
        Cesium.Matrix4.multiply(matrix, rotationZ, matrix);
      }

      //缩放比例
      if (this.options.scale > 0 && this.options.scale != 1) Cesium.Matrix4.multiplyByUniformScale(matrix, this.options.scale, matrix);

      //垂直轴变换 ，兼容旧版本数据z轴方向不对的情况
      //如果可以修改模型json源文件，可以在json文件里面加了一行来修正："gltfUpAxis" : "Z",
      if (Cesium.defined(this.options.axis)) {
        var rightaxis;
        if ((0, _util.isString)(this.options.axis)) {
          switch (this.options.axis.toUpperCase()) {
            case "Y_UP_TO_Z_UP":
              rightaxis = Cesium.Axis.Y_UP_TO_Z_UP;
              break;
            case "Z_UP_TO_Y_UP":
              rightaxis = Cesium.Axis.Z_UP_TO_Y_UP;
              break;
            case "X_UP_TO_Z_UP":
              rightaxis = Cesium.Axis.X_UP_TO_Z_UP;
              break;
            case "Z_UP_TO_X_UP":
              rightaxis = Cesium.Axis.Z_UP_TO_X_UP;
              break;
            case "X_UP_TO_Y_UP":
              rightaxis = Cesium.Axis.X_UP_TO_Y_UP;
              break;
            case "Y_UP_TO_X_UP":
              rightaxis = Cesium.Axis.Y_UP_TO_X_UP;
              break;
          }
        } else if (this.options.axis instanceof Cesium.Axis) {
          rightaxis = this.options.axis;
        }

        if (rightaxis) {
          matrix = Cesium.Matrix4.multiplyTransformation(matrix, rightaxis, matrix);
        }
      }
      this.tileset._root.transform = matrix;
      return matrix;
    }

    //普通,此种方式[x，y不能多次更改]

  }, {
    key: "updateMatrix2",
    value: function updateMatrix2() {
      if (!this.tileset || !this.options.offset) return;

      var catographic = Cesium.Cartographic.fromCartesian(this.tileset.boundingSphere.center);
      var surface = Cesium.Cartesian3.fromRadians(catographic.longitude, catographic.latitude, 0.0);
      var offset = this.position;
      var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
      var matrix = Cesium.Matrix4.fromTranslation(translation);
      this.tileset.modelMatrix = matrix;
      return matrix;
    }
    //修改高度【独立方法】
    // setHeight(height) {
    //   let center = Cesium.Cartographic.fromCartesian(this.tileset.boundingSphere.center);
    //   let surface = Cesium.Cartesian3.fromRadians(center.longitude, center.latitude, center.height);
    //   let offset = Cesium.Cartesian3.fromRadians(
    //     center.longitude,
    //     center.latitude,
    //     center.height + height
    //   );
    //   let translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
    //   this.tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
    // }

  }, {
    key: "updateStyle",
    value: function updateStyle(options) {
      for (var i in options) {
        if (_typeof(options[i]) === "object" && this.options[i]) {
          for (var key2 in options[i]) {
            this.options[i][key2] = options[i][key2];
          }
        } else {
          this.options[i] = options[i];
        }
      }

      if (!this.tileset) return;

      if (this.transform) {
        this.updateMatrix();
      } else {
        this.updateMatrix2();
      }
      return this;
    }

    //获取构件节点位置，现对于原始矩阵变化后的新位置

  }, {
    key: "getPositionByOrginMatrix",
    value: function getPositionByOrginMatrix(position) {
      if (this.orginMatrix) {
        var mat = Cesium.Matrix4.multiply(this.tileset._root.transform, this.orginMatrix, new Cesium.Matrix4());
        return Cesium.Matrix4.multiplyByPoint(mat, position, new Cesium.Cartesian3());
      }
      return position;
    }
  }, {
    key: "opacity",
    get: function get() {
      return this.options.opacity;
    },
    set: function set(value) {
      this.options.opacity = value;
      if (!this.tileset) return;

      this.tileset.style = new Cesium.Cesium3DTileStyle({
        color: "color() *vec4(1,1,1," + value + ")"
      });
    }

    //位置

  }, {
    key: "position",
    get: function get() {
      if (this.options.offset) {
        return Cesium.Cartesian3.fromDegrees(Cesium.defaultValue(this.options.offset.x, this.orginCenter.x), Cesium.defaultValue(this.options.offset.y, this.orginCenter.y), Cesium.defaultValue(this.options.offset.z, this.orginCenter.z));
      }

      return this.orginPosition;
    },
    set: function set(value) {
      this.offset = (0, _point.formatPosition)(value);
    }
  }, {
    key: "offset",
    get: function get() {
      if (this.options.offset) return this.options.offset;
      return this.orginCenter;
    },
    set: function set(value) {
      this.options.offset = this.options.offset || {};
      for (var key in value) {
        this.options.offset[key] = value[key];
      }

      if (this.transform) {
        this.updateMatrix();
      } else {
        this.updateMatrix2();
      }
    }

    //只调整高度

  }, {
    key: "height",
    get: function get() {
      if (this.options.offset) return this.options.offset.z;
      return 0;
    },
    set: function set(value) {
      this.options.offset = this.options.offset || {};
      this.options.offset.z = value;

      if (!this.tileset) return;

      if (this.transform) {
        this.updateMatrix();
      } else {
        this.updateMatrix2();
      }
    }

    //旋转方向

  }, {
    key: "rotation",
    get: function get() {
      if (this.options.rotation) return this.options.rotation;
      return this.orginRotation;
    },
    set: function set(value) {
      this.options.rotation = value;
      this.updateMatrix();
    }
  }, {
    key: "rotation_x",
    get: function get() {
      if (this.options.rotation && Cesium.defined(this.options.rotation.x)) return this.options.rotation.x;
      if (this.orginRotation && Cesium.defined(this.orginRotation.x)) return this.orginRotation.x;
      return 0;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.x = value;
      this.updateMatrix();
    }
  }, {
    key: "rotation_y",
    get: function get() {
      if (this.options.rotation && Cesium.defined(this.options.rotation.y)) return this.options.rotation.y;
      if (this.orginRotation && Cesium.defined(this.orginRotation.y)) return this.orginRotation.y;
      return 0;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.y = value;
      this.updateMatrix();
    }
  }, {
    key: "rotation_z",
    get: function get() {
      if (this.options.rotation && Cesium.defined(this.options.rotation.z)) return this.options.rotation.z;
      if (this.orginRotation && Cesium.defined(this.orginRotation.z)) return this.orginRotation.z;
      return 0;
    },
    set: function set(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.z = value;
      this.updateMatrix();
    }

    //轴方向

  }, {
    key: "axis",
    get: function get() {
      return this.options.axis;
    },
    set: function set(value) {
      this.options.axis = value;
      this.updateMatrix();
    }

    //缩放比例

  }, {
    key: "scale",
    get: function get() {
      return this.options.scale || 1;
    },
    set: function set(value) {
      this.options.scale = value;
      this.updateMatrix();
    }
  }]);

  return Cesium3DTilesetEx;
}(_DasClass2.DasClass);

//绑定到Viewer上


Object.defineProperties(Cesium.Cesium3DTileset.prototype, {
  das: {
    set: function set(value) {
      if (this._das) {
        this._das.updateStyle(value);
      } else {
        if (value instanceof Cesium.Viewer) this._das = value;else this._das = new Cesium3DTilesetEx(this, value);
      }
    },
    get: function get() {
      if (!this._das) {
        this._das = new Cesium3DTilesetEx(this);
      }
      return this._das;
    }
  }
});

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlashingEntity = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.loopArrayForFun = loopArrayForFun;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//定时闪烁高亮Entity（点、线、面）
var FlashingEntity = exports.FlashingEntity = function () {
  //========== 构造方法 ==========
  function FlashingEntity(options) {
    _classCallCheck(this, FlashingEntity);

    this.color = Cesium.Color.YELLOW.withAlpha(0);
  }

  //========== 方法 ==========


  _createClass(FlashingEntity, [{
    key: "highlight",
    value: function highlight(entitys, opts) {
      var that = this;
      this.unHighlight();

      opts = opts || {};

      this.entitys = entitys;
      this.maxAlpha = Cesium.defaultValue(opts.maxAlpha, 0.3);
      this.time = Cesium.defaultValue(opts.time, 10); //播放时长
      this.color = Cesium.defaultValue(opts.color, Cesium.Color.YELLOW);
      this.color = this.color.withAlpha(this.maxAlpha);
      this.onEnd = opts.onEnd;

      this._startTime();

      loopArrayForFun(entitys, function (entity) {
        if (entity.polygon) {
          entity.polygon.material_bak = entity.polygon.material;
          entity.polygon.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
            return that.color;
          }, false));
        }
        if (entity.polyline) {
          entity.polyline.material_bak = entity.polyline.material;
          entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
            return that.color;
          }, false));
        }
        if (entity.ellipse) {
          entity.ellipse.material_bak = entity.ellipse.material;
          entity.ellipse.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
            return that.color;
          }, false));
        }
        if (entity.rectangle) {
          entity.rectangle.material_bak = entity.rectangle.material;
          entity.rectangle.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
            return that.color;
          }, false));
        }
        if (entity.wall) {
          entity.wall.material_bak = entity.wall.material;
          entity.wall.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
            return that.color;
          }, false));
        }

        if (entity.point) {
          entity.point.color_bak = entity.point.color;
          entity.point.color = that.color;
        }
        if (entity.billboard) {
          entity.billboard.color_bak = entity.billboard.color;
          entity.billboard.color = that.color;
        }
        if (entity.model) {
          entity.model.color_bak = entity.model.color;
          entity.model.color = that.color;
        }
        if (entity.label) {
          entity.label.fillColor_bak = entity.label.fillColor;
          entity.label.fillColor = that.color;
        }
      });
      return this;
    }
  }, {
    key: "unHighlight",
    value: function unHighlight() {
      this._stopTime();

      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.polygon) {
            if (entity.polygon.material_bak) entity.polygon.material = entity.polygon.material_bak;
          }
          if (entity.polyline) {
            if (entity.polyline.material_bak) entity.polyline.material = entity.polyline.material_bak;
          }
          if (entity.ellipse) {
            if (entity.ellipse.material_bak) entity.ellipse.material = entity.ellipse.material_bak;
          }
          if (entity.rectangle) {
            if (entity.rectangle.material_bak) entity.rectangle.material = entity.rectangle.material_bak;
          }
          if (entity.wall) {
            if (entity.wall.material_bak) entity.wall.material = entity.wall.material_bak;
          }

          if (entity.point) {
            if (entity.point.color_bak) entity.point.color = entity.point.color_bak;
          }
          if (entity.billboard) {
            if (entity.billboard.color_bak) entity.billboard.color = entity.billboard.color_bak;
          }
          if (entity.model) {
            if (entity.model.color_bak) entity.model.color = entity.model.color_bak;
          }
          if (entity.label) {
            if (entity.label.fillColor_bak) entity.label.fillColor = entity.label.fillColor_bak;
          }
        });
        if (this.onEnd) this.onEnd(this.entitys);
        delete this.entitys;
      }
      return this;
    }
  }, {
    key: "_updateClr",
    value: function _updateClr() {
      var that = this;
      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.point) {
            entity.point.color = that.color;
          }
          if (entity.billboard) {
            entity.billboard.color = that.color;
          }
          if (entity.model) {
            entity.model.color = that.color;
          }
          if (entity.label) {
            entity.label.fillColor = that.color;
          }
        });
      }
    }
  }, {
    key: "_startTime",
    value: function _startTime() {
      var _this = this;

      var time = 30;
      var setp = this.maxAlpha / time;

      var alpha = 0;
      this.interVal = setInterval(function () {
        alpha += setp;
        if (alpha > _this.maxAlpha) alpha = 0;
        _this.color = _this.color.withAlpha(alpha);
        _this._updateClr();
      }, time);

      this.timeEndVal = setTimeout(function () {
        _this.unHighlight();
      }, this.time * 1000);
    }
  }, {
    key: "_stopTime",
    value: function _stopTime() {
      clearInterval(this.interVal);
      clearTimeout(this.timeEndVal);
    }
  }]);

  return FlashingEntity;
}();

//循环执行数组或对象
// 调用示例 loopArrayForFun(ArrOrObj, function (entity) {
//    drawControl.deleteEntity(entity);
// });


function loopArrayForFun(ArrOrObj, callback) {
  if (ArrOrObj == null) return;
  if ((0, _util.isArray)(ArrOrObj)) {
    var arr = [];
    for (var i = 0, len = ArrOrObj.length; i < len; i++) {
      arr.push(callback(ArrOrObj[i]));
    }
    return arr;
  } else {
    return callback(ArrOrObj);
  }
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GroupLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _BaseLayer2 = __webpack_require__(14);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupLayer = exports.GroupLayer = function (_BaseLayer) {
  _inherits(GroupLayer, _BaseLayer);

  function GroupLayer() {
    _classCallCheck(this, GroupLayer);

    return _possibleConstructorReturn(this, (GroupLayer.__proto__ || Object.getPrototypeOf(GroupLayer)).apply(this, arguments));
  }

  _createClass(GroupLayer, [{
    key: "create",
    value: function create() {
      this._layers = this.options._layers;
      var arr = this._layers;
      for (var i = 0, len = arr.length; i < len; i++) {
        this.hasOpacity = arr[i].hasOpacity;
        this.hasZIndex = arr[i].hasZIndex;
      }
    }
    //添加

  }, {
    key: "add",
    value: function add() {
      this._visible = true;

      var arr = this._layers;
      for (var i = 0, len = arr.length; i < len; i++) {
        arr[i].visible = true;
      }
      _get(GroupLayer.prototype.__proto__ || Object.getPrototypeOf(GroupLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this._visible = false;

      var arr = this._layers;
      for (var i = 0, len = arr.length; i < len; i++) {
        arr[i].visible = false;
      }
      _get(GroupLayer.prototype.__proto__ || Object.getPrototypeOf(GroupLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      var arr = this._layers;
      for (var i = 0, len = arr.length; i < len; i++) {
        arr[i].centerAt(duration);
      }
    }
    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      var arr = this._layers;
      for (var i = 0, len = arr.length; i < len; i++) {
        if (!arr[i].hasOpacity) continue;
        arr[i].setOpacity(value);
      }
    }
  }]);

  return GroupLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperMapImgLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TileLayer2 = __webpack_require__(43);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuperMapImgLayer = exports.SuperMapImgLayer = function (_TileLayer) {
  _inherits(SuperMapImgLayer, _TileLayer);

  function SuperMapImgLayer() {
    _classCallCheck(this, SuperMapImgLayer);

    return _possibleConstructorReturn(this, (SuperMapImgLayer.__proto__ || Object.getPrototypeOf(SuperMapImgLayer)).apply(this, arguments));
  }

  _createClass(SuperMapImgLayer, [{
    key: "add",
    value: function add() {
      _get(SuperMapImgLayer.prototype.__proto__ || Object.getPrototypeOf(SuperMapImgLayer.prototype), "add", this).call(this);

      var options = this.options;
      if (Cesium.defined(options.transparentBackColorTolerance)) {
        this.layer.transparentBackColorTolerance = options.transparentBackColorTolerance; //去黑边
      }
    }
  }]);

  return SuperMapImgLayer;
}(_TileLayer2.TileLayer);

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraticuleLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _BaseLayer2 = __webpack_require__(14);

var _GraticuleProvider = __webpack_require__(102);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GraticuleLayer = exports.GraticuleLayer = function (_BaseLayer) {
  _inherits(GraticuleLayer, _BaseLayer);

  function GraticuleLayer() {
    _classCallCheck(this, GraticuleLayer);

    return _possibleConstructorReturn(this, (GraticuleLayer.__proto__ || Object.getPrototypeOf(GraticuleLayer)).apply(this, arguments));
  }

  _createClass(GraticuleLayer, [{
    key: "add",


    //添加
    value: function add() {
      if (this._layer == null) {
        this.initData();
      }
      this.layer.setVisible(true);
      _get(GraticuleLayer.prototype.__proto__ || Object.getPrototypeOf(GraticuleLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      if (this._layer == null) return;

      this.layer.setVisible(false);
      _get(GraticuleLayer.prototype.__proto__ || Object.getPrototypeOf(GraticuleLayer.prototype), "remove", this).call(this);
    }
  }, {
    key: "initData",
    value: function initData() {
      this._layer = new _GraticuleProvider.GraticuleProvider({
        scene: this.viewer.scene,
        numLines: 10
      });
      this.fireMap(_DasClass.eventType.load, { layer: this._layer });
    }
  }, {
    key: "layer",
    get: function get() {
      return this._layer;
    }
  }]);

  return GraticuleLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraticuleProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var mins = [Cesium.Math.toRadians(0.05), Cesium.Math.toRadians(0.1), Cesium.Math.toRadians(0.2), Cesium.Math.toRadians(0.5), Cesium.Math.toRadians(1.0), Cesium.Math.toRadians(2.0), Cesium.Math.toRadians(5.0), Cesium.Math.toRadians(10.0)];

function gridPrecision(dDeg) {
  if (dDeg < 0.01) return 2;
  if (dDeg < 0.1) return 1;
  if (dDeg < 1) return 0;
  return 0;
}

function GraticuleProvider(options) {
  this._tilingScheme = options.tilingScheme || new Cesium.GeographicTilingScheme();

  this._color = options.color || new Cesium.Color(1.0, 1.0, 1.0, 0.4);

  this._tileWidth = options.tileWidth || 256;
  this._tileHeight = options.tileHeight || 256;

  this._ready = true;

  // default to decimal intervals
  this._sexagesimal = options.sexagesimal || false;
  this._numLines = options.numLines || 50;

  this._scene = options.scene;
  this._ellipsoid = this._scene.globe.ellipsoid;

  this._labels = new Cesium.LabelCollection();
  this._scene.primitives.add(this._labels);
  this._polylines = new Cesium.PolylineCollection();
  this._scene.primitives.add(this._polylines);

  var canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 256;
  this._canvas = canvas;

  var that = this;
  this._scene.camera.moveEnd.addEventListener(function () {
    if (!that._show) return;

    that._polylines.removeAll();
    that._labels.removeAll();
    that._currentExtent = null;
    that._drawGrid(that._getExtentView());
  });
  this._scene.imageryLayers.addImageryProvider(this);
}

var definePropertyWorks = function () {
  try {
    return "x" in Object.defineProperty({}, "x", {});
  } catch (e) {
    return false;
  }
}();

/**
 * Defines properties on an object, using Object.defineProperties if available,
 * otherwise returns the object unchanged.  This function should be used in
 * setup code to prevent errors from completely halting JavaScript execution
 * in legacy browsers.
 *
 * @private
 *
 * @exports defineProperties
 */
var defineProperties = Object.defineProperties;
if (!definePropertyWorks || !defineProperties) {
  defineProperties = function defineProperties(o) {
    return o;
  };
}

Object.defineProperties(GraticuleProvider.prototype, {
  url: {
    get: function get() {
      return undefined;
    }
  },

  proxy: {
    get: function get() {
      return undefined;
    }
  },

  tileWidth: {
    get: function get() {
      return this._tileWidth;
    }
  },

  tileHeight: {
    get: function get() {
      return this._tileHeight;
    }
  },

  maximumLevel: {
    get: function get() {
      return 18;
    }
  },

  minimumLevel: {
    get: function get() {
      return 0;
    }
  },
  tilingScheme: {
    get: function get() {
      return this._tilingScheme;
    }
  },
  rectangle: {
    get: function get() {
      return this._tilingScheme.rectangle;
    }
  },
  tileDiscardPolicy: {
    get: function get() {
      return undefined;
    }
  },
  errorEvent: {
    get: function get() {
      return this._errorEvent;
    }
  },
  ready: {
    get: function get() {
      return this._ready;
    }
  },
  credit: {
    get: function get() {
      return this._credit;
    }
  },
  hasAlphaChannel: {
    get: function get() {
      return true;
    }
  }
});

GraticuleProvider.prototype.makeLabel = function (lng, lat, text, top, color) {
  this._labels.add({
    position: this._ellipsoid.cartographicToCartesian(new Cesium.Cartographic(lng, lat, 10.0)),
    text: text,
    //font: 'normal',
    //style: Cesium.LabelStyle.FILL,
    //fillColor: 'white',
    //outlineColor: 'white',
    font: "normal small-caps normal 16px 楷体",
    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
    fillColor: Cesium.Color.AZURE,
    outlineColor: Cesium.Color.BLACK,
    outlineWidth: 2,

    pixelOffset: new Cesium.Cartesian2(5, top ? 5 : -5),
    eyeOffset: Cesium.Cartesian3.ZERO,
    horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
    verticalOrigin: top ? Cesium.VerticalOrigin.BOTTOM : Cesium.VerticalOrigin.TOP,
    scale: 1.0
  });
};

GraticuleProvider.prototype._drawGrid = function (extent) {
  if (this._currentExtent && this._currentExtent.equals(extent)) {
    return;
  }
  this._currentExtent = extent;

  this._polylines.removeAll();
  this._labels.removeAll();

  var minPixel = 0;
  var maxPixel = this._canvasSize;

  var dLat = 0,
      dLng = 0,
      index;
  // get the nearest to the calculated value
  for (index = 0; index < mins.length && dLat < (extent.north - extent.south) / 10; index++) {
    dLat = mins[index];
  }
  for (index = 0; index < mins.length && dLng < (extent.east - extent.west) / 10; index++) {
    dLng = mins[index];
  }

  // round iteration limits to the computed grid interval
  var minLng = (extent.west < 0 ? Math.ceil(extent.west / dLng) : Math.floor(extent.west / dLng)) * dLng;
  var minLat = (extent.south < 0 ? Math.ceil(extent.south / dLat) : Math.floor(extent.south / dLat)) * dLat;
  var maxLng = (extent.east < 0 ? Math.ceil(extent.east / dLat) : Math.floor(extent.east / dLat)) * dLat;
  var maxLat = (extent.north < 0 ? Math.ceil(extent.north / dLng) : Math.floor(extent.north / dLng)) * dLng;

  // extend to make sure we cover for non refresh of tiles
  minLng = Math.max(minLng - 2 * dLng, -Math.PI);
  maxLng = Math.min(maxLng + 2 * dLng, Math.PI);
  minLat = Math.max(minLat - 2 * dLat, -Math.PI / 2);
  maxLat = Math.min(maxLat + 2 * dLng, Math.PI / 2);

  var ellipsoid = this._ellipsoid;
  var lat,
      lng,
      granularity = Cesium.Math.toRadians(1);

  // labels positions
  var latitudeText = minLat + Math.floor((maxLat - minLat) / dLat / 2) * dLat;
  for (lng = minLng; lng < maxLng; lng += dLng) {
    // draw meridian
    var path = [];
    for (lat = minLat; lat < maxLat; lat += granularity) {
      path.push(new Cesium.Cartographic(lng, lat));
    }
    path.push(new Cesium.Cartographic(lng, maxLat));
    this._polylines.add({
      positions: ellipsoid.cartographicArrayToCartesianArray(path),
      width: 1
    });
    var degLng = Cesium.Math.toDegrees(lng);
    this.makeLabel(lng, latitudeText, this._sexagesimal ? this._decToSex(degLng) : degLng.toFixed(gridPrecision(dLng)), false);
  }

  // lats
  var longitudeText = minLng + Math.floor((maxLng - minLng) / dLng / 2) * dLng;
  for (lat = minLat; lat < maxLat; lat += dLat) {
    // draw parallels
    var _path = [];
    for (lng = minLng; lng < maxLng; lng += granularity) {
      _path.push(new Cesium.Cartographic(lng, lat));
    }
    _path.push(new Cesium.Cartographic(maxLng, lat));
    this._polylines.add({
      positions: ellipsoid.cartographicArrayToCartesianArray(_path),
      width: 1
    });
    var degLat = Cesium.Math.toDegrees(lat);
    this.makeLabel(longitudeText, lat, this._sexagesimal ? this._decToSex(degLat) : degLat.toFixed(gridPrecision(dLat)), true);
  }
};

GraticuleProvider.prototype.requestImage = function (x, y, level) {
  if (this._show) {
    this._drawGrid(this._getExtentView());
  }

  return this._canvas;
};

GraticuleProvider.prototype.setVisible = function (visible) {
  this._show = visible;
  if (!visible) {
    this._polylines.removeAll();
    this._labels.removeAll();
  } else {
    this._currentExtent = null;
    this._drawGrid(this._getExtentView());
  }
};

GraticuleProvider.prototype.isVisible = function () {
  return this._show;
};

GraticuleProvider.prototype._decToSex = function (d) {
  var degs = Math.floor(d);
  var mins = ((Math.abs(d) - degs) * 60.0).toFixed(2);
  if (mins == "60.00") {
    degs += 1.0;
    mins = "0.00";
  }
  return [degs, ":", mins].join("");
};

GraticuleProvider.prototype._getExtentView = function () {
  var camera = this._scene.camera;
  var canvas = this._scene.canvas;
  var corners = [camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(0, canvas.height), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), this._ellipsoid)];
  for (var index = 0; index < 4; index++) {
    if (corners[index] === undefined) {
      return Cesium.Rectangle.MAX_VALUE;
    }
  }
  return Cesium.Rectangle.fromCartographicArray(this._ellipsoid.cartesianArrayToCartographicArray(corners));
};

exports.GraticuleProvider = GraticuleProvider;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureGridLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _TileLayer2 = __webpack_require__(43);

var _config2Entity = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FeatureGridLayer = exports.FeatureGridLayer = function (_TileLayer) {
  _inherits(FeatureGridLayer, _TileLayer);

  //========== 构造方法 ==========
  function FeatureGridLayer(viewer, options) {
    _classCallCheck(this, FeatureGridLayer);

    var _this = _possibleConstructorReturn(this, (FeatureGridLayer.__proto__ || Object.getPrototypeOf(FeatureGridLayer)).call(this, viewer, options));

    _this.hasOpacity = false;
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(FeatureGridLayer, [{
    key: "create",
    value: function create() {
      var _this2 = this;

      this.dataSource = new Cesium.CustomDataSource(); //用于entity
      this._bindClustering(this.options.clustering);

      this.primitives = new Cesium.PrimitiveCollection(); //用于primitive

      this.options.id = Cesium.defaultValue(this.options.id, new Date().getTime());

      var that = this;
      this.options.type_new = "custom_featuregrid";
      this.options.addImageryCache = function (opts) {
        return that._addImageryCache(opts);
      };
      this.options.removeImageryCache = function (opts) {
        return that._removeImageryCache(opts);
      };
      this.options.removeAllImageryCache = function (opts) {
        return that._removeAllImageryCache(opts);
      };

      if (Cesium.defined(this.options.minimumLevel)) this.options.minimumTerrainLevel = this.options.minimumLevel;
      if (Cesium.defined(this.options.maximumLevel)) this.options.maximumTerrainLevel = this.options.maximumLevel;

      //是建筑物单体化时
      if (this.options.dth) {
        var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.options.dth);

        if (this.options.dth.type == "click") {
          this.on(_DasClass.eventType.click, function (e) {
            dthEvent.mouseover(e.sourceTarget);
          });
          this.viewer.das.on(_DasClass.eventType.clickMap, function (e) {
            if (!_this2._visible) return;
            dthEvent.mouseout();
          });
        } else {
          this.on(_DasClass.eventType.mouseOver, function (e) {
            dthEvent.mouseover(e.sourceTarget);
          });
          this.on(_DasClass.eventType.mouseOut, function (e) {
            dthEvent.mouseout();
          });
        }
        this.dthEvent = dthEvent;
      }

      var config = this.options;
      if (config.symbol && config.symbol.styleOptions) {
        var style = config.symbol.styleOptions;
        if (Cesium.defined(style.clampToGround)) {
          config.clampToGround = style.clampToGround;
        }
        if (Cesium.defined(style.color)) {
          var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
          config.fill = color;
        }
        if (Cesium.defined(style.outlineColor)) {
          var outlineColor = Cesium.Color.fromCssColorString(style.outlineColor || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
          config.stroke = outlineColor;
        }
        if (Cesium.defined(style.outlineWidth)) {
          config.strokeWidth = style.outlineWidth;
        }
        this.options = config;
      }
    }
  }, {
    key: "getLength",
    value: function getLength() {
      return this.primitives.length + this.dataSource.entities.values.length;
    }
  }, {
    key: "addEx",
    value: function addEx() {
      this.viewer.dataSources.add(this.dataSource);
      this.viewer.scene.primitives.add(this.primitives);
    }
  }, {
    key: "removeEx",
    value: function removeEx() {
      //是建筑物单体化时
      if (this.dthEvent) {
        this.dthEvent.mouseout();
      }
      this.viewer.dataSources.remove(this.dataSource);
      this.viewer.scene.primitives.remove(this.primitives);
    }
  }, {
    key: "_addImageryCache",
    value: function _addImageryCache(opts) {}
  }, {
    key: "_removeImageryCache",
    value: function _removeImageryCache(opts) {}
  }, {
    key: "_removeAllImageryCache",
    value: function _removeAllImageryCache() {}
    //聚合处理

  }, {
    key: "_bindClustering",
    value: function _bindClustering(options) {
      options = options || { enabled: false };

      this.dataSource.clustering.enabled = Cesium.defaultValue(options.enabled, false);
      this.dataSource.clustering.pixelRange = Cesium.defaultValue(options.pixelRange, 20); //多少像素矩形范围内聚合

      //一些属性
      var color = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.color, "#00ff00")).withAlpha(Cesium.defaultValue(options.opacity, 1.0));
      var size = Cesium.defaultValue(options.pixelSize, 48);
      var heightReference = Cesium.defaultValue(options.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
      if (options.clampToGround) heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;

      var singleDigitPins = {};
      var pinBuilder = new Cesium.PinBuilder();
      this.dataSource.clustering.clusterEvent.addEventListener(function (clusteredEntities, cluster) {
        var count = clusteredEntities.length;

        cluster.label.show = false;
        cluster.billboard.show = true;
        cluster.billboard.id = cluster.label.id;
        cluster.billboard.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
        cluster.billboard.heightReference = heightReference; //贴地

        if (!singleDigitPins[count]) {
          singleDigitPins[count] = pinBuilder.fromText(count, color, size).toDataURL();
        }
        cluster.billboard.image = singleDigitPins[count];
      });
    }
  }, {
    key: "layer",
    get: function get() {
      return this.dataSource;
    }
  }]);

  return FeatureGridLayer;
}(_TileLayer2.TileLayer);

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.POILayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _token = __webpack_require__(30);

var token = _interopRequireWildcard(_token);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _CustomFeatureGridLayer = __webpack_require__(44);

var _Attr = __webpack_require__(35);

var _Attr2 = __webpack_require__(34);

var _Attr3 = __webpack_require__(13);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POILayer = exports.POILayer = function (_CustomFeatureGridLay) {
  _inherits(POILayer, _CustomFeatureGridLay);

  //========== 构造方法 ==========
  function POILayer(viewer, options) {
    _classCallCheck(this, POILayer);

    var _this = _possibleConstructorReturn(this, (POILayer.__proto__ || Object.getPrototypeOf(POILayer)).call(this, viewer, options));

    _this._key_index = 0;
    _this._keys = _this.options.key || token.gaodeArr;
    return _this;
  }
  //========== 对外属性 ==========

  _createClass(POILayer, [{
    key: "getKey",
    value: function getKey() {
      var thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx];
    }

    //获取网格内的数据，callback为回调方法，参数传数据数组

  }, {
    key: "getDataForGrid",
    value: function getDataForGrid(opts, callback) {
      var jwd1 = pointconvert.wgs2gcj([opts.rectangle.xmin, opts.rectangle.ymax]); //加偏
      var jwd2 = pointconvert.wgs2gcj([opts.rectangle.xmax, opts.rectangle.ymin]); //加偏
      var polygon = jwd1[0] + "," + jwd1[1] + "|" + jwd2[0] + "," + jwd2[1];

      var filter = this.options.filter || {};
      filter.output = "json";
      filter.key = this.getKey();
      filter.polygon = polygon;
      if (!filter.offset) filter.offset = 25;
      if (!filter.types) filter.types = "120000|130000|190000";

      //查询POI服务
      var that = this;
      _zepto.zepto.ajax({
        url: "https://restapi.amap.com/v3/place/polygon",
        type: "get",
        dataType: "jsonp",
        timeout: 5000,
        data: filter,
        success: function success(data) {
          if (data.infocode !== "10000") {
            daslog.log("POI 请求失败", data);
            return;
          }
          var arrdata = data.pois;
          callback(arrdata);
        },
        error: function error(data) {
          daslog.error("POI 请求出错", data);
        }
      });
    }
    //根据数据创造entity

  }, {
    key: "createEntity",
    value: function createEntity(opts, attributes) {
      var inthtml = "<div>名称：" + attributes.name + "</div>" + "<div>地址：" + attributes.address + "</div>" + "<div>区域：" + attributes.pname + attributes.cityname + attributes.adname + "</div>" + "<div>类别：" + attributes.type + "</div>";

      var arrjwd = attributes.location.split(",");
      arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
      var lnglat = this.viewer.das.point2map({ x: arrjwd[0], y: arrjwd[1] });

      var entityOptions = {
        name: attributes.name,
        position: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, this.options.height || 3),
        popup: {
          html: inthtml,
          anchor: [0, -15]
        },
        properties: attributes
      };

      var symbol = this.options.symbol;
      if (symbol) {
        var styleOpt = symbol.styleOptions;
        if (symbol.styleField) {
          //存在多个symbol，按styleField进行分类
          var styleFieldVal = attributes[symbol.styleField];
          var styleOptField = symbol.styleFieldOptions[styleFieldVal];
          if (styleOptField != null) {
            // styleOpt = clone(styleOpt);
            styleOpt = _extends({}, styleOpt, styleOptField);
          }
        }
        styleOpt = styleOpt || {};

        if (styleOpt.image) {
          entityOptions.billboard = (0, _Attr2.style2Entity)(styleOpt);
          entityOptions.billboard.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
        } else {
          entityOptions.point = (0, _Attr.style2Entity)(styleOpt);
        }

        //加上文字标签
        if (styleOpt.label) {
          entityOptions.label = (0, _Attr3.style2Entity)(styleOpt.label);
          entityOptions.label.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
          entityOptions.label.text = attributes.name;
        }
      } else {
        //无配置时的默认值
        entityOptions.point = {
          color: Cesium.Color.fromCssColorString("#3388ff"),
          pixelSize: 10,
          outlineColor: Cesium.Color.fromCssColorString("#ffffff"),
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          scaleByDistance: new Cesium.NearFarScalar(1000, 1, 20000, 0.5)
        };
        entityOptions.label = {
          text: attributes.name,
          font: "normal small-caps normal 16px 楷体",
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          fillColor: Cesium.Color.AZURE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -15), //偏移量
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, //是地形上方的高度
          scaleByDistance: new Cesium.NearFarScalar(1000, 1, 5000, 0.8),
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 5000)
        };
      }

      var entity = this.dataSource.entities.add(entityOptions);
      return entity;
    }
  }]);

  return POILayer;
}(_CustomFeatureGridLayer.CustomFeatureGridLayer);

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(106)
var ieee754 = __webpack_require__(107)
var isArray = __webpack_require__(108)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(58)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 108 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WFSLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _CustomFeatureGridLayer = __webpack_require__(44);

var _util = __webpack_require__(3);

var _zepto = __webpack_require__(7);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WFSLayer = exports.WFSLayer = function (_CustomFeatureGridLay) {
  _inherits(WFSLayer, _CustomFeatureGridLay);

  function WFSLayer() {
    _classCallCheck(this, WFSLayer);

    return _possibleConstructorReturn(this, (WFSLayer.__proto__ || Object.getPrototypeOf(WFSLayer)).apply(this, arguments));
  }

  _createClass(WFSLayer, [{
    key: "getDataForGrid",

    //获取网格内的数据，callback为回调方法，参数传数据数组
    value: function getDataForGrid(opts, callback) {
      var that = this;

      //请求的wfs参数
      var parameters = {
        service: "WFS",
        request: "GetFeature",
        typeName: this.options.layer || this.options.typeName,
        version: "1.0.0",
        outputFormat: "application/json",
        bbox: opts.rectangle.xmin + "," + opts.rectangle.ymin + "," + opts.rectangle.xmax + "," + opts.rectangle.ymax
      };

      //其他可选参数
      if (Cesium.defined(this.options.parameters)) {
        for (var key in this.options.parameters) {
          parameters[key] = this.options.parameters[key];
        }
      }

      _zepto.zepto.ajax({
        url: this.options.url,
        type: "get",
        data: parameters,
        success: function success(featureCollection) {
          if (!that._visible || !that._cacheGrid[opts.key]) {
            return; //异步请求结束时,如果已经卸载了网格就直接跳出。
          }

          if (featureCollection == undefined || featureCollection == null) {
            return; //数据为空
          }

          if (featureCollection.type == "Feature") featureCollection = { type: "FeatureCollection", features: [featureCollection] };

          callback(featureCollection.features);
        },
        error: function error(data) {
          daslog.warn("wfs请求出错", data);
        }
      });
    }
    //根据数据创造entity

  }, {
    key: "createEntity",
    value: function createEntity(opts, item, callback) {
      if (this.options.dth && this.options.dth.buffer > 0) {
        //是建筑物单体化时,缓冲扩大点范围
        item = (0, _util.buffer)(item, this.options.dth.buffer);
      }

      var that = this;
      var dataSource = Cesium.GeoJsonDataSource.load(item, this.options);
      dataSource.then(function (dataSource) {
        if (that.checkHasBreak[opts.key]) {
          return; //异步请求结束时，如果已经卸载了网格就直接跳出。
        }

        if (dataSource.entities.values.length == 0) return null;
        var entity = dataSource.entities.values[0];
        entity.entityCollection.remove(entity); //从原有的集合中删除

        entity._id = that.options.id + "_" + opts.key + "_" + entity.id;

        that._addEntity(entity, callback);
      }).otherwise(function (error) {
        that.showError("服务出错", error);
      });

      return null;
    }
    //更新entity，并添加到地图上

  }, {
    key: "_addEntity",
    value: function _addEntity(entity, callback) {
      // this.dataSource.entities.removeById(entity._id);
      // if (this.dataSource.entities.contains(entity))return
      if (this.dataSource.entities.getById(entity._id)) return;

      this.dataSource.entities.add(entity); //加入到当前图层集合图层中

      //根据config配置，更新entitys
      this.config2Entity(entity);

      callback(entity);
    }
  }]);

  return WFSLayer;
}(_CustomFeatureGridLayer.CustomFeatureGridLayer);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterLayer = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _BaseLayer2 = __webpack_require__(14);

var _zepto = __webpack_require__(7);

var _Attr = __webpack_require__(21);

var _water = __webpack_require__(59);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WaterLayer = exports.WaterLayer = function (_BaseLayer) {
  _inherits(WaterLayer, _BaseLayer);

  function WaterLayer() {
    _classCallCheck(this, WaterLayer);

    return _possibleConstructorReturn(this, (WaterLayer.__proto__ || Object.getPrototypeOf(WaterLayer)).apply(this, arguments));
  }

  _createClass(WaterLayer, [{
    key: "create",
    value: function create() {}
    //添加

  }, {
    key: "add",
    value: function add() {
      this.primitives = new Cesium.PrimitiveCollection();
      this.viewer.scene.primitives.add(this.primitives);

      if (this.arrData) {
        this.createWater();
      } else {
        this.queryData();
      }
      _get(WaterLayer.prototype.__proto__ || Object.getPrototypeOf(WaterLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this.viewer.scene.primitives.remove(this.primitives);
      _get(WaterLayer.prototype.__proto__ || Object.getPrototypeOf(WaterLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else {
        if (this.rectangle) this.viewer.das.centerAt(this.rectangle, { duration: duration });
      }
    }
  }, {
    key: "clearData",
    value: function clearData() {
      if (this.primitives) this.primitives.removeAll();
      this.arrData = null;
    }
  }, {
    key: "setData",
    value: function setData(geojson) {
      //兼容不同命名
      this.clearData();
      return this.queryData(geojson);
    }
  }, {
    key: "queryData",
    value: function queryData(geojson) {
      var that = this;

      var config = (0, _util.getProxyUrl)(this.options);
      geojson = geojson || config.url || config.data;
      if (!geojson) return; //没有需要加载的对象

      if (config.url) {
        _zepto.zepto.ajax({
          type: "get",
          dataType: "json",
          url: config.url,
          timeout: Cesium.defaultValue(config.timeout, 0), //永不超时
          success: function success(geojson) {
            var dataSource = Cesium.GeoJsonDataSource.load(geojson);
            dataSource.then(function (dataSource) {
              var entities = dataSource.entities.values;
              that.showResult(entities);
            }).otherwise(function (error) {
              that.showError("服务出错", error);
            });
          },
          error: function error(XMLHttpRequest, textStatus, errorThrown) {
            daslog.warn("json文件加载失败！", config);
          }
        });
      } else {
        var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
        dataSource.then(function (dataSource) {
          var entities = dataSource.entities.values;
          that.showResult(entities);
        }).otherwise(function (error) {
          that.showError("服务出错", error);
        });
      }
    }
  }, {
    key: "showResult",
    value: function showResult(entities) {
      var positionsALL = [];
      var arrData = [];

      for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];

        var positions = (0, _Attr.getPositions)(entity);
        positionsALL = positionsALL.concat(positions);

        positions = (0, _point.setPositionsHeight)(positions, 0);

        var watercfg = this.getWaterCfg(entity);
        var height = Cesium.defaultValue(watercfg.height, 0);

        arrData.push({
          positions: positions,
          height: height,
          config: watercfg
        });
      }

      this.rectangle = (0, _point.getRectangle)(positionsALL, true);

      this.arrData = arrData;
      this.createWater();

      this.fireMap(_DasClass.eventType.load, {
        primitives: this.primitives,
        data: arrData
      });
    }
  }, {
    key: "createWater",
    value: function createWater() {
      if (!this._visible) return;

      for (var i = 0; i < this.arrData.length; i++) {
        var item = this.arrData[i];

        // 水效果
        var polygon = new Cesium.PolygonGeometry({
          height: item.height, //水面高度
          extrudedHeight: item.height, //底部高
          polygonHierarchy: new Cesium.PolygonHierarchy(item.positions)
        });
        var primitive = (0, _water.createWaterPrimitive)(polygon, item.config);
        primitive.height_bak = item.height;
        this.primitives.add(primitive);
      }

      if (this.options.flyTo) this.centerAtByFlyEnd();
    }
  }, {
    key: "getWaterCfg",
    value: function getWaterCfg(entity) {
      var attr = (0, _util.getAttrVal)(entity.properties);

      var symbol = this.options.symbol;
      var styleOpt = symbol.styleOptions;

      if (symbol.styleField) {
        //存在多个symbol，按styleField进行分类
        var styleFieldVal = attr[symbol.styleField];
        var styleOptField = symbol.styleFieldOptions[styleFieldVal];
        if (styleOptField != null) {
          styleOpt = (0, _util.clone)(styleOpt);
          styleOpt = _extends({}, styleOpt, styleOptField);
        }
      }

      if (typeof symbol.callback === "function") {
        //只是动态返回symbol的自定义的回调方法，返回style
        var _styleOptField = symbol.callback(attr, entity, symbol);
        if (_styleOptField != null) {
          styleOpt = (0, _util.clone)(styleOpt);
          styleOpt = _extends({}, styleOpt, _styleOptField);
        }
      }
      styleOpt = styleOpt || {};

      return styleOpt;
    }

    //更新 闸门内 水域

  }, {
    key: "updateHeight",
    value: function updateHeight(height) {
      var eRadis = 6378137;
      for (var i = 0; i < this.primitives.length; i++) {
        var primitive = this.primitives.get(i);

        var n = (eRadis + height) / (eRadis + primitive.height_bak);
        var modelMatrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(n, n, n));
        primitive.modelMatrix = modelMatrix;
      }
    }
  }, {
    key: "layer",
    get: function get() {
      return this.primitives;
    }
  }]);

  return WaterLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GltfLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _BaseLayer2 = __webpack_require__(14);

var _Attr = __webpack_require__(36);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GltfLayer = exports.GltfLayer = function (_BaseLayer) {
  _inherits(GltfLayer, _BaseLayer);

  //========== 构造方法 ==========
  function GltfLayer(viewer, options) {
    _classCallCheck(this, GltfLayer);

    var _this = _possibleConstructorReturn(this, (GltfLayer.__proto__ || Object.getPrototypeOf(GltfLayer)).call(this, viewer, options));

    _this.hasOpacity = true;
    return _this;
  }

  _createClass(GltfLayer, [{
    key: "add",

    //添加
    value: function add() {
      if (this.entity) {
        this.viewer.entities.add(this.entity);
      } else {
        this.initData();
      }
      _get(GltfLayer.prototype.__proto__ || Object.getPrototypeOf(GltfLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this.viewer.entities.remove(this.entity);
      _get(GltfLayer.prototype.__proto__ || Object.getPrototypeOf(GltfLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.entity == null) return;

      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else {
        var cfg = this.options.position;
        this.viewer.das.centerPoint(cfg, { duration: duration, isWgs84: true });
      }
    }
  }, {
    key: "initData",
    value: function initData() {
      var _this2 = this;

      //位置信息
      var cfg = this.options.position;
      cfg = this.viewer.das.point2map(cfg); //转换坐标系
      var position = Cesium.Cartesian3.fromDegrees(cfg.x, cfg.y, cfg.z || 0);

      //样式信息
      var style = this.options.style || {};
      if (Cesium.defined(this._opacity) && this._opacity != 1) style.opacity = this._opacity;

      //方向
      var heading = Cesium.Math.toRadians(style.heading || cfg.heading || 0);
      var pitch = Cesium.Math.toRadians(style.pitch || cfg.pitch || 0);
      var roll = Cesium.Math.toRadians(style.roll || cfg.roll || 0);
      var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
      var converter = this.options.converter || Cesium.Transforms.eastNorthUpToFixedFrame;
      var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr, this.viewer.scene.globe.ellipsoid, converter);

      var modelattr = (0, _Attr.style2Entity)(style);
      modelattr.uri = this.options.url;

      this.entity = this.viewer.entities.add(new Cesium.Entity({
        name: this.options.name,
        position: position,
        orientation: orientation,
        model: modelattr
      }));
      //das3d扩展的属性
      this.entity._config = this.options;
      this.entity.eventTarget = this;

      //readyPromise为修改cesium内部源码来实现的回调
      this.entity.readyPromise = function (entity, model) {
        _this2.fireMap(_DasClass.eventType.load, { entity: entity, model: model });
      };

      var config = this.options;
      if (this.options.popup) {
        this.entity.popup = {
          html: function html(entity) {
            var attr = entity.properties || entity.data || {};

            if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)(config, attr);
          },
          anchor: config.popupAnchor || [0, -15]
        };
      }
      if (this.options.tooltip) {
        this.entity.tooltip = {
          html: function html(entity) {
            var attr = entity.properties || entity.data || {};

            if ((0, _util.isString)(attr)) return attr;else return (0, _util.getPopupForConfig)({ popup: config.tooltip }, attr);
          },
          anchor: config.tooltipAnchor || [0, -15]
        };
      }

      if (this.options.flyTo) this.centerAtByFlyEnd();

      this.fireMap(_DasClass.eventType.loadBefore, { entity: this.entity });
    }
    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      if (this.entity == null) return;
      this.entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(value);
    }
  }, {
    key: "layer",
    get: function get() {
      return this.entity;
    }
  }, {
    key: "model",
    get: function get() {
      return this.entity;
    }
  }]);

  return GltfLayer;
}(_BaseLayer2.BaseLayer);

//[静态属性]本类中支持的事件类型常量


GltfLayer.event = {
  load: _DasClass.eventType.load,
  loadBefore: _DasClass.eventType.loadBefore,
  click: _DasClass.eventType.click,
  mouseOver: _DasClass.eventType.mouseOver,
  mouseOut: _DasClass.eventType.mouseOut
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tiles3dLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _BaseLayer2 = __webpack_require__(14);

var _util = __webpack_require__(3);

var _point = __webpack_require__(2);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tiles3dLayer = exports.Tiles3dLayer = function (_BaseLayer) {
  _inherits(Tiles3dLayer, _BaseLayer);

  //========== 构造方法 ==========
  function Tiles3dLayer(viewer, options) {
    _classCallCheck(this, Tiles3dLayer);

    var _this = _possibleConstructorReturn(this, (Tiles3dLayer.__proto__ || Object.getPrototypeOf(Tiles3dLayer)).call(this, viewer, options));

    _this.hasOpacity = true;

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (options.readyPromise) {
      var readyPromisefun = options.readyPromise;
      delete options.readyPromise;
      _this.on(_DasClass.eventType.loadBefore, function (event) {
        readyPromisefun(event.tileset);
      });
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
    return _this;
  }

  _createClass(Tiles3dLayer, [{
    key: "add",

    //添加
    value: function add() {
      if (this.tileset) {
        if (!this.viewer.scene.primitives.contains(this.tileset)) this.viewer.scene.primitives.add(this.tileset);
      } else {
        this.initData();
      }
      _get(Tiles3dLayer.prototype.__proto__ || Object.getPrototypeOf(Tiles3dLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      if (Cesium.defined(this.options.visibleDistanceMax)) this.viewer.scene.camera.changed.removeEventListener(this.updateVisibleDistance, this);

      //解除绑定的事件
      if (this.tileset) {
        this.tileset.initialTilesLoaded.removeEventListener(this.onInitialTilesLoaded, this);
        this.tileset.allTilesLoaded.removeEventListener(this.onAllTilesLoaded, this);

        if (this.viewer.scene.primitives.contains(this.tileset)) this.viewer.scene.primitives.remove(this.tileset);

        delete this.tileset;
      }
      if (this.boundingSphere) delete this.boundingSphere;
      _get(Tiles3dLayer.prototype.__proto__ || Object.getPrototypeOf(Tiles3dLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else if (this.boundingSphere && !isNaN(this.boundingSphere.radius)) {
        this.viewer.camera.flyToBoundingSphere(this.boundingSphere, {
          offset: new Cesium.HeadingPitchRange(this.viewer.camera.heading, this.viewer.camera.pitch, this.boundingSphere.radius * 2),
          duration: duration
        });
      } else if (this.tileset._loadOk) {
        this.viewer.das.centerPoint(this.tileset.das.position, {
          duration: duration
        });
      }
    }

    /**
     * 创建顶点着色器代码
     * @param modelSwings
     * @returns {string}
     * @private
     */

  }, {
    key: "_createVS",
    value: function _createVS() {
      var vs = "\n            uniform mat4 dasModelSwing;\n\n        ";

      var vsmain = "\n            float swing_speed;   //\u9707\u52A8\u9891\u7387\n            float swing_angle;   //\u632F\u5E45\n            float swing_height;\n            float swing_isSwing;   //\u662F\u5426\u5F00\u59CB\u6447\n            \n            for (int i = 0; i < 4; i++) {\n                swing_height = dasModelSwing[i][0];\n                swing_angle =  dasModelSwing[i][1];\n                swing_speed =  dasModelSwing[i][2];\n                swing_isSwing =  dasModelSwing[i][3];\n    \n                swing_angle =( swing_angle/ 8.0);           // \u632F\u5E45\n                \n                if(v_stcVertex.z > swing_height && swing_isSwing == 1.0){\n                    float index = (czm_frameNumber / swing_speed);    // \u63A7\u5236\u9891\u7387\n                    float positionx= ( sin(index) * (v_stcVertex.z * 0.13) * swing_angle);\n                    gl_Position.x +=positionx;\n                }    \n            }\n        ";
      return {
        vs: vs,
        vsmain: vsmain
      };
    }
  }, {
    key: "initData",
    value: function initData() {
      var _this2 = this;

      // 构造vs
      if (this.options && this.options.vs) {
        this.options.dasVS = this._createVS(this.options.vs);
      }

      this.tileset = this.viewer.scene.primitives.add(new Cesium.Cesium3DTileset((0, _util.getProxyUrl)(this.options)));
      this.tileset.das = this.options; //Cesium3DTilesetEx
      this.tileset.eventTarget = this;

      //兼容历史版本
      this.tileset._config = this.options;
      // for (var key in this.options) {
      //   if (key == "url" || key == "type" || key == "style" || key == "classificationType") continue;
      //   try {
      //     this.tileset[key] = this.options[key];
      //   } catch (e) {
      //     //
      //   }
      // }

      //绑定一些事件
      this.tileset.initialTilesLoaded.addEventListener(this.onInitialTilesLoaded, this);
      this.tileset.allTilesLoaded.addEventListener(this.onAllTilesLoaded, this);

      if (this.tileset._loadOk) {
        this._initModel(this.tileset);
      } else {
        this.tileset.das.on(_DasClass.eventType.load, function (e) {
          _this2._initModel(e.sourceTarget);
        });
      }
    }
  }, {
    key: "_initModel",
    value: function _initModel(tileset) {
      this.fireMap(_DasClass.eventType.loadBefore, { tileset: tileset });

      //记录模型原始的中心点
      this.boundingSphere = tileset.boundingSphere;
      this.orginMatrixInverse = tileset.das.orginMatrix;
      this.originalCenter = tileset.das.orginCenter;

      //高度自动贴地处理
      if (this.options.offset && (this.options.offset.z == "auto" || this.options.offset.z == "-height")) {
        tileset.das.clampToGround(this.viewer);
      }

      //转换坐标进行加偏处理，如果是国测局坐标系时
      var rawCenter = this.viewer.das.point2map(tileset.das.orginCenter);
      if (rawCenter !== tileset.das.orginCenter) {
        delete rawCenter.z;
        tileset.das.offset = rawCenter;
      }

      //透明度
      if (this.hasOpacity && this._opacity != 1) {
        this.setOpacity(this._opacity);
      }
      //设置最大视距后自动隐藏（不建议，效率一般）
      if (Cesium.defined(this.options.visibleDistanceMax)) this.bindVisibleDistance();

      if (this.options.flyTo) this.centerAtByFlyEnd();

      this.fireMap(_DasClass.eventType.load, { tileset: tileset });
    }
    //刷新事件

  }, {
    key: "refreshEvent",
    value: function refreshEvent() {
      if (this.tileset == null) return false;

      this.tileset.eventTarget = this;
      this.tileset.contextmenuItems = this.options.contextmenuItems;
      return true;
    }
    //该回调只执行一次

  }, {
    key: "onInitialTilesLoaded",
    value: function onInitialTilesLoaded(e) {
      this.fireMap(_DasClass.eventType.initialTilesLoaded, { tile: e });
    }
    //该回调会执行多次，视角变化后重新加载一次完成后都会回调

  }, {
    key: "onAllTilesLoaded",
    value: function onAllTilesLoaded(e) {
      this.fireMap(_DasClass.eventType.allTilesLoaded, { tile: e });
    }

    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;

      if (this.options.onSetOpacity) {
        this.options.onSetOpacity(value); //外部自定义处理
      } else {
        if (this.tileset) {
          this.tileset.das.opacity = value;
        }
      }
    }
  }, {
    key: "showClickFeature",
    value: function showClickFeature(value) {
      this.tileset.das.options.showClickFeature = value;
    }

    //绑定  设置最大视距后自动隐藏（不建议，效率一般）

  }, {
    key: "bindVisibleDistance",
    value: function bindVisibleDistance() {
      this.viewer.scene.camera.changed.addEventListener(this.updateVisibleDistance, this);
    }
  }, {
    key: "updateVisibleDistance",
    value: function updateVisibleDistance() {
      if (!this._visible) return;
      if (this.viewer.scene.mode !== Cesium.SceneMode.SCENE3D) return;
      if (!this.tileset || !this.tileset._loadOk) return;

      var camera_distance = Cesium.Cartesian3.distance(this.tileset.das.position, this.viewer.camera.positionWC);
      if (camera_distance > this.options.visibleDistanceMax + 100000) {
        //在模型的外包围外
        this.tileset.show = false;
      } else {
        var target = (0, _point.pickCenterPoint)(this.viewer.scene); //取屏幕中心点坐标
        if (Cesium.defined(target)) {
          var distance = Cesium.Cartesian3.distance(target, this.viewer.camera.positionWC);
          this.tileset.show = distance < this.options.visibleDistanceMax;
        } else {
          this.tileset.show = true;
        }
      }
    }
  }, {
    key: "layer",
    get: function get() {
      return this.tileset;
    }
  }, {
    key: "model",
    get: function get() {
      return this.tileset;
    }
  }]);

  return Tiles3dLayer;
}(_BaseLayer2.BaseLayer);

//[静态属性]本类中支持的事件类型常量


Tiles3dLayer.event = {
  load: _DasClass.eventType.load,
  loadBefore: _DasClass.eventType.loadBefore,
  initialTilesLoaded: _DasClass.eventType.initialTilesLoaded,
  allTilesLoaded: _DasClass.eventType.allTilesLoaded,
  click: _DasClass.eventType.click,
  mouseOver: _DasClass.eventType.mouseOver,
  mouseOut: _DasClass.eventType.mouseOut
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KmlLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _GeoJsonLayer2 = __webpack_require__(45);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KmlLayer = exports.KmlLayer = function (_GeoJsonLayer) {
  _inherits(KmlLayer, _GeoJsonLayer);

  function KmlLayer() {
    _classCallCheck(this, KmlLayer);

    return _possibleConstructorReturn(this, (KmlLayer.__proto__ || Object.getPrototypeOf(KmlLayer)).apply(this, arguments));
  }

  _createClass(KmlLayer, [{
    key: "queryData",
    value: function queryData() {
      var that = this;

      var config = (0, _util.getProxyUrl)(this.options);

      if (config.symbol && config.symbol.styleOptions) {
        var style = config.symbol.styleOptions;
        if (Cesium.defined(style.clampToGround)) {
          config.clampToGround = style.clampToGround;
        }
      }

      var dataSource = Cesium.KmlDataSource.load(config.url, {
        camera: this.viewer.scene.camera,
        canvas: this.viewer.scene.canvas,
        clampToGround: config.clampToGround
      });
      dataSource.then(function (dataSource) {
        that.showResult(dataSource);
      }).otherwise(function (error) {
        that.showError("服务出错", error);
      });
    }
  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      var attr = { name: entity.name, description: entity.description };
      var extendedData = entity._kml.extendedData;
      for (var key in extendedData) {
        attr[key] = extendedData[key].value;
      }
      attr = (0, _util.getAttrVal)(attr);

      if (attr.description) {
        attr.description = attr.description.replace(/<div[^>]+>/g, ""); //剔除div html标签
      }

      return attr;
    }
  }]);

  return KmlLayer;
}(_GeoJsonLayer2.GeoJsonLayer);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CzmlLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _GeoJsonLayer2 = __webpack_require__(45);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CzmlLayer = exports.CzmlLayer = function (_GeoJsonLayer) {
  _inherits(CzmlLayer, _GeoJsonLayer);

  function CzmlLayer() {
    _classCallCheck(this, CzmlLayer);

    return _possibleConstructorReturn(this, (CzmlLayer.__proto__ || Object.getPrototypeOf(CzmlLayer)).apply(this, arguments));
  }

  _createClass(CzmlLayer, [{
    key: "queryData",
    value: function queryData() {
      var that = this;

      var config = (0, _util.getProxyUrl)(this.options);

      var dataSource = Cesium.CzmlDataSource.load(config.url, config);
      dataSource.then(function (dataSource) {
        that.showResult(dataSource);
      }).otherwise(function (error) {
        that.showError("服务出错", error);
      });
    }
  }, {
    key: "getEntityAttr",
    value: function getEntityAttr(entity) {
      if (entity.description && entity.description.getValue) return entity.description.getValue(this.viewer.clock.currentTime);
    }
  }]);

  return CzmlLayer;
}(_GeoJsonLayer2.GeoJsonLayer);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TerrainLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _BaseLayer2 = __webpack_require__(14);

var _layer = __webpack_require__(24);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TerrainLayer = exports.TerrainLayer = function (_BaseLayer) {
  _inherits(TerrainLayer, _BaseLayer);

  function TerrainLayer() {
    _classCallCheck(this, TerrainLayer);

    return _possibleConstructorReturn(this, (TerrainLayer.__proto__ || Object.getPrototypeOf(TerrainLayer)).apply(this, arguments));
  }

  _createClass(TerrainLayer, [{
    key: "add",

    //添加
    value: function add() {
      if (!this.terrain) {
        this.terrain = (0, _layer.getTerrainProvider)(this.options.terrain || this.options);
        this.fireMap(_DasClass.eventType.load, { terrain: this.terrain });
      }
      this.viewer.terrainProvider = this.terrain;
      _get(TerrainLayer.prototype.__proto__ || Object.getPrototypeOf(TerrainLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this.viewer.terrainProvider = (0, _layer.getEllipsoidTerrain)();
      _get(TerrainLayer.prototype.__proto__ || Object.getPrototypeOf(TerrainLayer.prototype), "remove", this).call(this);
    }
  }, {
    key: "layer",
    get: function get() {
      return this.terrain;
    }
  }]);

  return TerrainLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _BaseLayer2 = __webpack_require__(14);

var _Draw = __webpack_require__(6);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawLayer = exports.DrawLayer = function (_BaseLayer) {
  _inherits(DrawLayer, _BaseLayer);

  function DrawLayer() {
    _classCallCheck(this, DrawLayer);

    return _possibleConstructorReturn(this, (DrawLayer.__proto__ || Object.getPrototypeOf(DrawLayer)).apply(this, arguments));
  }

  _createClass(DrawLayer, [{
    key: "create",
    value: function create() {
      this.drawControl = new _Draw.Draw(this.viewer, {
        hasEdit: false,
        nameTooltip: false,
        removeScreenSpaceEvent: false
      });
    }
    //添加

  }, {
    key: "add",
    value: function add() {
      if (this._isload) this.drawControl.setVisible(true);else this._loadData();
      _get(DrawLayer.prototype.__proto__ || Object.getPrototypeOf(DrawLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      this.drawControl.setVisible(false);
      _get(DrawLayer.prototype.__proto__ || Object.getPrototypeOf(DrawLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      var arr = this.drawControl.getEntitys();
      this.viewer.das.flyTo(arr, { duration: duration });
    }
  }, {
    key: "_loadData",
    value: function _loadData() {
      var that = this;
      _zepto.zepto.ajax({
        type: "get",
        dataType: "json",
        url: this.options.url,
        timeout: 10000,
        success: function success(data) {
          that._isload = true;
          var arr = that.drawControl.jsonToEntity(data, true, that.options.flyTo);
          that._bindEntityConfig(arr);

          that.fireMap(_DasClass.eventType.load, {
            draw: that.drawControl,
            entities: arr
          });

          if (that.options.flyTo) that.centerAtByFlyEnd();
        },
        error: function error(XMLHttpRequest, textStatus, errorThrown) {
          daslog.warn("json文件加载失败！", that.options);
        }
      });
    }
  }, {
    key: "_bindEntityConfig",
    value: function _bindEntityConfig(arrEntity) {
      var that = this;

      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];

        //popup弹窗
        if (this.options.columns || this.options.popup) {
          entity.popup = (0, _util.bindLayerPopup)(this.options.popup, function (inhtml, entity) {
            var attr = entity.attribute.attr;
            attr.layer_name = that.options.name;
            attr.draw_type = entity.attribute.type;
            attr.draw_typename = entity.attribute.name;
            return (0, _util.getPopupForConfig)({
              name: that.options.name,
              popup: inhtml,
              popupNameField: that.options.popupNameField
            }, attr);
          });
        }
        if (this.options.tooltip) {
          entity.tooltip = (0, _util.bindLayerPopup)(this.options.tooltip, function (inhtml, entity) {
            var attr = entity.attribute.attr;
            attr.layer_name = that.options.name;
            attr.draw_type = entity.attribute.type;
            attr.draw_typename = entity.attribute.name;
            return (0, _util.getTooltipForConfig)({
              name: that.options.name,
              tooltip: inhtml,
              tooltipNameField: that.options.tooltipNameField
            }, attr);
          });
        }
        entity.eventTarget = this;

        if (this.options.contextmenuItems) {
          entity.contextmenuItems = this.options.contextmenuItems;
        }
      }
    }

    //刷新事件

  }, {
    key: "refreshEvent",
    value: function refreshEvent() {
      var arrEntity = this.drawControl.getEntitys();
      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];

        entity.eventTarget = this;
        entity.contextmenuItems = this.options.contextmenuItems;
      }
      return true;
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(style) {
      var arrEntity = this.drawControl.getEntitys();
      for (var i = 0, len = arrEntity.length; i < len; i++) {
        var entity = arrEntity[i];
        this.drawControl.updateStyle(style, entity);
      }
      return arrEntity;
    }
  }, {
    key: "layer",
    get: function get() {
      if (this.drawControl) return this.drawControl.dataSource;else return null;
    }
  }]);

  return DrawLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawLabel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(25);

var _Attr = __webpack_require__(13);

var attr = _interopRequireWildcard(_Attr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawLabel = exports.DrawLabel = function (_DrawPoint) {
  _inherits(DrawLabel, _DrawPoint);

  //========== 构造方法 ==========
  function DrawLabel(opts) {
    _classCallCheck(this, DrawLabel);

    var _this = _possibleConstructorReturn(this, (DrawLabel.__proto__ || Object.getPrototypeOf(DrawLabel)).call(this, opts));

    _this.type = "label";
    _this.attrClass = attr; //对应的属性控制静态类
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawLabel, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = null;

      //绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      var _drawShow = Cesium.defaultValue(attribute.drawShow, false);

      var that = this;
      var addattr = {
        show: _drawShow,
        _drawShow: _drawShow, //edit编辑时使用
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        label: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.label);
    }
  }]);

  return DrawLabel;
}(_Draw.DrawPoint);

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawModel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _point = __webpack_require__(2);

var _Draw = __webpack_require__(25);

var _Attr = __webpack_require__(36);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(13);

var _Edit = __webpack_require__(119);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawModel = exports.DrawModel = function (_DrawPoint) {
  _inherits(DrawModel, _DrawPoint);

  //========== 构造方法 ==========
  function DrawModel(opts) {
    _classCallCheck(this, DrawModel);

    var _this = _possibleConstructorReturn(this, (DrawModel.__proto__ || Object.getPrototypeOf(DrawModel)).call(this, opts));

    _this.type = "model";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditModel; //获取编辑对象
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawModel, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      var _this2 = this;

      dataSource = dataSource || this.dataSource;
      this._positions_draw = null;

      //绘制时，是否自动隐藏模型，可避免拾取坐标存在问题。
      var _drawShow = Cesium.defaultValue(attribute.drawShow, false);
      attribute.style.radius = Cesium.defaultValue(attribute.style.radius, 100); //默认值
      attribute.editType = Cesium.defaultValue(attribute.editType, "point"); //默认值

      var that = this;
      var addattr = {
        show: true, //_drawShow
        _drawShow: _drawShow, //edit编辑时使用
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        model: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      if (attribute.style && attribute.style.label) {
        //同时加文字
        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
      }

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.entity.loadOk = false;
      this.entity.draw_tooltip = "加载模型中…";
      this.entity.readyPromise = function (entity, model) {
        delete _this2.entity.draw_tooltip;

        entity.loadOk = true;
        entity.attribute.style.radius = model.boundingSphere.radius;

        _this2.fire(_DasClass.eventType.load, { drawtype: _this2.type, entity: entity, model: model });
      };

      //10s超时容错处理
      // setTimeout(() => {
      //     if (!this.entity || this.entity.loadOk) return
      //     this.entity.loadOk = true
      // }, 10000);

      return this.entity;
    }
    //判断gltf是否加载完成

  }, {
    key: "isLoadOk",
    value: function isLoadOk() {
      return this.entity.loadOk;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      this.updateOrientation(style, entity);
      if (style && style.label) {
        //同时加文字
        (0, _Attr2.style2Entity)(style.label, entity.label);
      }
      return attr.style2Entity(style, entity.model);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      this.updateOrientation(this.entity.attribute.style, this.entity);
    }
    //角度更新

  }, {
    key: "updateOrientation",
    value: function updateOrientation(style, entity) {
      var position = (0, _point.getPositionValue)(entity.position);
      if (position == null) return;

      var heading = Cesium.Math.toRadians(Number(style.heading || 0.0));
      var pitch = Cesium.Math.toRadians(Number(style.pitch || 0.0));
      var roll = Cesium.Math.toRadians(Number(style.roll || 0.0));

      var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
      entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
    }
  }]);

  return DrawModel;
}(_Draw.DrawPoint);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditModel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Attr = __webpack_require__(42);

var circleAttr = _interopRequireWildcard(_Attr);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(26);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(16);

var _measure = __webpack_require__(18);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditModel = exports.EditModel = function (_EditBase) {
  _inherits(EditModel, _EditBase);

  function EditModel() {
    _classCallCheck(this, EditModel);

    return _possibleConstructorReturn(this, (EditModel.__proto__ || Object.getPrototypeOf(EditModel)).apply(this, arguments));
  }

  _createClass(EditModel, [{
    key: "setPositions",

    //外部更新位置
    value: function setPositions(position) {
      if (util.isArray(position) && position.length == 1) {
        position = position[0];
      }
      this.entity.position.setValue(position);
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var _this2 = this;

      var that = this;

      this.entity.draw_tooltip = _Tooltip.message.dragger.def;
      draggerCtl.createDragger(this.entityCollection, {
        dragger: this.entity,
        onDragStart: function onDragStart(dragger, newPosition) {
          if (_this2.axisModel) {
            _this2.axisModel.show = false;
          }
        },
        onDrag: function onDrag(dragger, newPosition) {
          that.entity.position.setValue(newPosition);
        },
        onDragEnd: function onDragEnd(dragger, newPosition) {
          if (_this2.axisModel) {
            _this2.axisModel.show = true;
          }
          that.updateDraggers();
        }
      });

      var style = this.entity.attribute.style;

      var position = (0, _point.getPositionValue)(this.entity.position);
      var height = Cesium.Cartographic.fromCartesian(position).height;
      var radius = style.radius * style.scale;

      // 加载坐标轴模型
      if (this.entity.attribute.editType == "axis") {
        if (!this.axisModel) {
          var axisModel = this.viewer.scene.primitives.add(Cesium.Model.fromGltf({
            id: "axis",
            url: this.entity.attribute.axisUrl || "http://data.dasgis.cn/gltf/das/axis.gltf",
            modelMatrix: new Cesium.Matrix4(),
            colorBlendMode: Cesium.ColorBlendMode.HIGHLIGHT
          }));
          axisModel.readyPromise.then(function (axisModel) {
            axisModel.activeAnimations.addAll();
          });
          this.axisModel = axisModel;
        }
        this.axisModel.show = true;
        this.axisModel.modelMatrix = this.getModelMatrix(position);

        this.bindAxisEvent();
      } else if (this.entity.attribute.editType == "point") {
        //辅助显示：创建角度调整底部圆
        this.entityAngle = this.entityCollection.add({
          name: "角度调整底部圆",
          position: new Cesium.CallbackProperty(function (time) {
            return (0, _point.getPositionValue)(that.entity.position);
          }, false),
          ellipse: circleAttr.style2Entity({
            fill: false,
            outline: true,
            outlineColor: "#ffff00",
            outlineOpacity: 0.8,
            radius: radius,
            height: height
          })
        });

        //创建角度调整 拖拽点
        var majorPos = (0, _matrix.getPositionByDirectionAndLen)(position, -style.heading, radius);
        var majorDragger = draggerCtl.createDragger(this.entityCollection, {
          position: majorPos,
          type: draggerCtl.PointType.EditAttr,
          tooltip: _Tooltip.message.dragger.editHeading,
          onDrag: function onDrag(dragger, position) {
            var entityPosition = (0, _point.getPositionValue)(that.entity.position);
            var heading = (0, _measure.getAngle)(entityPosition, position);
            style.heading = that.formatNum(heading, 1);
            that.updateOrientation();

            dragger.position = (0, _matrix.getPositionByDirectionAndLen)(entityPosition, -heading, radius);
          }
        });
        this.draggers.push(majorDragger);

        //缩放控制点
        var position_scale = (0, _point.addPositionsHeight)(position, radius);
        var draggerScale = draggerCtl.createDragger(this.entityCollection, {
          position: position_scale,
          type: draggerCtl.PointType.MoveHeight,
          tooltip: _Tooltip.message.dragger.editScale,
          onDrag: function onDrag(dragger, positionNew) {
            var radiusNew = Cesium.Cartesian3.distance(positionNew, position);

            var radiusOld = dragger.radius / style.scale;
            var scaleNew = radiusNew / radiusOld;
            dragger.radius = radiusNew;

            style.scale = that.formatNum(scaleNew, 2);
            that.entity.model.scale = style.scale;

            that.updateDraggers();
          }
        });
        draggerScale.radius = radius;
        this.draggers.push(draggerScale);
      }
    }
  }, {
    key: "destroyDraggers",
    value: function destroyDraggers() {
      _get(EditModel.prototype.__proto__ || Object.getPrototypeOf(EditModel.prototype), "destroyDraggers", this).call(this);

      if (this.entityAngle) {
        this.entityCollection.remove(this.entityAngle);
        delete this.entityAngle;
      }

      if (this.axisModel) {
        this.axisModel.show = false;
        this.destroyAxisEvent();
      }
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(position) {
      var cfg = this.entity.attribute.style;

      position = position || (0, _point.getPositionValue)(this.entity.position);

      var hpRoll = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(cfg.heading || 0), Cesium.Math.toRadians(cfg.pitch || 0), Cesium.Math.toRadians(cfg.roll || 0));
      var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position, hpRoll);

      var style = this.entity.attribute.style;
      var scale = style.radius * style.scale / 1.5;

      Cesium.Matrix4.multiplyByUniformScale(modelMatrix, scale, modelMatrix);

      return modelMatrix;
    }
    //角度更新

  }, {
    key: "updateOrientation",
    value: function updateOrientation() {
      var style = this.entity.attribute.style;
      var position = (0, _point.getPositionValue)(this.entity.position);
      if (position == null) return;

      var heading = Cesium.Math.toRadians(Number(style.heading || 0.0));
      var pitch = Cesium.Math.toRadians(Number(style.pitch || 0.0));
      var roll = Cesium.Math.toRadians(Number(style.roll || 0.0));

      var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
      this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      if (this.axisModel) {
        this.viewer.scene.primitives.remove(this.axisModel);
        delete this.axisModel;
      }

      delete this.entity.draw_tooltip;
      delete this.entity._isDragger;
      delete this.entity._noMousePosition;
      delete this.entity._pointType;
      delete this.entity.onDrag;
    }

    //update Axis Matrix

  }, {
    key: "bindAxisEvent",
    value: function bindAxisEvent() {
      var that = this;
      // 判断当前是否点击在坐标轴上进行拖动和旋转
      var isAxis = false;
      var zhou = undefined; // 当前拖拽的是哪个轴

      var viewer = this.viewer;

      var downHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
      downHandler.setInputAction(function (event) {
        var pickedObject = viewer.scene.pick(event.position);
        if (Cesium.defined(pickedObject) && pickedObject.id === that.axisModel.id) {
          zhou = pickedObject.mesh.name;
          isAxis = true;
          //console.log('单击了:' + zhou);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      downHandler.setInputAction(function (event) {
        var startCartesian3 = viewer.scene.pickPosition(event.startPosition);
        var endCartesian3 = viewer.scene.pickPosition(event.endPosition);

        if (isAxis && startCartesian3 && endCartesian3) {
          that.cameraControl(false); // 禁止球转动和拖动

          switch (zhou) {
            // case 'XArrow_1':
            //     that.axisMove(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_X, 'x', 'z');
            //     break;
            // case 'YArrow_1':
            //     that.axisMove(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_Z, 'y', 'z');
            //     break;
            // case 'ZArrow_1':
            //     that.axisMove(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_Y, 'x', 'y');
            //     break;

            case "XAxis_1":
              that.axisRotate(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_Y, "z", "x");
              break;
            case "YAxis_1":
              that.axisRotate(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_X, "y", "z");
              break;
            case "ZAxis_1":
              that.axisRotate(startCartesian3, endCartesian3, Cesium.Cartesian3.UNIT_Z, "x", "y");
              break;
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      downHandler.setInputAction(function (event) {
        isAxis = false;
        that.cameraControl(true);
      }, Cesium.ScreenSpaceEventType.LEFT_UP);

      this.downHandler = downHandler;
    }
  }, {
    key: "destroyAxisEvent",
    value: function destroyAxisEvent() {
      if (this.downHandler) {
        this.downHandler.destroy();
        this.downHandler = null;
      }
    }
    //平移模型 处理
    // axisMove (startCartesian3, endCartesian3, surface, zeroAxis1, zeroAxis2) {

    //     var position = getPositionValue(this.entity.position);
    //     var modelMatrix = this.getModelMatrix(position) // this.model.modelMatrix;

    //     var point = this.axisTransForm(modelMatrix, startCartesian3, endCartesian3, surface);

    //     // 两点差值
    //     var sub = Cesium.Cartesian3.subtract(point.end, point.start, new Cesium.Cartesian3());
    //     sub[zeroAxis1] = 0;
    //     sub[zeroAxis2] = 0;

    //     var sub2 = Cesium.Matrix4.multiplyByPoint(modelMatrix, sub, new Cesium.Cartesian3());

    //     // 移动模型
    //     this.model.modelMatrix[12] = sub2.x;
    //     this.model.modelMatrix[13] = sub2.y;
    //     this.model.modelMatrix[14] = sub2.z;

    //     //更新 坐标轴模型
    //     this.updateAxisMatrix();
    // }
    //旋转模型 处理

  }, {
    key: "axisRotate",
    value: function axisRotate(startCartesian3, endCartesian3, surface, tant1, tant2) {
      var position = (0, _point.getPositionValue)(this.entity.position);
      var modelMatrix = this.getModelMatrix(position); // this.model.modelMatrix;
      var point = this.axisTransForm(modelMatrix, startCartesian3, endCartesian3, surface);

      // 两点角度
      var tant = (point.start[tant1] * point.end[tant2] - point.start[tant2] * point.end[tant1]) / (point.start[tant1] * point.end[tant1] + point.start[tant2] * point.end[tant2]);

      var quat = Cesium.Quaternion.fromAxisAngle(surface, Math.atan(tant)); //quat为围绕这个surface轴旋转d度的四元数
      var rot_mat3 = Cesium.Matrix3.fromQuaternion(quat);
      var m2 = Cesium.Matrix4.multiplyByMatrix3(modelMatrix, rot_mat3, new Cesium.Matrix4());

      var style = this.entity.attribute.style;

      var hpr = (0, _matrix.getHeadingPitchRollByMatrix)(m2);
      style.heading = this.formatNum(Cesium.Math.toDegrees(hpr.heading), 1);
      style.pitch = this.formatNum(Cesium.Math.toDegrees(hpr.pitch), 1);
      style.roll = this.formatNum(Cesium.Math.toDegrees(hpr.roll), 1);

      this.updateOrientation();

      //更新 坐标轴模型
      this.axisModel.modelMatrix = this.getModelMatrix(position);

      this.fire(_DasClass.eventType.editStyle, {
        edittype: this.entity.attribute.type,
        entity: this.entity,
        position: position
      });
    }

    // 旋转和平移函数得到射线和面交点(基础方法)

  }, {
    key: "axisTransForm",
    value: function axisTransForm(modelMatrix, startCartesian3, endCartesian3, surface) {
      var matrix = Cesium.Matrix4.inverseTransformation(modelMatrix, new Cesium.Matrix4());

      // 获取相机坐标
      var camera1 = this.viewer.camera.position;

      // 转 模型坐标
      var camera = Cesium.Matrix4.multiplyByPoint(matrix, camera1, new Cesium.Cartesian3());
      var startM = Cesium.Matrix4.multiplyByPoint(matrix, startCartesian3, new Cesium.Cartesian3());
      var endM = Cesium.Matrix4.multiplyByPoint(matrix, endCartesian3, new Cesium.Cartesian3());

      // 从相机看模型的方向
      var startDirection = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(startM, camera, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var endDirection = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(endM, camera, new Cesium.Cartesian3()), new Cesium.Cartesian3());

      // 面
      var plane = Cesium.Plane.fromPointNormal(Cesium.Cartesian3.ZERO, surface);

      // 射线
      var startRay = new Cesium.Ray(camera, startDirection);
      var endRay = new Cesium.Ray(camera, endDirection);

      // 射线和面交点
      var start = Cesium.IntersectionTests.rayPlane(startRay, plane);
      var end = Cesium.IntersectionTests.rayPlane(endRay, plane);

      return { start: start, end: end };
    }

    //球是否可以转动（编辑时停止球的操作）

  }, {
    key: "cameraControl",
    value: function cameraControl(isCamera) {
      this.viewer.scene.screenSpaceCameraController.enableRotate = isCamera;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = isCamera;
      this.viewer.scene.screenSpaceCameraController.enableZoom = isCamera;
      this.viewer.scene.screenSpaceCameraController.enableTilt = isCamera;
      this.viewer.scene.screenSpaceCameraController.enableLook = isCamera;
    }
  }]);

  return EditModel;
}(_Edit.EditBase);

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _Attr = __webpack_require__(17);

var _Edit = __webpack_require__(62);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCurve = exports.DrawCurve = function (_DrawPolyline) {
  _inherits(DrawCurve, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawCurve(opts) {
    _classCallCheck(this, DrawCurve);

    var _this = _possibleConstructorReturn(this, (DrawCurve.__proto__ || Object.getPrototypeOf(DrawCurve)).call(this, opts));

    _this.type = "curve";
    _this.editClass = _Edit.EditCurve; //获取编辑对象
    return _this;
  }

  _createClass(DrawCurve, [{
    key: "getDrawPosition",
    value: function getDrawPosition() {
      return this._positions_show;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      if (this._positions_draw == null || this._positions_draw.length < 3) {
        this._positions_show = this._positions_draw;
        return;
      }

      this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      this.entity._positions_draw = this._positions_draw;
      this.entity._positions_show = this._positions_show;

      entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
        return entity._positions_show;
      }, false);

      this._positions_show = null;
    }
  }]);

  return DrawCurve;
}(_Draw.DrawPolyline);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPolylineVolume = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(56);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(63);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPolylineVolume = exports.DrawPolylineVolume = function (_DrawPolyline) {
  _inherits(DrawPolylineVolume, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawPolylineVolume(opts) {
    _classCallCheck(this, DrawPolylineVolume);

    var _this = _possibleConstructorReturn(this, (DrawPolylineVolume.__proto__ || Object.getPrototypeOf(DrawPolylineVolume)).call(this, opts));

    _this.type = "polylineVolume";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditPolylineVolume; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 9999; //最多允许点的个数
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawPolylineVolume, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      var that = this;
      var addattr = {
        polylineVolume: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      addattr.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
        return that.getDrawPosition();
      }, false);

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.entity._positions_draw = this._positions_draw;

      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.polylineVolume);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {}
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      entity.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
        return entity._positions_draw;
      }, false);
    }
  }]);

  return DrawPolylineVolume;
}(_Draw.DrawPolyline);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawCorridor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _Attr = __webpack_require__(41);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(64);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCorridor = exports.DrawCorridor = function (_DrawPolyline) {
  _inherits(DrawCorridor, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawCorridor(opts) {
    _classCallCheck(this, DrawCorridor);

    var _this = _possibleConstructorReturn(this, (DrawCorridor.__proto__ || Object.getPrototypeOf(DrawCorridor)).call(this, opts));

    _this.type = "corridor";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditCorridor; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 9999; //最多允许点的个数
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawCorridor, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      var that = this;
      var addattr = {
        corridor: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      addattr.corridor.positions = new Cesium.CallbackProperty(function (time) {
        return that.getDrawPosition();
      }, false);

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.entity._positions_draw = this._positions_draw;

      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.corridor);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      var style = this.entity.attribute.style;
      if (!style.clampToGround) {
        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
        if (maxHight != 0) {
          this.entity.corridor.height = maxHight;
          style.height = maxHight;

          if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) this.entity.corridor.extrudedHeight = maxHight + Number(style.extrudedHeight);
        }
      }
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      entity.corridor.positions = new Cesium.CallbackProperty(function (time) {
        return entity._positions_draw;
      }, false);
    }
  }]);

  return DrawCorridor;
}(_Draw.DrawPolyline);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawRectangle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _Attr = __webpack_require__(66);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(17);

var _Edit = __webpack_require__(67);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawRectangle = exports.DrawRectangle = function (_DrawPolyline) {
  _inherits(DrawRectangle, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawRectangle(opts) {
    _classCallCheck(this, DrawRectangle);

    var _this = _possibleConstructorReturn(this, (DrawRectangle.__proto__ || Object.getPrototypeOf(DrawRectangle)).call(this, opts));

    _this.type = "rectangle";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditRectangle; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 2; //最多允许点的个数
    return _this;
  }

  _createClass(DrawRectangle, [{
    key: "getRectangle",
    value: function getRectangle() {
      var positions = this.getDrawPosition();
      if (positions.length < 2) return null;
      return Cesium.Rectangle.fromCartesianArray(positions);
    }
    //根据attribute参数创建Entity

  }, {
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      var that = this;
      var addattr = {
        rectangle: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      addattr.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
        return that.getRectangle();
      }, false);

      //线：边线宽度大于1时用polyline
      var lineStyle = _extends({
        color: attribute.style.outlineColor,
        width: attribute.style.outlineWidth,
        opacity: attribute.style.outlineOpacity
      }, attribute.style.outlineStyle || {});
      addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
        clampToGround: attribute.style.clampToGround,
        arcType: Cesium.ArcType.RHUMB,
        outline: false,
        show: false
      });

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.entity._positions_draw = this._positions_draw;
      this.bindOutline(this.entity, lineStyle); //边线

      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.rectangle);
    }
  }, {
    key: "bindOutline",
    value: function bindOutline(entity, lineStyle) {
      var attribute = entity.attribute;

      //本身的outline需要隐藏
      entity.rectangle.outline = new Cesium.CallbackProperty(function (time) {
        return attribute.style.outline && attribute.style.outlineWidth == 1;
      }, false);

      //是否显示：边线宽度大于1时
      entity.polyline.show = new Cesium.CallbackProperty(function (time) {
        return attribute.style.outline && attribute.style.outlineWidth > 1;
      }, false);
      entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
        if (!entity.polyline.show.getValue(time)) return null;
        if (!entity._positions_draw) return null;

        return attr.getOutlinePositions(entity);
      }, false);
      entity.polyline.width = new Cesium.CallbackProperty(function (time) {
        return entity.rectangle.outlineWidth;
      }, false);
      //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
      if (!lineStyle.lineType || lineStyle.lineType == "solid") {
        entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
          return entity.rectangle.outlineColor.getValue(time);
        }, false));
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      var style = this.entity.attribute.style;
      if (!style.clampToGround) {
        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
        if (maxHight != 0) {
          this.entity.rectangle.height = maxHight;
          style.height = maxHight;

          if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) this.entity.rectangle.extrudedHeight = maxHight + Number(style.extrudedHeight);
        }
      }
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this._positions_draw;
      //entity.rectangle.coordinates = this.getRectangle();
      entity.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
        if (entity._positions_draw.length < 2) return null;
        return Cesium.Rectangle.fromCartesianArray(entity._positions_draw);
      }, false);
    }
  }]);

  return DrawRectangle;
}(_Draw.DrawPolyline);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawCircle = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _Attr = __webpack_require__(42);

var attr = _interopRequireWildcard(_Attr);

var _Attr2 = __webpack_require__(17);

var _Edit = __webpack_require__(68);

var _polygon = __webpack_require__(10);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCircle = exports.DrawCircle = function (_DrawPolyline) {
  _inherits(DrawCircle, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawCircle(opts) {
    _classCallCheck(this, DrawCircle);

    var _this = _possibleConstructorReturn(this, (DrawCircle.__proto__ || Object.getPrototypeOf(DrawCircle)).call(this, opts));

    _this.type = "ellipse";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditCircle; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 2; //最多允许点的个数
    return _this;
  }

  _createClass(DrawCircle, [{
    key: "getShowPosition",
    value: function getShowPosition(time) {
      if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
      return null;
    }
    //根据attribute参数创建Entity

  }, {
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (attribute.type == "ellipse")
        //椭圆
        this._maxPointNum = 3;
        //圆
      else this._maxPointNum = 2;

      var that = this;
      var addattr = {
        position: new Cesium.CallbackProperty(function (time) {
          return that.getShowPosition(time);
        }, false),
        ellipse: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      //线：边线宽度大于1时用polyline
      var lineStyle = _extends({
        color: attribute.style.outlineColor,
        width: attribute.style.outlineWidth,
        opacity: attribute.style.outlineOpacity
      }, attribute.style.outlineStyle || {});
      addattr.polyline = (0, _Attr2.style2Entity)(lineStyle, {
        clampToGround: attribute.style.clampToGround,
        arcType: Cesium.ArcType.RHUMB,
        outline: false,
        show: false
      });

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      this.bindOutline(this.entity, lineStyle); //边线
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.ellipse);
    }
  }, {
    key: "bindOutline",
    value: function bindOutline(entity, lineStyle) {
      var attribute = entity.attribute;

      //本身的outline需要隐藏
      entity.ellipse.outline = new Cesium.CallbackProperty(function (time) {
        return attribute.style.outline && attribute.style.outlineWidth == 1;
      }, false);

      //是否显示：边线宽度大于1时
      entity.polyline.show = new Cesium.CallbackProperty(function (time) {
        return attribute.style.outline && attribute.style.outlineWidth > 1;
      }, false);
      entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
        if (!entity.polyline.show.getValue(time)) return null;

        return attr.getOutlinePositions(entity);
      }, false);
      entity.polyline.width = new Cesium.CallbackProperty(function (time) {
        return entity.ellipse.outlineWidth;
      }, false);

      //虚线等情况下不支持动态修改颜色,只有实线可以动态改颜色。
      if (!lineStyle.lineType || lineStyle.lineType == "solid") {
        entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
          return entity.ellipse.outlineColor.getValue(time);
        }, false));
      }
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isLoad) {
      if (!this._positions_draw) return;

      if (isLoad) {
        if (this._positions_draw instanceof Cesium.Cartesian3) {
          this._positions_draw = [this._positions_draw];
        }
        this.addPositionsForRadius(this._positions_draw[0]);
        return;
      }

      if (this._positions_draw.length < 2) return;

      var style = this.entity.attribute.style;

      //高度处理
      if (!style.clampToGround) {
        var height = this.formatNum(Cesium.Cartographic.fromCartesian(this._positions_draw[0]).height, 2);
        this.entity.ellipse.height = height;
        style.height = height;

        if (style.extrudedHeight && (0, _util.isNumber)(style.extrudedHeight)) {
          var extrudedHeight = height + Number(style.extrudedHeight);
          this.entity.ellipse.extrudedHeight = extrudedHeight;
        }
      }

      //半径处理
      var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
      this.entity.ellipse.semiMinorAxis = radius; //短半轴

      if (this._maxPointNum == 3) {
        //长半轴
        var semiMajorAxis;
        if (this._positions_draw.length == 3) {
          semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
        } else {
          semiMajorAxis = radius;
        }
        this.entity.ellipse.semiMajorAxis = semiMajorAxis;

        style.semiMinorAxis = radius;
        style.semiMajorAxis = semiMajorAxis;
      } else {
        this.entity.ellipse.semiMajorAxis = radius;

        style.radius = radius;
      }
    }
  }, {
    key: "addPositionsForRadius",
    value: function addPositionsForRadius(position) {
      var style = this.entity.attribute.style;

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        semiMajorAxis: this.entity.ellipse.semiMajorAxis.getValue(this.viewer.clock.currentTime), //长半轴
        semiMinorAxis: this.entity.ellipse.semiMinorAxis.getValue(this.viewer.clock.currentTime), //短半轴
        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
      });

      //长半轴上的坐标点
      var majorPos = outerPositions[1];
      this._positions_draw.push(majorPos);

      if (this._maxPointNum == 3) {
        //椭圆
        //短半轴上的坐标点
        var minorPos = outerPositions[0];
        this._positions_draw.push(minorPos);
      }
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this._positions_draw;
      //this.entity.position = this.getShowPosition();
      entity.position = new Cesium.CallbackProperty(function (time) {
        if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
        return null;
      }, false);
    }
  }]);

  return DrawCircle;
}(_Draw.DrawPolyline);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawCylinder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _point = __webpack_require__(2);

var _Attr = __webpack_require__(69);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(126);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawCylinder = exports.DrawCylinder = function (_DrawPolyline) {
  _inherits(DrawCylinder, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawCylinder(opts) {
    _classCallCheck(this, DrawCylinder);

    var _this = _possibleConstructorReturn(this, (DrawCylinder.__proto__ || Object.getPrototypeOf(DrawCylinder)).call(this, opts));

    _this.type = "cylinder";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditCylinder; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 2; //最多允许点的个数
    return _this;
  }

  _createClass(DrawCylinder, [{
    key: "getShowPosition",
    value: function getShowPosition(time) {
      if (this._positions_draw && this._positions_draw.length > 1) return (0, _point.addPositionsHeight)(this._positions_draw[0], this.entity.cylinder.length.getValue(time) / 2);
      return null;
    }
    //根据attribute参数创建Entity

  }, {
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      var that = this;
      var addattr = {
        position: new Cesium.CallbackProperty(function (time) {
          return that.getShowPosition(time);
        }, false),
        cylinder: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.cylinder);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isLoad) {
      if (!this._positions_draw) return;

      if (isLoad) {
        if (this._positions_draw instanceof Cesium.Cartesian3) {
          this._positions_draw = [this._positions_draw];
        }
        this.addPositionsForRadius(this._positions_draw[0]);
        return;
      }

      if (this._positions_draw.length < 2) return;

      var style = this.entity.attribute.style;

      //半径处理
      var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
      this.entity.cylinder.bottomRadius = radius;

      style.topRadius = this.entity.cylinder.topRadius.getValue(this.viewer.clock.currentTime);
      style.bottomRadius = radius;
    }
  }, {
    key: "addPositionsForRadius",
    value: function addPositionsForRadius(position) {
      var style = this.entity.attribute.style;

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        semiMajorAxis: style.bottomRadius, //长半轴
        semiMinorAxis: style.bottomRadius //短半轴
      });

      //长半轴上的坐标点
      this._positions_draw.push(outerPositions[0]);
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this._positions_draw;
      //this.entity.position = this.getShowPosition();
      entity.position = new Cesium.CallbackProperty(function (time) {
        if (entity._positions_draw && entity._positions_draw.length > 0) return (0, _point.addPositionsHeight)(entity._positions_draw[0], entity.cylinder.length.getValue(time) / 2);
        return null;
      }, false);
    }
  }]);

  return DrawCylinder;
}(_Draw.DrawPolyline);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditCylinder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Dragger = __webpack_require__(15);

var draggerCtl = _interopRequireWildcard(_Dragger);

var _Tooltip = __webpack_require__(8);

var _Edit = __webpack_require__(28);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditCylinder = exports.EditCylinder = function (_EditPolygon) {
  _inherits(EditCylinder, _EditPolygon);

  function EditCylinder() {
    _classCallCheck(this, EditCylinder);

    return _possibleConstructorReturn(this, (EditCylinder.__proto__ || Object.getPrototypeOf(EditCylinder)).apply(this, arguments));
  }

  _createClass(EditCylinder, [{
    key: "getGraphic",

    //取enity对象的对应矢量数据
    value: function getGraphic() {
      return this.entity.cylinder;
    }
    //修改坐标会回调，提高显示的效率

  }, {
    key: "changePositionsToCallback",
    value: function changePositionsToCallback() {
      this._positions_draw = this.entity._positions_draw;

      var time = this.viewer.clock.currentTime;
      var style = this.entity.attribute.style;

      style.topRadius = this.getGraphic().topRadius.getValue(time);
      this.getGraphic().topRadius = new Cesium.CallbackProperty(function (time) {
        return style.topRadius;
      }, false);

      style.bottomRadius = this.getGraphic().bottomRadius.getValue(time);
      this.getGraphic().bottomRadius = new Cesium.CallbackProperty(function (time) {
        return style.bottomRadius;
      }, false);

      style.length = this.getGraphic().length.getValue(time);
      this.getGraphic().length = new Cesium.CallbackProperty(function (time) {
        return style.length;
      }, false);
    }
    //图形编辑结束后调用

  }, {
    key: "finish",
    value: function finish() {
      this.entity._positions_draw = this._positions_draw;

      var style = this.entity.attribute.style;
      this.getGraphic().topRadius = style.topRadius;
      this.getGraphic().bottomRadius = style.bottomRadius;
      this.getGraphic().length = style.length;
    }
  }, {
    key: "bindDraggers",
    value: function bindDraggers() {
      var that = this;

      var style = this.entity.attribute.style;
      var positions = this.getPosition();

      //中心点
      var index = 0;
      var dragger = draggerCtl.createDragger(this.entityCollection, {
        position: positions[index],
        type: draggerCtl.PointType.MoveAll,
        onDrag: function onDrag(dragger, position) {
          positions[dragger.index] = position;

          //=====全部更新==========
          that.updateDraggers();
        }
      });
      dragger.index = index;
      this.draggers.push(dragger);

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: positions[index],
        semiMajorAxis: style.bottomRadius, //长半轴
        semiMinorAxis: style.bottomRadius, //短半轴
        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
      });

      //长半轴上的坐标点
      index = 1;
      var majorPos = outerPositions[0];
      positions[index] = majorPos;
      var bottomRadiusDragger = draggerCtl.createDragger(this.entityCollection, {
        position: majorPos,
        type: draggerCtl.PointType.EditAttr,
        tooltip: _Tooltip.message.dragger.editRadius,
        onDrag: function onDrag(dragger, position) {
          positions[dragger.index] = position;

          var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
          style.bottomRadius = radius;

          that.updateDraggers();
        }
      });
      bottomRadiusDragger.index = index;
      this.draggers.push(bottomRadiusDragger);

      //创建高度拖拽点
      index = 2;
      var position = (0, _point.addPositionsHeight)(positions[0], style.length);
      positions[index] = position;
      var draggerTop = draggerCtl.createDragger(this.entityCollection, {
        position: position,
        type: draggerCtl.PointType.MoveHeight,
        tooltip: _Tooltip.message.dragger.moveHeight,
        onDrag: function onDrag(dragger, position) {
          positions[dragger.index] = position;
          var length = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
          style.length = length;

          that.updateDraggers();
        }
      });
      draggerTop.index = index;
      this.draggers.push(draggerTop);

      // if (style.topRadius > 0) {
      //     //获取圆（或椭圆）边线上的坐标点数组
      //     var outerPositionsTop = getEllipseOuterPositions({
      //         position: position,
      //         semiMajorAxis: style.topRadius, //长半轴
      //         semiMinorAxis: style.topRadius, //短半轴
      //         rotation: Cesium.Math.toRadians(Number(style.rotation || 0)),
      //     });
      //     //长半轴上的坐标点
      //     index = 3
      //     var majorPos = outerPositionsTop[0];
      //     positions[index] = majorPos;
      //     var topRadiusDragger = draggerCtl.createDragger(this.entityCollection, {
      //         position: majorPos,
      //         type: draggerCtl.PointType.EditAttr,
      //         tooltip: message.dragger.editRadius,
      //         onDrag: function (dragger, position) {
      //             var center = positions[2]

      //             //高度改为圆锥高度
      //             var height = Cesium.Cartographic.fromCartesian(center).height;
      //             var car = Cesium.Cartographic.fromCartesian(position)
      //             position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
      //             dragger.position.setValue(position)

      //             position = position
      //             positions[dragger.index] = position;

      //             var radius = that.formatNum(Cesium.Cartesian3.distance(center, position), 2);
      //             style.topRadius = radius;

      //             that.updateDraggers();
      //         }
      //     });
      //     topRadiusDragger.index = index;
      //     this.draggers.push(topRadiusDragger);
      // }
    }
  }]);

  return EditCylinder;
}(_Edit.EditPolygon);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawEllipsoid = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _Attr = __webpack_require__(70);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(71);

var _polygon = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawEllipsoid = exports.DrawEllipsoid = function (_DrawPolyline) {
  _inherits(DrawEllipsoid, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawEllipsoid(opts) {
    _classCallCheck(this, DrawEllipsoid);

    var _this = _possibleConstructorReturn(this, (DrawEllipsoid.__proto__ || Object.getPrototypeOf(DrawEllipsoid)).call(this, opts));

    _this.type = "ellipsoid";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditEllipsoid; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 3; //最多允许点的个数
    return _this;
  }

  _createClass(DrawEllipsoid, [{
    key: "getShowPosition",
    value: function getShowPosition(time) {
      if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
      return null;
    }
    //根据attribute参数创建Entity

  }, {
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      var that = this;
      var addattr = {
        position: new Cesium.CallbackProperty(function (time) {
          return that.getShowPosition(time);
        }, false),
        ellipsoid: attr.style2Entity(attribute.style),
        attribute: attribute
      };

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.ellipsoid);
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing(isLoad) {
      if (!this._positions_draw) return;

      if (isLoad) {
        if (this._positions_draw instanceof Cesium.Cartesian3) {
          this._positions_draw = [this._positions_draw];
        }
        this.addPositionsForRadius(this._positions_draw[0]);
        return;
      }

      if (this._positions_draw.length < 2) return;

      var style = this.entity.attribute.style;

      //半径处理
      var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
      style.radii_x = radius; //短半轴
      style.radii_z = radius;

      //长半轴
      var semiMajorAxis;
      if (this._positions_draw.length == 3) {
        semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
      } else {
        semiMajorAxis = radius;
      }
      style.radii_y = semiMajorAxis;

      this.updateRadii(style);
    }
  }, {
    key: "updateRadii",
    value: function updateRadii(style) {
      var radii = new Cesium.Cartesian3(style.radii_x, style.radii_y, style.radii_z);
      if (this.entity.ellipsoid.radii) this.entity.ellipsoid.radii.setValue(radii);else this.entity.ellipsoid.radii = radii;
    }
  }, {
    key: "addPositionsForRadius",
    value: function addPositionsForRadius(position) {
      var style = this.entity.attribute.style;

      //获取圆（或椭圆）边线上的坐标点数组
      var outerPositions = (0, _polygon.getEllipseOuterPositions)({
        position: position,
        semiMajorAxis: Number(style.radii_x), //长半轴
        semiMinorAxis: Number(style.radii_y), //短半轴
        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
      });

      //长半轴上的坐标点
      this._positions_draw.push(outerPositions[0]);

      //短半轴上的坐标点
      this._positions_draw.push(outerPositions[1]);
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      // this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象
      // this.entity._positions_draw = this._positions_draw;
      // this.entity.position = this.getShowPosition();

      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this._positions_draw;
      entity.position = new Cesium.CallbackProperty(function (time) {
        if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
        return null;
      }, false);
    }
  }]);

  return DrawEllipsoid;
}(_Draw.DrawPolyline);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawWall = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(19);

var _Attr = __webpack_require__(57);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(72);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawWall = exports.DrawWall = function (_DrawPolyline) {
  _inherits(DrawWall, _DrawPolyline);

  //========== 构造方法 ==========
  function DrawWall(opts) {
    _classCallCheck(this, DrawWall);

    var _this = _possibleConstructorReturn(this, (DrawWall.__proto__ || Object.getPrototypeOf(DrawWall)).call(this, opts));

    _this.type = "wall";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditWall; //获取编辑对象

    _this._minPointNum = 2; //至少需要点的个数
    _this._maxPointNum = 9999; //最多允许点的个数

    _this.maximumHeights = null;
    _this.minimumHeights = null;
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawWall, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = [];

      if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
      if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

      if (attribute.config) {
        //允许外部传入
        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
      } else {
        this._minPointNum = this._minPointNum_def;
        this._maxPointNum = this._maxPointNum_def;
      }

      this.maximumHeights = [];
      this.minimumHeights = [];

      var that = this;
      var addattr = {
        wall: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      addattr.wall.positions = new Cesium.CallbackProperty(function (time) {
        var arr = that.getDrawPosition();
        if (attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);
      addattr.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
        var arr = that.getMinimumHeights();
        if (attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);
      addattr.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
        var arr = that.getMaximumHeights();
        if (attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);

      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.wall);
    }
  }, {
    key: "getMaximumHeights",
    value: function getMaximumHeights(entity) {
      return this.maximumHeights;
    }
  }, {
    key: "getMinimumHeights",
    value: function getMinimumHeights(entity) {
      return this.minimumHeights;
    }
  }, {
    key: "updateAttrForDrawing",
    value: function updateAttrForDrawing() {
      var style = this.entity.attribute.style;
      var position = this.getDrawPosition();
      var len = position.length;

      this.maximumHeights = new Array(len);
      this.minimumHeights = new Array(len);

      for (var i = 0; i < len; i++) {
        var height = Cesium.Cartographic.fromCartesian(position[i]).height;
        this.minimumHeights[i] = height;
        this.maximumHeights[i] = height + Number(style.extrudedHeight);
      }
    }
    //获取外部entity的坐标到_positions_draw

  }, {
    key: "setDrawPositionByEntity",
    value: function setDrawPositionByEntity(entity) {
      var positions = this.getPositions(entity);
      this._positions_draw = positions;

      var time = this.viewer.clock.currentTime;
      this._minimumHeights = entity.wall.minimumHeights && entity.wall.minimumHeights.getValue(time);
      this._maximumHeights = entity.wall.maximumHeights && entity.wall.maximumHeights.getValue(time);
      if (!this._minimumHeights || this._minimumHeights.length == 0 || !this._maximumHeights || this._maximumHeights.length == 0) return;

      entity.attribute.style = entity.attribute.style || {};
      entity.attribute.style.extrudedHeight = this._maximumHeights[0] - this._minimumHeights[0];
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象
      // this.entity.wall.positions = this.getDrawPosition();
      // this.entity.wall.minimumHeights = this.getMinimumHeights();
      // this.entity.wall.maximumHeights = this.getMaximumHeights();

      entity._positions_draw = this.getDrawPosition();
      entity.wall.positions = new Cesium.CallbackProperty(function (time) {
        var arr = entity._positions_draw;
        if (entity.attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);

      entity._minimumHeights = this.getMinimumHeights();
      entity.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
        var arr = entity._minimumHeights;
        if (entity.attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);

      entity._maximumHeights = this.getMaximumHeights();
      entity.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
        var arr = entity._maximumHeights;
        if (entity.attribute.style.closure) return arr.concat(arr[0]);
        //闭合
        else return arr;
      }, false);
    }
  }]);

  return DrawWall;
}(_Draw.DrawPolyline);

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawPlane = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(25);

var _Attr = __webpack_require__(53);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(73);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawPlane = exports.DrawPlane = function (_DrawPoint) {
  _inherits(DrawPlane, _DrawPoint);

  //========== 构造方法 ==========
  function DrawPlane(opts) {
    _classCallCheck(this, DrawPlane);

    var _this = _possibleConstructorReturn(this, (DrawPlane.__proto__ || Object.getPrototypeOf(DrawPlane)).call(this, opts));

    _this.type = "plane";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditPlane; //获取编辑对象
    return _this;
  }
  //根据attribute参数创建Entity


  _createClass(DrawPlane, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = null;

      var that = this;
      var addattr = {
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        plane: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.plane);
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      entity.position = new Cesium.CallbackProperty(function (time) {
        return entity._positions_draw;
      }, false);
    }
  }]);

  return DrawPlane;
}(_Draw.DrawPoint);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawBox = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(25);

var _Attr = __webpack_require__(55);

var attr = _interopRequireWildcard(_Attr);

var _Edit = __webpack_require__(74);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DrawBox = exports.DrawBox = function (_DrawPoint) {
  _inherits(DrawBox, _DrawPoint);

  //========== 构造方法 ==========
  function DrawBox(opts) {
    _classCallCheck(this, DrawBox);

    var _this = _possibleConstructorReturn(this, (DrawBox.__proto__ || Object.getPrototypeOf(DrawBox)).call(this, opts));

    _this.type = "box";
    _this.attrClass = attr; //对应的属性控制静态类
    _this.editClass = _Edit.EditBox; //获取编辑对象
    return _this;
  }

  //根据attribute参数创建Entity


  _createClass(DrawBox, [{
    key: "createFeature",
    value: function createFeature(attribute, dataSource) {
      dataSource = dataSource || this.dataSource;
      this._positions_draw = null;

      var that = this;
      var addattr = {
        position: new Cesium.CallbackProperty(function (time) {
          return that.getDrawPosition();
        }, false),
        box: attr.style2Entity(attribute.style),
        attribute: attribute
      };
      this.entity = dataSource.entities.add(addattr); //创建要素对象
      return this.entity;
    }
  }, {
    key: "style2Entity",
    value: function style2Entity(style, entity) {
      return attr.style2Entity(style, entity.box);
    }
    //图形绘制结束后调用

  }, {
    key: "finish",
    value: function finish() {
      var entity = this.entity;

      entity.editing = this.getEditClass(entity); //绑定编辑对象

      entity._positions_draw = this.getDrawPosition();
      entity.position = new Cesium.CallbackProperty(function (time) {
        return entity._positions_draw;
      }, false);
    }
  }]);

  return DrawBox;
}(_Draw.DrawPoint);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShpLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _BaseLayer2 = __webpack_require__(14);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ShpLayer = exports.ShpLayer = function (_BaseLayer) {
  _inherits(ShpLayer, _BaseLayer);

  function ShpLayer(viewer, options) {
    _classCallCheck(this, ShpLayer);

    var _this = _possibleConstructorReturn(this, (ShpLayer.__proto__ || Object.getPrototypeOf(ShpLayer)).call(this, viewer, options));

    _this.hasOpacity = true;
    return _this;
  }

  _createClass(ShpLayer, [{
    key: "initData",
    value: function initData() {
      this.viewer = viewer;
      this.serverUrl = this.options.url;
      this.serverName = this.options.layer;
      this.style = Cesium.defaultValue(this.options.style, { //参考api文档的Cesium.VectorStyle类
        tileCacheSize: 200,
        fill: false, //是否填充，仅面数据有效。
        outline: true, //是否显示边，仅面数据有效。
        outlineColor: "rgb(255,255,0)",
        lineWidth: 2,
        showMaker: false,
        showCenterLabel: false
      });
    }
  }, {
    key: "add",
    value: function add() {
      if (this.imageryLayer != null) {
        this.remove();
      }

      this.initData();

      var serverUrl = this.serverUrl;
      var serverName = this.serverName;
      var that = this;
      Cesium.when.all([Cesium.Resource.fetchBlob(serverUrl + "/" + serverName + ".shp"), Cesium.Resource.fetchBlob(serverUrl + "/" + serverName + ".dbf"), Cesium.Resource.fetchBlob(serverUrl + "/" + serverName + ".prj")], function (files) {
        files[0].name = serverName + ".shp";
        files[1].name = serverName + ".dbf";
        files[2].name = serverName + ".prj";

        var shpProvider = new Cesium.VectorTileImageryProvider({
          source: files,
          removeDuplicate: false,
          zIndex: 2,
          defaultStyle: that.style,
          maximumLevel: 20,
          minimumLevel: 1,
          simplify: false
        });
        shpProvider.readyPromise.then(function () {
          that.imageryLayer = that.viewer.imageryLayers.addImageryProvider(shpProvider);
          //透明度
          if (that.hasOpacity && that._opacity != 1) {
            that.setOpacity(that._opacity);
          }
        });
      });
    }

    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;
      if (this.imageryLayer == null) return;

      this.imageryLayer.alpha = value;
    }

    /**
     *  移除
     */

  }, {
    key: "remove",
    value: function remove() {
      if (this.imageryLayer == null) return;
      this.viewer.imageryLayers.remove(this.imageryLayer, false);
      this.imageryLayer = null;

      _get(ShpLayer.prototype.__proto__ || Object.getPrototypeOf(ShpLayer.prototype), "remove", this).call(this);
    }
  }, {
    key: "layer",
    get: function get() {
      return this.imageryLayer;
    }
  }]);

  return ShpLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.I3SLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _BaseLayer2 = __webpack_require__(14);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * I3SLayer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var I3SLayer = exports.I3SLayer = function (_BaseLayer) {
  _inherits(I3SLayer, _BaseLayer);

  //========== 构造方法 ==========
  function I3SLayer(viewer, options) {
    _classCallCheck(this, I3SLayer);

    var _this = _possibleConstructorReturn(this, (I3SLayer.__proto__ || Object.getPrototypeOf(I3SLayer)).call(this, viewer, options));

    _this.hasOpacity = true;
    _this.hasZIndex = true;
    return _this;
  }

  _createClass(I3SLayer, [{
    key: "add",


    //添加
    value: function add() {
      if (!this.options.reload && this.dataSource) {
        //this.options.reload可以外部控制每次都重新请求数据
        this.viewer.dataSources.add(this.dataSource);
      } else {
        this.queryData();
      }
      _get(I3SLayer.prototype.__proto__ || Object.getPrototypeOf(I3SLayer.prototype), "add", this).call(this);
    }
    //移除

  }, {
    key: "remove",
    value: function remove() {
      if (this.dataSource) {
        this.viewer.scene.primitives.remove(this.dataSource._sceneServer._layerCollection[0].tileset);
        delete this.dataSource;
      }
      _get(I3SLayer.prototype.__proto__ || Object.getPrototypeOf(I3SLayer.prototype), "remove", this).call(this);
    }
    //定位至数据区域

  }, {
    key: "centerAt",
    value: function centerAt(duration) {
      if (this.options.extent || this.options.center) {
        this.viewer.das.centerAt(this.options.extent || this.options.center, {
          duration: duration,
          isWgs84: true
        });
      } else {
        if (this.dataSource == null) return;
        this.viewer.das.flyTo(this.dataSource.entities.values, { duration: duration });
      }
    }
  }, {
    key: "queryData",
    value: function queryData() {
      var dataSource = new Cesium.I3SDataSource("I3SLayer", viewer.scene, {
        autoCenterCameraOnStart: true, // auto center to the location of the i3s
        geoidTiledTerrainProvider: this.options.geoidTiledTerrainProvider // pass the geoid service
      });

      dataSource.camera = this.viewer.camera; // for debug

      dataSource.loadUrl(this.options.url).then(function () {});

      this.dataSource = dataSource;
    }

    //设置透明度

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._opacity = value;
      if (this.dataSource == null) return;

      var entities = this.dataSource.entities.values;

      for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];

        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
          this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
          if (entity.polygon.outlineColor) {
            this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
          }
        }

        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
          this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
        }

        if (entity.billboard) {
          entity.billboard.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.model) {
          entity.model.color = Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
        }

        if (entity.label) {
          var _opacity = this._opacity;
          if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

          if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
          if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
          if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
        }
      }
    }
  }, {
    key: "layer",
    get: function get() {
      return this.dataSource;
    }
  }]);

  return I3SLayer;
}(_BaseLayer2.BaseLayer);

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaiduImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function BaiduImageryProvider(option) {
  var url = option.url;
  if (Cesium.defined(option.layer)) {
    switch (option.layer) {
      case "vec":
        url = "http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=" + (option.bigfont ? "ph" : "pl") + "&scaler=1&p=1";
        break;
      case "img_d":
        url = "http://shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46";
        break;
      case "img_z":
        url = "http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=" + (option.bigfont ? "sh" : "sl") + "&v=020";
        break;

      case "custom":
        //Custom 各种自定义样式
        //可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
        option.customid = option.customid || "midnight";
        url = "http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=" + option.customid;
        break;

      case "time":
        //实时路况
        var time = new Date().getTime();
        url = "http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=" + time + "&label=web2D&v=017";
        break;
    }
  }
  this._url = url;

  this._tileWidth = 256;
  this._tileHeight = 256;
  this._maximumLevel = 18;

  this._tilingScheme = new Cesium.WebMercatorTilingScheme({
    rectangleSouthwestInMeters: new Cesium.Cartesian2(-33554054, -33746824),
    rectangleNortheastInMeters: new Cesium.Cartesian2(33554054, 33746824)
  });

  this._credit = undefined;
  this._rectangle = this._tilingScheme.rectangle;
  this._ready = true;
} //百度地图

Object.defineProperties(BaiduImageryProvider.prototype, {
  url: {
    get: function get() {
      return this._url;
    }
  },

  token: {
    get: function get() {
      return this._token;
    }
  },

  proxy: {
    get: function get() {
      return this._proxy;
    }
  },

  tileWidth: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileWidth must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileWidth;
    }
  },

  tileHeight: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileHeight must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileHeight;
    }
  },

  maximumLevel: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("maximumLevel must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._maximumLevel;
    }
  },

  minimumLevel: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("minimumLevel must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return 0;
    }
  },

  tilingScheme: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tilingScheme must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tilingScheme;
    }
  },

  rectangle: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("rectangle must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._rectangle;
    }
  },

  tileDiscardPolicy: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileDiscardPolicy must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileDiscardPolicy;
    }
  },

  errorEvent: {
    get: function get() {
      return this._errorEvent;
    }
  },

  ready: {
    get: function get() {
      return this._ready;
    }
  },

  readyPromise: {
    get: function get() {
      return this._readyPromise.promise;
    }
  },

  credit: {
    get: function get() {
      return this._credit;
    }
  },

  usingPrecachedTiles: {
    get: function get() {
      return this._useTiles;
    }
  },

  hasAlphaChannel: {
    get: function get() {
      return true;
    }
  },

  layers: {
    get: function get() {
      return this._layers;
    }
  }
});

BaiduImageryProvider.prototype.getTileCredits = function (x, y, level) {
  return undefined;
};

BaiduImageryProvider.prototype.requestImage = function (x, y, level) {
  if (!this._ready) {
    throw new Cesium.DeveloperError("requestImage must not be called before the imagery provider is ready.");
  }

  var xTiles = this._tilingScheme.getNumberOfXTilesAtLevel(level);
  var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);

  var url = this._url.replace("{x}", x - xTiles / 2).replace("{y}", yTiles / 2 - y - 1).replace("{z}", level).replace("{s}", "0");

  return Cesium.ImageryProvider.loadImage(this, url);
};

exports.BaiduImageryProvider = BaiduImageryProvider;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TencentImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //腾讯地图


var TencentImageryProvider = exports.TencentImageryProvider = function (_Cesium$UrlTemplateIm) {
  _inherits(TencentImageryProvider, _Cesium$UrlTemplateIm);

  function TencentImageryProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TencentImageryProvider);

    var url = options.url;
    if (Cesium.defined(options.layer)) {
      switch (options.layer) {
        case "vec":
          url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=1&scene=0";
          break;
        case "img_d":
          url = "https://p{s}.map.gtimg.com/sateTiles/{z}/{sx}/{sy}/{x}_{reverseY}.jpg?version=400";
          options["customTags"] = {
            sx: function sx(imageryProvider, x, y, level) {
              return x >> 4;
            },
            sy: function sy(imageryProvider, x, y, level) {
              return (1 << level) - y >> 4;
            }
          };
          break;
        case "img_z":
          url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=2&scene=0";
          break;
        case "custom":
          //Custom 各种自定义样式
          //可选值：灰白地图:3,暗色地图:4
          options.customid = options.customid || "4";
          url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=" + options.customid + "&scene=0";
          break;
      }
    }
    options.url = url;
    options.subdomains = Cesium.defaultValue(options.subdomains, ["0", "1", "2"]);

    return _possibleConstructorReturn(this, (TencentImageryProvider.__proto__ || Object.getPrototypeOf(TencentImageryProvider)).call(this, options));
  }

  return TencentImageryProvider;
}(Cesium.UrlTemplateImageryProvider);

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureGridImageryProvider = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function FeatureGridImageryProvider(options) {
  options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
  this.options = options;

  this._tileWidth = Cesium.defaultValue(options.tileWidth, 256);
  this._tileHeight = Cesium.defaultValue(options.tileHeight, 256);
  this._minimumLevel = Cesium.defaultValue(options.minimumLevel, 0);
  this._maximumLevel = options.maximumLevel;

  if (options.rectangle && options.rectangle.xmin && options.rectangle.xmax && options.rectangle.ymin && options.rectangle.ymax) {
    var xmin = options.rectangle.xmin;
    var xmax = options.rectangle.xmax;
    var ymin = options.rectangle.ymin;
    var ymax = options.rectangle.ymax;
    options.rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
  }
  if (Cesium.defined(options.bbox) && options.bbox.length && options.bbox.length == 4) {
    options.rectangle = Cesium.Rectangle.fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]); //[xmin,ymin,xmax,ymax]
  }

  this._tilingScheme = Cesium.defaultValue(options.tilingScheme, new Cesium.GeographicTilingScheme({ ellipsoid: options.ellipsoid }));
  this._rectangle = Cesium.defaultValue(options.rectangle, this._tilingScheme.rectangle);
  this._rectangle = Cesium.Rectangle.intersection(this._rectangle, this._tilingScheme.rectangle);
  this._hasAlphaChannel = Cesium.defaultValue(options.hasAlphaChannel, true);

  this._errorEvent = new Cesium.Event();
  this._readyPromise = Cesium.when.resolve(true);
  this._credit = undefined;
  this._ready = true;
}

Object.defineProperties(FeatureGridImageryProvider.prototype, {
  url: {
    get: function get() {
      return this._url;
    }
  },

  token: {
    get: function get() {
      return this._token;
    }
  },

  proxy: {
    get: function get() {
      return this._proxy;
    }
  },

  tileWidth: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileWidth must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileWidth;
    }
  },

  tileHeight: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileHeight must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileHeight;
    }
  },

  maximumLevel: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("maximumLevel must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._maximumLevel;
    }
  },

  minimumLevel: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("minimumLevel must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');
      return 0;
    }
  },

  tilingScheme: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tilingScheme must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tilingScheme;
    }
  },

  rectangle: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("rectangle must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._rectangle;
    }
  },

  tileDiscardPolicy: {
    get: function get() {
      //>>includeStart('debug', pragmas.debug);
      if (!this._ready) {
        throw new Cesium.DeveloperError("tileDiscardPolicy must not be called before the imagery provider is ready.");
      }
      //>>includeEnd('debug');

      return this._tileDiscardPolicy;
    }
  },

  errorEvent: {
    get: function get() {
      return this._errorEvent;
    }
  },

  ready: {
    get: function get() {
      return this._ready;
    }
  },

  readyPromise: {
    get: function get() {
      return this._readyPromise.promise;
    }
  },

  credit: {
    get: function get() {
      return this._credit;
    }
  },

  usingPrecachedTiles: {
    get: function get() {
      return this._useTiles;
    }
  },

  hasAlphaChannel: {
    get: function get() {
      return true;
    }
  },

  layers: {
    get: function get() {
      return this._layers;
    }
  }
});

FeatureGridImageryProvider.prototype.getTileCredits = function (x, y, level) {
  return undefined;
};

//显示瓦片信息
FeatureGridImageryProvider.prototype.requestImage = function (x, y, level) {
  var canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 256;

  if (level < this._minimumLevel || Cesium.defined(this._maximumLevel) && level > this._maximumLevel) return canvas;

  if (this.options.debuggerTileInfo) {
    var context = canvas.getContext("2d");

    context.strokeStyle = "#ffff00";
    context.lineWidth = 2;
    context.strokeRect(1, 1, 255, 255);

    var label = "L" + level + "X" + x + "Y" + y;
    context.font = "bold 25px Arial";
    context.textAlign = "center";
    context.fillStyle = "black";
    context.fillText(label, 127, 127);
    context.fillStyle = "#ffff00";
    context.fillText(label, 124, 124);
  }
  return canvas;
};

FeatureGridImageryProvider.prototype._getGridKey = function (opts) {
  return opts.level + "_x" + opts.x + "_y" + opts.y;
};

FeatureGridImageryProvider.prototype.addImageryCache = function (opts) {
  if (opts.level < this._minimumLevel || opts.level < opts.maxLevel - 1 || Cesium.defined(this._maximumLevel) && opts.level >= this._maximumLevel) return;

  // daslog.log('新增' + JSON.stringify(opts));
  if (this.options.addImageryCache) {
    opts.key = this._getGridKey(opts);
    this.options.addImageryCache(opts);
  }
};

FeatureGridImageryProvider.prototype.removeImageryCache = function (opts) {
  var hasRemoveAll = opts.maxLevel < this._minimumLevel || Cesium.defined(this._maximumLevel) && opts.level >= this._maximumLevel;
  if (hasRemoveAll && this.options.removeAllImageryCache) {
    this.options.removeAllImageryCache();
    return;
  }

  // daslog.log('删除' + JSON.stringify(opts));
  if (this.options.removeImageryCache) {
    opts.key = this._getGridKey(opts);
    this.options.removeImageryCache(opts);
  }
};

exports.FeatureGridImageryProvider = FeatureGridImageryProvider;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//默认演示，从plot的 标号默认值F12打印 拷贝，方便读取
// delete defaultStyle.circle.radius
var defaultStyle = exports.defaultStyle = {
  label: {
    text: "文字",
    color: "#ffffff",
    opacity: 1,
    font_family: "楷体",
    font_size: 30,
    border: true,
    border_color: "#000000",
    border_width: 3,
    background: false,
    background_color: "#000000",
    background_opacity: 0.5,
    font_weight: "normal",
    font_style: "normal",
    scaleByDistance: false,
    scaleByDistance_far: 1000000,
    scaleByDistance_farValue: 0.1,
    scaleByDistance_near: 1000,
    scaleByDistance_nearValue: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    visibleDepth: true
  },
  point: {
    pixelSize: 10,
    color: "#3388ff",
    opacity: 1,
    outline: true,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    outlineWidth: 2,
    scaleByDistance: false,
    scaleByDistance_far: 1000000,
    scaleByDistance_farValue: 0.1,
    scaleByDistance_near: 1000,
    scaleByDistance_nearValue: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 10000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    visibleDepth: true
  },
  billboard: {
    opacity: 1,
    scale: 1,
    rotation: 0,
    horizontalOrigin: "CENTER",
    verticalOrigin: "BOTTOM",
    scaleByDistance: false,
    scaleByDistance_far: 1000000,
    scaleByDistance_farValue: 0.1,
    scaleByDistance_near: 1000,
    scaleByDistance_nearValue: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 10000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    visibleDepth: true
  },
  "font-point": {
    iconClass: "fa fa-automobile",
    iconSize: 50,
    color: "#00ffff",
    opacity: 1,
    horizontalOrigin: "CENTER",
    verticalOrigin: "CENTER",
    rotation: 0,
    scaleByDistance: false,
    scaleByDistance_far: 1000000,
    scaleByDistance_farValue: 0.1,
    scaleByDistance_near: 1000,
    scaleByDistance_nearValue: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 10000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    visibleDepth: true
  },
  model: {
    scale: 1,
    heading: 0,
    pitch: 0,
    roll: 0,
    fill: false,
    color: "#3388ff",
    opacity: 1,
    silhouette: false,
    silhouetteColor: "#ffffff",
    silhouetteSize: 2,
    silhouetteAlpha: 0.8,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false
  },
  polyline: {
    lineType: "solid",
    animationDuration: 1000,
    animationImage: "img/textures/lineClr.png",
    color: "#3388ff",
    width: 4,
    clampToGround: false,
    outline: false,
    outlineColor: "#ffffff",
    outlineWidth: 2,
    depthFail: false,
    depthFailColor: "#ff0000",
    depthFailOpacity: 0.2,
    opacity: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    zIndex: 0
  },
  polylineVolume: {
    color: "#00FF00",
    radius: 10,
    shape: "pipeline",
    outline: false,
    outlineColor: "#ffffff",
    opacity: 1,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0
  },
  wall: {
    extrudedHeight: 50,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationImage: "img/textures/fence.png",
    animationRepeatX: 1,
    animationAxisY: false,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0
  },
  corridor: {
    height: 0,
    width: 100,
    cornerType: "ROUNDED",
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    color: "#3388ff",
    opacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    zIndex: 0
  },
  extrudedCorridor: {
    height: 0,
    extrudedHeight: 50,
    width: 100,
    cornerType: "ROUNDED",
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    color: "#00FF00",
    opacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    zIndex: 0
  },
  polygon: {
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#3388ff",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    zIndex: 0
  },
  polygon_clampToGround: {
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#ffff00",
    opacity: 0.6,
    stRotation: 0,
    clampToGround: true,
    zIndex: 0
  },
  extrudedPolygon: {
    extrudedHeight: 100,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    perPositionHeight: true,
    zIndex: 0
  },
  rectangle: {
    height: 0,
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#3388ff",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    stRotation: 0,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    zIndex: 0
  },
  rectangleImg: { opacity: 1, rotation: 0, clampToGround: true, zIndex: 0 },
  extrudedRectangle: {
    extrudedHeight: 100,
    height: 0,
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    stRotation: 0,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    zIndex: 0
  },
  circle: {
    height: 0,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#3388ff",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false,
    zIndex: 0
  },
  circle_clampToGround: {
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#ffff00",
    opacity: 0.6,
    stRotation: 0,
    rotation: 0,
    clampToGround: true,
    zIndex: 0
  },
  extrudedCircle: {
    extrudedHeight: 100,
    height: 0,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    zIndex: 0
  },
  ellipse: {
    // semiMinorAxis: 100,
    // semiMajorAxis: 100,
    height: 0,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#3388ff",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    clampToGround: false,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    zIndex: 0
  },
  ellipse_clampToGround: {
    // semiMinorAxis: 100,
    // semiMajorAxis: 100,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#ffff00",
    opacity: 0.6,
    stRotation: 0,
    rotation: 0,
    clampToGround: true,
    zIndex: 0
  },
  extrudedEllipse: {
    // semiMinorAxis: 100,
    // semiMajorAxis: 100,
    extrudedHeight: 100,
    height: 0,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    stRotation: 0,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    rotation: 0,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    zIndex: 0
  },
  cylinder: {
    topRadius: 0,
    bottomRadius: 100,
    length: 100,
    fill: true,
    fillType: "color",
    animationDuration: 1000,
    animationCount: 1,
    animationGradient: 0.1,
    color: "#00FF00",
    opacity: 0.6,
    outline: false,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0
  },
  ellipsoid: {
    radii_x: 100,
    radii_y: 100,
    radii_z: 100,
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6
  },
  plane: {
    dimensionsX: 100,
    dimensionsY: 100,
    plane_normal: "z",
    plane_distance: 0,
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0
  },
  box: {
    dimensionsX: 100,
    dimensionsY: 100,
    dimensionsZ: 100,
    fill: true,
    fillType: "color",
    grid_lineCount: 8,
    grid_lineThickness: 2,
    grid_cellAlpha: 0.1,
    stripe_oddcolor: "#ffffff",
    stripe_repeat: 6,
    checkerboard_oddcolor: "#ffffff",
    checkerboard_repeat: 4,
    color: "#00FF00",
    opacity: 0.6,
    outline: true,
    outlineWidth: 1,
    outlineColor: "#ffffff",
    outlineOpacity: 0.6,
    distanceDisplayCondition: false,
    distanceDisplayCondition_far: 100000,
    distanceDisplayCondition_near: 0,
    clampToGround: false
  }
};
defaultStyle.imagepoint = defaultStyle.billboard; //兼容历史命名
defaultStyle.ellipse = defaultStyle.circle;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyboardRoam = exports.KeyboardType = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var moveStep = 10; //平移步长 (米)
var dirStep = 25; //相机原地旋转步长，值越大步长越小。
var rotateStep = 1.0; //相机围绕目标点旋转速率，0.3 - 2.0
var minPitch = 0.1; //最小仰角  0 - 1
var maxPitch = 0.95; //最大仰角  0 - 1

var KeyboardType = exports.KeyboardType = {
  ENLARGE: 0,
  NARROW: 1,
  LEFT_ROTATE: 2,
  RIGHT_ROTATE: 3,
  TOP_ROTATE: 4,
  BOTTOM_ROTATE: 5
};

//快捷键，键盘漫游

var KeyboardRoam = exports.KeyboardRoam = function () {
  //========== 构造方法 ==========
  function KeyboardRoam(options) {
    _classCallCheck(this, KeyboardRoam);

    this.viewer = options.viewer;
    var canvas = this.viewer.scene.canvas;

    this.flags = {
      moveForward: false,
      moveBackward: false,
      moveUp: false,
      moveDown: false,
      moveLeft: false,
      moveRight: false
    };

    canvas.setAttribute("tabindex", "0"); // needed to put focus on the canvas
    canvas.onclick = function () {
      canvas.focus();
    };

    var that = this;
    document.addEventListener("keydown", function (event) {
      if (!that._enable) return;

      var flagName = that.getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== "undefined") {
        that.flags[flagName] = true;
      }
    }, false);
    document.addEventListener("keyup", function (event) {
      if (!that._enable) return;

      var flagName = that.getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== "undefined") {
        that.flags[flagName] = false;
      }
    }, false);

    this._enable = false;
  }

  //========== 对外属性 ==========

  //是否禁用


  _createClass(KeyboardRoam, [{
    key: "bind",


    //========== 方法 ==========

    value: function bind(opts) {
      if (this._enable) return;
      this._enable = true;

      if (Cesium.defined(opts)) {
        //支持绑定方法内重新赋值参数
        moveStep = opts.moveStep || opts.speedRatio || moveStep;
        dirStep = opts.dirStep || dirStep;
        rotateStep = opts.rotateStep || rotateStep;
        minPitch = opts.minPitch || minPitch;
        maxPitch = opts.maxPitch || maxPitch;
      }

      this.viewer.clock.onTick.addEventListener(this.cameraFunc, this);
    }
  }, {
    key: "unbind",
    value: function unbind() {
      if (!this._enable) return;
      this._enable = false;

      this.viewer.clock.onTick.removeEventListener(this.cameraFunc, this);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbind();
      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }

    //=================相关事件回调方法======================

  }, {
    key: "getFlagForKeyCode",
    value: function getFlagForKeyCode(keyCode) {
      switch (keyCode) {
        //平移
        case "W".charCodeAt(0):
          //向前平移镜头，不改变相机朝向
          return "moveForward";
        case "S".charCodeAt(0):
          //向后平移镜头，不改变相机朝向
          return "moveBackward";
        case "D".charCodeAt(0):
          //向右平移镜头，不改变相机朝向
          return "moveRight";
        case "A".charCodeAt(0):
          //向左平移镜头，不改变相机朝向
          return "moveLeft";
        case "Q".charCodeAt(0):
          //向上平移镜头，不改变相机朝向
          return "moveUp";
        case "E".charCodeAt(0):
          //向下平移镜头，不改变相机朝向
          return "moveDown";

        //相对于相机本身
        case 38:
          //方向键上键
          this.rotateCamera(KeyboardType.TOP_ROTATE); //相机原地上旋转
          break;
        case 37:
          //方向键左键
          this.rotateCamera(KeyboardType.LEFT_ROTATE); //相机原地左旋转
          break;
        case 39:
          //方向键右键
          this.rotateCamera(KeyboardType.RIGHT_ROTATE); //相机原地右旋转
          break;
        case 40:
          //方向键下键
          this.rotateCamera(KeyboardType.BOTTOM_ROTATE); //相机原地下旋转
          break;

        //相对于屏幕中心点
        case "I".charCodeAt(0):
        case 104:
          //数字键盘8
          this.moveCamera(KeyboardType.ENLARGE); //向屏幕中心靠近
          break;
        case "K".charCodeAt(0):
        case 101:
          //数字键盘5
          this.moveCamera(KeyboardType.NARROW); //向屏幕中心远离
          break;
        case "J".charCodeAt(0):
        case 100:
          //数字键盘4
          this.moveCamera(KeyboardType.LEFT_ROTATE); //围绕屏幕中心左旋转
          break;
        case "L".charCodeAt(0):
        case 102:
          //数字键盘6
          this.moveCamera(KeyboardType.RIGHT_ROTATE); //围绕屏幕中心右旋转
          break;
        case "U".charCodeAt(0):
        case 103:
          //数字键盘7
          this.moveCamera(KeyboardType.TOP_ROTATE); //围绕屏幕中心上旋转
          break;
        case "O".charCodeAt(0):
        case 105:
          //数字键盘9
          this.moveCamera(KeyboardType.BOTTOM_ROTATE); //围绕屏幕中心下旋转
          break;

        default:
          break;
      }
      return undefined;
    }

    //=================平移======================

  }, {
    key: "startMoveForward",
    value: function startMoveForward() {
      this.flags["moveForward"] = true;
    }
  }, {
    key: "stopMoveForward",
    value: function stopMoveForward() {
      this.flags["moveForward"] = false;
    }
  }, {
    key: "startMoveBackward",
    value: function startMoveBackward() {
      this.flags["moveBackward"] = true;
    }
  }, {
    key: "stopMoveBackward",
    value: function stopMoveBackward() {
      this.flags["moveBackward"] = false;
    }
  }, {
    key: "startMoveRight",
    value: function startMoveRight() {
      this.flags["moveRight"] = true;
    }
  }, {
    key: "stopMoveRight",
    value: function stopMoveRight() {
      this.flags["moveRight"] = false;
    }
  }, {
    key: "startMoveLeft",
    value: function startMoveLeft() {
      this.flags["moveLeft"] = true;
    }
  }, {
    key: "stopMoveLeft",
    value: function stopMoveLeft() {
      this.flags["moveLeft"] = false;
    }
  }, {
    key: "moveForward",
    value: function moveForward(distance) {
      //和模型的相机移动不太一样  不是沿着相机目标方向，而是默认向上方向 和 向右 方向的插值方向
      var camera = this.viewer.camera;
      var direction = camera.direction;
      //获得此位置默认的向上方向
      var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

      // right = direction * up
      var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());

      direction = Cesium.Cartesian3.cross(up, right, new Cesium.Cartesian3());

      direction = Cesium.Cartesian3.normalize(direction, direction);
      direction = Cesium.Cartesian3.multiplyByScalar(direction, distance, direction);

      camera.position = Cesium.Cartesian3.add(camera.position, direction, camera.position);
    }
  }, {
    key: "cameraFunc",
    value: function cameraFunc(clock) {
      var camera = this.viewer.camera;

      // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
      // var cameraHeight = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(camera.position).height;
      // var moveRate = cameraHeight / moveStep;
      var moveRate = moveStep;

      if (this.flags.moveForward) {
        this.moveForward(moveRate);
      }
      if (this.flags.moveBackward) {
        this.moveForward(-moveRate);
      }
      if (this.flags.moveUp) {
        camera.moveUp(moveRate);
      }
      if (this.flags.moveDown) {
        camera.moveDown(moveRate);
      }
      if (this.flags.moveLeft) {
        camera.moveLeft(moveRate);
      }
      if (this.flags.moveRight) {
        camera.moveRight(moveRate);
      }
    }

    //=================相对于屏幕或相机======================

  }, {
    key: "resetCameraPos",
    value: function resetCameraPos(newCamera) {
      if (!newCamera) return;
      this.viewer.scene.camera.position = newCamera.position;
      this.viewer.scene.camera.direction = newCamera.direction;
      this.viewer.scene.camera.right = newCamera.right;
      this.viewer.scene.camera.up = newCamera.up;
    }
  }, {
    key: "limitAngle",
    value: function limitAngle(up, position, type) {
      var dotNum = Cesium.Cartesian3.dot(up, Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3()));
      if (type == "up" && dotNum < minPitch) return false;
      if (type == "down" && dotNum > maxPitch) return false;
      return true;
    }
  }, {
    key: "computedNewPos",
    value: function computedNewPos(camera, dir, rotate) {
      // var step = rotateStep;
      var oldpos = camera.position;
      var winCenter = (0, _point.getCenter)(this.viewer);
      if (!winCenter) return;
      var center = Cesium.Cartesian3.fromDegrees(winCenter.x, winCenter.y, winCenter.z);
      if (!center) return;
      var oldDis = Cesium.Cartesian3.distance(center, oldpos);
      var step = oldDis / 100;
      step = rotate ? step * rotateStep : step;
      var newCamera = {};
      var ray = new Cesium.Ray(oldpos, dir);
      newCamera.position = Cesium.Ray.getPoint(ray, step);

      // var cheight = Cesium.Cartographic.fromCartesian(newCamera.position).height;
      // if (cheight < 500)   return;

      newCamera.direction = camera.direction;
      newCamera.right = camera.right;
      newCamera.up = camera.up;
      if (rotate) {
        var newDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(newCamera.position, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());
        ray = new Cesium.Ray(center, newDir);
        newCamera.position = Cesium.Ray.getPoint(ray, oldDis);
        newCamera.direction = Cesium.Cartesian3.negate(newDir, new Cesium.Cartesian3());
        // newCamera.up = camera.up;
        newCamera.up = Cesium.Cartesian3.normalize(newCamera.position, new Cesium.Cartesian3());
        newCamera.right = Cesium.Cartesian3.cross(newCamera.direction, newCamera.up, new Cesium.Cartesian3());
      }
      return newCamera;
    }
  }, {
    key: "moveCamera",
    value: function moveCamera(type) {
      var camera = this.viewer.scene.camera;
      var newCamera;
      switch (type) {
        case KeyboardType.ENLARGE:
          newCamera = this.computedNewPos(camera, camera.direction);
          break;
        case KeyboardType.NARROW:
          newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.direction, new Cesium.Cartesian3()));
          break;
        case KeyboardType.LEFT_ROTATE:
          newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.right, new Cesium.Cartesian3()), true);
          break;
        case KeyboardType.RIGHT_ROTATE:
          newCamera = this.computedNewPos(camera, camera.right, true);
          break;
        case KeyboardType.TOP_ROTATE:
          if (!this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), "up")) return;
          newCamera = this.computedNewPos(camera, Cesium.clone(camera.up), true);
          break;
        case KeyboardType.BOTTOM_ROTATE:
          if (!this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), "down")) return;
          newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.up, new Cesium.Cartesian3()), true);
          break;
      }
      if (!newCamera) return;
      this.resetCameraPos(newCamera);
    }
  }, {
    key: "rotateCamera",
    value: function rotateCamera(type) {
      var winPos = [0, 0];
      var width = this.viewer.scene.canvas.clientWidth;
      var height = this.viewer.scene.canvas.clientHeight;
      var step = (width + height) / dirStep;
      switch (type) {
        case KeyboardType.LEFT_ROTATE:
          winPos = [-step * width / height, 0];
          break;
        case KeyboardType.RIGHT_ROTATE:
          winPos = [step * width / height, 0];
          break;
        case KeyboardType.TOP_ROTATE:
          winPos = [0, step];
          break;
        case KeyboardType.BOTTOM_ROTATE:
          winPos = [0, -step];
          break;
        default:
          return;
      }
      var x = winPos[0] / width;
      var y = winPos[1] / height;
      //这计算了，分别向右 和 向上移动的
      var lookFactor = 0.05;
      var camera = this.viewer.camera;
      camera.lookRight(x * lookFactor);
      camera.lookUp(y * lookFactor);

      //获得direction 方向
      var direction = camera.direction;
      //获得此位置默认的向上方向
      var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

      // right = direction * up
      var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());
      // up = right * direction
      up = Cesium.Cartesian3.cross(right, direction, new Cesium.Cartesian3());

      camera.up = up;
      camera.right = right;
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(value) {
      if (value) this.bind();else this.unbind();
    }
  }, {
    key: "moveStep",
    get: function get() {
      return moveStep;
    },
    set: function set(value) {
      moveStep = value;
    }
  }, {
    key: "dirStep",
    get: function get() {
      return dirStep;
    },
    set: function set(value) {
      dirStep = value;
    }
  }, {
    key: "rotateStep",
    get: function get() {
      return rotateStep;
    },
    set: function set(value) {
      rotateStep = value;
    }
  }, {
    key: "minPitch",
    get: function get() {
      return minPitch;
    },
    set: function set(value) {
      minPitch = value;
    }
  }, {
    key: "maxPitch",
    get: function get() {
      return maxPitch;
    },
    set: function set(value) {
      maxPitch = value;
    }
  }]);

  return KeyboardRoam;
}();

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Popup = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _index = __webpack_require__(22);

var attrUtil = _interopRequireWildcard(_index);

var _config2Entity = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//该类不仅仅是popup处理，是所有一些有关单击事件的统一处理入口（从效率考虑）。

var Popup = exports.Popup = function () {
  //========== 构造方法 ==========
  function Popup(viewer, options) {
    _classCallCheck(this, Popup);

    this.viewer = viewer;
    this.options = options || {};

    this._isOnly = true;
    this._enable = true;
    this._depthTest = true;
    this.viewerid = viewer._container.id;
    this.objPopup = {};

    this.highlighted = {
      feature: undefined,
      originalColor: new Cesium.Color()
    };
    this.defaultHighlightedClr = Cesium.Color.fromCssColorString("#95e40c");

    //兼容历史接口
    this.getPopupForConfig = _util.getPopupForConfig;
    this.getPopup = _util.getPopup;

    //添加弹出框
    var infoDiv = '<div id="' + this.viewerid + '-das3d-pupup-all" ></div>';
    (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

    //单击事件
    this.viewer.das.on(_DasClass.eventType.click, this.mousePickingClick, this);
    //移动事件
    this.viewer.scene.postRender.addEventListener(this.bind2scene, this);
  }

  //========== 对外属性 ==========
  //显示单个模式


  _createClass(Popup, [{
    key: "mousePickingClick",


    //========== 方法 ==========

    //鼠标点击事件
    value: function mousePickingClick(event) {
      this.removeFeatureForImageryLayer();
      this.removeFeatureFor3dtiles();

      if (this._isOnly) this.close();
      if (!this._enable) return;

      var position = event.position;
      var pickedObject;
      try {
        pickedObject = this.viewer.scene.pick(position);
      } catch (e) {
        //
      }

      var isFindPopup = false;
      var isFindClick = false;

      //存在单击的对象
      if (Cesium.defined(pickedObject)) {
        //普通entity对象 && viewer.scene.pickPositionSupported
        if (Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
          var entity = pickedObject.id;

          // if (entity.eventTarget && entity.eventTarget.popup) {
          //   entity.popup = entity.popup || entity.eventTarget.popup;
          // }

          //popup
          if (Cesium.defined(entity.popup)) {
            var cartesian = void 0;
            if (entity.billboard || entity.label || entity.point || entity.model) {
              //对点状数据做特殊处理，
              cartesian = entity.position;
            } else {
              cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
            }
            this.show(entity, cartesian, position);
            isFindPopup = true;
          }

          //加统一的click处理
          if (entity.click && typeof entity.click === "function") {
            entity.click(entity, position);
            isFindClick = true;
          }
          //单击对象所关联的管理类(基于DasClass)，进行click事件抛出。
          if (entity.eventTarget && entity.eventTarget.fire) {
            entity.eventTarget.fire(_DasClass.eventType.click, {
              sourceTarget: entity,
              position: position
            });
            isFindClick = true;
          }
        }
        //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
        else if (Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
            //取属性
            var attr = {};
            var names = pickedObject.getPropertyNames();
            for (var i = 0; i < names.length; i++) {
              var name = names[i];
              if (!pickedObject.hasProperty(name)) continue;

              var val = pickedObject.getProperty(name);
              if (val == null) continue;
              attr[name] = val;
            }

            var cfg = pickedObject.tileset.das.options;

            //popup
            if (Cesium.defined(cfg.popup)) {
              var _cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
              var item = {
                id: pickedObject._batchId,
                popup: (0, _util.bindLayerPopup)(cfg.popup, function (inhtml, entity) {
                  return (0, _util.getPopupForConfig)({
                    name: cfg.name,
                    popup: inhtml,
                    popupNameField: cfg.popupNameField
                  }, attr);
                }),
                popupPosition: cfg.popupPosition,
                tileset: pickedObject.tileset,
                eventTarget: pickedObject.tileset.eventTarget,
                data: attr
              };
              this.show(item, _cartesian, position);
              isFindPopup = true;
            }

            //高亮显示单体对象
            if (cfg.showClickFeature) {
              if (cfg.clickFeatureColor) {
                //兼容历史写法
                cfg.pickFeatureStyle = cfg.pickFeatureStyle || {};
                cfg.pickFeatureStyle.color = cfg.clickFeatureColor;
              }
              this.showFeatureFor3dtiles(pickedObject, cfg.pickFeatureStyle);
            }

            //加统一的click处理
            if (cfg.click && typeof cfg.click === "function") {
              cfg.click({ attr: attr, feature: pickedObject, tileset: pickedObject.tileset }, position);
              isFindClick = true;
            }
            //单击对象所关联的管理类(基于DasClass)，进行click事件抛出。
            if (pickedObject.tileset.eventTarget && pickedObject.tileset.eventTarget.fire) {
              pickedObject.tileset.eventTarget.fire(_DasClass.eventType.click, {
                sourceTarget: pickedObject,
                tileset: pickedObject.tileset,
                data: attr,
                position: position
              });
              isFindClick = true;
            }
          }
          //primitive对象
          else if (Cesium.defined(pickedObject.primitive)) {
              var primitive = pickedObject.primitive;

              //popup
              if (Cesium.defined(primitive.popup)) {
                var _cartesian2 = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                this.show(primitive, _cartesian2, position);
                isFindPopup = true;
              }

              //加统一的click处理
              if (primitive.click && typeof primitive.click === "function") {
                primitive.click(primitive, position);
                isFindClick = true;
              }
              //单击对象所关联的管理类(基于DasClass)，进行click事件抛出。
              if (primitive.eventTarget && primitive.eventTarget.fire) {
                primitive.eventTarget.fire(_DasClass.eventType.click, {
                  sourceTarget: primitive,
                  position: position
                });
                isFindClick = true;
              }
            } else {
              //未单击到矢量或模型数据时
              daslog.log("单击到了对象，请确认是否要做处理", pickedObject);
            }
      }

      if (!isFindPopup) {
        this.pickImageryLayerFeatures(position);
      }

      //单击地图空白（未单击到矢量或模型数据）时
      if (!isFindClick) {
        this.viewer.das.fire(_DasClass.eventType.clickMap, {
          position: position
        });
      }
    }

    //瓦片图层上的矢量对象，动态获取

  }, {
    key: "pickImageryLayerFeatures",
    value: function pickImageryLayerFeatures(position) {
      var scene = this.viewer.scene;
      var pickRay = scene.camera.getPickRay(position); //position : Cesium.Cartesian2
      var imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);
      if (!Cesium.defined(imageryLayerFeaturePromise)) {
        return;
      }

      var that = this;
      Cesium.when(imageryLayerFeaturePromise, function (features) {
        if (!Cesium.defined(features) || features.length === 0) {
          return;
        }

        //单击选中的要素对象
        var feature = features[0];
        if (feature.imageryLayer == null || feature.imageryLayer.config == null) return;
        var cfg = feature.imageryLayer.config;

        that.pickFeatures(feature, position, cfg);

        if (cfg.click && typeof cfg.click === "function") {
          cfg.click(features, position); //返回所有的features
        }
        //单击对象所关联的管理类(基于DasClass)，进行click事件抛出。
        if (feature.imageryLayer.eventTarget && feature.imageryLayer.eventTarget.fire) {
          feature.imageryLayer.eventTarget.fire(_DasClass.eventType.click, {
            sourceTarget: feature.imageryLayer,
            features: features,
            position: position
          });
        }
      }, function (e) {
        daslog.warn("pickImageryLayerFeatures底图出错", e);
      });
    }
  }, {
    key: "pickFeatures",
    value: function pickFeatures(feature, viewerPoint, cfg) {
      //属性
      var attr = feature.properties;
      if (!Cesium.defined(attr) && feature.data) {
        attr = feature.data.properties || feature.data.attributes;
      }

      //显示popup
      var result = (0, _util.getPopupForConfig)(cfg, attr);
      if (result) {
        var position = (0, _point.getCurrentMousePosition)(this.viewer.scene, viewerPoint);
        this.show({
          id: "imageryLayerFeaturePromise",
          popup: {
            html: result,
            anchor: cfg.popupAnchor || [0, -12]
          },
          popupPosition: cfg.popupPosition
        }, position, viewerPoint);
      }

      //显示要素
      if (cfg.showClickFeature && feature.data) {
        if (feature.data.geometry && JSON.stringify(feature.data.geometry).length > Cesium.defaultValue(cfg.pickFeatureMax, 9000)) {
          //配置有maxLength时，屏蔽大数据下的页面卡顿
          daslog.log("showFeatureForImageryLayer屏蔽的大数据，避免卡顿", feature.data.geometry);
          return;
        }

        this.showFeatureForImageryLayer(feature.data, cfg.pickFeatureStyle);
      }
    }

    //popup处理

  }, {
    key: "show",
    value: function show(entity, cartesian, viewPoint) {
      if (entity == null || entity.popup == null) return;

      if (!cartesian) {
        //外部直接传入entity调用show时，可以不传入坐标，自动取值
        cartesian = attrUtil.getCenterPosition(entity);
      }

      //对点状贴地数据做特殊处理，
      var graphic = entity.billboard || entity.label || entity.point || entity.model;
      if (graphic && graphic.heightReference) {
        cartesian = (0, _point.getPositionValue)(cartesian);

        var tempCarto = Cesium.Cartographic.fromCartesian(cartesian);
        if (tempCarto) {
          // && tempCarto.height == 0
          var that = this;
          if (graphic.heightReference._value == Cesium.HeightReference.CLAMP_TO_GROUND) {
            //贴地点，重新计算高度
            cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
              asyn: true,
              callback: function callback(newHeight, cartOld) {
                //daslog.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                that._showView(entity, cartesianNew, viewPoint);
              }
            });
            return;
          } else if (graphic.heightReference._value == Cesium.HeightReference.RELATIVE_TO_GROUND) {
            cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
              relativeHeight: true,
              asyn: true,
              callback: function callback(newHeight, cartOld) {
                //daslog.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                that._showView(entity, cartesianNew, viewPoint);
              }
            });
            return;
          }
        }
      }

      this._showView(entity, cartesian, viewPoint);
    }
  }, {
    key: "_showView",
    value: function _showView(entity, cartesian, viewPoint) {
      var eleId = this.getPopupId(entity);
      this.close(eleId);

      this.objPopup[eleId] = {
        id: entity.id,
        popup: entity.popup,
        popupPosition: entity.popupPosition, //配置的固定位置 类似弹窗
        entity: entity,
        cartesian: cartesian,
        viewPoint: viewPoint
      };

      //显示内容
      var inhtml;
      if (_typeof(entity.popup) === "object") {
        inhtml = entity.popup.html;
        this.objPopup[eleId].onAdd = entity.popup.onAdd;
        this.objPopup[eleId].onRemove = entity.popup.onRemove;

        if (typeof entity.popup.visible === "function") {
          if (!entity.popup.visible(entity)) {
            return;
          }
        }
      } else {
        inhtml = entity.popup;
      }
      if (!inhtml) return;

      var that = this;
      if (typeof inhtml === "function") {
        //回调方法
        inhtml = inhtml(entity, cartesian, function (inhtml) {
          that._camera_cache = null;
          (0, _zepto.zepto)("#" + eleId).remove();
          that._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
        });
      }

      if (!inhtml) return;

      this._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
    }
  }, {
    key: "getItem",
    value: function getItem(eleId) {
      return this.objPopup[eleId];
    }
  }, {
    key: "_showHtml",
    value: function _showHtml(inhtml, eleId, entity, cartesian, viewPoint) {
      (0, _zepto.zepto)("#" + this.viewerid + "-das3d-pupup-all").append('<div id="' + eleId + '" class="das3d-popup">' + '            <a id="' + eleId + '-popup-close" data-id="' + eleId + '" class="das3d-popup-close-button das3d-popup-color" >×</a>' + '            <div class="das3d-popup-content-wrapper das3d-popup-background">' + '                <div class="das3d-popup-content das3d-popup-color">' + inhtml + "</div>" + "            </div>" + '            <div id="' + eleId + '-popup-btmtip" class="das3d-popup-tip-container"><div class="das3d-popup-tip das3d-popup-background"></div></div>' + "        </div>");

      var that = this;
      (0, _zepto.zepto)("#" + eleId + "-popup-close").click(function () {
        var eleId = (0, _zepto.zepto)(this).attr("data-id");
        that.close(eleId, true);
      });

      //计算显示位置
      if (entity.popupPosition) {
        //固定显示，类似弹窗
        this.showFixViewPoint(eleId, cartesian, entity.popup, entity.popupPosition);
        (0, _zepto.zepto)("#" + eleId + "-popup-btmtip").remove(); //去掉小箭头
      } else {
        this._camera_cache = null;

        var result = this.updateViewPoint(eleId, cartesian, entity.popup, viewPoint);
        if (!result && this._depthTest) {
          this.close(eleId);
          return;
        }
      }

      //popup的DOM添加到页面的回调方法
      if (this.objPopup[eleId] && this.objPopup[eleId].onAdd) {
        this.objPopup[eleId].onAdd(eleId, entity);
      }
    }
  }, {
    key: "updateViewPoint",
    value: function updateViewPoint(eleId, position, popup, point) {
      var _position = (0, _point.getPositionValue)(position);
      if (!Cesium.defined(_position)) {
        return false;
      }

      //如果视角和位置都没有变化，直接返回
      var camera = this.viewer.camera;
      var _thiscache = _position.x + "=" + _position.y + "-" + _position.z + "-" + camera.positionWC.x + "=" + camera.positionWC.y + "-" + camera.positionWC.z + "-" + camera.heading + "-" + camera.pitch + "-" + camera.roll;
      if (_thiscache == this._camera_cache) {
        return true;
      }
      this._camera_cache = _thiscache;
      //如果视角和位置都没有变化，直接返回

      var newpoint = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, _position);
      if (Cesium.defined(newpoint)) {
        point = newpoint;
        if (this.objPopup[eleId]) this.objPopup[eleId].viewPoint = newpoint;
      }

      var _dom = (0, _zepto.zepto)("#" + eleId);
      if (!Cesium.defined(point)) {
        daslog.log("wgs84ToWindowCoordinates无法转换为屏幕坐标", _position);
        _dom.hide();
        return true;
      }

      //判断是否在球的背面
      var scene = this.viewer.scene;
      if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
        //三维模式下
        var occluder = new Cesium.EllipsoidalOccluder(scene.globe.ellipsoid, scene.camera.positionWC);
        var visible = occluder.isPointVisible(_position);
        //visible为true说明点在球的正面，否则点在球的背面。
        //需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true
        if (!visible) {
          _dom.hide();
          return true;
        }
      }
      //判断是否在球的背面

      _dom.show();

      //更新html ，实时更新
      if ((typeof popup === "undefined" ? "undefined" : _typeof(popup)) === "object" && popup.timeRender && popup.html && typeof popup.html === "function") {
        var inhtml = popup.html(this.objPopup[eleId] && this.objPopup[eleId].entity, _position);
        (0, _zepto.zepto)("#" + eleId + " .das3d-popup-content").html(inhtml);
      }

      var x = point.x - _dom.width() / 2;
      var y = point.y - _dom.height();

      if (popup && (typeof popup === "undefined" ? "undefined" : _typeof(popup)) === "object" && popup.anchor) {
        x += popup.anchor[0];
        y += popup.anchor[1];
      }
      _dom.css("transform", "translate3d(" + x + "px," + y + "px, 0)");

      return true;
    }

    //固定显示再一个配置的popupPosition位置（类似弹窗）

  }, {
    key: "showFixViewPoint",
    value: function showFixViewPoint(eleId, position, popup, popupPosition) {
      //更新html ，实时更新
      if ((typeof popup === "undefined" ? "undefined" : _typeof(popup)) === "object" && popup.timeRender && popup.html && typeof popup.html === "function") {
        var inhtml = popup.html(this.objPopup[eleId] && this.objPopup[eleId].entity, position);
        (0, _zepto.zepto)("#" + eleId + " .das3d-popup-content").html(inhtml);
      }

      var _dom = (0, _zepto.zepto)("#" + eleId);

      var x = 0;
      if (Cesium.defined(popupPosition.left)) x = popupPosition.left;
      if (Cesium.defined(popupPosition.right)) {
        x = document.documentElement.clientWidth - _dom.width() - popupPosition.right;
      }

      var y = 0;
      if (Cesium.defined(popupPosition.top)) y = popupPosition.top;
      if (Cesium.defined(popupPosition.bottom)) {
        y = document.documentElement.clientHeight - _dom.height() - popupPosition.bottom;
      }

      _dom.css("transform", "translate3d(" + x + "px," + y + "px, 0)");

      return true;
    }
  }, {
    key: "bind2scene",
    value: function bind2scene() {
      for (var i in this.objPopup) {
        var item = this.objPopup[i];
        if (item.popupPosition) continue;

        var result = this.updateViewPoint(i, item.cartesian, item.popup, item.viewPoint);
        if (!result && this._depthTest) {
          this.close(i);
        }
      }
    }
  }, {
    key: "getPopupId",
    value: function getPopupId(entity) {
      var eleId = this.viewerid + "popup_" + ((entity.id || "") + "").replace(new RegExp("[^0-9a-zA-Z_]", "gm"), "_");
      return eleId;
    }
  }, {
    key: "close",
    value: function close(eleId, removFea) {
      if (!this._isOnly && eleId) {
        if ((typeof eleId === "undefined" ? "undefined" : _typeof(eleId)) === "object") {
          //传入参数是eneity对象
          eleId = this.getPopupId(eleId);
        }

        for (var i in this.objPopup) {
          if (eleId == this.objPopup[i].id || eleId == i) {
            //popup的DOM从页面移除的回调方法
            if (this.objPopup[i] && this.objPopup[i].onRemove) {
              this.objPopup[i].onRemove(i, this.objPopup[i].entity);
            }

            (0, _zepto.zepto)("#" + i).remove();
            delete this.objPopup[i];
            break;
          }
        }
      } else {
        for (var _i in this.objPopup) {
          //popup的DOM从页面移除的回调方法
          if (this.objPopup[_i] && this.objPopup[_i].onRemove) {
            this.objPopup[_i].onRemove(_i, this.objPopup[_i].entity);
          }
        }

        (0, _zepto.zepto)("#" + this.viewerid + "-das3d-pupup-all").empty();
        this.objPopup = {};
      }
      this._camera_cache = null;

      if (removFea) {
        this.removeFeatureForImageryLayer();
        this.removeFeatureFor3dtiles();
      }
    }

    //=====================单击高亮对象处理========================
    //单击Tile瓦片时同步，高亮显示要素处理

  }, {
    key: "removeFeatureForImageryLayer",
    value: function removeFeatureForImageryLayer() {
      if (this.lastShowFeature == null) return;
      this.viewer.dataSources.remove(this.lastShowFeature);
      this.lastShowFeature = null;
    }
  }, {
    key: "showFeatureForImageryLayer",
    value: function showFeatureForImageryLayer(item, style) {
      var that = this;
      this.removeFeatureForImageryLayer();

      var feature = item;
      if (item.geometryType && item.geometryType.indexOf("esri") != -1) {
        //arcgis图层时
        var L = window.das3d.L || window.L;
        if (L && L.esri) {
          feature = L.esri.Util.arcgisToGeoJSON(item.geometry);
        } else {
          daslog.warn("需要引入 das-esri 插件解析arcgis标准的json数据！");
          return;
        }
      } else if (item.geometry && item.geometry.type) {
        var _L = window.das3d.L || window.L;
        if (_L) {
          //处理数据里面的坐标为4326
          var geojson = _L.geoJSON(item.geometry, {
            coordsToLatLng: function coordsToLatLng(coords) {
              if (coords[0] > 180 || coords[0] < -180) {
                return _L.CRS.EPSG3857.unproject(_L.point(coords[0], coords[1]));
              }
              return new _L.LatLng(coords[1], coords[0], coords[2]);
            }
          });
          feature = geojson.toGeoJSON();
        }
      }

      if (feature == null) return;

      var loadOpts;
      if (style) {
        loadOpts = {
          clampToGround: Cesium.defaultValue(style.clampToGround, false),
          fill: Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5))),
          stroke: Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0))),
          strokeWidth: Cesium.defaultValue(style.outlineWidth, 1)
        };
      }

      var dataSource = Cesium.GeoJsonDataSource.load(feature, loadOpts);
      dataSource.then(function (dataSource) {
        that.viewer.dataSources.add(dataSource);
        that.lastShowFeature = dataSource;

        if (style) {
          var entities = dataSource.entities.values;
          (0, _config2Entity.style2Entity)(entities, style);

          if (Cesium.defined(style.showTime)) {
            //定时自动关闭
            setTimeout(function () {
              that.removeFeatureForImageryLayer();
            }, style.showTime);
          }
        }
      }).otherwise(function (error) {
        daslog.warn("json加载出错", error);
      });
    }

    //单击3dtiles单体化，高亮显示构件处理

  }, {
    key: "removeFeatureFor3dtiles",
    value: function removeFeatureFor3dtiles() {
      if (Cesium.defined(this.highlighted.feature)) {
        try {
          this.highlighted.feature.color = this.highlighted.originalColor;
        } catch (ex) {
          //
        }
        this.highlighted.feature = undefined;
      }
    }
  }, {
    key: "showFeatureFor3dtiles",
    value: function showFeatureFor3dtiles(pickedFeature, style) {
      this.removeFeatureFor3dtiles();
      this.highlighted.feature = pickedFeature;

      // Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);

      if (style) {
        pickedFeature.color = Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));
      } else {
        pickedFeature.color = this.defaultHighlightedClr;
      }
    }

    //=================================================

  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      this.viewer.scene.postRender.removeEventListener(this.bind2scene, this);
      this.viewer.das.off(_DasClass.eventType.click, this.mousePickingClick, this);

      (0, _zepto.zepto)("#" + this.viewerid + "-das3d-pupup-all").remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "isOnly",
    get: function get() {
      return this._isOnly;
    },
    set: function set(val) {
      this._isOnly = val;
    }

    //是否禁用

  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(value) {
      this._enable = value;
      if (!value) {
        this.close();
      }
    }

    //是否打开深度判断（true时判断是否在球背面）

  }, {
    key: "depthTest",
    get: function get() {
      return this._depthTest;
    },
    set: function set(value) {
      this._depthTest = value;
    }
  }]);

  return Popup;
}();

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tooltip = exports.Tooltip = function () {
  //========== 构造方法 ==========
  function Tooltip(viewer, options) {
    _classCallCheck(this, Tooltip);

    this.viewer = viewer;
    this.options = options || {};

    this._enable = true;
    this.viewerid = viewer._container.id;
    this.tooltipcontentid = this.viewerid + "-das3d-tooltip-content";

    this.highlighted = {
      feature: undefined,
      originalColor: new Cesium.Color()
    };
    this.defaultHighlightedClr = Cesium.Color.fromCssColorString("#95e40c");

    //兼容历史接口
    this.getTooltipForConfig = _util.getTooltipForConfig;

    //添加弹出框
    var infoDiv = "<div id=\"" + this.viewerid + "-das3d-tooltip-view\" class=\"das3d-popup\" style=\"display:none;\">\n                 <div class=\"das3d-popup-content-wrapper  das3d-popup-background\">\n                     <div id=\"" + this.tooltipcontentid + "\" class=\"das3d-popup-content das3d-popup-color\"></div>\n                 </div>\n                 <div class=\"das3d-popup-tip-container\"><div class=\"das3d-popup-tip  das3d-popup-background\"></div></div>\n           </div> ";
    (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

    this._tooltipDOM = (0, _zepto.zepto)("#" + this.viewerid + "-das3d-tooltip-view");
    this._tooltipContentDOM = (0, _zepto.zepto)("#" + this.tooltipcontentid);

    //鼠标移动事件
    this.options.cacheTime = Cesium.defaultValue(this.options.cacheTime, 100);
    this.viewer.das.on(_DasClass.eventType.mouseMove, this.mouseMoveHandler, this);

    this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    this.handler.setInputAction(function (event) {
      //鼠标移动事件
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  }

  //========== 对外属性 ==========

  //是否禁用


  _createClass(Tooltip, [{
    key: "mouseMoveHandler",


    //========== 方法 ==========
    //鼠标移动事件，setTimeout是为了优化效率
    value: function mouseMoveHandler(event) {
      var _this = this;

      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
      this.moveTimer = setTimeout(function () {
        delete _this.moveTimer;
        _this.mouseMovingPicking(event);
      }, this.options.cacheTime);
    }
    //鼠标移动事件

  }, {
    key: "mouseMovingPicking",
    value: function mouseMovingPicking(event) {
      var _this2 = this;

      if (!this._enable) return;

      (0, _zepto.zepto)(".cesium-viewer").css("cursor", "");

      if (this.viewer.scene.screenSpaceCameraController.enableRotate === false || this.viewer.scene.screenSpaceCameraController.enableTilt === false || this.viewer.scene.screenSpaceCameraController.enableTranslate === false) {
        this.close();
        return;
      }

      var position = event.endPosition;

      var entity; //鼠标感知的对象，可能是entity或primitive等
      var pickedObject;
      try {
        pickedObject = this.viewer.scene.pick(position, 5, 5);
      } catch (e) {}
      //


      //普通entity对象 && this.viewer.scene.pickPositionSupported
      if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
        entity = pickedObject.id;
      }
      //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
      else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
          var cfg = pickedObject.tileset.das.options;

          //取属性
          var attr = {};
          var names = pickedObject.getPropertyNames();
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            if (!pickedObject.hasProperty(name)) continue;

            var val = pickedObject.getProperty(name);
            if (val == null) continue;
            attr[name] = val;
          }

          entity = {
            id: pickedObject._batchId,
            tooltip: {
              html: (0, _util.getTooltipForConfig)(cfg, attr),
              anchor: cfg.popupAnchor || [0, -15]
            },
            attr: attr, //回调方法中用
            feature: pickedObject, //回调方法中用
            eventTarget: pickedObject.tileset.eventTarget
          };
          if (!cfg.noMouseMove) {
            if (cfg.mouseover) entity.mouseover = cfg.mouseover;
            if (cfg.mouseout) entity.mouseout = cfg.mouseout;
          }

          //高亮显示单体对象
          if (cfg.showMoveFeature) {
            this.showFeatureFor3dtiles(pickedObject, cfg.moveFeatureColor);
          }
        }
        //primitive对象
        else if (pickedObject && Cesium.defined(pickedObject.primitive)) {
            entity = pickedObject.primitive;
          }

      if (entity) {
        //存在鼠标感知的对象
        if (entity.popup || entity.click || entity.cursorCSS) {
          (0, _zepto.zepto)(".cesium-viewer").css("cursor", entity.cursorCSS || "pointer");
        }

        //单击对象所关联的管理类(基于DasClass)，进行mouseMove事件抛出。
        if (entity.eventTarget && entity.eventTarget.fire) {
          entity.eventTarget.fire(_DasClass.eventType.mouseMove, {
            sourceTarget: entity,
            position: position
          });
        }

        //加统一的 mouseover 鼠标移入处理
        if (!entity.noMouseMove) {
          //排除标识了不处理其移入事件的对象 ，比如高亮对象本身
          if (this.lastTime) {
            clearTimeout(this.lastTime);
            this.lastTime = null;
          }
          this.lastTime = setTimeout(function (e) {
            _this2.lastTime = null;
            _this2.activateMouseOver(entity, position);
          }, 20);
        }

        //tooltip
        if (entity.tooltip) {
          var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
          this.show(entity, cartesian, position);
        } else {
          this.close();
        }
      } else {
        this.close();

        if (this.lastTime) {
          clearTimeout(this.lastTime);
          this.lastTime = null;
        }
        this.lastTime = setTimeout(function (e) {
          _this2.lastTime = null;
          _this2.activateMouseOut();
        }, 20);
      }
    }
  }, {
    key: "show",
    value: function show(entity, cartesian, position) {
      if (entity == null || entity.tooltip == null) return;

      //计算显示位置
      if (position == null) position = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, cartesian);
      if (position == null) {
        this.close();
        return;
      }

      if (this._lastTooltipEntity !== entity) {
        //避免鼠标移动时重复构造DOM
        //显示内容
        var inhtml;
        var onAdd;
        if (_typeof(entity.tooltip) === "object") {
          inhtml = entity.tooltip.html;
          onAdd = entity.tooltip.onAdd;
          this.onRemove = entity.tooltip.onRemove;

          if (typeof entity.tooltip.visible === "function") {
            if (!entity.tooltip.visible(entity)) {
              this.close();
              return;
            }
          }
        } else {
          inhtml = entity.tooltip;
        }

        if (typeof inhtml === "function") {
          inhtml = inhtml(entity, cartesian); //回调方法
        }
        if (!inhtml) return;

        this._tooltipContentDOM.html(inhtml);
        this._tooltipDOM.show();

        //tooltip的DOM添加到页面的回调方法
        if (onAdd) onAdd(this.tooltipcontentid);
      }
      this._lastTooltipEntity = entity;

      //定位位置
      var x = position.x - this._tooltipDOM.width() / 2;
      var y = position.y - this._tooltipDOM.height();

      var tooltip = entity.tooltip;
      if (tooltip && (typeof tooltip === "undefined" ? "undefined" : _typeof(tooltip)) === "object" && tooltip.anchor) {
        x += tooltip.anchor[0];
        y += tooltip.anchor[1];
      } else {
        y -= 15; //默认偏上10像素
      }
      this._tooltipDOM.css("transform", "translate3d(" + x + "px," + y + "px, 0)");
    }
  }, {
    key: "close",
    value: function close() {
      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
      if (this.onRemove) {
        this.onRemove(this.tooltipcontentid);
        delete this.onRemove;
      }

      this._tooltipContentDOM.empty();
      this._tooltipDOM.hide();

      this.removeFeatureFor3dtiles();
      delete this._lastTooltipEntity;
    }
  }, {
    key: "activateMouseOver",
    value: function activateMouseOver(entity, position) {
      if (this._lastMouseEntity === entity) return;

      this.activateMouseOut();

      if (entity.mouseover && typeof entity.mouseover === "function") entity.mouseover(entity, position);
      //鼠标移入对象所关联的管理类(基于DasClass)，进行mouseOver事件抛出。
      if (entity.eventTarget && entity.eventTarget.fire) {
        entity.eventTarget.fire(_DasClass.eventType.mouseOver, {
          sourceTarget: entity,
          position: position
        });
      }

      this._lastMouseEntity = entity;
    }
  }, {
    key: "activateMouseOut",
    value: function activateMouseOut() {
      if (this._lastMouseEntity == null) return;

      if (this._lastMouseEntity.mouseout && typeof this._lastMouseEntity.mouseout === "function") this._lastMouseEntity.mouseout(this._lastMouseEntity);
      //鼠标移入对象所关联的管理类(基于DasClass)，进行mouseOver事件抛出。
      if (this._lastMouseEntity.eventTarget && this._lastMouseEntity.eventTarget.fire) {
        this._lastMouseEntity.eventTarget.fire(_DasClass.eventType.mouseOut, {
          sourceTarget: this._lastMouseEntity
        });
      }
      this._lastMouseEntity = null;
    }

    //=====================高亮对象处理========================
    //鼠标移入3dtiles单体化，高亮显示构件处理

  }, {
    key: "removeFeatureFor3dtiles",
    value: function removeFeatureFor3dtiles() {
      if (Cesium.defined(this.highlighted.feature)) {
        try {
          this.highlighted.feature.color = this.highlighted.originalColor;
        } catch (ex) {
          //
        }
        this.highlighted.feature = undefined;
      }
    }
  }, {
    key: "showFeatureFor3dtiles",
    value: function showFeatureFor3dtiles(pickedFeature, color) {
      this.removeFeatureFor3dtiles();
      this.highlighted.feature = pickedFeature;

      // Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);
      if (color && typeof color === "string") color = Cesium.Color.fromCssColorString(color);
      pickedFeature.color = color || this.defaultHighlightedClr;
    }

    //=================================================

  }, {
    key: "destroy",
    value: function destroy() {
      this.close();
      this.viewer.das.off(_DasClass.eventType.mouseMove, this.mouseMoveHandler, this);
      this._tooltipDOM.remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(value) {
      this._enable = value;
      if (!value) {
        this.close();
      }
    }
  }]);

  return Tooltip;
}();

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextMenu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ContextMenu = exports.ContextMenu = function () {
  //========== 构造方法 ==========
  function ContextMenu(viewer, options) {
    var _this = this;

    _classCallCheck(this, ContextMenu);

    this.viewer = viewer;
    this.viewerid = viewer._container.id;

    this._enable = true;
    this.menuIndex = 0;
    this.objMenu = {};

    //添加弹出框
    var infoDiv = "<div id=\"" + this.viewerid + "-das3d-contextmenu\" class=\"das3d-contextmenu\" style=\"display:none;\">\n                            <ul id=\"" + this.viewerid + "-das3d-contextmenu-ul\" class=\"das3d-contextmenu-ul\"> \n                            </ul>\n                        </div>";
    (0, _zepto.zepto)("#" + viewer._container.id).append(infoDiv);

    this._contextmenuDOM = (0, _zepto.zepto)("#" + this.viewerid + "-das3d-contextmenu");
    this._contextmenuULDOM = (0, _zepto.zepto)("#" + this.viewerid + "-das3d-contextmenu-ul");

    var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function (event) {
      _this.close();
    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
    handler.setInputAction(function (event) {
      _this.close();
    }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
    handler.setInputAction(function (event) {
      _this.close();
    }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
    handler.setInputAction(function (event) {
      _this.close();
    }, Cesium.ScreenSpaceEventType.PINCH_START);
    handler.setInputAction(function (event) {
      _this.close();
    }, Cesium.ScreenSpaceEventType.WHEEL);
    handler.setInputAction(function (event) {
      _this.close();
      if (!_this._enable) return;

      var position = event.position;

      var entity; //鼠标感知的对象，可能是entity或primitive
      var pickedObject = viewer.scene.pick(position, 5, 5);

      // fangmm 拾取到的第一个entity是鼠标按下显示的图标
      if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
        if (pickedObject.id.id === 'mouseCursorIcon') {
          pickedObject = viewer.scene.drillPick(position)[1];
        }
      }

      var contextmenuItems = viewer.das.contextmenuItems;
      //普通entity对象
      if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
        entity = pickedObject.id;
        if (Cesium.defined(entity.contextmenuItems)) contextmenuItems = entity.contextmenuItems;
      }
      //primitive对象
      else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive)) {
          entity = pickedObject.primitive;
          if (Cesium.defined(entity.contextmenuItems) || Cesium.defined(entity._config) && Cesium.defined(entity._config.contextmenuItems)) contextmenuItems = entity.contextmenuItems || entity._config.contextmenuItems;
        }

      _this.showView(contextmenuItems, position, entity);
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    this.handler = handler;
  }

  //========== 对外属性 ==========

  //是否禁用


  _createClass(ContextMenu, [{
    key: "showView",


    //========== 方法 ==========

    value: function showView(contextmenu, positionMouse, entity) {
      if (!contextmenu || contextmenu.length == 0) {
        this.close();
        return;
      }

      var cartesian = point.getCurrentMousePosition(this.viewer.scene, positionMouse);

      var inhtml = "";
      for (var i = 0, len = contextmenu.length; i < len; i++) {
        var item = contextmenu[i];
        var result = this.getItemHtml(item, {
          positionMouse: positionMouse,
          position: cartesian,
          target: entity
        });
        if (result) inhtml += result;
      }

      if (inhtml == "") {
        this.close();
        return;
      }

      var that = this;
      this._contextmenuULDOM.html(inhtml);
      (0, _zepto.zepto)("#" + this.viewerid + "-das3d-contextmenu-ul .contextmenu-item").click(function (e) {
        var index = Number((0, _zepto.zepto)(this).attr("data-index"));
        var item = that.objMenu[index];
        var callback = item.callback || item.calback; //兼容不同参数名
        if (callback) {
          callback({
            positionMouse: positionMouse,
            position: cartesian,
            data: item,
            target: entity
          });
        }
        that.close();
      });

      //鼠标滑过弹出二级菜单
      (0, _zepto.zepto)("#" + this.viewerid + "-das3d-contextmenu-ul .contextmenu-item").mouseover(function (e) {
        (0, _zepto.zepto)(".das3d-sub-menu").hide(); //所有的二级菜单隐藏

        var sub_menu = this.querySelector(".das3d-sub-menu");
        if (sub_menu) {
          sub_menu.style.display = "block";
        }

        (0, _zepto.zepto)("#" + that.viewerid + "-das3d-contextmenu-ul .active").removeClass("active");
        (0, _zepto.zepto)(this).addClass("active");
      });

      var top = positionMouse.y;
      var left = positionMouse.x;
      this._contextmenuDOM.css({
        //不显示前，无法计算width和width
        top: top,
        left: left
      }).show();
      this._show = true;
      this._target = entity;

      var menuHeight = this._contextmenuDOM.height();
      var menuWidth = this._contextmenuDOM.width();

      (0, _zepto.zepto)("#" + this.viewerid + "-das3d-contextmenu-ul .das3d-sub-menu").css({
        left: menuWidth + 3 + "px"
      });

      //判断垂直方向 是否超过了 屏幕高度
      if (top + menuHeight > this.viewer.scene.canvas.clientHeight) {
        top -= menuHeight - 10;
        if (top <= 0) top = 0;
      } else {
        top += 10;
      }

      //判断水平方向 是否超过了屏幕宽度
      if (left + menuWidth > this.viewer.scene.canvas.clientWidth) {
        left -= menuWidth - 10;
        if (left <= 0) left = 0;
      } else {
        left += 10;
      }

      this._contextmenuDOM.css({
        top: top,
        left: left
      });
    }
  }, {
    key: "getItemHtml",
    value: function getItemHtml(item, eventresult) {
      if (item.hasOwnProperty("visible")) {
        var visible = item.visible;
        try {
          if (typeof visible === "function") {
            //回调方法
            eventresult.data = item;
            visible = item.visible(eventresult);
          }
        } catch (e) {
          daslog.error("右键菜单操作出错", e);
        }

        if (!visible) return null;
      }

      var inhtml;
      if (item.text) {
        var childrenHtml = "";
        var childTip = "";
        if (item.children) {
          childrenHtml = '<ul class="das3d-contextmenu-ul das3d-sub-menu">';
          for (var j = 0, len2 = item.children.length; j < len2; j++) {
            var childitem = item.children[j];
            eventresult.data = childitem;
            var result = this.getItemHtml(childitem, eventresult);
            if (result) childrenHtml += result;
          }
          childrenHtml += "</ul>";
          childTip = '&nbsp;&nbsp;<i class="fa fa-caret-right"></i>';
        }

        this.menuIndex++;
        this.objMenu[this.menuIndex] = item;

        inhtml = "<li class=\"contextmenu-item\" data-index=\"" + this.menuIndex + "\">\n                        <a href=\"javascript:void(0)\"><i class=\"" + item.iconCls + "\"></i>" + item.text + childTip + "</a>\n                        " + childrenHtml + "\n                    </li>";
      } else inhtml = '<li class="line"></li>';
      return inhtml;
    }
  }, {
    key: "close",
    value: function close() {
      if (!this._show) return;
      this._contextmenuDOM.hide();
      this._show = false;
      this._target = null;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.close();

      this.handler.destroy();
      this._contextmenuDOM.remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(value) {
      this._enable = value;
      if (!value) {
        this.close();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    }
  }, {
    key: "target",
    get: function get() {
      return this._target;
    }
  }]);

  return ContextMenu;
}();

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Location = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util2 = __webpack_require__(3);

var _util = _interopRequireWildcard(_util2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//“鼠标经纬度提示”控件
var Location = exports.Location = function () {
  //========== 构造方法 ==========
  function Location(viewer, options) {
    var _this = this;

    _classCallCheck(this, Location);

    this.viewer = viewer;
    this.options = options;

    this.format = options.format || "<div>经度:{x}</div> <div>纬度:{y}</div> <div>海拔：{z}米</div> <div>方向：{heading}度</div> <div>俯仰角：{pitch}度</div>  <div>视高：{height}米</div>";

    var containerid = viewer._container.id + "-das3d-location";
    var inhtml = '<div id="' + containerid + '"  class="das3d-locationbar animation-slide-bottom no-print" ><div class="das3d-locationbar-content"></div></div>';
    (0, _zepto.zepto)("#" + viewer._container.id).append(inhtml);

    this._dom = (0, _zepto.zepto)("#" + containerid);
    this._domContent = (0, _zepto.zepto)("#" + containerid + " .das3d-locationbar-content");

    if (options.style) this._dom.css(options.style);else {
      this._dom.css({
        left: viewer.animation ? "170px" : "0",
        right: "0",
        bottom: viewer.timeline ? "25px" : "0"
      });
    }
    this._visible = true;

    this.locationData = {};
    this.locationData.height = viewer.camera.positionCartographic.height.toFixed(1);
    this.locationData.heading = Cesium.Math.toDegrees(viewer.camera.heading).toFixed(0);
    this.locationData.pitch = Cesium.Math.toDegrees(viewer.camera.pitch).toFixed(0);

    this.options.cacheTime = Cesium.defaultValue(this.options.cacheTime, 100);
    this.viewer.das.on(_DasClass.eventType.mouseMove, this.mouseMoveHandler, this);

    //帧率
    if (options.fps) {
      // 帧率的计算借助了Cesium中的东西，需要开启debugShowFramesPerSecond
      viewer.scene.debugShowFramesPerSecond = true;

      var timeTik = setInterval(function () {
        if (!viewer || !viewer.scene._performanceDisplay) return;
        clearInterval(timeTik);
        _this.timeTik = null;

        var domFPS = (0, _zepto.zepto)(".cesium-performanceDisplay");

        //修改样式
        domFPS.addClass("das3d-locationbar-content").removeClass("cesium-performanceDisplay");

        //移除空节点
        domFPS.children(".cesium-performanceDisplay-throttled").remove();

        //添加到状态栏
        _this._dom.prepend(domFPS);
      }, 500);
      this.timeTik = timeTik;
    }

    //相机移动结束事件
    viewer.scene.camera.moveEnd.addEventListener(this.updaeCamera, this);
  }

  //========== 对外属性 ==========
  //是否显示


  _createClass(Location, [{
    key: "mouseMoveHandler",


    //========== 方法 ==========
    //鼠标移动事件，setTimeout是为了优化效率
    value: function mouseMoveHandler(event) {
      var _this2 = this;

      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
      this.moveTimer = setTimeout(function () {
        delete _this2.moveTimer;
        _this2.updateData(event);
      }, this.options.cacheTime);
    }
  }, {
    key: "updateData",
    value: function updateData(movement) {
      if (!this._visible) return;

      if (this.viewer.scene.mode !== Cesium.SceneMode.SCENE3D) {
        return;
      }

      var cartesian = point.getCurrentMousePosition(this.viewer.scene, movement.endPosition);
      if (!cartesian) return;

      var cartographic = Cesium.Cartographic.fromCartesian(cartesian);

      this.locationData.z = (cartographic.height / this.viewer.scene.terrainExaggeration).toFixed(1);
      this.locationData.height = this.viewer.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(0);
      this.locationData.pitch = Cesium.Math.toDegrees(this.viewer.camera.pitch).toFixed(0);
      this.locationData.level = this.viewer.das.level;

      var jd = Cesium.Math.toDegrees(cartographic.longitude);
      var wd = Cesium.Math.toDegrees(cartographic.latitude);
      var fixedLen;
      switch (this.options.crs) {
        default:
          //和地图一致的原坐标
          fixedLen = this.options.hasOwnProperty("toFixed") ? this.options.toFixed : 6;
          this.locationData.x = jd.toFixed(fixedLen);
          this.locationData.y = wd.toFixed(fixedLen);
          break;
        case "degree":
          //度分秒形式
          this.locationData.x = _util.formatDegree(jd);
          this.locationData.y = _util.formatDegree(wd);
          break;
        case "project":
          //投影坐标
          fixedLen = this.options.hasOwnProperty("toFixed") ? this.options.toFixed : 0;
          var mkt = pointconvert.cartesian2mercator([cartesian.x, cartesian.y]);
          this.locationData.x = mkt[0].toFixed(fixedLen);
          this.locationData.y = mkt[1].toFixed(fixedLen);
          break;

        case "wgs":
          //标准wgs84格式坐标
          fixedLen = this.options.hasOwnProperty("toFixed") ? this.options.toFixed : 6;
          var wgsPoint = this.viewer.das.point2wgs({ x: jd, y: wd }); //坐标转换为wgs
          this.locationData.x = wgsPoint.x.toFixed(fixedLen);
          this.locationData.y = wgsPoint.y.toFixed(fixedLen);
          break;
        case "wgs-degree":
          //标准wgs84格式坐标
          var wgsPointD = this.viewer.das.point2wgs({ x: jd, y: wd }); //坐标转换为wgs
          this.locationData.x = _util.formatDegree(wgsPointD.x);
          this.locationData.y = _util.formatDegree(wgsPointD.y);
          break;
      }

      var inhtml;
      if (typeof this.format === "function") {
        //回调方法
        inhtml = this.format(this.locationData);
      } else {
        inhtml = _util.template(this.format, this.locationData);
      }
      this._domContent.html(inhtml);
    }
  }, {
    key: "updaeCamera",
    value: function updaeCamera() {
      if (!this._visible) return;

      if (this.viewer.scene.mode !== Cesium.SceneMode.SCENE3D) {
        return;
      }

      this.locationData.height = this.viewer.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(0);
      this.locationData.pitch = Cesium.Math.toDegrees(this.viewer.camera.pitch).toFixed(0);
      this.locationData.level = this.viewer.das.level;

      if (this.locationData.x == null) return;

      var inhtml;
      if (typeof this.format === "function") {
        //回调方法
        inhtml = this.format(this.locationData);
      } else {
        inhtml = _util.template(this.format, this.locationData);
      }

      this._domContent.html(inhtml);
    }
  }, {
    key: "css",
    value: function css(style) {
      this._dom.css(style);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      //相机移动结束事件
      this.viewer.scene.camera.moveEnd.removeEventListener(this.updaeCamera, this);
      this.viewer.das.off(_DasClass.eventType.mouseMove, this.mouseMoveHandler, this);

      if (this.options.fps) {
        this.viewer.scene.debugShowFramesPerSecond = false;
      }

      if (this.timeTik) {
        clearInterval(this.timeTik);
        this.timeTik = null;
      }

      this._dom.remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._visible;
    },
    set: function set(value) {
      this._visible = value;

      if (value) this._dom.show();else this._dom.hide();
    }
  }]);

  return Location;
}();

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MouseZoomStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _point = __webpack_require__(2);

var point = _interopRequireWildcard(_point);

var _util2 = __webpack_require__(3);

var _util = _interopRequireWildcard(_util2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//鼠标旋转、放大时的美化图标
var MouseZoomStyle = exports.MouseZoomStyle = function () {
  //========== 构造方法 ==========
  function MouseZoomStyle(viewer, options) {
    var _this = this;

    _classCallCheck(this, MouseZoomStyle);

    this.viewer = viewer;
    this.options = options || {};

    var containerid = viewer._container.id + "-das3d-mousezoom";
    (0, _zepto.zepto)("#" + viewer._container.id).append('<div id="' + containerid + '" class="das3d-mousezoom"><div class="zoomimg"/></div>');
    this._dom = (0, _zepto.zepto)("#" + containerid);

    this.enable = Cesium.defaultValue(this.options.enable, true);

    var timetik = -1;
    var that = this;
    var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
    handler.setInputAction(function (evnet) {
      if (!_this._enable) return;
      // this._dom.addClass("das3d-mousezoom-visible");
      clearTimeout(timetik);
      timetik = setTimeout(function () {
        //  that._dom.removeClass("das3d-mousezoom-visible");
      }, 200);
    }, Cesium.ScreenSpaceEventType.WHEEL);

    handler.setInputAction(function (evnet) {
      if (!_this._enable) return;
      var position = point.getCurrentMousePosition(viewer.scene, evnet.position);
      if (!position) return;

      if (viewer.camera.positionCartographic.height > viewer.scene.screenSpaceCameraController.minimumCollisionTerrainHeight) return;

      handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      clearTimeout(timetik);
      _this._dom.css({
        top: evnet.position.y + "px",
        left: evnet.position.x + "px"
      });
      // this._dom.addClass("das3d-mousezoom-visible");
    }, options.rightDrag ? Cesium.ScreenSpaceEventType.RIGHT_DOWN : Cesium.ScreenSpaceEventType.MIDDLE_DOWN);

    handler.setInputAction(function (evnet) {
      //  this._dom.removeClass("das3d-mousezoom-visible");
      handler.setInputAction(function (evnet) {
        that._dom.css({
          top: evnet.endPosition.y + "px",
          left: evnet.endPosition.x + "px"
        });
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }, options.rightDrag ? Cesium.ScreenSpaceEventType.RIGHT_UP : Cesium.ScreenSpaceEventType.MIDDLE_UP);

    this.handler = handler;
  }

  //========== 对外属性 ==========

  //是否显示


  _createClass(MouseZoomStyle, [{
    key: "destroy",


    //========== 方法 ==========

    value: function destroy() {
      if (this.handler) {
        this.handler.destroy();
        delete this.handler;
      }
      this._dom.remove();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(val) {
      this._enable = val;
      if (val) this._dom.show();else this._dom.hide();
    }
  }]);

  return MouseZoomStyle;
}();

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ES5BaseWidget = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _loader = __webpack_require__(49);

var _widgetManager = __webpack_require__(48);

var _ES5Class = __webpack_require__(144);

var _zepto = __webpack_require__(7);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var layer = window.layer; //请引入layer弹窗插件

var _resources_cache = [];

var ES5BaseWidget = exports.ES5BaseWidget = _ES5Class.ES5Class.extend({
  viewer: null,
  options: {},
  config: {}, //配置的config信息
  path: "", //当前widget目录相对路径
  isActivate: false, //是否激活状态
  isCreate: false,
  initialize: function initialize(cfg, map) {
    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (cfg instanceof Cesium.Viewer) {
      var temppar = cfg;
      cfg = map;
      map = temppar;
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    this.viewer = map;
    this.config = cfg;
    this.path = cfg.path || "";
    this.init();
  },
  addCacheVersion: function addCacheVersion(_resource) {
    if (_resource == null) return _resource;

    var cacheVersion = (0, _widgetManager.getCacheVersion)();
    if (cacheVersion) {
      if (_resource.indexOf("?") == -1) _resource += "?time=" + cacheVersion;else if (_resource.indexOf("time=" + cacheVersion) == -1) _resource += "&time=" + cacheVersion;
    }
    return _resource;
  },
  //激活插件
  activateBase: function activateBase() {
    var that = this;

    if (this.isActivate) {
      //已激活状态时跳出
      this.changeWidgetView(function (viewopt) {
        if (viewopt._dom) {
          //将层置顶
          (0, _zepto.zepto)(".layui-layer").each(function () {
            (0, _zepto.zepto)(this).css("z-index", 19891000);
          });
          (0, _zepto.zepto)(viewopt._dom).css("z-index", 19891014);
        }
      });
      return;
    }

    this.beforeActivate();
    this.isActivate = true;
    //daslog.log('激活widget:' + this.config.uri);

    if (!this.isCreate) {
      //首次进行创建
      if (this.options.resources && this.options.resources.length > 0) {
        var resources = [];

        for (var i = 0; i < this.options.resources.length; i++) {
          var _resource = this.options.resources[i];
          _resource = this._getUrl(_resource);

          if (_resources_cache.indexOf(_resource) != -1) continue; //不加重复资源

          resources.push(_resource);
        }
        _resources_cache = _resources_cache.concat(resources); //不加重复资源

        _loader.Loader.async(resources, function () {
          var result = that.create(function () {
            that._createWidgetView();
            that.isCreate = true;
          });
          if (result) return;
          if (that.config.createAtStart) {
            that.config.createAtStart = false;
            that.isActivate = false;
            that.isCreate = true;
            return;
          }
          that._createWidgetView();
          that.isCreate = true;
        });
        return;
      } else {
        var result = this.create(function () {
          that._createWidgetView();
          this.isCreate = true;
        });
        if (result) return;
        if (that.config.createAtStart) {
          that.config.createAtStart = false;
          that.isActivate = false;
          that.isCreate = true;
          return;
        }
      }
      this.isCreate = true;
    }
    this._createWidgetView();

    return this;
  },
  //创建插件的view
  _createWidgetView: function _createWidgetView() {
    var viewopt = this.options.view;
    if (viewopt === undefined || viewopt === null) {
      this._startActivate();
    } else if ((0, _util.isArray)(viewopt)) {
      this._viewcreate_allcount = viewopt.length;
      this._viewcreate_okcount = 0;

      for (var i = 0; i < viewopt.length; i++) {
        this.createItemView(viewopt[i]);
      }
    } else {
      this._viewcreate_allcount = 1;
      this._viewcreate_okcount = 0;
      this.createItemView(viewopt);
    }
  },
  changeWidgetView: function changeWidgetView(callback) {
    var viewopt = this.options.view;
    if (viewopt === undefined || viewopt === null) {
      return false;
    } else if ((0, _util.isArray)(viewopt)) {
      var hascal = false;
      for (var i = 0; i < viewopt.length; i++) {
        hascal = hascal || callback(viewopt[i]);
      }
      return hascal;
    } else {
      return callback(viewopt);
    }
  },
  createItemView: function createItemView(viewopt) {
    var _this = this;

    switch (viewopt.type) {
      default:
      case "window":
        this._openWindow(viewopt);
        break;
      case "divwindow":
        this._openDivWindow(viewopt);
        break;
      case "append":
        this.getHtml(this._getUrl(viewopt.url), function (html) {
          _this._appendView(viewopt, html);
        });
        break;
      case "custom":
        //自定义
        var that = this;
        viewopt.open(this._getUrl(viewopt.url), function (html) {
          that.winCreateOK(viewopt, html);

          that._viewcreate_okcount++;
          if (that._viewcreate_okcount >= that._viewcreate_allcount) {
            that._startActivate(html);
          }
        }, this);
        break;
    }
  },
  _viewcreate_allcount: 0,
  _viewcreate_okcount: 0,
  //==============layer弹窗=================
  _openWindow: function _openWindow(viewopt) {
    var that = this;
    var view_url = this._getUrl(viewopt.url);

    var opts = {
      type: 2,
      content: [view_url, "no"],
      success: function success(layero) {
        viewopt._layerOpening = false;
        viewopt._dom = layero;

        //得到iframe页的窗口对象，执行iframe页的方法：viewWindow.method();
        var viewWindow = window[layero.find("iframe")[0]["name"]];

        //设置css
        if (that.config.css) (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(that.config.css);

        //隐藏弹窗
        if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

        layer.setTop(layero);
        that.winCreateOK(viewopt, viewWindow);

        that._viewcreate_okcount++;
        if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);

        //通知页面,页面需要定义initWidgetView方法
        if (viewWindow && viewWindow.initWidgetView) viewWindow.initWidgetView(that);else daslog.warn("" + view_url + "页面没有定义function initWidgetView(widget)方法，无法初始化widget页面!");
      }
    };
    if (viewopt._layerIdx > 0) {
      //debugger
    }

    viewopt._layerOpening = true;
    viewopt._layerIdx = layer.open(this._getWinOpt(viewopt, opts));
  },
  _openDivWindow: function _openDivWindow(viewopt) {
    var view_url = this._getUrl(viewopt.url);
    //div弹窗
    var that = this;
    this.getHtml(view_url, function (data) {
      var opts = {
        type: 1,
        content: data,
        success: function success(layero) {
          viewopt._layerOpening = false;
          viewopt._dom = layero;

          //隐藏弹窗
          if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

          layer.setTop(layero);
          that.winCreateOK(viewopt, layero);

          that._viewcreate_okcount++;
          if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);
        }
      };
      viewopt._layerOpening = true;
      viewopt._layerIdx = layer.open(that._getWinOpt(viewopt, opts));
    });
  },
  _getUrl: function _getUrl(url) {
    url = this.addCacheVersion(url);

    if (url.startsWith("/") || url.startsWith(".") || url.startsWith("http")) return url;else return this.path + url;
  },
  _getWinOpt: function _getWinOpt(viewopt, opts) {
    //优先使用cofig中配置，覆盖js中的定义
    var def = (0, _widgetManager.getDefWindowOptions)();
    var windowOptions = _extends({}, def, viewopt.windowOptions, this.config.windowOptions);
    viewopt.windowOptions = windowOptions; //赋值

    var that = this;
    var _size = this._getWinSize(windowOptions);

    var title = false;
    if (!windowOptions.noTitle) {
      title = this.config.name || " ";
      if (this.config.icon) {
        title = '<i class="' + this.config.icon + '" ></i>&nbsp;' + title;
      }
    }

    //默认值
    var defOpts = {
      title: title,
      area: _size.area,
      offset: _size.offset,
      shade: 0,
      maxmin: false,
      beforeEnd: function beforeEnd() {
        that.beforeDisable();
      },
      end: function end() {
        // 销毁后触发的回调
        viewopt._layerIdx = -1;
        viewopt._dom = null;
        that.disableBase(true);
      },
      full: function full(dom) {
        //最大化后触发的回调
        that.winFull(dom);
      },
      min: function min(dom) {
        //最小化后触发的回调
        that.winMin(dom);
      },
      restore: function restore(dom) {
        //还原 后触发的回调
        that.winRestore(dom);
      }
    };
    return _extends({}, defOpts, windowOptions, opts);
  },
  //计算弹窗大小和位置
  _getWinSize: function _getWinSize(windowOptions) {
    //获取高宽
    var _width = this.bfb2Number(windowOptions.width, document.documentElement.clientWidth, windowOptions);
    var _height = this.bfb2Number(windowOptions.height, document.documentElement.clientHeight, windowOptions);

    //计算位置offset
    var offset = "";
    var position = windowOptions.position;
    if (position) {
      if (typeof position == "string") {
        //t顶部,b底部,r右边缘,l左边缘,lt左上角,lb左下角,rt右上角,rb右下角
        offset = position;
      } else if ((typeof position === "undefined" ? "undefined" : _typeof(position)) == "object") {
        var _top;
        var _left;

        if (position.hasOwnProperty("top") && position.top != null) {
          _top = this.bfb2Number(position.top, document.documentElement.clientHeight, windowOptions);
        }
        if (position.hasOwnProperty("bottom") && position.bottom != null) {
          windowOptions._hasresize = true;

          var _bottom = this.bfb2Number(position.bottom, document.documentElement.clientHeight, windowOptions);

          if (_top != null) {
            _height = document.documentElement.clientHeight - _top - _bottom;
          } else {
            _top = document.documentElement.clientHeight - _height - _bottom;
          }
        }

        if (position.hasOwnProperty("left") && position.left != null) {
          _left = this.bfb2Number(position.left, document.documentElement.clientWidth, windowOptions);
        }
        if (position.hasOwnProperty("right") && position.right != null) {
          windowOptions._hasresize = true;
          var _right = this.bfb2Number(position.right, document.documentElement.clientWidth, windowOptions);

          if (_left != null) {
            _width = document.documentElement.clientWidth - _left - _right;
          } else {
            _left = document.documentElement.clientWidth - _width - _right;
          }
        }

        if (_top == null) _top = (document.documentElement.clientHeight - _height) / 2;
        if (_left == null) _left = (document.documentElement.clientWidth - _width) / 2;

        offset = [_top + "px", _left + "px"];
      }
    }

    //最大最小高度判断
    if (windowOptions.hasOwnProperty("minHeight") && _height < windowOptions.minHeight) {
      windowOptions._hasresize = true;
      _height = windowOptions.minHeight;
    }
    if (windowOptions.hasOwnProperty("maxHeight") && _height > windowOptions.maxHeight) {
      windowOptions._hasresize = true;
      _height = windowOptions.maxHeight;
    }

    //最大最小宽度判断
    if (windowOptions.hasOwnProperty("minHeight") && _width < windowOptions.minWidth) {
      windowOptions._hasresize = true;
      _width = windowOptions.minWidth;
    }
    if (windowOptions.hasOwnProperty("maxWidth") && _width > windowOptions.maxWidth) {
      windowOptions._hasresize = true;
      _width = windowOptions.maxWidth;
    }

    var area;
    if (_width && _height) area = [_width + "px", _height + "px"];else area = _width + "px";

    return { area: area, offset: offset };
  },
  bfb2Number: function bfb2Number(str, allnum, windowOptions) {
    if (typeof str == "string" && str.indexOf("%") != -1) {
      windowOptions._hasresize = true;

      return allnum * Number(str.replace("%", "")) / 100;
    }
    return str;
  },
  //==============直接添加到index上=================
  _appendView: function _appendView(viewopt, html) {
    viewopt._dom = (0, _zepto.zepto)(html).appendTo(viewopt.parent || "body");

    //设置css
    if (this.config.css) (0, _zepto.zepto)(viewopt._dom).css(this.config.css);

    this.winCreateOK(viewopt, html);

    this._viewcreate_okcount++;
    if (this._viewcreate_okcount >= this._viewcreate_allcount) this._startActivate(html);
  },

  //释放插件
  disableBase: function disableBase(nobefore) {
    if (!this.isActivate) return;

    if (!nobefore) this.beforeDisable();

    var has = this.changeWidgetView(function (viewopt) {
      if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
        if (viewopt._layerOpening) {
          //窗口还在加载中
          //daslog.log('释放widget窗口还在加载中:' + viewopt._layerIdx);
        }
        layer.close(viewopt._layerIdx);
        return true;
      } else {
        if (viewopt.type == "append" && viewopt._dom) {
          viewopt._dom.remove();
          viewopt._dom = null;
        }
        if (viewopt.type == "custom" && viewopt.close) {
          viewopt.close();
        }
        return false;
      }
    });
    if (has) return;

    this.disable();
    this.isActivate = false;

    //还原配置为初始状态
    if (this.config.autoReset) {
      this.resetConfig();
    }

    //daslog.log('释放widget:' + this.config.uri);
  },
  //还原配置为初始状态
  resetConfig: function resetConfig() {
    if (this.config._firstConfigBak) {
      var _backData = this.config._firstConfigBak;
      for (var aa in _backData) {
        if (aa == "uri") continue;
        this.config[aa] = _backData[aa];
      }
    }
  },
  //设置view弹窗的显示和隐藏
  setViewVisible: function setViewVisible(visible) {
    this.changeWidgetView(function (viewopt) {
      if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
        if (visible) {
          (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).show();
        } else {
          (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).hide();
        }
      } else if (viewopt.type == "append" && viewopt._dom) {
        if (visible) (0, _zepto.zepto)(viewopt._dom).show();else (0, _zepto.zepto)(viewopt._dom).hide();
      }
    });
  },
  //设置view弹窗的css
  setViewCss: function setViewCss(style) {
    this.changeWidgetView(function (viewopt) {
      if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
        (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(style);
      } else if (viewopt.type == "append" && viewopt._dom) {
        (0, _zepto.zepto)(viewopt._dom).css(style);
      }
    });
  },
  //主窗体改变大小后触发
  indexResize: function indexResize() {
    if (!this.isActivate) return;

    var that = this;
    this.changeWidgetView(function (viewopt) {
      if (viewopt._layerIdx == null || viewopt._layerIdx == -1 || viewopt.windowOptions == null || !viewopt.windowOptions._hasresize) return;

      var _size = that._getWinSize(viewopt.windowOptions);

      var _style = {};
      if ((0, _util.isArray)(_size.area)) {
        if (_size.area[0]) _style.width = _size.area[0];
        if (_size.area[1]) _style.height = _size.area[1];
      }

      if ((0, _util.isArray)(_size.offset)) {
        if (_size.offset[1]) _style.top = _size.offset[0];
        if (_size.offset[1]) _style.left = _size.offset[1];
      }
      (0, _zepto.zepto)(viewopt._dom).attr("myTopLeft", true);
      layer.style(viewopt._layerIdx, _style);

      if (viewopt.type == "divwindow") layer.iframeAuto(viewopt._layerIdx);
    });
  },
  _startActivate: function _startActivate(layero) {
    this.activate(layero);
    if (this.config.success) {
      this.config.success(this);
    }
    if (!this.isActivate) {
      //窗口打开中没加载完成时，被释放
      this.disableBase();
    }
  },
  //子类继承后覆盖
  init: function init() {},
  //子类继承后覆盖
  create: function create(endfun) {},
  //子类继承后覆盖
  beforeActivate: function beforeActivate() {},
  activate: function activate(layero) {},

  //子类继承后覆盖
  beforeDisable: function beforeDisable() {},
  disable: function disable() {},

  //子类继承后覆盖
  winCreateOK: function winCreateOK(opt, result) {},
  //窗口最大化后触发
  winFull: function winFull() {},
  //窗口最小化后触发
  winMin: function winMin() {},
  //窗口还原 后触发
  winRestore: function winRestore() {},

  //公共方法
  getHtml: function getHtml(url, callback) {
    _zepto.zepto.ajax({
      url: url,
      type: "GET",
      dataType: "html",
      timeout: 0, //永不超时
      success: function success(data) {
        callback(data);
      }
    });
  }
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ES5Class = ES5Class;
//es5语法定义的class，新类可以:
// XXXClass.extend({
// 	initialize: function (options) {
//   },
// });

function ES5Class() {}

function extend(dest) {
  var i, j, len, src;

  for (j = 1, len = arguments.length; j < len; j++) {
    src = arguments[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}

ES5Class.extend = function (props) {
  // @function extend(props: Object): Function
  // [Extends the current class](#class-inheritance) given the properties to be included.
  // Returns a Javascript function that is a class constructor (to be called with `new`).
  var NewClass = function NewClass() {
    // call the constructor
    if (this.initialize) {
      this.initialize.apply(this, arguments);
    }

    // call all constructor hooks
    this.callInitHooks();
  };

  var parentProto = NewClass.__super__ = this.prototype;

  var proto = Object.create(parentProto);
  proto.constructor = NewClass;

  NewClass.prototype = proto;

  // inherit parent's statics
  for (var i in this) {
    if (this.hasOwnProperty(i) && i !== "prototype" && i !== "__super__") {
      NewClass[i] = this[i];
    }
  }

  // mix static properties into the class
  if (props.statics) {
    extend(NewClass, props.statics);
    delete props.statics;
  }

  // mix includes into the prototype
  if (props.includes) {
    // checkDeprecatedMixinEvents(props.includes);
    extend.apply(null, [proto].concat(props.includes));
    delete props.includes;
  }

  // merge options
  if (proto.options) {
    props.options = extend(Object.create(proto.options), props.options);
  }

  // mix given properties into the prototype
  extend(proto, props);

  proto._initHooks = [];

  // add method for calling all hooks
  proto.callInitHooks = function () {
    if (this._initHooksCalled) {
      return;
    }

    if (parentProto.callInitHooks) {
      parentProto.callInitHooks.call(this);
    }

    this._initHooksCalled = true;

    for (var i = 0, len = proto._initHooks.length; i < len; i++) {
      proto._initHooks[i].call(this);
    }
  };

  return NewClass;
};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseWidget = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _zepto = __webpack_require__(7);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _loader = __webpack_require__(49);

var _widgetManager = __webpack_require__(48);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _resources_cache = [];
var layer = window.layer; //请引入layer弹窗插件

var BaseWidget = exports.BaseWidget = function (_DasClass) {
  _inherits(BaseWidget, _DasClass);

  function BaseWidget(viewer, config) {
    _classCallCheck(this, BaseWidget);

    var _this = _possibleConstructorReturn(this, (BaseWidget.__proto__ || Object.getPrototypeOf(BaseWidget)).call(this, config));

    _this.viewer = viewer;
    _this.config = config; //配置的config信息
    _this.path = config.path || ""; //当前widget目录相对路径

    _this.isActivate = false; //是否激活状态
    _this.isCreate = false;
    _this._viewcreate_allcount = 0;
    _this._viewcreate_okcount = 0;

    _this._viewConfig = _this.view;

    _this.init();
    return _this;
  }

  //内部子类重写，相关外部资源的引入
  // get resources(){
  //     return [];
  // }
  //内部子类重写，相关view等配置
  // get view() {
  //     return {};
  // }

  //==============激活插件=================
  //激活插件


  _createClass(BaseWidget, [{
    key: "activateBase",
    value: function activateBase() {
      var that = this;

      if (this.isActivate) {
        //已激活状态时跳出
        this.changeWidgetView(function (viewopt) {
          if (viewopt._dom) {
            //将层置顶
            (0, _zepto.zepto)(".layui-layer").each(function () {
              (0, _zepto.zepto)(this).css("z-index", 19891000);
            });
            (0, _zepto.zepto)(viewopt._dom).css("z-index", 19891014);
          }
        });
        return;
      }

      _widgetManager.eventTarget.fire(_DasClass2.eventType.beforeActivate, {
        sourceTarget: this
      });
      this.beforeActivate();
      this.isActivate = true;
      //daslog.log('激活widget:' + this.config.uri);

      if (!this.isCreate) {
        _widgetManager.eventTarget.fire(_DasClass2.eventType.beforeCreate, {
          sourceTarget: this
        });

        //首次进行创建
        if (this.resources && this.resources.length > 0) {
          var resources = [];

          for (var i = 0; i < this.resources.length; i++) {
            var _resource = this.resources[i];
            _resource = this._getUrl(_resource);

            if (_resources_cache.indexOf(_resource) != -1) continue; //不加重复资源

            resources.push(_resource);
          }
          _resources_cache = _resources_cache.concat(resources); //不加重复资源

          _loader.Loader.async(resources, function () {
            var result = that.create(function () {
              that._createWidgetView();
              that.isCreate = true;
            });
            _widgetManager.eventTarget.fire(_DasClass2.eventType.created, {
              sourceTarget: that
            });

            if (result) return;
            if (that.config.createAtStart) {
              that.config.createAtStart = false;
              that.isActivate = false;
              that.isCreate = true;
              return;
            }
            that._createWidgetView();
            that.isCreate = true;
          });
          return;
        } else {
          var result = this.create(function () {
            that._createWidgetView();
            this.isCreate = true;
          });
          _widgetManager.eventTarget.fire(_DasClass2.eventType.created, {
            sourceTarget: this
          });

          if (result) return;
          if (that.config.createAtStart) {
            that.config.createAtStart = false;
            that.isActivate = false;
            that.isCreate = true;
            return;
          }
        }
        this.isCreate = true;
      }
      this._createWidgetView();

      return this;
    }
    //子类继承后覆盖

  }, {
    key: "init",
    value: function init() {}
    //子类继承后覆盖

  }, {
    key: "create",
    value: function create(endfun) {}

    //创建插件的view

  }, {
    key: "_createWidgetView",
    value: function _createWidgetView() {
      var viewopt = this._viewConfig;
      if (viewopt === undefined || viewopt === null) {
        this._startActivate();
      } else if ((0, _util.isArray)(viewopt)) {
        this._viewcreate_allcount = viewopt.length;
        this._viewcreate_okcount = 0;

        for (var i = 0; i < viewopt.length; i++) {
          this.createItemView(viewopt[i]);
        }
      } else {
        this._viewcreate_allcount = 1;
        this._viewcreate_okcount = 0;
        this.createItemView(viewopt);
      }
    }
  }, {
    key: "changeWidgetView",
    value: function changeWidgetView(callback) {
      var viewopt = this._viewConfig;
      if (viewopt === undefined || viewopt === null) {
        return false;
      } else if ((0, _util.isArray)(viewopt)) {
        var hascal = false;
        for (var i = 0; i < viewopt.length; i++) {
          hascal = callback(viewopt[i]);
        }
        return hascal;
      } else {
        return callback(viewopt);
      }
    }
  }, {
    key: "createItemView",
    value: function createItemView(viewopt) {
      var that = this;
      switch (viewopt.type) {
        default:
        case "window":
          this._openWindow(viewopt);
          break;
        case "divwindow":
          this._openDivWindow(viewopt);
          break;
        case "append":
          that.getHtml(this._getUrl(viewopt.url), function (html) {
            that._appendView(viewopt, html);
          });
          break;
        case "custom":
          //自定义
          viewopt.open(this._getUrl(viewopt.url), function (html) {
            that.winCreateOK(viewopt, html);
            _widgetManager.eventTarget.fire(_DasClass2.eventType.openView, {
              sourceTarget: that,
              view: viewopt,
              dom: html
            });
            that._viewcreate_okcount++;
            if (that._viewcreate_okcount >= that._viewcreate_allcount) {
              that._startActivate(html);
            }
          }, this);
          break;
      }
    }

    //==============layer弹窗=================

  }, {
    key: "_openWindow",
    value: function _openWindow(viewopt) {
      var that = this;
      var view_url = this._getUrl(viewopt.url);

      var opts = {
        type: 2,
        content: [view_url, "no"],
        success: function success(layero) {
          viewopt._layerOpening = false;
          viewopt._dom = layero;

          //得到iframe页的窗口对象，执行iframe页的方法：viewWindow.method();
          var viewWindow = window[layero.find("iframe")[0]["name"]];

          //设置css
          if (that.config.css) (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(that.config.css);

          //隐藏弹窗
          if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

          layer.setTop(layero);

          that.winCreateOK(viewopt, viewWindow);
          _widgetManager.eventTarget.fire(_DasClass2.eventType.openView, {
            sourceTarget: that,
            view: viewopt,
            dom: layero
          });

          that._viewcreate_okcount++;
          if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);

          //通知页面,页面需要定义initWidgetView方法
          if (viewWindow && viewWindow.initWidgetView) viewWindow.initWidgetView(that);else daslog.warn(view_url + "页面没有定义function initWidgetView(widget)方法，无法初始化widget页面!");
        }
      };
      if (viewopt._layerIdx > 0) {
        //debugger
      }

      viewopt._layerOpening = true;
      viewopt._layerIdx = layer.open(this._getWinOpt(viewopt, opts));
    }
  }, {
    key: "_openDivWindow",
    value: function _openDivWindow(viewopt) {
      var view_url = this._getUrl(viewopt.url);
      //div弹窗
      var that = this;
      this.getHtml(view_url, function (data) {
        var opts = {
          type: 1,
          content: data,
          success: function success(layero) {
            viewopt._layerOpening = false;
            viewopt._dom = layero;

            //隐藏弹窗
            if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

            layer.setTop(layero);
            that.winCreateOK(viewopt, layero);
            _widgetManager.eventTarget.fire(_DasClass2.eventType.openView, {
              sourceTarget: that,
              view: viewopt,
              dom: layero
            });

            that._viewcreate_okcount++;
            if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);
          }
        };
        viewopt._layerOpening = true;
        viewopt._layerIdx = layer.open(that._getWinOpt(viewopt, opts));
      });
    }
  }, {
    key: "_getUrl",
    value: function _getUrl(url) {
      url = this.addCacheVersion(url);

      if (url.startsWith("/") || url.startsWith(".") || url.startsWith("http")) return url;else return this.path + url;
    }
  }, {
    key: "_getWinOpt",
    value: function _getWinOpt(viewopt, opts) {
      //优先使用cofig中配置，覆盖js中的定义
      var def = (0, _widgetManager.getDefWindowOptions)();
      var windowOptions = _extends({}, def, viewopt.windowOptions, this.config.windowOptions);
      viewopt.windowOptions = windowOptions; //赋值

      var that = this;
      var _size = this._getWinSize(windowOptions);

      var title = false;
      if (!windowOptions.noTitle) {
        title = this.config.name || " ";
        if (this.config.icon) {
          title = '<i class="' + this.config.icon + '" ></i>&nbsp;' + title;
        }
      }

      //默认值
      var defOpts = {
        title: title,
        area: _size.area,
        offset: _size.offset,
        shade: 0,
        maxmin: false,
        beforeEnd: function beforeEnd() {
          that.beforeDisable();
        },
        end: function end() {
          // 销毁后触发的回调
          viewopt._layerIdx = -1;
          viewopt._dom = null;
          that.disableBase();
        },
        full: function full(dom) {
          //最大化后触发的回调
          that.winFull(dom);
        },
        min: function min(dom) {
          //最小化后触发的回调
          that.winMin(dom);
        },
        restore: function restore(dom) {
          //还原 后触发的回调
          that.winRestore(dom);
        }
      };
      return _extends({}, defOpts, windowOptions, opts);
    }
    //计算弹窗大小和位置

  }, {
    key: "_getWinSize",
    value: function _getWinSize(windowOptions) {
      //获取高宽
      var _width = this.bfb2Number(windowOptions.width, document.documentElement.clientWidth, windowOptions);
      var _height = this.bfb2Number(windowOptions.height, document.documentElement.clientHeight, windowOptions);

      //计算位置offset
      var offset = "";
      var position = windowOptions.position;
      if (position) {
        if (typeof position == "string") {
          //t顶部,b底部,r右边缘,l左边缘,lt左上角,lb左下角,rt右上角,rb右下角
          offset = position;
        } else if ((typeof position === "undefined" ? "undefined" : _typeof(position)) == "object") {
          var _top;
          var _left;

          if (position.hasOwnProperty("top") && position.top != null) {
            _top = this.bfb2Number(position.top, document.documentElement.clientHeight, windowOptions);
          }
          if (position.hasOwnProperty("bottom") && position.bottom != null) {
            windowOptions._hasresize = true;

            var _bottom = this.bfb2Number(position.bottom, document.documentElement.clientHeight, windowOptions);

            if (_top != null) {
              _height = document.documentElement.clientHeight - _top - _bottom;
            } else {
              _top = document.documentElement.clientHeight - _height - _bottom;
            }
          }

          if (position.hasOwnProperty("left") && position.left != null) {
            _left = this.bfb2Number(position.left, document.documentElement.clientWidth, windowOptions);
          }
          if (position.hasOwnProperty("right") && position.right != null) {
            windowOptions._hasresize = true;
            var _right = this.bfb2Number(position.right, document.documentElement.clientWidth, windowOptions);

            if (_left != null) {
              _width = document.documentElement.clientWidth - _left - _right;
            } else {
              _left = document.documentElement.clientWidth - _width - _right;
            }
          }

          if (_top == null) _top = (document.documentElement.clientHeight - _height) / 2;
          if (_left == null) _left = (document.documentElement.clientWidth - _width) / 2;

          offset = [_top + "px", _left + "px"];
        }
      }

      //最大最小高度判断
      if (windowOptions.hasOwnProperty("minHeight") && _height < windowOptions.minHeight) {
        windowOptions._hasresize = true;
        _height = windowOptions.minHeight;
      }
      if (windowOptions.hasOwnProperty("maxHeight") && _height > windowOptions.maxHeight) {
        windowOptions._hasresize = true;
        _height = windowOptions.maxHeight;
      }

      //最大最小宽度判断
      if (windowOptions.hasOwnProperty("minHeight") && _width < windowOptions.minWidth) {
        windowOptions._hasresize = true;
        _width = windowOptions.minWidth;
      }
      if (windowOptions.hasOwnProperty("maxWidth") && _width > windowOptions.maxWidth) {
        windowOptions._hasresize = true;
        _width = windowOptions.maxWidth;
      }

      var area;
      if (_width && _height) area = [_width + "px", _height + "px"];else area = _width + "px";

      return { area: area, offset: offset };
    }

    //主窗体改变大小后触发

  }, {
    key: "indexResize",
    value: function indexResize() {
      if (!this.isActivate) return;

      var that = this;
      this.changeWidgetView(function (viewopt) {
        if (viewopt._layerIdx == null || viewopt._layerIdx == -1 || viewopt.windowOptions == null || !viewopt.windowOptions._hasresize) return;

        var _size = that._getWinSize(viewopt.windowOptions);

        var _style = {};
        if ((0, _util.isArray)(_size.area)) {
          if (_size.area[0]) _style.width = _size.area[0];
          if (_size.area[1]) _style.height = _size.area[1];
        }

        if ((0, _util.isArray)(_size.offset)) {
          if (_size.offset[1]) _style.top = _size.offset[0];
          if (_size.offset[1]) _style.left = _size.offset[1];
        }
        (0, _zepto.zepto)(viewopt._dom).attr("myTopLeft", true);
        layer.style(viewopt._layerIdx, _style);

        if (viewopt.type == "divwindow") layer.iframeAuto(viewopt._layerIdx);
      });
    }
    //==============直接添加dom节点=================

  }, {
    key: "_appendView",
    value: function _appendView(viewopt, html) {
      viewopt._dom = (0, _zepto.zepto)(html).appendTo(viewopt.parent || "body");

      //设置css
      if (this.config.css) (0, _zepto.zepto)(viewopt._dom).css(this.config.css);

      this.winCreateOK(viewopt, html);

      this._viewcreate_okcount++;
      if (this._viewcreate_okcount >= this._viewcreate_allcount) this._startActivate(html);
    }

    //子类继承后覆盖

  }, {
    key: "winCreateOK",
    value: function winCreateOK(opt, result) {}
    //窗口最大化后触发

  }, {
    key: "winFull",
    value: function winFull() {}
    //窗口最小化后触发

  }, {
    key: "winMin",
    value: function winMin() {}
    //窗口还原 后触发

  }, {
    key: "winRestore",
    value: function winRestore() {}
  }, {
    key: "_startActivate",
    value: function _startActivate(layero) {
      this.activate(layero);
      _widgetManager.eventTarget.fire(_DasClass2.eventType.activated, {
        sourceTarget: this
      });

      if (this.config.success) {
        this.config.success(this);
      }
      if (!this.isActivate) {
        //窗口打开中没加载完成时，被释放
        this.disableBase();
      }
    }
    //子类继承后覆盖

  }, {
    key: "beforeActivate",
    value: function beforeActivate() {}
  }, {
    key: "activate",
    value: function activate(layero) {}

    //==============释放插件=================
    //释放插件

  }, {
    key: "disableBase",
    value: function disableBase() {
      if (!this.isActivate) return;
      this.isActivate = false;

      this.beforeDisable();
      _widgetManager.eventTarget.fire(_DasClass2.eventType.beforeDisable, {
        sourceTarget: this
      });

      //关闭所有窗口
      this.changeWidgetView(function (viewopt) {
        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
          if (viewopt._layerOpening) {
            //窗口还在加载中
            //daslog.log('释放widget窗口还在加载中:' + viewopt._layerIdx);
          }
          layer.close(viewopt._layerIdx);
          return true;
        } else {
          if (viewopt.type == "append" && viewopt._dom) {
            viewopt._dom.remove();
            viewopt._dom = null;
          }
          if (viewopt.type == "custom" && viewopt.close) {
            viewopt.close();
          }
          return false;
        }
      });

      this.disable();

      //还原配置为初始状态
      if (this.config.autoReset) {
        this.resetConfig();
      }
      _widgetManager.eventTarget.fire(_DasClass2.eventType.disabled, {
        sourceTarget: this
      });
      //daslog.log('释放widget:' + this.config.uri);
    }
    //子类继承后覆盖

  }, {
    key: "beforeDisable",
    value: function beforeDisable() {}
  }, {
    key: "disable",
    value: function disable() {}

    //==============其他方法=================

  }, {
    key: "bfb2Number",
    value: function bfb2Number(str, allnum, windowOptions) {
      if (typeof str == "string" && str.indexOf("%") != -1) {
        windowOptions._hasresize = true;

        return allnum * Number(str.replace("%", "")) / 100;
      }
      return str;
    }
  }, {
    key: "addCacheVersion",
    value: function addCacheVersion(_resource) {
      if (_resource == null) return _resource;

      var cacheVersion = (0, _widgetManager.getCacheVersion)();
      if (cacheVersion) {
        if (_resource.indexOf("?") == -1) _resource += "?time=" + cacheVersion;else if (_resource.indexOf("time=" + cacheVersion) == -1) _resource += "&time=" + cacheVersion;
      }
      return _resource;
    }
    //还原配置为初始状态

  }, {
    key: "resetConfig",
    value: function resetConfig() {
      if (this.config._firstConfigBak) {
        var _backData = this.config._firstConfigBak;
        for (var aa in _backData) {
          if (aa == "uri") continue;
          this.config[aa] = _backData[aa];
        }
      }
    }
    //设置view弹窗的显示和隐藏

  }, {
    key: "setViewVisible",
    value: function setViewVisible(visible) {
      this.changeWidgetView(function (viewopt) {
        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
          if (visible) {
            (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).show();
          } else {
            (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).hide();
          }
        } else if (viewopt.type == "append" && viewopt._dom) {
          if (visible) (0, _zepto.zepto)(viewopt._dom).show();else (0, _zepto.zepto)(viewopt._dom).hide();
        }
      });
    }
    //设置view弹窗的css

  }, {
    key: "setViewCss",
    value: function setViewCss(style) {
      this.changeWidgetView(function (viewopt) {
        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
          (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(style);
        } else if (viewopt.type == "append" && viewopt._dom) {
          (0, _zepto.zepto)(viewopt._dom).css(style);
        }
      });
    }

    //公共方法

  }, {
    key: "getHtml",
    value: function getHtml(url, callback) {
      _zepto.zepto.ajax({
        url: url,
        type: "GET",
        dataType: "html",
        timeout: 0, //永不超时
        success: function success(data) {
          callback(data);
        }
      });
    }
  }]);

  return BaseWidget;
}(_DasClass2.DasClass);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMap = createMap;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _util2 = __webpack_require__(3);

var _util = _interopRequireWildcard(_util2);

var _token = __webpack_require__(30);

var token = _interopRequireWildcard(_token);

var _ViewerEx = __webpack_require__(75);

var _GaodePOIGeocoder = __webpack_require__(147);

var _layer2 = __webpack_require__(24);

var _layer = _interopRequireWildcard(_layer2);

var _dasAuthentication = __webpack_require__(148);

var dasAuthentication = _interopRequireWildcard(_dasAuthentication);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function createMap(opt) {
  if (opt.url) {
    _zepto.zepto.ajax({
      type: "get",
      dataType: "json",
      url: opt.url,
      timeout: 0, //永不超时
      success: function success(config) {
        if (config.serverURL) opt.serverURL = config.serverURL;
        //map初始化
        var viewer = initMap(config.map3d, opt);
        setTimeout(function () {
          var Authentication = new dasAuthentication.dasAuthentication({ viewer: viewer });
        });
        Cesium.MouseOperationController = new das3d.MouseOperationController({ viewer: viewer });
        Cesium.MouseOperationController.init();
        var skyAtmosphere = viewer.scene.skyAtmosphere; //修改天空大气颜色, 显得好看点
        skyAtmosphere.saturationShift = 0.08;
        skyAtmosphere.brightnessShift = 0.45;
        skyAtmosphere.hueShift = 0;
        viewer.scene.highDynamicRange = false;

        // fangmm 20210817 把回调位置调整到最后，使外部调用MouseOperationController不会报错
        if (opt.success) opt.success(viewer, config, config); //第2个config为了兼容1.7以前版本

        //  var pOperation = changeOperation(viewer);
        // new pOperation().init();
      },
      error: function error(XMLHttpRequest, textStatus, errorThrown) {
        daslog.warn("文件加载失败！", opt);
        _util.alert(opt.url + "文件加载失败！");
      }
    });
    return null;
  } else {
    var viewer = initMap(opt.data, opt);
    setTimeout(function () {
      var Authentication = new dasAuthentication.dasAuthentication({ viewer: viewer });
    });
    Cesium.MouseOperationController = new das3d.MouseOperationController({ viewer: viewer });
    Cesium.MouseOperationController.init();

    // fangmm 20210817 把回调位置调整到最后，使外部调用MouseOperationController不会报错
    if (opt.success) opt.success(viewer, opt.data);
    // var pOperation = changeOperation(viewer);
    // new pOperation().init();
    return viewer;
  }
}

function initMap(config, optsWB) {
  var id = optsWB.id;

  //数据优先级：optsWB > config > opts

  //如果options未设置时的默认参数
  var opts = {
    animation: false, //是否创建动画小器件，左下角仪表
    timeline: false, //是否显示时间线控件
    fullscreenButton: true, //右下角全屏按钮
    vrButton: false, //右下角vr虚拟现实按钮

    geocoder: false, //是否显示地名查找控件
    sceneModePicker: false, //是否显示投影方式控件
    homeButton: true, //回到默认视域按钮
    navigationHelpButton: true, //是否显示帮助信息控件
    navigationInstructionsInitiallyVisible: false, //在用户明确单击按钮之前是否自动显示

    infoBox: true, //是否显示点击要素之后显示的信息
    selectionIndicator: false, //选择模型是是否显示绿色框,
    shouldAnimate: true,
    showRenderLoopErrors: true, //是否显示错误弹窗信息

    baseLayerPicker: false, //地图底图
    contextmenu: true //右键菜单
  };

  //config中可以配置map所有options
  for (var key in config) {
    opts[key] = config[key];
  }
  //wboptions中可以配置map所有options覆盖

  for (var _key in optsWB) {
    if (_key === "id" || _key === "success") continue;
    opts[_key] = optsWB[_key];
  }

  //一些默认值的修改
  Cesium.Ion.defaultAccessToken = opts.ionToken || token.ion;
  Cesium.AnimationViewModel.defaultTicks = opts.animationTicks || [0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.0];

  //自定义搜索栏Geocoder
  if (opts.geocoder === true) {
    opts.geocoder = new _GaodePOIGeocoder.GaodePOIGeocoder(opts.geocoderConfig);
  }

  //地形
  var terrainProvider;
  if (opts.terrain && opts.terrain.visible) {
    terrainProvider = getTerrainProvider(opts.terrain, opts.serverURL);
    opts.terrainProvider = terrainProvider;
  } else {
    opts.terrainProvider = _layer.getEllipsoidTerrain();
  }

  //地图底图图层预处理
  var hasremoveimagery = false;
  if (opts.baseLayerPicker) {
    //有baseLayerPicker插件时
    if (!opts.imageryProviderViewModels && opts.basemaps && opts.basemaps.length > 0) {
      var imgOBJ = getImageryProviderArr(opts.basemaps);
      opts.imageryProviderViewModels = imgOBJ.imageryProviderViewModels;
      if (imgOBJ.index == -1) hasremoveimagery = true;else opts.selectedImageryProviderViewModel = imgOBJ.imageryProviderViewModels[imgOBJ.index];
    }

    if (!opts.terrainProviderViewModels) {
      opts.terrainProviderViewModels = getTerrainProviderViewModelsArr();
      opts.selectedTerrainProviderViewModel = opts.terrainProviderViewModels[1];
    }
  } else {
    //无baseLayerPicker插件时
    if (opts.imageryProvider == null) {
      //未配底图时
      hasremoveimagery = true;
      opts.imageryProvider = new Cesium.TileMapServiceImageryProvider({
        url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII")
      });
    }
  }

  //地球初始化
  var viewer = new Cesium.Viewer(id, opts);
  viewer.scene.postProcessStages.fxaa.enabled = true; //开启抗锯齿
  //地图底图图层
  if (hasremoveimagery) {
    var imageryLayerCollection = viewer.imageryLayers;
    var length = imageryLayerCollection.length;
    for (var i = 0; i < length; i++) {
      var layer = imageryLayerCollection.get(0);
      imageryLayerCollection.remove(layer, true);
    }
  }
  if (opts.geocoder) {
    opts.geocoder.viewer = viewer;
    delete opts.geocoder;
  }

  delete opts.imageryProviderViewModels;
  delete opts.selectedImageryProviderViewModel;
  delete opts.terrainProviderViewModels;
  delete opts.selectedTerrainProviderViewModel;
  delete opts.terrainProvider;
  delete opts.imageryProvider;

  viewer.das = new _ViewerEx.ViewerEx(viewer, opts); //扩展的viewer支持

  viewer.das.terrainProvider = terrainProvider;
  viewer.gisdata = { config: viewer.das.config }; //兼容1.7以前的历史版本属性
  if (opts.center) {
    var center = opts.center;
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(center.x, center.y, center.z),
      orientation: {
        heading: Cesium.Math.toRadians(center.heading),
        pitch: Cesium.Math.toRadians(center.pitch),
        roll: Cesium.Math.toRadians(center.roll)
      }
    });
  }
  return viewer;
}

//获取配置的地形
function getTerrainProvider(cfg, serverURL) {
  if (cfg && cfg.url) {
    if (serverURL) {
      cfg.url = cfg.url.replace("$serverURL$", serverURL);
    }
    cfg.url = cfg.url.replace("$hostname$", location.hostname).replace("$host$", location.host);
  }

  return _layer.getTerrainProvider(cfg);
}

//获取自定义底图切换
function getImageryProviderArr(layersCfg) {
  var providerViewModels = [];
  var selectedIndex = -1;

  window._temp_createImageryProvider = _layer.createImageryProvider;

  for (var i = 0; i < layersCfg.length; i++) {
    var item = layersCfg[i];
    if (item.type == "group" && item.layers == null) continue;

    if (item.visible) selectedIndex = providerViewModels.length;

    var funstr = "window._temp_das_basemaps" + i + " = function () {\
                        var item = " + JSON.stringify(item) + ';\
                        if (item.type == "group") {\
                            var arrVec = [];\
                            for (var index = 0; index < item.layers.length; index++) {\
                                var temp = window._temp_createImageryProvider(item.layers[index]);\
                                if (temp == null) continue;\
                                arrVec.push(temp);\
                            }\
                            return arrVec;\
                        }\
                        else {\
                            return window._temp_createImageryProvider(item);\
                        } \
                    }';
    eval(funstr);

    var imgModel = new Cesium.ProviderViewModel({
      name: item.name || "未命名",
      tooltip: item.name || "未命名",
      iconUrl: item.icon || "",
      creationFunction: eval("window._temp_das_basemaps" + i)
    });
    providerViewModels.push(imgModel);
  }

  return {
    imageryProviderViewModels: providerViewModels,
    index: selectedIndex
  };
}

function getTerrainProviderViewModelsArr() {
  return [new Cesium.ProviderViewModel({
    name: "无地形",
    iconUrl: Cesium.buildModuleUrl("Widgets/Images/TerrainProviders/Ellipsoid.png"),
    tooltip: "WGS84标准椭球，即 EPSG:4326",
    category: "",
    creationFunction: function creationFunction() {
      return _layer.getEllipsoidTerrain();
    }
  }), new Cesium.ProviderViewModel({
    name: "中国地形",
    iconUrl: Cesium.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
    tooltip: "高分辨率中国地形",
    category: "",
    creationFunction: function creationFunction() {
      return _layer.getTerrainProvider({
        // url: "//data.dasgis.cn/terrain"
        url: "//gisearth-1301434080.cos.ap-nanjing.myqcloud.com/MapData/terrain"
      });
    }
  }), new Cesium.ProviderViewModel({
    name: "Cesium Ion 全球地形",
    iconUrl: Cesium.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
    tooltip: "Cesium官方Ion提供的高分辨率全球地形",
    category: "",
    creationFunction: function creationFunction() {
      return _layer.getTerrainProvider({
        type: "ion"
      });
    }
  }), new Cesium.ProviderViewModel({
    name: "ArcGIS 全球地形",
    iconUrl: Cesium.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
    tooltip: "arcgis官方提供的高分辨率全球地形",
    category: "",
    creationFunction: function creationFunction() {
      return _layer.getTerrainProvider({
        type: "arcgis",
        url: "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer"
      });
    }
  })];
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GaodePOIGeocoder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _util = __webpack_require__(3);

var _token = __webpack_require__(30);

var token = _interopRequireWildcard(_token);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//高德POI查询 类
var GaodePOIGeocoder = exports.GaodePOIGeocoder = function () {
  //========== 构造方法 ==========
  function GaodePOIGeocoder(options) {
    _classCallCheck(this, GaodePOIGeocoder);

    options = options || {};
    this.citycode = options.citycode || "";
    //内置高德地图服务key，建议后期传入自己申请的
    this.gaodekey = options.key || token.gaodeArr;
  }

  //========== 对外属性 ==========
  // //裁剪距离
  // get distance() {
  //     return this._distance || 0;
  // }
  // set distance(val) {
  //     this._distance = val;
  // }

  //========== 方法 ==========

  _createClass(GaodePOIGeocoder, [{
    key: "getOneKey",
    value: function getOneKey() {
      var arr = this.gaodekey;
      var n = Math.floor(Math.random() * arr.length + 1) - 1;
      return arr[n];
    }
  }, {
    key: "geocode",
    value: function geocode(query, geocodeType) {
      var that = this;

      var key = this.getOneKey();

      var resource = new Cesium.Resource({
        url: "https://restapi.amap.com/v3/place/text",
        queryParameters: {
          key: key,
          city: this.citycode,
          //citylimit: true,
          keywords: query
        }
      });

      return resource.fetchJson().then(function (results) {
        if (results.status == 0) {
          (0, _util.msg)("请求失败(" + results.infocode + ")：" + results.info);
          return;
        }
        if (results.pois.length === 0) {
          (0, _util.msg)("未查询到“" + query + "”相关数据！");
          return;
        }

        var height = 3000;
        if (that.viewer.camera.positionCartographic.height < height) height = that.viewer.camera.positionCartographic.height;

        return results.pois.map(function (resultObject) {
          var arrjwd = resultObject.location.split(",");
          arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
          var lnglat = that.viewer.das.point2map({ x: arrjwd[0], y: arrjwd[1] });

          return {
            displayName: resultObject.name,
            destination: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, height)
          };
        });
      });
    }
  }]);

  return GaodePOIGeocoder;
}();

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dasAuthentication = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//授权验证类

var dasAuthentication = exports.dasAuthentication = function () {
    function dasAuthentication(options) {
        _classCallCheck(this, dasAuthentication);

        this.viewer = options.viewer;
        this.ipstr = window.location.hostname + ":" + (window.location.port || 80);
        this.serverIP = this.viewer.das.config.serverIP || "http://" + this.ipstr;
        this.noAuthorization = false; //没有授权?
        this.initWidth; //水印图片宽度
        this.initHeight; //水印高度
        this.degree; //水印旋转角度
        this.userAgent = navigator.userAgent; //得到浏览器信息
        this.idx = 1;
        var that = this;
        setTimeout(function () {
            that.getToken(that);
        }, 5000);
    }

    _createClass(dasAuthentication, [{
        key: "getToken",
        value: function getToken(that) {
            //var that = this;
            $.ajax({
                type: "GET",
                // url: ipstr+'api/check.do?token='+dasToken,
                url: that.serverIP + "/auth/license?datetime=" + new Date().getTime(),
                success: function success(config) {
                    if (!(config.data[19] - 0)) {
                        alert(Base64.decode("5b2T5YmN5L2/55So55qE5LqR56uv5Zyw55CD5pyq5rOo5YaM"));
                        that.addImage(that.viewer);
                        that.noAuthorization = true;
                        setInterval(function () {
                            alert(Base64.decode("5b2T5YmN5L2/55So55qE5LqR56uv5Zyw55CD5pyq5rOo5YaM"));
                        }, 30000);
                        that.watermark();
                    } else {
                        if (that.viewer.das.config.showLogo === true) {
                            that.addImage(that.viewer);
                        }
                    }
                },
                error: function error(XMLHttpRequest, textStatus, errorThrown) {
                    that.addImage(that.viewer);
                    that.watermark();
                    alert(Base64.decode("5b2T5YmN5L2/55So55qE5LqR56uv5Zyw55CD5pyq5rOo5YaM"));
                }
            });
        }
    }, {
        key: "addImage",
        value: function addImage(viewer) {
            var ViewportQuad = new Cesium.ViewportQuad();
            //左 下 长 宽  PB
            ViewportQuad.rectangle = new Cesium.BoundingRectangle(17, 50, 140, 42), viewer.scene.primitives.add(ViewportQuad), ViewportQuad.material = new Cesium.Material({
                fabric: {
                    type: "Image",
                    uniforms: {
                        color: new Cesium.Color(1, 1, 1, 1),
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHkAAAAnCAYAAAArfufOAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAACHDwAAjA8AAP1SAACBQAAAfXkAAOmLAAA85QAAGcxzPIV3AAAKL2lDQ1BJQ0MgUHJvZmlsZQAASMedlndUVNcWh8+9d3qhzTDSGXqTLjCA9C4gHQRRGGYGGMoAwwxNbIioQEQREQFFkKCAAaOhSKyIYiEoqGAPSBBQYjCKqKhkRtZKfHl57+Xl98e939pn73P32XuftS4AJE8fLi8FlgIgmSfgB3o401eFR9Cx/QAGeIABpgAwWempvkHuwUAkLzcXerrICfyL3gwBSPy+ZejpT6eD/0/SrFS+AADIX8TmbE46S8T5Ik7KFKSK7TMipsYkihlGiZkvSlDEcmKOW+Sln30W2VHM7GQeW8TinFPZyWwx94h4e4aQI2LER8QFGVxOpohvi1gzSZjMFfFbcWwyh5kOAIoktgs4rHgRm4iYxA8OdBHxcgBwpLgvOOYLFnCyBOJDuaSkZvO5cfECui5Lj25qbc2ge3IykzgCgaE/k5XI5LPpLinJqUxeNgCLZ/4sGXFt6aIiW5paW1oamhmZflGo/7r4NyXu7SK9CvjcM4jW94ftr/xS6gBgzIpqs+sPW8x+ADq2AiB3/w+b5iEAJEV9a7/xxXlo4nmJFwhSbYyNMzMzjbgclpG4oL/rfzr8DX3xPSPxdr+Xh+7KiWUKkwR0cd1YKUkpQj49PZXJ4tAN/zzE/zjwr/NYGsiJ5fA5PFFEqGjKuLw4Ubt5bK6Am8Kjc3n/qYn/MOxPWpxrkSj1nwA1yghI3aAC5Oc+gKIQARJ5UNz13/vmgw8F4psXpjqxOPefBf37rnCJ+JHOjfsc5xIYTGcJ+RmLa+JrCdCAACQBFcgDFaABdIEhMANWwBY4AjewAviBYBAO1gIWiAfJgA8yQS7YDApAEdgF9oJKUAPqQSNoASdABzgNLoDL4Dq4Ce6AB2AEjIPnYAa8AfMQBGEhMkSB5CFVSAsygMwgBmQPuUE+UCAUDkVDcRAPEkK50BaoCCqFKqFaqBH6FjoFXYCuQgPQPWgUmoJ+hd7DCEyCqbAyrA0bwwzYCfaGg+E1cBycBufA+fBOuAKug4/B7fAF+Dp8Bx6Bn8OzCECICA1RQwwRBuKC+CERSCzCRzYghUg5Uoe0IF1IL3ILGUGmkXcoDIqCoqMMUbYoT1QIioVKQ21AFaMqUUdR7age1C3UKGoG9QlNRiuhDdA2aC/0KnQcOhNdgC5HN6Db0JfQd9Dj6DcYDIaG0cFYYTwx4ZgEzDpMMeYAphVzHjOAGcPMYrFYeawB1g7rh2ViBdgC7H7sMew57CB2HPsWR8Sp4sxw7rgIHA+XhyvHNeHO4gZxE7h5vBReC2+D98Oz8dn4Enw9vgt/Az+OnydIE3QIdoRgQgJhM6GC0EK4RHhIeEUkEtWJ1sQAIpe4iVhBPE68QhwlviPJkPRJLqRIkpC0k3SEdJ50j/SKTCZrkx3JEWQBeSe5kXyR/Jj8VoIiYSThJcGW2ChRJdEuMSjxQhIvqSXpJLlWMkeyXPKk5A3JaSm8lLaUixRTaoNUldQpqWGpWWmKtKm0n3SydLF0k/RV6UkZrIy2jJsMWyZf5rDMRZkxCkLRoLhQWJQtlHrKJco4FUPVoXpRE6hF1G+o/dQZWRnZZbKhslmyVbJnZEdoCE2b5kVLopXQTtCGaO+XKC9xWsJZsmNJy5LBJXNyinKOchy5QrlWuTty7+Xp8m7yifK75TvkHymgFPQVAhQyFQ4qXFKYVqQq2iqyFAsVTyjeV4KV9JUCldYpHVbqU5pVVlH2UE5V3q98UXlahabiqJKgUqZyVmVKlaJqr8pVLVM9p/qMLkt3oifRK+g99Bk1JTVPNaFarVq/2ry6jnqIep56q/ojDYIGQyNWo0yjW2NGU1XTVzNXs1nzvhZei6EVr7VPq1drTltHO0x7m3aH9qSOnI6XTo5Os85DXbKug26abp3ubT2MHkMvUe+A3k19WN9CP16/Sv+GAWxgacA1OGAwsBS91Hopb2nd0mFDkqGTYYZhs+GoEc3IxyjPqMPohbGmcYTxbuNe408mFiZJJvUmD0xlTFeY5pl2mf5qpm/GMqsyu21ONnc332jeaf5ymcEyzrKDy+5aUCx8LbZZdFt8tLSy5Fu2WE5ZaVpFW1VbDTOoDH9GMeOKNdra2Xqj9WnrdzaWNgKbEza/2BraJto22U4u11nOWV6/fMxO3Y5pV2s3Yk+3j7Y/ZD/ioObAdKhzeOKo4ch2bHCccNJzSnA65vTC2cSZ79zmPOdi47Le5bwr4urhWuja7ybjFuJW6fbYXd09zr3ZfcbDwmOdx3lPtKe3527PYS9lL5ZXo9fMCqsV61f0eJO8g7wrvZ/46Pvwfbp8Yd8Vvnt8H67UWslb2eEH/Lz89vg98tfxT/P/PgAT4B9QFfA00DQwN7A3iBIUFdQU9CbYObgk+EGIbogwpDtUMjQytDF0Lsw1rDRsZJXxqvWrrocrhHPDOyOwEaERDRGzq91W7109HmkRWRA5tEZnTdaaq2sV1iatPRMlGcWMOhmNjg6Lbor+wPRj1jFnY7xiqmNmWC6sfaznbEd2GXuKY8cp5UzE2sWWxk7G2cXtiZuKd4gvj5/munAruS8TPBNqEuYS/RKPJC4khSW1JuOSo5NP8WR4ibyeFJWUrJSBVIPUgtSRNJu0vWkzfG9+QzqUvia9U0AV/Uz1CXWFW4WjGfYZVRlvM0MzT2ZJZ/Gy+rL1s3dkT+S453y9DrWOta47Vy13c+7oeqf1tRugDTEbujdqbMzfOL7JY9PRzYTNiZt/yDPJK817vSVsS1e+cv6m/LGtHlubCyQK+AXD22y31WxHbedu799hvmP/jk+F7MJrRSZF5UUfilnF174y/ariq4WdsTv7SyxLDu7C7OLtGtrtsPtoqXRpTunYHt897WX0ssKy13uj9l4tX1Zes4+wT7hvpMKnonO/5v5d+z9UxlfeqXKuaq1Wqt5RPXeAfWDwoOPBlhrlmqKa94e4h+7WetS212nXlR/GHM44/LQ+tL73a8bXjQ0KDUUNH4/wjowcDTza02jV2Nik1FTSDDcLm6eORR67+Y3rN50thi21rbTWouPguPD4s2+jvx064X2i+yTjZMt3Wt9Vt1HaCtuh9uz2mY74jpHO8M6BUytOdXfZdrV9b/T9kdNqp6vOyJ4pOUs4m3924VzOudnzqeenL8RdGOuO6n5wcdXF2z0BPf2XvC9duex++WKvU++5K3ZXTl+1uXrqGuNax3XL6+19Fn1tP1j80NZv2d9+w+pG503rm10DywfODjoMXrjleuvyba/b1++svDMwFDJ0dzhyeOQu++7kvaR7L+9n3J9/sOkh+mHhI6lH5Y+VHtf9qPdj64jlyJlR19G+J0FPHoyxxp7/lP7Th/H8p+Sn5ROqE42TZpOnp9ynbj5b/Wz8eerz+emCn6V/rn6h++K7Xxx/6ZtZNTP+kv9y4dfiV/Kvjrxe9rp71n/28ZvkN/NzhW/l3x59x3jX+z7s/cR85gfsh4qPeh+7Pnl/eriQvLDwG/eE8/s3BCkeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAIXRFWHRDcmVhdGlvbiBUaW1lADIwMTk6MDY6MjYgMTg6NTU6MzQyUs/lAAAZSElEQVR4Xu1ceXxVxfU/9759TUjIAtlYDWFRsiCIAi2iuBYq4N7a/rS2Wqks0lpFEGvAlipYa6tWW9f+sAJVi/2guJRiZQmERQSEsEoSyP7yXt7+7uv3zLvv8d4jC4HU/lG+n89kZs6cmXvvnJkz58zMixQOh+lcUHh/lcGcn9dXCsspGiI5rFVaQ6GW2u1zs9pUlvP4L6PbQi5c1GS32VKnSLI0CTXHShqlvyQpkG8C0KxcEw7Km5H8WPJ6V1f83Fyrlp3H14wzFvKop/xDwpLuZxLRjZIuaEYgSRtCCwqRBjEQCgTI1XiSfI5mCvsDJMla0ppSyWIvCGs1KX8PK6FfbZ2j/adgPo+vDV0KedgTznST0bpYksJ3QbCybPATaSFACJYFzUJua2qgxr2HyNfSSiFZprAki7qSokD+AdIEg6S19SJ7QRmZrfnvhwPBmdse0B8QTP+jqKys1KWnp2tefvll/8KFCzFT/nPoVMijngxNJI38hqQNZssmX0S4ej+Eixgh4PNQ7eYvIWQ3BQwmCur0FNJoTwk5DCEHA6Tz+0jvayOdz0u6jBzKHHy5Twoa7quYI78oGLuBRYsWyfPmzctUs2eMYDDos9vtzWo2BtAnaDSau9APm2RZflYlUyAQKJEkybxr167NBQUFRgikFTwnQOtTW1trzsjIKEG+WafTfaFWiQH0txBdpSjKdLT9foSaCPA8j7buDoVC14NnjUo+K/j9/gv0ev2XaHOL2+3+ltlsfri5uXl+WlpaK5d3KOSyZcqP8RJPS0afRjb6hHBlg1cIl4XdfLSe6rYdJa/GSH6jmYJaPYU1GggYCj0KNM2ClpUQaf1eMrpdZPQ4SaM3UkbxtaRTev1+26ZVM5U3p0f0/RkAH9EHH1GjZs8Y+M738T1XqdkYIORLtFrtZyjfhPJLVDLz70Z+WFtbW5bX6/XECxkDYDiE+znyHyA/Wa0SA+h/A/06CPA6CPA9pq1fv147dOhQo8PhCAwaNMgHni6FDJ4/Iro+kkvAC6j7sJpOEDLCGxisTyP+HH01yWKx1EWmXBLKlisPSZL8W9nk1cgmD4lgcZGEOKzz0oldh6lm61fkMtrJY00hP2axouUZHCdgBrJhqO+QVoeBYCG3LZXcllQKQeD1294FveWe0kumvS5jdqo1ugRePoRwpLsBVU9GWkhEeXn5ZpRzWcnx48dNEWrPY9y4cbdg9jsHDhy4VCW1CwgovhONCFaEVAi1N8dq3oDQLlD/N9AgD4B/BCbDvYImSuJQuly5UyK5XAjWfErA0LekaHxUveUINRxoIY8FwoXgWICULNx2wMIO6gzktWBgoG4o4Ke6nWsxcLw3l6YseFpl6xI8MvEBsOi7He5QmxBggUK4gQULFmAdokyU63NycpxMA0ZGuIjQUbOh9uapWSs6cD5m/t1qvicAkyU4Fs8tR9iJZ1+u0tGt0q0IPPDKIxR6kvN4h3XgPRwN0Cofq+UXcR489yFm7fh/Ho8nN0HIpcuDZTJJz0pGqGUOUM+y2Q017Kdg2E/VG49Ty1fOU7MX6rmXWUcTBqTSbcVZdHtJFk0uTKO+9vYHWkTQevKabeQz2UhxOqju4Gd4lu++0mXKd1W2rwVQk7xOtaihEZ3SgJjXbM7Hlg902IMIj6hpK2bKLxDPFIVJaGlpSXG5XDzj9JwHn53zrKo5HwXzIerLabT3JgbNv8AL7SldCFLnlnAEZvD2iws5TERsiKNpEPLQvja2JvOmhr3fwM9hMQ+Wre7YDI4IOEj1u+uo6csGIeCwyUy3lmTTXRdn0yX5dkpQMCr21Lnp9e119NymGmrxwAqPg4Q12uhpI0trExSEm9IvvZqMco4r7A4Nq/ip8ZjK9rWARzq0Q/Xu3bt1Q4YMmQ7h72Rjig0ydJJNZWsX6Lt6CGizmuX8etQZr2ZjQFtj0NmjEJ4BTyNIdvBBBUYA2n5ELKACPH8i1uhPIiURoPxRlC1E/EvED+7Zs0efn4+OV2E0GgfiPTahfDtsiCtVssDatWubY0KGofUwjOLHNRAwr71RFc0zuOWIA2vocXKb7VRS2IdevLGQijLMol5XaHQHafaag/R6ZeKSqIG6NrscZHY2kcaeSnkXX0Mhp3lVxSx5uspyGvCubMSIWXK2QBsvoLPZ+uX0IkSPwLDK5bzJZKoG7R2ow9+CZxrTugJ434FQ1nIadd9FxMYbC1GPPFu38DmJjb7bEAuA7kbUBloG6t+BZ70K2grkb8KAGAeBfcp8LEys4/revXvzLP85eJ5qaGhYCLoXazwvGU2ouyLO8NoKvlFcF+k30PYKvNvfhJBLFjlSNSn2I5I+kCJb2khjjRhZvAY7G3104pP91Ka30q0TBtPvphWSLm7qftngoY+rWuhQk5dCSphyUvR0Wb8UujjPxnZXDM9urKGfvHuQHy7yeDDpvZjNjiZhcaeMnkhW04BwwCuVbp+j2y6YkoC6bnzEORlH+PAH0DFPqumHkC5Hx16GdDM66gs840WEvVGeroB6D4N3sZoVQP0E65qfg/w8hFSUvVldXf19rP/LkY9Z16D/BfkZeJfREPIWbif6fqLROKDOVNDfRNLhdDqHYCZnqEL2wnrPhqvI5S8jv/2xxx4rE0LGLP4ZrOknNDYI1wwhQ9BsRfvg4x5ft59cfg1NHXcBvXrrsJjgtte00dz3DtI/DvISdjouwEwvn9yPpg3nJSqCZz6rofvfrVJzbHEEMJObobabSZOeTrklkzGbLSsqZkm3qCwJ4A5BlLCFio6xIPwJQYdOmYvvOaQWtQt04m6DwSBeAvw3oTNWIL4FoQadux71f4GZ8Uekh4gKAHiuRPuzUbYGfDFfmoH29qO9hGeCL0HIVVVVhgEDBtyIdnjGPoOynyBOcKGQ/yvyU2F4jcBysZvbwbPYjX0ASbaueYA4kG4Gz5V4v2lobwloy5B/joXMdZD/PaLvIGjxbqO4LXXXQrpDgu8rNjtUPzhEQWrcdZI8boX6FWTS8zOKYgL+w5YTNPrZyg4FzNhf76YZr++hu1cfIGHiADPH9qXpIzIiGUCRNRSAz8zGmNJQT/6gkyRNcCprFpUlAax6EN6ODyDnoQN0+LgN+OinksuTQ1TADHQiu1aMXLQhXgzt1JwAkO8dDSAP5TLgZDydA1i79NnZL1aTnUGs/xA6C1IA3/MsntEfyaj38RznIdADO3bseBLvuge0ayHIWyPFYtDfg2BF2b3RwSKXLA8Mk0gqEnvRYqsyAH83RN4WH7UeqocVbKWnbhhKZl1kPLyxo45+uHo/BaOS6wIvbqmlme+cmr23FZ/arBI+NATMrhXDUXOIJH3QqLHZrhWELsBWKj5IuDfonPmCqIINKnzoKozyEpV0GjBjj3KMNvoiZHEadY6lp6fb0MGvRQPKxIYH4jvj6RywZrY7IM8UaGM0nrkayfGIQ4cOHWrXn09GSUlJADP1ZgzUnyOb8O1o5020+yc1i2eQ5puc4MOGqKDDkkJ1FcfIpzPTyIGZdMUFvQTzVw4f/Qgzs7tgC/uJf3xFu060CZUdj5CsjcxkvIn3ZI166CFNVIs7RUpKykJ0fBo+6q9QXwkHH5ixN6HsBtBfSnZholi6dGkd6rJhxEIWLg0GS3R2c2ftQ3hCTf8dIWpgsZrcyemuwHvUPp+vn5o9DWiHO/RbeD5b228NHTqU36cj8JJ0B6txNc+D5CVEwn1BW7wLxx18Je8MMo0BE0oqE6dIfJrEQVao+UgTuR1+8htNdEtZjJd+CUG1+c94BzIBD609TCOXb4ORlrh9HN0RUyDssKOFFLhrYa1SphZ3CMzQYYjY6fdgRkY3K2KAOvsNyvai80bCEr1fJSdAPRg4gZCNkAN+pba2Nn59PYrnvMYJlG3kwGnQXkF0Sj11AAjgB8XFxYegXn+gkk4D2myC0KZiVl7c1NTU0SYL73IxZqHNl/FNg1lDYQB/BJodbfC6zfAg/TjKe8FTeJX3+ZkoQ+kWSupxIc9iPJCatleL3SyeYRMHRWYxa+cVO+tFuifBW6GKRisCphFsgCaMPGVwZ1ud7FrgA1/h0Y+P+gVm7UG1KAZWZ/iWOZwG30Kob7FhkAzU/wP4nkEyH6ElLy9vDoRyVioYWmAK2uNty4s5j+dOQdQHtK84Hw/QahB2IzhhK6zBM7empaUxTQwqBtLPIxxBO3NVktjzRqjG938CegbSczFAPlDLafXq1S+Axq7UpAULFjzFNHaGxFoURd3OY+RRtOJUSdJqqTAj4rHsb3BTkxtGWQf4TkkW/WbKoC7DvAl5lGKK054sZMxm3j1jeJ3C7jCVmu5vdyOCR2dRUREbJKX4mH9t2LAhthfc2Nhow6weis6eDMH9CKP+m+Bht8sGN+OXKpvAypUreTuRNcZJ8F2DeDT40pAuR8x7xt0G6v4KdXnfOBPPPY6wGO8zCPTnVBaGsF9BWwS+ERDWes7D9UlDnmcs73pFMRy0ArSzF9/zU5fLlXfw4MH7QeNgB20+2lmu8gpMnz49hFn+HdRxMR/ix6TSZUqdrA1myHCfFF0zHf5oIznNqeJkKcWip6aFY0XlTw456PIX2l+GinOstG1mh/bNaeC1ueyZypjxpvX7yNraSCaXgwyDhlNGn9Hk9wTzdswzHRcMccBLs4X5QzXNu028frA1lw16VK2dBvCGIXz2QSs4z+v0+PHjG1CHtxhFOaJKRKuxhr4KdfcV0u+jw3hmf4EO5a1N9Km8CIIbAst1MereoJ6KscpnLfgIaKl4zrvl5eUb4s+JUSbcNbS5HeW8fCTMGJRdyW2jfBXaEBtC4JuEeg141g7BpILbQpSKAf7ShAkTMFaDo/BdfAK1BXVHMw/q3oD2/gLanTyTY3uO9V9UkU9joKDeINbKQJwFHb8BkozaVj+1eM98rb4w20Ij+5ySB6vssOqg8cEFIxxUOlIbMXeEPwhhLMIgZC34IDaktiKsRnganTEbH/ttpN8DjwS1+FikJhF3DqI/o+w18N3p9XrZFStDxyxGnU5dHnT6zxBdwWkI3MMxA3V5X3suz87kiwAYLBV4VhDlxSj/J8LG+MACZj7wRA8b2GX8MFnADPCy9fw8Bul88LO636AWxdZT0Faz8MH3ilS2TNknaYOFIUMjHd34EbksmMUmS+zYsPnRSynFqKETrgD1fVzYHe2CDyoGp0PFdzwW6Imr+9OE/mLi0MinK2lXrUukeYvT2tokNkZ0+YMoq2AChRsbLBUL+/D2XwLY4MAHTEKyAR/IQj0JWu3evXtP8joc4UoEykeiI1dCeLcj3qSSOwQfKlgslsNIfgTh3wtVX46BwG4Od/C38MztEBZb3e8g5o2HMwKefzXq345ke3vCfIRasW/fvmVdWNgxoL2JLGw1WwOhzsagqFTzMbCQ3yeNcmVj7UZqqK8VZ77su0bx0d0X0TcHRARzIazj3VC1ZwMNNEHNw2Mow6Ijd0ChXo9+Bk0RGexaCNniaBB72bqCIZSZN66uYqYmwVY4Vxw9etRYUFDgVbP/U2ALdh+FNNRWVw1jyxixcuPw3j4+NIngnjHClTwrzLgwQwiYse5Ac0zADL4LJiMwNAYM8qC8T2R6EP+rAmbIWAQ+9bobKRAMCH+V1+J4vLrtpJh5DD5avKhvh7ZNh7AZtLT0mgFqjuj5zXG3c2Hv8PUgGe4Tp/WmNCwVJE5hzqNnACG7P/G2VodZuKdd3wEa2gK07NOIkcvG16rbh1K27cxP+3Qamf5yWxHl2CN11lW10Novm0SaEb3sx7c6+R0s5r6khJR1avF59ADkijnWBkmj3yWuzoaC4ggwGeUfH6OdtZG1eECakT69ZySV5HR6ni7Qx26gD+4aQZPVbdFWX4ju+Wvctigexdd1dX6vELScmkFy2HR8h+vxs76bDeOFd6Z4e4/DLgS+pLcMrg7vavUIWltbe8U9IzlELd2zBm/2sFegZnkfnnfjuG3etOk2hG62Zw5+TCfpSO9xw9L1nSZoL9T1lFe/EHvXDBb05vuK6aUZhTSKz42TNMCg3iZafFV/2vdAWcya9gbDNOWVL+hQY8zjgJoOkt7nEefKhBltzbkI2iT8onJu95D5xCh6asTqYwTebxb83n+xcCLkcwMsWi3aHI4ku249Cj6WLCoq2olnxLZqkdapz+NduW5DnCejEalw4bGDTQfW9feYreIOFm9phuXEX7/k9zLS298dBh/XolIicMBHPtLsZR+AclMMlKkaWFHUOP1085/30qeHY6doYg3mqz9mZwsZ3E6i9GzKGTKl1Rt29f98lv2UPu8m8D38EO4U4aawVZ2fn8/7vTehbAnih5jO4IMDuFSFoLsdDseO9PR0vEgE3CcoH4k4G+UNb7/9diXvJnEZXKwMq9XK7htf2x0hKnQA1iAGg4F5gkjvstlsMUsW7lk+XDM/2lHgpg2vq6vbhHfI0+v1fDBSCR98Guoe4fdEfBi0d48dO3ZTbm7uJajXCHdpl9pUpxBCZpQuD01qazm+rqXqY/LCyuYjRj7rZWs73hgzaGV68Bt5NGd8Ltn0yT+BSkRACdMrMNwefv8I1btU1w/P00DAOgjY1OaAgOErG0zUp2Qa1Ir5p1tnyZ1eWe0K+J4EITPQWdHrMZ+DLrYNkX4cEd/YEGqI67EfyxsTPJsGDhzId6pj97VQvtvpdE6w2+1NZypkCOIHKP8dgnBZwO8D7Tb4+avUPF8PYn+ctzRzUXYzYr7HVcDljJUrV2qvv/76PFXIvOXIx6viVAv5p5GexenOEJPetlmaD22p+a9lDptKFrwTbzOaXZhlUKXsx/LlO7RKvqBCiz48SgVLNtO9b1fRmn1NVN3qFwcYPFz4TteGI630yAdHafDSCrp71f6IgFHIbfCvKYzuVrI4mxE7STKZKavkOtKQZbu0b0fCPmxPYcmSJVXoEH49PoDnfWI+gOCtwX8GAoEL0bmz0Vkp6Hxxbbd///7XIj8e9Ech2N6IeYfLbbFYkk/HhqHZQFIQhwK8x4427kLyAJ5RigE0A3kDNMOPuDwK0HjQrcczFtbX1/MNEXE2jLgKtO/feOON8UvXcNAXBIPByxCzRvgx/5ojUtQxYjOZMXRpo82iTdsGK3twS30FtR3fS3jryO0N9QZHSMzsyC8lhDXejkUeA+ry+s4+sAzDTit+LuNRBw7W/sy+lF00kaSAzakEA6U98fsofM9pM5lVLzqZd8N4WzF2+MCXDqA+L0b59aDPRF2+Z3UTeK+AwD9AntU3d/xazN41PIu5XtxM5pkYOwFigPZ3tBc7sFd/UlMK2jfQNm9dViIWg0Wtbz5x4oS9T5/I7h4EbeVL+CjbCD5xcBCnrmM0pNchPYkvR/AFRKZ1hASneM+8dGeQAtehifpeGaMod8w0Su03mKzhIFkcjWRF4Gu04iDB44LB5Iba9Qjh8Wzn7UmOOc90A8p5tppczajbFNMOWo2GbMWXUs6IySzgAPTajP/kD+AgFD684LVF3FjgWYZOej4lJaUenf//IBUxHRAjHmvdhyhngYRQ7xbwvILBcAjCT/6ZzTGU8wyNhXgBYyYuyM7OrseA4b3z6E9wko3KhqiAzwB8NzwKYQWj3c7XTCBx5wPYPlu/XwoG8THhOvJZKK1vCeWNu46yx1xCtqx0soQDEHQj2VoayOZogPAQkOdBwHQxGBALuqNexDwwWEXrLSayXVRKuRO/TfZehaR4jLxG3Voxp/0fhfUUYNREfz0hbnbMnz9/MjqHD+jfWLVqVRbUafSyvDCsDh8+bIBKXAlDqRCC5eNKXldTIMB2Lx+0B7YDwM8DZROMpcy9e/dORRus9pJPchIOQ9AfUdXanoo8pXa7gdOEzKh4QFcJ9XkZ2twT9sL4cpnJbM6j7KFjqGDSFZR71TcovfgCsuf1JqvNQGY5SKaQh8y+NjL5XGQKeMgkK2Syoiwvi1JLLqS+11xHuWOvol5ZRRRGe4rXUA+36eptczQr1cf2JPjO81sIqxA+Q98uRtyCjv+VWh691tt36tSpIzFzF6p5ocrz8vL4EtznZrOZb5e0IUS3WZMP//NRxs9JCFjH0/HM6HLROycnZzjcoiVqPvmsOmFmV1dXs7XNwhwAgc/l60ORkrNHwpqcjOInT1o0msxlGFJ3gVPiO2Dt/T6Z08kIh6BFwjKFA1jDOR3UkeKDW4Y8KdI6Jej93rZ5pm7/OrEr4Hsc6GDx6wK1s/io61PMzAejLofqVq0F3wSV53UEvlfmg2odtHXrVm1xcfHvkP8eeKKW8QbM7On8W6zomsz09oB1Mo9/lQEt8Drqi5uUqM9rdzpCEVylzKysLB48vCY3gkcYhFGALq70Ig7zxX9oBH3UhQKdb5swzxqkr0V5ATRVp7866VTIUZT8OniprNX8WiJpDOf5+q649Jf0nwYSEBVyEEYaCxpCDlO4CsRH4CatULn+a0DHSRBGfwi/DQJp94ZkU1OTHcLMAU8LZvVZ/TsMPqfmGII47QpQR1DfbSCWEQeef853rs5IyFGULQtdLkkyuwUYTeovGXhGs6CTEIaAhaAxj/HnIwj4T5UbV7/Vnd8in0fPoFtCjmLUIvhmKZnw1eSxMCUKQcpDMzak2VhwosWTSOwPK8oWn9z2j3PZwTqPcwXRvwGbdJHf31JZSgAAAABJRU5ErkJggg=="
                    }
                }
            });
            viewer.das.logoObj = ViewportQuad;
        }
    }, {
        key: "watermark",
        value: function watermark(settings) {
            //默认设置
            var defaultSettings = {
                watermarl_element: "body",
                watermark_txt: "云端地球未注册",
                watermark_x: 20, //水印起始位置x轴坐标
                watermark_y: 20, //水印起始位置Y轴坐标
                watermark_rows: 2000, //水印行数
                watermark_cols: 2000, //水印列数
                watermark_x_space: 70, //水印x轴间隔
                watermark_y_space: 30, //水印y轴间隔
                watermark_color: '#aaa', //水印字体颜色
                watermark_alpha: 0.4, //水印透明度
                watermark_fontsize: '15px', //水印字体大小
                watermark_font: '微软雅黑', //水印字体
                watermark_width: 210, //水印宽度
                watermark_height: 80, //水印长度
                watermark_angle: 15 //水印倾斜度数
            };
            //采用配置项替换默认值，作用类似jquery.extend
            if (arguments.length === 1 && _typeof(arguments[0]) === "object") {
                var src = arguments[0] || {};
                for (key in src) {
                    if (src[key] && defaultSettings[key] && src[key] === defaultSettings[key]) continue;else if (src[key]) defaultSettings[key] = src[key];
                }
            }
            var oTemp = document.createDocumentFragment();
            var maskElement = document.getElementById(defaultSettings.watermarl_element) || document.body;
            //获取页面最大宽度
            var page_width = Math.max(maskElement.scrollWidth, maskElement.clientWidth);
            //获取页面最大高度
            var page_height = Math.max(maskElement.scrollHeight, maskElement.clientHeight);
            //水印数量自适应元素区域尺寸
            defaultSettings.watermark_cols = Math.ceil(page_width / (defaultSettings.watermark_x_space + defaultSettings.watermark_width));
            defaultSettings.watermark_rows = Math.ceil(page_height / (defaultSettings.watermark_y_space + defaultSettings.watermark_height));
            var x;
            var y;
            for (var i = 0; i < defaultSettings.watermark_rows; i++) {
                y = defaultSettings.watermark_y + (defaultSettings.watermark_y_space + defaultSettings.watermark_height) * i;
                for (var j = 0; j < defaultSettings.watermark_cols; j++) {
                    x = defaultSettings.watermark_x + (defaultSettings.watermark_width + defaultSettings.watermark_x_space) * j;
                    var mask_div = document.createElement('div');
                    mask_div.id = 'mask_div' + i + j;
                    mask_div.className = 'mask_div';
                    //mask_div.appendChild(document.createTextNode(defaultSettings.watermark_txt));
                    mask_div.innerHTML = defaultSettings.watermark_txt;
                    //设置水印div倾斜显示
                    mask_div.style.webkitTransform = "rotate(-" + defaultSettings.watermark_angle + "deg)";
                    mask_div.style.MozTransform = "rotate(-" + defaultSettings.watermark_angle + "deg)";
                    mask_div.style.msTransform = "rotate(-" + defaultSettings.watermark_angle + "deg)";
                    mask_div.style.OTransform = "rotate(-" + defaultSettings.watermark_angle + "deg)";
                    mask_div.style.transform = "rotate(-" + defaultSettings.watermark_angle + "deg)";
                    mask_div.style.visibility = "";
                    mask_div.style.position = "absolute";
                    mask_div.style.left = x + 'px';
                    mask_div.style.top = y + 'px';
                    mask_div.style.overflow = "hidden";
                    mask_div.style.zIndex = "9999";
                    mask_div.style.pointerEvents = 'none'; //pointer-events:none  让水印不遮挡页面的点击事件
                    //mask_div.style.border="solid #eee 1px";　　　　　　　　　　//兼容IE9以下的透明度设置                mask_div.style.filter="alpha(opacity=50)";
                    mask_div.style.opacity = defaultSettings.watermark_alpha;
                    mask_div.style.fontSize = defaultSettings.watermark_fontsize;
                    mask_div.style.fontFamily = defaultSettings.watermark_font;
                    mask_div.style.color = defaultSettings.watermark_color;
                    mask_div.style.textAlign = "center";
                    mask_div.style.width = defaultSettings.watermark_width + 'px';
                    mask_div.style.height = defaultSettings.watermark_height + 'px';
                    mask_div.style.display = "block";
                    oTemp.appendChild(mask_div);
                };
            };
            maskElement.appendChild(oTemp);
        }
    }]);

    return dasAuthentication;
}();

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FloodByEntity = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(10);

var _Attr = __webpack_require__(21);

var polygonAttr = _interopRequireWildcard(_Attr);

var _tileset = __webpack_require__(32);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//淹没分析(平面)类
var FloodByEntity = exports.FloodByEntity = function (_DasClass) {
  _inherits(FloodByEntity, _DasClass);

  //========== 构造方法 ==========
  function FloodByEntity(options, oldparam) {
    _classCallCheck(this, FloodByEntity);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (FloodByEntity.__proto__ || Object.getPrototypeOf(FloodByEntity)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    return _this;
  }

  //========== 对外属性 ==========
  //高度


  _createClass(FloodByEntity, [{
    key: "start",


    //========== 方法 ==========

    //开发分析
    value: function start(entity, options) {
      var _this2 = this;

      this.stop();

      this.entity = entity;
      this.options = options;

      //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
      if (this.options.onChange) {
        var onChangefun = options.onChange;
        delete options.onChange;
        this.off(_DasClass2.eventType.change);
        this.on(_DasClass2.eventType.change, function (e) {
          onChangefun(e.height);
        });
      }
      if (this.options.onStop) {
        var onStopfun = options.onStop;
        delete options.onStop;
        this.off(_DasClass2.eventType.end);
        this.on(_DasClass2.eventType.end, onStopfun);
      }
      //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

      this.extrudedHeight = options.height;
      this.entity.polygon.extrudedHeight = new Cesium.CallbackProperty(function (time) {
        return _this2.extrudedHeight;
      }, false);

      this.fire(_DasClass2.eventType.start);

      //修改高度值
      var positions = polygonAttr.getPositions(this.entity);
      var _has3dtiles = Cesium.defaultValue(options.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(this.viewer.scene, positions))); //是否在3ditiles上面
      if (!_has3dtiles) {
        this._last_depthTestAgainstTerrain = this.viewer.scene.globe.depthTestAgainstTerrain;
        this.viewer.scene.globe.depthTestAgainstTerrain = true;
      }

      positions = (0, _point.setPositionsHeight)(positions, options.height);
      this.entity.polygon.hierarchy = new Cesium.PolygonHierarchy(positions);

      this.timeIdx = setInterval(function () {
        if (_this2.extrudedHeight >= _this2.options.maxHeight) {
          _this2.stop();
          _this2.fire(_DasClass2.eventType.end);
          return;
        }
        var newHeight = _this2.extrudedHeight + _this2.options.speed / 10;
        if (newHeight > _this2.options.maxHeight) {
          _this2.extrudedHeight = _this2.options.maxHeight;
        } else {
          _this2.extrudedHeight = newHeight;
        }

        _this2.fire(_DasClass2.eventType.change, {
          height: _this2.extrudedHeight
        });
      }, 100);
    }
    //停止分析

  }, {
    key: "stop",
    value: function stop() {
      clearInterval(this.timeIdx);
    }

    //清除分析

  }, {
    key: "clear",
    value: function clear() {
      this.stop();
      if (this._last_depthTestAgainstTerrain !== null) this.viewer.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
      this.entity = null;
    }

    //更新高度

  }, {
    key: "updateHeight",
    value: function updateHeight(height) {
      this.extrudedHeight = height;

      this.fire(_DasClass2.eventType.change, {
        height: this.extrudedHeight
      });
    }
  }, {
    key: "getHeightRange",
    value: function getHeightRange(positions) {
      return (0, _polygon.getHeightRange)(positions, this.viewer.scene, {
        inSurface: true
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(FloodByEntity.prototype.__proto__ || Object.getPrototypeOf(FloodByEntity.prototype), "destroy", this).call(this);
    }
  }, {
    key: "height",
    get: function get() {
      return this.extrudedHeight;
    },
    set: function set(val) {
      this.extrudedHeight = val;
    }
  }]);

  return FloodByEntity;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


FloodByEntity.event = {
  start: _DasClass2.eventType.start,
  change: _DasClass2.eventType.change,
  end: _DasClass2.eventType.end
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FloodByTerrain = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形淹没（材质）分析 类
var FloodByTerrain = exports.FloodByTerrain = function (_DasClass) {
  _inherits(FloodByTerrain, _DasClass);

  //========== 构造方法 ==========
  function FloodByTerrain(options, oldparam) {
    _classCallCheck(this, FloodByTerrain);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (FloodByTerrain.__proto__ || Object.getPrototypeOf(FloodByTerrain)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    _this.minHeight = options.minHeight;
    _this.maxHeight = options.maxHeight;

    //检查参数
    if (!Cesium.defined(_this.minHeight)) {
      daslog.warn("minHeight请传入有效数值！");
      return _possibleConstructorReturn(_this);
    }
    if (!Cesium.defined(_this.maxHeight)) {
      daslog.warn("maxHeight请传入有效数值！");
      return _possibleConstructorReturn(_this);
    }
    if (_this.minHeight > _this.maxHeight) {
      //互相交换数据
      var temp = _this.minHeight;
      _this.minHeight = _this.maxHeight;
      _this.maxHeight = temp;
    }

    _this.height = options.height;
    _this.floodVar = Cesium.defaultValue(options.floodVar, [0, 0, 0, 500]); //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
    _this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.rect_flood = Cesium.defaultValue(options.rect_flood, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
    _this.ym_max_index = Cesium.defaultValue(options.ym_max_index, 0); //点选点的个数
    _this._globe = Cesium.defaultValue(options.globe, true); //是否全球淹没
    _this._speed = Cesium.defaultValue(options.speed, 1); //淹没速度
    _this._visibleOutArea = Cesium.defaultValue(options.visibleOutArea, true); //是否显示非淹没区域
    _this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
    _this._show = Cesium.defaultValue(options.show, true);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (options.onChange) {
      var onChangefun = options.onChange;
      delete options.onChange;
      _this.on(_DasClass2.eventType.change, function (e) {
        onChangefun(e.height);
      });
    }
    if (options.onStop) {
      var onStopfun = options.onStop;
      delete options.onStop;
      _this.on(_DasClass2.eventType.end, onStopfun);
    }
    _this.cancelFloodSpeed = _this.stop; //别名
    _this.reFlood = _this.restart;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    if (options.positions && options.positions.length > 0) _this.start(options.positions);
    return _this;
  }

  //========== 对外属性 ==========
  //分析参数


  _createClass(FloodByTerrain, [{
    key: "start",

    //========== 方法 ==========

    //初始化
    value: function start(positions) {
      this._positions = positions || this._positions;
      if (!positions || positions.length == 0) return;

      this._prepareFlood(positions);
      this._setFloodVar();
      this._startFlood();
      this._activeFloodSpeed();
    }

    //激活淹没动画

  }, {
    key: "_activeFloodSpeed",
    value: function _activeFloodSpeed() {
      var that = this;
      if (!this.activeFlooding) {
        this.fire(_DasClass2.eventType.start);
        this.activeFlooding = function () {
          if (that.height) {
            that.floodVar[1] = that.height();
          } else {
            that.floodVar[1] += that.speed / 50; //50帧每秒
          }
          if (that.floodVar[1] > that.floodVar[2]) {
            that.floodVar[1] = that.floodVar[2];
            that.stop();
            // that.onStop&&that.onStop();
            return;
          }
          if (that.floodVar[1] < that.floodVar[0]) {
            that.floodVar[1] = that.floodVar[0];
            that.stop();
            // that.onStop&&that.onStop();
            return;
          }
          that.floodAnalysis.floodVar[1] = that.floodVar[1];
          that.fire(_DasClass2.eventType.change, {
            height: that.floodVar[1]
          });
        };
        this.viewer.clock.onTick.addEventListener(this.activeFlooding);
      }
    }

    //暂停淹没动画

  }, {
    key: "stop",
    value: function stop() {
      if (this.activeFlooding) {
        this.viewer.clock.onTick.removeEventListener(this.activeFlooding);
      }
      this.activeFlooding = null;
      this.fire(_DasClass2.eventType.end);
    }
    //重新淹没

  }, {
    key: "restart",
    value: function restart() {
      this.floodVar[1] = this.floodVar[0];
      this._activeFloodSpeed();
    }

    //与处理顶点数组

  }, {
    key: "_prepareFlood",
    value: function _prepareFlood(arr) {
      this.ym_pos_arr = arr;
      var len = arr.length;
      if (len == 0) return;
      this.ym_max_index = len;
      var minX = 99999999;
      var minY = 99999999;
      var minZ = 99999999;
      var maxX = -99999999;
      var maxY = -99999999;
      var maxZ = -99999999;
      for (var i = 0; i < len; i++) {
        if (arr[i]) {
          this.ym_pos_x[i] = arr[i].x;
          this.ym_pos_y[i] = arr[i].y;
          this.ym_pos_z[i] = arr[i].z;

          if (arr[i].x > maxX) {
            maxX = arr[i].x;
          }
          if (arr[i].x < minX) {
            minX = arr[i].x;
          }

          if (arr[i].y > maxY) {
            maxY = arr[i].y;
          }
          if (arr[i].y < minY) {
            minY = arr[i].y;
          }

          if (arr[i].z > maxZ) {
            maxZ = arr[i].z;
          }
          if (arr[i].z < minZ) {
            minZ = arr[i].z;
          }
        } else {
          this.ym_pos_x[i] = 0.0;
          this.ym_pos_y[i] = 0.0;
          this.ym_pos_z[i] = 0.0;
        }
      }
      var chaNum = this.boundingSwell;
      this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
    }
    //设置淹没高度

  }, {
    key: "_setFloodVar",
    value: function _setFloodVar() {
      this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
    }
    //开始淹没

  }, {
    key: "_startFlood",
    value: function _startFlood() {
      this.floodAnalysis.floodVar[0] = this.floodVar[0];
      this.floodAnalysis.floodVar[1] = this.floodVar[1];
      this.floodAnalysis.ym_pos_x = this.ym_pos_x;
      this.floodAnalysis.ym_pos_y = this.ym_pos_y;
      this.floodAnalysis.ym_pos_z = this.ym_pos_z;
      this.floodAnalysis.rect_flood = this.rect_flood;
      this.floodAnalysis.ym_pos_arr = this.ym_pos_arr;
      this.floodAnalysis.floodSpeed = this.speed;
      this.floodAnalysis.ym_max_index = this.ym_max_index;
      this.floodAnalysis.globe = this.globe = false;
      this.floodAnalysis.showElseArea = this.visibleOutArea;
      this.viewer.scene.globe.material = Cesium.Material.fromType("YanMo");
    }
  }, {
    key: "clear",
    value: function clear() {
      this.stop();
      this.viewer.scene.globe.material = null;
      this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(FloodByTerrain.prototype.__proto__ || Object.getPrototypeOf(FloodByTerrain.prototype), "destroy", this).call(this);
    }
  }, {
    key: "floodAnalysis",
    get: function get() {
      return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
    }
  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = val;
      this.start(val);
    }

    //显示非淹没区域

  }, {
    key: "visibleOutArea",
    get: function get() {
      return this._visibleOutArea;
    },
    set: function set(val) {
      this._visibleOutArea = val;
      this.floodAnalysis.showElseArea = val;
    }

    //全球淹没

  }, {
    key: "globe",
    get: function get() {
      return this._globe;
    },
    set: function set(val) {
      this._globe = val;
      this.floodAnalysis.globe = val;
    }

    //淹没速度

  }, {
    key: "speed",
    get: function get() {
      return this._speed;
    },
    set: function set(val) {
      this._speed = Number(val);
    }
    //点集合的包围盒膨胀数值

  }, {
    key: "boundingSwell",
    get: function get() {
      return this._boundingSwell;
    },
    set: function set(num) {
      var rect = this._base_rect;
      this._boundingSwell = Number(num);
      this.rect_flood = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] - this.boundingSwell, rect[4] - this.boundingSwell, rect[5] - this.boundingSwell, 0, 0, 0];
      this.floodAnalysis.rect_flood = this.rect_flood;
    }

    //显示和隐藏

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (val) {
        this.viewer.scene.globe.material = Cesium.Material.fromType("YanMo");
      } else {
        this.viewer.scene.globe.material = null;
      }
    }
  }]);

  return FloodByTerrain;
}(_DasClass2.DasClass);
//[静态属性]本类中支持的事件类型常量


FloodByTerrain.event = {
  start: _DasClass2.eventType.start,
  change: _DasClass2.eventType.change,
  end: _DasClass2.eventType.end
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Measure = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var util = _interopRequireWildcard(_util);

var _Draw = __webpack_require__(6);

var _MeasureBase = __webpack_require__(29);

var _MeasureAngle = __webpack_require__(77);

var _MeasureArea = __webpack_require__(37);

var _MeasureAreaSurface = __webpack_require__(78);

var _MeasureHeight = __webpack_require__(50);

var _MeasureHeightTriangle = __webpack_require__(79);

var _MeasureLength = __webpack_require__(38);

var _MeasureLengthSection = __webpack_require__(80);

var _MeasureLengthSurface = __webpack_require__(81);

var _MeasurePoint = __webpack_require__(82);

var _MeasureVolume = __webpack_require__(83);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //提供测量长度、面积等 [绘制基于draw]

//量算类(统一入口)
var Measure = exports.Measure = function (_DasClass) {
  _inherits(Measure, _DasClass);

  function Measure(options, oldparam) {
    _classCallCheck(this, Measure);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Measure.__proto__ || Object.getPrototypeOf(Measure)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    _this.clearMeasure = _this.clear; //别名, 但不建议使用。
    _this.measuerLength = _this.length;
    _this.measureSection = _this.section;
    _this.measureArea = _this.area;
    _this.measureHeight = _this.height;
    _this.measureAngle = _this.angle;
    _this.measurePoint = _this.point;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.options = options;

    // 标绘对象
    _this.drawControl = new _Draw.Draw(options.viewer, _extends({
      hasEdit: options.hasEdit || true,
      isAutoEditing: false,
      hasDel: function hasDel(e) {
        return false;
      }
    }, options));
    _this.options.draw = _this.drawControl;
    return _this;
  }

  _createClass(Measure, [{
    key: "length",


    /*长度测量*/
    value: function length(opts) {
      this.stopDraw();
      if (opts && opts.terrain) {
        //兼容v2.2之前旧版本处理,贴地
        return this.surfaceLength(opts);
      } else {
        if (!this._measureLength) {
          this._measureLength = new _MeasureLength.MeasureLength(this.options, this);
        }
        this._measureLength.startDraw(opts);
        return this._measureLength;
      }
    }

    /*贴地 长度测量*/

  }, {
    key: "surfaceLength",
    value: function surfaceLength(opts) {
      this.stopDraw();
      if (!this._measureLengthSurface) {
        this._measureLengthSurface = new _MeasureLengthSurface.MeasureLengthSurface(this.options, this);
      }
      this._measureLengthSurface.startDraw(opts);
      return this._measureLengthSurface;
    }

    /*剖面分析*/

  }, {
    key: "section",
    value: function section(opts) {
      this.stopDraw();
      if (!this._measureLengthSection) {
        this._measureLengthSection = new _MeasureLengthSection.MeasureLengthSection(this.options, this);
      }
      this._measureLengthSection.startDraw(opts);
      return this._measureLengthSection;
    }

    /*面积测量*/

  }, {
    key: "area",
    value: function area(opts) {
      this.stopDraw();
      if (opts && opts.terrain) {
        //兼容v2.2之前旧版本处理,贴地
        return this.surfaceeArea(opts);
      } else {
        if (!this._measureArea) {
          this._measureArea = new _MeasureArea.MeasureArea(this.options, this);
        }
        this._measureArea.startDraw(opts);
        return this._measureArea;
      }
    }

    /*贴地 面积测量*/

  }, {
    key: "surfaceeArea",
    value: function surfaceeArea(opts) {
      this.stopDraw();
      if (!this._measureAreaSurface) {
        this._measureAreaSurface = new _MeasureAreaSurface.MeasureAreaSurface(this.options, this);
      }
      this._measureAreaSurface.startDraw(opts);
      return this._measureAreaSurface;
    }

    /*体积测量（方量分析）*/

  }, {
    key: "volume",
    value: function volume(opts) {
      this.stopDraw();
      if (!this._measureVolume) {
        this._measureVolume = new _MeasureVolume.MeasureVolume(this.options, this);
      }
      this._measureVolume.startDraw(opts);
      return this._measureVolume;
    }

    /*高度测量*/

  }, {
    key: "height",
    value: function height(opts) {
      this.stopDraw();
      if (opts && opts.isSuper) {
        //兼容v2.2之前旧版本处理,三角测量
        return this.triangleHeight(opts);
      } else {
        if (!this._measureHeight) {
          this._measureHeight = new _MeasureHeight.MeasureHeight(this.options, this);
        }
        this._measureHeight.startDraw(opts);
        return this._measureHeight;
      }
    }

    /*三角高度测量*/

  }, {
    key: "triangleHeight",
    value: function triangleHeight(opts) {
      this.stopDraw();
      if (!this._measureHeightTriangle) {
        this._measureHeightTriangle = new _MeasureHeightTriangle.MeasureHeightTriangle(this.options, this);
      }
      this._measureHeightTriangle.startDraw(opts);
      return this._measureHeightTriangle;
    }

    /*角度测量*/

  }, {
    key: "angle",
    value: function angle(opts) {
      this.stopDraw();
      if (!this._measureAngle) {
        this._measureAngle = new _MeasureAngle.MeasureAngle(this.options, this);
      }
      this._measureAngle.startDraw(opts);
      return this._measureAngle;
    }

    /*坐标测量*/

  }, {
    key: "point",
    value: function point(opts) {
      this.stopDraw();
      if (!this._measurePoint) {
        this._measurePoint = new _MeasurePoint.MeasurePoint(this.options, this);
      }
      this._measurePoint.startDraw(opts);
      return this._measurePoint;
    }

    //取消并停止绘制
    //如果上次未完成绘制就单击了新的，清除之前未完成的。

  }, {
    key: "stopDraw",
    value: function stopDraw() {
      if (this._measureAngle) this._measureAngle.stopDraw();
      if (this._measureArea) this._measureArea.stopDraw();
      if (this._measureAreaSurface) this._measureAreaSurface.stopDraw();
      if (this._measureHeight) this._measureHeight.stopDraw();
      if (this._measureHeightTriangle) this._measureHeightTriangle.stopDraw();
      if (this._measureLength) this._measureLength.stopDraw();
      if (this._measureLengthSection) this._measureLengthSection.stopDraw();
      if (this._measureLengthSurface) this._measureLengthSurface.stopDraw();
      if (this._measurePoint) this._measurePoint.stopDraw();
      if (this._measureVolume) this._measureVolume.stopDraw();
    }

    //外部控制，完成绘制，比如手机端无法双击结束

  }, {
    key: "endDraw",
    value: function endDraw() {
      if (this._measureAngle) this._measureAngle.endDraw();
      if (this._measureArea) this._measureArea.endDraw();
      if (this._measureAreaSurface) this._measureAreaSurface.endDraw();
      if (this._measureHeight) this._measureHeight.endDraw();
      if (this._measureHeightTriangle) this._measureHeightTriangle.endDraw();
      if (this._measureLength) this._measureLength.endDraw();
      if (this._measureLengthSection) this._measureLengthSection.endDraw();
      if (this._measureLengthSurface) this._measureLengthSurface.endDraw();
      if (this._measurePoint) this._measurePoint.endDraw();
      if (this._measureVolume) this._measureVolume.endDraw();
    }

    /*清除测量*/

  }, {
    key: "clear",
    value: function clear() {
      if (this._measureAngle) this._measureAngle.clear();
      if (this._measureArea) this._measureArea.clear();
      if (this._measureAreaSurface) this._measureAreaSurface.clear();
      if (this._measureHeight) this._measureHeight.clear();
      if (this._measureHeightTriangle) this._measureHeightTriangle.clear();
      if (this._measureLength) this._measureLength.clear();
      if (this._measureLengthSection) this._measureLengthSection.clear();
      if (this._measureLengthSurface) this._measureLengthSurface.clear();
      if (this._measurePoint) this._measurePoint.clear();
      if (this._measureVolume) this._measureVolume.clear();
    }

    /** 更新量测结果的单位 */

  }, {
    key: "updateUnit",
    value: function updateUnit(unit, oldparam) {
      //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
      if (oldparam) {
        unit = oldparam;
      }
      //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

      var arr = this.dataSource.entities.values;
      for (var i = 0, len = arr.length; i < len; i++) {
        var entity = arr[i];
        if (entity.label && entity.attribute && entity.showText) {
          entity.showText(unit);
        }
      }
    }
  }, {
    key: "formatArea",
    value: function formatArea(val, unit) {
      return util.formatArea(val, unit);
    }
  }, {
    key: "formatLength",
    value: function formatLength(val, unit) {
      return util.formatLength(val, unit);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.stopDraw();
      this.clear();

      this.drawControl.destroy();
      _get(Measure.prototype.__proto__ || Object.getPrototypeOf(Measure.prototype), "destroy", this).call(this);
    }
  }, {
    key: "draw",
    get: function get() {
      return this.drawControl;
    }
  }, {
    key: "dataSource",
    get: function get() {
      return this.drawControl.dataSource;
    }
  }]);

  return Measure;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


Measure.event = _MeasureBase.MeasureBase.event;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skyline = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _Skyline = __webpack_require__(153);

var _Skyline2 = _interopRequireDefault(_Skyline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//天际线 类
var Skyline = exports.Skyline = function (_DasClass) {
  _inherits(Skyline, _DasClass);

  function Skyline(options, oldparam) {
    _classCallCheck(this, Skyline);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Skyline.__proto__ || Object.getPrototypeOf(Skyline)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    _this.tjxWidth = Cesium.defaultValue(options.tjxWidth, 2); //天际线宽度
    _this.strokeType = Cesium.defaultValue(options.strokeType, new Cesium.Cartesian3(true, false, false)); //天际线，物体描边，全描边
    _this.tjxColor = Cesium.defaultValue(options.tjxColor, new Cesium.Color(1.0, 0.0, 0.0)); //边际线颜色
    _this.bjColor = Cesium.defaultValue(options.bjColor, new Cesium.Color(0.0, 0.0, 1.0)); //物体描边颜色
    _this.mbDis = Cesium.defaultValue(options.mbDis, 500); //物体描边距离

    var that = _this;
    _this.postProcess = new Cesium.PostProcessStage({
      fragmentShader: _Skyline2.default,
      uniforms: {
        height: function height() {
          return that.viewer.camera.positionCartographic.height;
        },
        lineWidth: function lineWidth() {
          return that.tjxWidth;
        },
        strokeType: function strokeType() {
          return that.strokeType;
        },
        tjxColor: function tjxColor() {
          return that.tjxColor;
        },
        bjColor: function bjColor() {
          return that.bjColor;
        },
        cameraPos: function cameraPos() {
          return that.viewer.scene.camera.position;
        },
        mbDis: function mbDis() {
          return that.mbDis;
        }
      }
    });
    _this.postProcess.enabled = Cesium.defaultValue(options.enabled, true);
    _this.viewer.scene.postProcessStages.add(_this.postProcess);
    return _this;
  }

  //显示和隐藏


  _createClass(Skyline, [{
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      // this.postProcess.destroy();
      // delete this.postProcess;

      _get(Skyline.prototype.__proto__ || Object.getPrototypeOf(Skyline.prototype), "destroy", this).call(this);
    }
  }, {
    key: "enabled",
    get: function get() {
      return this.postProcess.enabled;
    },
    set: function set(val) {
      this.postProcess.enabled = val;
    }
  }]);

  return Skyline;
}(_DasClass2.DasClass);

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float lineWidth;\r\nuniform float height;\r\nuniform bvec3 strokeType;\r\nuniform vec3 tjxColor;\r\nuniform vec3 bjColor;\r\nuniform vec3 cameraPos;\r\nuniform float mbDis;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nbool isTJX(vec2 uv,float lw){\r\n    vec2 pixelSize = lw / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n\r\n    vec2 currUV = uv + vec2(dx0, dy0);\r\n    vec4 currDepth = texture2D(depthTexture, currUV);\r\n    float depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    return false;\r\n}\r\nvoid main(){\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    if(height>14102.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    if(strokeType.y||strokeType.z){\r\n        vec4 wp = czm_inverseView * positionEC;\r\n        if(distance(wp.xyz,cameraPos)>mbDis){\r\n            gl_FragColor = color;\r\n        }else{\r\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\r\n            if(dotNum<0.05){\r\n                gl_FragColor = vec4(bjColor,1.0);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if(strokeType.x||strokeType.z){\r\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\r\n        if(tjx){\r\n            gl_FragColor = vec4(tjxColor,1.0);\r\n            return;\r\n        }\r\n    }\r\n    gl_FragColor = color;\r\n}"

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkylineAnalyse = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _Drawline = __webpack_require__(155);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//天际线 类
var SkylineAnalyse = exports.SkylineAnalyse = function (_DasClass) {
  _inherits(SkylineAnalyse, _DasClass);

  function SkylineAnalyse(options, oldparam) {
    _classCallCheck(this, SkylineAnalyse);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (SkylineAnalyse.__proto__ || Object.getPrototypeOf(SkylineAnalyse)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
    _this._viewer = options.viewer;
    _this.scene = options.viewer.scene;
    _this.context = _this.scene.context;
    _this._viewer = options.viewer;
    _this._lineColor = Cesium.defaultValue(options.lineColor, Cesium.Color.RED); //天际线颜色
    _this._lineWidth = Cesium.defaultValue(options.lineWidth, 2); //天际线线宽
    _this._faceColor = Cesium.defaultValue(options.faceColor, Cesium.Color.CHOCOLATE); //限高体颜色
    _this._faceOutlineColor = Cesium.defaultValue(options.faceOutlineColor, Cesium.Color.WHITE); //限高体轮廓颜色
    _this._radius = Cesium.defaultValue(options.radius, 5000); //天际线分析范围
    _this._viewPosition = Cesium.defaultValue(options.viewPosition, void 0);
    _this._heading = Cesium.defaultValue(options.heading, void 0);
    _this._pitch = Cesium.defaultValue(options.pitch, void 0);
    _this._roll = Cesium.defaultValue(options.roll, void 0);
    _this._fov = Cesium.defaultValue(options.fov, void 0);
    _this.height = _this.context.drawingBufferHeight;
    _this.width = _this.context.drawingBufferWidth;
    _this.uniformState = _this.context.uniformState;
    _this.camera = _this.scene.camera;
    _this.customCamera = null;
    _this.isUpdateRadius = true; //是否可以修改半径
    _this.fragmentShader = "\n    #extension GL_OES_standard_derivatives : enable\n    uniform sampler2D depthTexture;\n    varying vec2 v_textureCoordinates;\n    void main() \n    {\n        gl_FragColor = czm_packDepth(texture2D(depthTexture, v_textureCoordinates).r);\n    }";
    _this.init();
    return _this;
  }

  _createClass(SkylineAnalyse, [{
    key: "init",
    value: function init() {
      this.createTexture();
      this.createFramebuffer();
      this.clear();
      this.isDestroyStatus = false;
    }

    //创建纹理

  }, {
    key: "createTexture",
    value: function createTexture() {
      //颜色纹理
      this.colorTexture = new Cesium.Texture({
        context: this.context,
        width: this.width,
        height: this.height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
      });
      //深度模版纹理
      this.depthStencilTexture = new Cesium.Texture({
        context: this.context,
        width: this.width,
        height: this.height,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });
      //_深度纹理
      this._depthTexture = new Cesium.Texture({
        context: this.context,
        width: this.width,
        height: this.height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });
    }
    //创建缓冲器

  }, {
    key: "createFramebuffer",
    value: function createFramebuffer() {
      this.frameBuffer = new Cesium.Framebuffer({
        context: this.context,
        colorTextures: [this.colorTexture],
        depthStencilTexture: this.depthStencilTexture,
        destroyAttachments: !1
      });
      this._copyDepthFramebuffer = new Cesium.Framebuffer({
        context: this.context,
        colorTextures: [this._depthTexture],
        destroyAttachments: !1
      });
      this.passState = new Cesium.PassState(this.context);
      this.passState.framebuffer = this.frameBuffer;
      this.passState.viewport = new Cesium.BoundingRectangle(0, 0, this.width, this.height);
      this.depthPassState = new Cesium.PassState(this.context);
      this.depthPassState.framebuffer = this._copyDepthFramebuffer;
      this.depthPassState.viewport = new Cesium.BoundingRectangle(0, 0, this.width, this.height);
    }
    //清除

  }, {
    key: "clear",
    value: function clear() {
      this.clearCommand = new Cesium.ClearCommand({
        depth: 1,
        color: new Cesium.Color(1, 1, 1, 0)
      });
      this.clearPassState = new Cesium.PassState(this.context);
      this.clearCommand.framebuffer = this.frameBuffer;
    }

    //修改命令

  }, {
    key: "updateCommand",
    value: function updateCommand() {
      this.clearCommand.execute(this.context, this.clearPassState), this.updateCustomCamera(), this.uniformState.updateCamera(this.camera);
      for (var frustumCommandsList = this.scene._view.frustumCommandsList, frustumCommandsListLength = frustumCommandsList.length, commands = void 0, itemIndices = void 0, oldIndex = void 0, PassArr = [Cesium.Pass.ENVIRONMENT, Cesium.Pass.GLOBE, Cesium.Pass.CESIUM_3D_TILE], s = 0; s < frustumCommandsListLength; ++s) {
        var l = frustumCommandsListLength - s - 1;
        var item = frustumCommandsList[l];
        this.uniformState.updateFrustum(this.camera.frustum);
        for (var h = 0; h < PassArr.length; h++) {
          var arrItem = PassArr[h];
          for (this.uniformState.updatePass(arrItem), commands = item.commands[arrItem], itemIndices = item.indices[arrItem], oldIndex = 0; oldIndex < itemIndices; ++oldIndex) {
            commands[oldIndex]._framebuffer;
            commands[oldIndex].execute(this.context, this.passState);
          }
        }
      }
      var fromCache = Cesium.RenderState.fromCache({
        viewport: new Cesium.BoundingRectangle(0, 0, this.width, this.height)
      });
      var overlay = Cesium.Pass.OVERLAY;
      var that = this;
      that.drawDepthCommand = that.context.createViewportQuadCommand(that.fragmentShader, {
        renderState: fromCache,
        uniformMap: {
          depthTexture: function depthTexture() {
            return that.frameBuffer.depthStencilTexture;
          }
        },
        pass: overlay,
        framebuffer: this._copyDepthFramebuffer,
        primitiveType: Cesium.PrimitiveType.TRIANGLES
      });
      this.drawDepthCommand.execute(this.context, this.depthPassState);
    }

    //更新自定义相机

  }, {
    key: "updateCustomCamera",
    value: function updateCustomCamera() {
      var that = this;
      var scene = this.scene;
      var heading = void 0;
      var pitch = void 0;
      var roll = void 0;
      var fov = void 0;
      var position = void 0;
      if (!this.customCamera) {
        this.customCamera = new Cesium.Camera(scene);
        this.customCamera = Cesium.Camera.clone(scene.camera, this.customCamera);
        this.customCamera.frustum.near = 1;
        this.customCamera.frustum.far = that._radius;
        if (Cesium.defined(this._viewPosition)) {
          position = this._viewPosition;
        } else {
          position = scene.camera.position;
        }
        if (Cesium.defined(this._heading)) {
          heading = this._heading;
        } else {
          heading = scene.camera.heading;
        }
        if (Cesium.defined(this._pitch)) {
          pitch = this._pitch;
        } else {
          pitch = scene.camera.pitch;
        }
        if (Cesium.defined(this._roll)) {
          roll = this._roll;
        } else {
          roll = scene.camera.roll;
        }
        if (Cesium.defined(this._fov)) {
          fov = this._fov;
        } else {
          fov = scene.camera.frustum.fov;
        }
        this.customCamera.frustum.fov = fov;
        this.customCamera.setView({
          destination: position,
          orientation: {
            heading: heading,
            pitch: pitch,
            roll: roll
          },
          convert: !1
        });
        this.camera = this.customCamera;
        var gpsPosition = new Cesium.Cartographic.fromCartesian(position);
        var lon = Cesium.Math.toDegrees(gpsPosition.longitude);
        var lat = Cesium.Math.toDegrees(gpsPosition.latitude);
        var height = gpsPosition.height;
        this.historyViewPosition = [lon, lat, height];
      }
    }

    //更新缓冲区

  }, {
    key: "updateBuffer",
    value: function updateBuffer() {
      var that = this;
      that.updateCommand();
      var width = this.width;
      var height = this.height;
      var readPixels = this.context.readPixels({
        x: this.passState.viewport.x,
        y: this.passState.viewport.y,
        width: width,
        height: height,
        framebuffer: that._copyDepthFramebuffer
      });
      var tempCartesian = new Cesium.Cartesian4(1, 1 / 255, 1 / 65025, 1 / 16581375);
      var contextUniformState = this.context.uniformState;
      var contextProjection = (contextUniformState.inverseProjection, contextUniformState.currentFrustum);
      var inverseProjectionX = contextProjection.x;
      var inverseProjectionY = contextProjection.y;
      var pointsArr = [];
      var newCartesian = new Cesium.Cartesian4();
      this.pixels = readPixels;
      for (var firsrtType = 0, pixelsLengthArr = new Uint8Array(readPixels.length), formBufferArr = {
        drawingBufferXArray: [],
        drawingBufferYArray: [],
        x: [],
        y: [],
        unpackDepthArray: []
      }, p = 0; p < width; p++) {
        firsrtType = true;
        for (var m = height; m > -1; m--) {
          var g = m * width * 4 + 4 * p;
          if (pixelsLengthArr[g] = readPixels[g], pixelsLengthArr[g + 1] = readPixels[g + 1], pixelsLengthArr[g + 2] = readPixels[g + 2], pixelsLengthArr[g + 3] = readPixels[g + 3], 1 == firsrtType && readPixels[g] > 0) {
            formBufferArr.drawingBufferXArray.push(p), formBufferArr.drawingBufferYArray.push(m), formBufferArr.x.push(1 - p / width), formBufferArr.y.push(m / height), formBufferArr.unpackDepthArray.push(readPixels[g]);
            var unpack = Cesium.Cartesian4.unpack(readPixels, g, new Cesium.Cartesian4());
            Cesium.Cartesian4.divideByScalar(unpack, 255, unpack);
            var tempCartesianY = Cesium.Cartesian4.dot(unpack, tempCartesian),
                UNIT_WClone = Cesium.Cartesian4.clone(Cesium.Cartesian4.UNIT_W, new Cesium.Cartesian4());
            UNIT_WClone.x = p / width * 2 - 1, UNIT_WClone.y = m / height * 2 - 1, UNIT_WClone.z = 2 * tempCartesianY - 1, UNIT_WClone.w = 1;
            var multiplyByVector,
                frustum = that.camera.frustum;
            if (Cesium.defined(frustum.fovy)) {
              multiplyByVector = Cesium.Matrix4.multiplyByVector(contextUniformState.inverseViewProjection, UNIT_WClone, new Cesium.Cartesian4());
              var multiplyByVectorEnt = 1 / multiplyByVector.w;
              Cesium.Cartesian3.multiplyByScalar(multiplyByVector, multiplyByVectorEnt, multiplyByVector);
            } else Cesium.defined(frustum._offCenterFrustum) && (frustum = frustum._offCenterFrustum), multiplyByVector = newCartesian, multiplyByVector.x = .5 * (UNIT_WClone.x * (frustum.right - frustum.left) + frustum.left + frustum.right), multiplyByVector.y = .5 * (UNIT_WClone.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top), multiplyByVector.z = .5 * (UNIT_WClone.z * (inverseProjectionX - inverseProjectionY) - inverseProjectionX - inverseProjectionY), multiplyByVector.w = 1, multiplyByVector = Cesium.Matrix4.multiplyByVector(contextUniformState.inverseView, multiplyByVector, multiplyByVector);
            var multiplyByVectorCartesian4 = Cesium.Cartesian3.fromCartesian4(multiplyByVector, new Cesium.Cartesian3());
            pointsArr.push(multiplyByVectorCartesian4), firsrtType = false;
          } else pixelsLengthArr[g + 3] = 0;
        }
      }
      return this.data = formBufferArr, this.points = pointsArr, this.collinear(), formBufferArr;
    }

    //极限高度

  }, {
    key: "limitHeight",
    value: function limitHeight() {
      Cesium.defined(this.points) || this.updateBuffer(), this.drawline && this.removeAlllimitHeights(), this.highlight = new Cesium.ClassificationPrimitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: new Cesium.PolygonGeometry({
            polygonHierarchy: new Cesium.PolygonHierarchy(this.points),
            vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
            extrudedHeight: 1e4,
            perPositionHeight: !0
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString("#F26419").withAlpha(.9)),
            show: new Cesium.ShowGeometryInstanceAttribute(!0)
          },
          id: "volume 1"
        }),
        classificationType: Cesium.ClassificationType.CESIUM_3D_TILE
      }), this.scene.primitives.add(this.highlight);
    }

    //是否准备好导出数据

  }, {
    key: "isReadyExportGeoData",
    value: function isReadyExportGeoData() {
      return !!this.geoObj;
    }

    //是否准备好导出czml数据

  }, {
    key: "isReadyExportCzmlData",
    value: function isReadyExportCzmlData() {
      return !!this.czmlData;
    }

    //拾取天际线

  }, {
    key: "pickSkyLine",
    value: function pickSkyLine(e) {
      var t = this,
          n = this;
      if (Cesium.defined(this.points) && Cesium.defined(this.degreeArray) || this.updateBuffer(), this.geoObj = {
        type: "Feature",
        properties: {
          camera: {
            position: this.scene.camera.position,
            heading: this.scene.camera.heading,
            pitch: this.scene.camera.pitch,
            roll: this.scene.camera.roll
          }
        },
        geometry: {
          type: "LineString",
          coordinates: this.degreeArray
        }
      }, e) {
        this.removeGeoJsonDataSource();
        Cesium.GeoJsonDataSource.load(this.geoObj, {
          stroke: n._lineColor,
          strokeWidth: n._lineWidth
        }).then(function (e) {
          t.geoJsonDataSource = e, t._viewer.dataSources.add(t.geoJsonDataSource);
        });
      } else {
        if (this.drawline) {
          this.removeAllLines();
        }
        this.drawline = new Cesium.Primitive({
          geometryInstances: new Cesium.GeometryInstance({
            id: 'polylineinstance',
            geometry: new Cesium.PolylineGeometry({
              positions: this.car3Array,
              width: this._lineWidth, //线宽
              vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT
            }),
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(this._lineColor) //color  必须设置 不然没有效果
            }
          }),
          appearance: new Cesium.PolylineColorAppearance({
            translucent: false
          })
        });
        this.scene.primitives.add(this.drawline);
      }
    }

    //绘制

  }, {
    key: "drawHeightGeo",
    value: function drawHeightGeo(e) {
      var that = this,
          nthat = this;
      Cesium.defined(this.faceArray) || this.updateBuffer(), this.removeAllFaces(), this.removeCzmlJsonDataSource();
      var Color_i = [255 * this._faceColor.red, 255 * this._faceColor.green, 255 * this._faceColor.blue, 255 * this._faceColor.alpha],
          color_r = [255 * this._faceOutlineColor.red, 255 * this._faceOutlineColor.green, 255 * this._faceOutlineColor.blue, 255 * this._faceOutlineColor.alpha],
          concat = this.historyViewPosition.concat(this.faceArray);
      if (this.czmlData = [{
        id: "document",
        name: "CZML zIndex",
        version: "1.0"
      }, {
        id: "orangePolygon",
        name: "Orange polygon with per-position heights and outline",
        polygon: {
          positions: {
            cartographicDegrees: concat
          },
          material: {
            solidColor: {
              color: {
                rgba: Color_i
              }
            }
          },
          extrudedHeight: 0,
          perPositionHeight: !0,
          outline: !0,
          outlineColor: {
            rgba: color_r
          }
        }
      }, {
        id: "myObject",
        properties: {
          camera: {
            position: this.scene.camera.position,
            heading: this.scene.camera.heading,
            pitch: this.scene.camera.pitch,
            roll: this.scene.camera.roll
          }
        }
      }], true !== e) {
        Cesium.CzmlDataSource.load(nthat.czmlData).then(function (e) {
          that.czmlJsonDataSource = e, nthat._viewer.dataSources.add(that.czmlJsonDataSource);
        });
      } else {
        this.drawFace = new _Drawline.Drawline({
          positions: this.points,
          scene: this.scene,
          type: "face",
          color: this._faceColor
        });
        this.scene.primitives.add(this.drawFace);
      }
    }

    //帧循环

  }, {
    key: "update",
    value: function update() {
      //(Cesium.defined(this.drawline) || Cesium.defined(this.geoJsonDataSource) || Cesium.defined(this.geojsonDataSourceUrl)) && (this.isUpdateLineColor || this.isUpdateRadius) && (this.isUpdateRadius ? this.pickSkyLine() : (Cesium.defined(this.drawline) && (this.drawline.getGeometryInstanceAttributes('polylineinstance').color = Cesium.ColorGeometryInstanceAttribute.toValue(this._lineColor)),
      //  Cesium.defined(this.geoJsonDataSource) && (this.geoJsonDataSource.stroke = this._lineColor),
      //  Cesium.defined(this.geojsonDataSourceUrl) && (this.geojsonDataSourceUrl.stroke = this._lineColor))),
      //  Cesium.defined(this.drawFace) && (this.isUpdateFaceColor || this.isUpdateRadius) && (this.isUpdateRadius ? this.drawHeightGeo() : this.drawFace.color = this._faceColor),
      //  this.isUpdateRadius = !1
      (Cesium.defined(this.drawline) || Cesium.defined(this.geoJsonDataSource) || Cesium.defined(this.geojsonDataSourceUrl)) && (this.isUpdateLineColor || this.isUpdateRadius) && (this.isUpdateRadius ? this.pickSkyLine() : (Cesium.defined(this.drawline) && (this.drawline.getGeometryInstanceAttributes('polylineinstance').color = Cesium.ColorGeometryInstanceAttribute.toValue(this._lineColor)), Cesium.defined(this.geoJsonDataSource) && (this.geoJsonDataSource.stroke = this._lineColor), Cesium.defined(this.geojsonDataSourceUrl) && (this.geojsonDataSourceUrl.stroke = this._lineColor)));
      Cesium.defined(this.drawFace) && (this.isUpdateFaceColor || this.isUpdateRadius) && (this.isUpdateRadius ? this.drawHeightGeo() : this.drawFace.color = this._faceColor);
      this.isUpdateRadius = false;
    }

    //销毁纹理

  }, {
    key: "_destroyTexture",
    value: function _destroyTexture() {
      this.colorTexture = this.colorTexture && !this.colorTexture.isDestroyed() && this.colorTexture.destroy(), this.depthStencilTexture = this.depthStencilTexture && !this.depthStencilTexture.isDestroyed() && this.depthStencilTexture.destroy();
    }

    //销毁缓冲区

  }, {
    key: "_destroyFrameBuffer",
    value: function _destroyFrameBuffer() {
      this.framebuffer = this.framebuffer && !this.framebuffer.isDestroyed() && this.framebuffer.destroy();
    }

    //获取销毁状态

  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return this.isDestroyStatus;
    }

    //销毁所有绘制的线段

  }, {
    key: "removeAllLines",
    value: function removeAllLines() {
      Cesium.defined(this.drawline) && (this.scene.primitives.remove(this.drawline), this.drawline = void 0);
    }

    //删除GeoJson数据源

  }, {
    key: "removeGeoJsonDataSource",
    value: function removeGeoJsonDataSource() {
      Cesium.defined(this.geojsonDataSourceUrl) && (this._viewer.dataSources.remove(this.geojsonDataSourceUrl), this.geojsonDataSourceUrl = void 0), Cesium.defined(this.geoJsonDataSource) && (this._viewer.dataSources.remove(this.geoJsonDataSource), this.geoJsonDataSource = void 0);
    }
  }, {
    key: "removeCzmlJsonDataSource",
    value: function removeCzmlJsonDataSource() {
      Cesium.defined(this.czmlJsonUrlDataSource) && (this._viewer.dataSources.remove(this.czmlJsonUrlDataSource), this.czmlJsonUrlDataSource = void 0), Cesium.defined(this.czmlJsonDataSource) && (this._viewer.dataSources.remove(this.czmlJsonDataSource), this.czmlJsonDataSource = void 0);
    }
  }, {
    key: "removeAlllimitHeights",
    value: function removeAlllimitHeights() {
      Cesium.defined(this.highlight) && (this.scene.primitives.remove(this.highlight), this.highlight = void 0);
    }
  }, {
    key: "removeAllFaces",
    value: function removeAllFaces() {
      Cesium.defined(this.drawFace) && (this.scene.primitives.remove(this.drawFace), this.drawFace = void 0);
    }
  }, {
    key: "remove",
    value: function remove() {
      this.removeAlllimitHeights(), this.removeAllFaces(), this.removeAllLines(), this.removeGeoJsonDataSource(), this.removeCzmlJsonDataSource();
    }
  }, {
    key: "removeHeightGeo",
    value: function removeHeightGeo() {
      this.removeAlllimitHeights(), this.removeAllFaces(), this.removeGeoJsonDataSource(), this.removeCzmlJsonDataSource();
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this._destroyTexture(), this._destroyFrameBuffer(), Cesium.defined(this.drawDepthCommand) && (this.drawDepthCommand.shaderProgram && this.drawDepthCommand.shaderProgram.destroy(), this.drawDepthCommand = void 0), this.remove(), this.isDestroyStatus = !0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return this._destroy(), Cesium.destroyObject(this);
    }
  }, {
    key: "makeUpLineGeojson",
    value: function makeUpLineGeojson(e) {
      if (this.geoObj) {
        this.content = JSON.stringify(this.geoObj);
        this.fileName = e || "skylineAnliles";
        this.makeUpGeojsonFile();
      } else {
        console.error("请先提取天际线数据");
      }
      //this.geoObj ? (this.content = (0,
      //  l.default)(this.geoObj, null, 2),
      //  this.fileName = e || "skylineAnliles",
      //  this.makeUpGeojsonFile()) : console.error("请先提取天际线数据")
    }
  }, {
    key: "makeUpGeojsonFile",
    value: function makeUpGeojsonFile() {
      var domlink = document.createElement("a");
      domlink.download = this.fileName;
      var t = new Blob([this.content], {
        type: "application/json"
      });
      domlink.href = URL.createObjectURL(t);
      document.body.appendChild(domlink);
      domlink.click();
      document.body.removeChild(domlink);
    }
  }, {
    key: "loadLines",
    value: function loadLines() {
      var o = this;
      this.remove();
      var a = this;
      if (e) {
        if (1 == t) {
          var s = Cesium.GeoJsonDataSource.load(e, {
            stroke: Cesium.defined(i) ? i : Cesium.Color.RED,
            strokeWidth: Cesium.defined(r) ? r : 2
          });
          s.then(function (e) {
            o.geojsonDataSourceUrl = e, o._viewer.dataSources.add(o.geojsonDataSourceUrl);
          }), Cesium.loadJson(e).then(function (e) {
            e.properties && e.properties.camera && n(e.properties.camera);
          }).otherwise(function (e) {
            console.error(e);
          });
        } else Cesium.loadJson(e).then(function (e) {
          if (e && e.geometry && e.geometry.coordinates.length > 0) {
            var t = e.geometry.coordinates.flat(),
                r = Cesium.Cartesian3.fromDegreesArrayHeights(t);
            a._lineColor;
            i && i, a.drawline = new _Drawline.Drawline({
              positions: r,
              scene: a.scene,
              type: "line",
              color: a._lineColor
            }), a.scene.primitives.add(a.drawline);
          } else console.error("geo数据不正常");
          e.properties && e.properties.camera && n(e.properties.camera);
        }).otherwise(function (e) {
          console.error(e);
        });
      } else console.error("路径错误");
    }
  }, {
    key: "makeupgeoface",
    value: function makeupgeoface(e) {
      if (!this.czmlData) return void console.error("请先绘制限高体");
      this.content = JSON.stringify(this.czmlData);
      this.fileName = e || "skyfaceAnliles";
      this.makeUpGeojsonFile();
    }
  }, {
    key: "loadFaces",
    value: function loadFaces() {
      var that = this;
      if (this.remove(), e) {
        Cesium.CzmlDataSource.load(e).then(function (e) {
          that.czmlJsonUrlDataSource = e, that._viewer.dataSources.add(that.czmlJsonUrlDataSource);
        }).then(function () {
          Cesium.loadJson(e).then(function (e) {
            var n = e.filter(function (e) {
              return "myObject" == e.id;
            });
            n.length > 0 && t(n[0].properties.camera);
          });
        });
      } else console.error("路径错误");
    }
  }, {
    key: "collinear",
    value: function collinear() {
      for (var e = [this.points[0]], t = [], n = [], i = [], r = 0, o = 1; o < this.points.length - 1; o++) {
        var a = this.points[o - 1],
            s = this.points[o],
            l = this.points[o + 1],
            u = Cesium.Cartesian3.subtract(s, a, new Cesium.Cartesian3()),
            h = Cesium.Cartesian3.subtract(l, s, new Cesium.Cartesian3()),
            c = Cesium.Cartesian3.cross(u, h, new Cesium.Cartesian3()),
            d = Cesium.Cartesian3.magnitude(c),
            f = Cesium.Cartesian3.magnitude(u),
            p = Cesium.Cartesian3.magnitude(h),
            m = d / (f * p);
        if (Math.abs(m) > 0.3) {
          var g = new Cesium.Cartographic.fromCartesian(this.points[o]),
              v = Cesium.Math.toDegrees(g.longitude),
              y = Cesium.Math.toDegrees(g.latitude),
              _ = g.height;
          t.push([v, y, _]), n.push(this.points[o]), i.push(v, y, _), e.push(this.points[o]), r++;
        }
      }
      this.degreeArray = t, this.car3Array = n, this.faceArray = i;
    }

    //========== 对外属性 ==========

  }, {
    key: "viewer",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._viewer = val;
      }
    }
  }, {
    key: "lineColor",
    get: function get() {
      return this._lineColor;
    },
    set: function set(val) {
      if (val) {
        this._lineColor = val;
        this.isUpdateLineColor = true;
        this.update();
      }
    }
  }, {
    key: "lineWidth",
    get: function get() {
      return this._lineWidth;
    },
    set: function set(val) {
      if (val) {
        this._lineWidth = val;

        if (this.drawline) {
          this.removeAllLines();
        }
        this.drawline = new Cesium.Primitive({
          geometryInstances: new Cesium.GeometryInstance({
            id: 'polylineinstance',
            geometry: new Cesium.PolylineGeometry({
              positions: this.car3Array,
              width: this._lineWidth, //线宽
              vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT
            }),
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(this._lineColor) //color  必须设置 不然没有效果
            }
          }),
          appearance: new Cesium.PolylineColorAppearance({
            translucent: false
          })
        });
        this.scene.primitives.add(this.drawline);
      }
    }
  }, {
    key: "faceColor",
    get: function get() {
      return this._faceColor;
    },
    set: function set(val) {
      if (val) {
        this._faceColor = val;
        this.isUpdateFaceColor = true;
        this.drawHeightGeo();
      }
    }
  }, {
    key: "faceOutlineColor",
    get: function get() {
      return this._faceOutlineColor;
    },
    set: function set(val) {
      if (val) {
        this._faceOutlineColor = val;
        this.isUpdateFaceColor = true;
        this.drawHeightGeo();
      }
    }
  }, {
    key: "radius",
    get: function get() {
      return this._radius;
    },
    set: function set(val) {
      if (val) {
        this._radius = Number(val);
        this.isUpdateRadius = true;
        this.update();
      }
    }
  }, {
    key: "viewPosition",
    get: function get() {
      return this._viewPosition;
    },
    set: function set(val) {
      if (val) {
        this._viewPosition = val;
      }
    }
  }, {
    key: "heading",
    get: function get() {
      return this._heading;
    },
    set: function set(val) {
      if (val) {
        this._heading = val;
      }
    }
  }, {
    key: "pitch",
    get: function get() {
      return this._pitch;
    },
    set: function set(val) {
      if (val) {
        this._pitch = val;
      }
    }
  }, {
    key: "roll",
    get: function get() {
      return this._roll;
    },
    set: function set(val) {
      if (val) {
        this._roll = val;
      }
    }
  }, {
    key: "fov",
    get: function get() {
      return this._fov;
    },
    set: function set(val) {
      if (val) {
        this._fov = val;
      }
    }
  }]);

  return SkylineAnalyse;
}(_DasClass2.DasClass);

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawline = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Drawline = exports.Drawline = function (_DasClass) {
  _inherits(Drawline, _DasClass);

  function Drawline(options, oldparam) {
    _classCallCheck(this, Drawline);

    var _this = _possibleConstructorReturn(this, (Drawline.__proto__ || Object.getPrototypeOf(Drawline)).call(this, options));

    if (!Cesium.defined(options.scene)) {
      throw new Cesium.DeveloperError("options.scene is required.");
    }
    if (!Cesium.defined(options.positions)) {
      throw new Cesium.DeveloperError("options.positions is required.");
    }
    _this.positions = options.positions;
    _this._scene = options.scene;
    _this._type = Cesium.defaultValue(options.type, "line");
    _this._color = Cesium.defaultValue(options.color, Cesium.Color.RED);
    _this._height = Cesium.defaultValue(options.height, 100);
    _this.isUpdateColor = false;
    _this.init();
    return _this;
  }

  _createClass(Drawline, [{
    key: "init",
    value: function init() {
      this._modelMatrix = Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY);
      this.modelMatrix = new Cesium.Matrix4();
      this._boundingSphere = new Cesium.BoundingSphere();
      this._invertViewMatrix = new Cesium.Matrix4();
      this._viewMatrix = new Cesium.Matrix4();
    }
  }, {
    key: "createCommand",
    value: function createCommand() {
      var that = this;
      var t = this._scene;
      var n = this._scene.context;
      var i = this.positions;
      var r = null;
      var o = null;
      if ("line" == this._type) {
        r = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * (i.length + 1));
        o = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_SHORT, i.length);
        for (var a = 0; i.length > a; a++) {
          o[a] = a + 1;
        }
        r[0] = 0;
        r[1] = 0;
        r[2] = 0;
        r[3] = 1;
        this.primitiveType = Cesium.PrimitiveType.LINE_STRIP;
        for (var s = 0; s < i.length; s++) {
          var l = i[s];
          r[4 * (s + 1)] = l.x;
          r[4 * (s + 1) + 1] = l.y;
          r[4 * (s + 1) + 2] = l.z;
          r[4 * (s + 1) + 3] = 1;
        }
      } else {
        var u = i.length + 1;
        r = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 8 * u);
        o = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_SHORT, 12 * (i.length - 1) + 12);
        o[0] = 0;
        o[1] = u;
        o[2] = 1;
        o[3] = u;
        o[4] = 1;
        o[5] = u + 1;
        var h = 12 * (i.length - 1) + 6;
        o[h] = 0;
        o[h + 1] = u;
        o[h + 2] = u - 1;
        o[h + 3] = u;
        o[h + 4] = u - 1;
        o[h + 5] = 2 * u - 1;
        for (var a = 0; a < i.length - 1; a++) {
          var c = 12 * a + 6;
          o[c] = 0;
          o[c + 1] = a + 1;
          o[c + 2] = a + 2;
          o[c + 3] = u;
          o[c + 4] = u + a + 1;
          o[c + 5] = u + a + 2;
          o[c + 6] = a + 2;
          o[c + 7] = u + a + 2;
          o[c + 8] = a + 1;
          o[c + 9] = u + a + 2;
          o[c + 10] = a + 1;
          o[c + 11] = u + a + 1;
        }
        var d = Cesium.Cartesian3.clone(t.camera.position);
        var f = new Cesium.Cartographic.fromCartesian(d);
        var p = new Cesium.Cartesian3.fromRadians(f.longitude, f.latitude, this._height);
        var m = new Cesium.Cartesian3.fromRadians(f.longitude, f.latitude, 10);
        r[0] = p.x;
        r[1] = p.y;
        r[2] = p.z;
        r[3] = 1;
        r[4 * u] = m.x;
        r[4 * u + 1] = m.y;
        r[4 * u + 2] = m.z;
        r[4 * u + 3] = 1;
        this.primitiveType = Cesium.PrimitiveType.TRIANGLES;
        for (var s = 1; s < u; s++) {
          var l = i[s - 1];
          r[4 * s] = l.x;
          r[4 * s + 1] = l.y;
          r[4 * s + 2] = l.z;
          r[4 * s + 3] = 1;
          var g = new Cesium.Cartographic.fromCartesian(l);
          var v = new Cesium.Cartesian3.fromRadians(g.longitude, g.latitude, 10);
          r[4 * (s + u)] = v.x;
          r[4 * (s + u) + 1] = v.y;
          r[4 * (s + u) + 2] = v.z;
          r[4 * (s + u) + 3] = 1;
        }
      }
      var y = {
        enabled: true,
        factor: 1.1,
        units: 4
      };
      var _ = Cesium.RenderState.fromCache({
        cull: {
          enabled: !1
        },
        depthTest: {
          enabled: !0
        },
        polygonOffset: y
      });
      var x = {
        das3dColor: function das3dColor() {
          return that._color;
        }
      };
      var w = {
        aPosition: 0,
        normal: 1
      };
      var b = Cesium.ShaderProgram.fromCache({
        context: n,
        vertexShaderSource: "attribute vec4 aPosition;\n                        void main() \n                        {\n                            gl_Position = czm_modelViewProjection *  aPosition; \n                        } ",
        fragmentShaderSource: "uniform vec4 das3dColor;void main(){   gl_FragColor = das3dColor;}",
        attributeLocations: w
      });
      this._shaderprogram = b;
      var C = Cesium.Buffer.createVertexBuffer({
        context: n,
        typedArray: r,
        usage: Cesium.BufferUsage.STATIC_DRAW
      });
      var M = Cesium.Buffer.createIndexBuffer({
        context: n,
        typedArray: o,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_SHORT
      });
      var S = new Cesium.VertexArray({
        context: n,
        attributes: [{
          index: 0,
          vertexBuffer: C,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }],
        indexBuffer: M
      });
      this._initBoundingSphere = Cesium.BoundingSphere.fromVertices(r);
      var T = this.primitiveType;
      this._lineCommand = new Cesium.DrawCommand({
        vertexArray: S,
        primitiveType: T,
        renderState: _,
        shaderProgram: b,
        uniformMap: x,
        owner: this,
        pass: Cesium.Pass.TRANSLUCENT,
        modelMatrix: new Cesium.Matrix4(),
        boundingVolume: new Cesium.BoundingSphere(),
        cull: true
      });
    }
  }, {
    key: "update",
    value: function update(e) {
      var t = this;
      Cesium.defined(this._lineCommand) || this.createCommand(e.context);
      if (!Cesium.Matrix4.equals(this.modelMatrix, this._modelMatrix)) {
        Cesium.Matrix4.clone(this.modelMatrix, this._modelMatrix);
        this._lineCommand.modelMatrix = Cesium.Matrix4.IDENTITY;
        this._lineCommand.boundingVolume = Cesium.BoundingSphere.transform(this._initBoundingSphere, Cesium.Matrix4.IDENTITY, this._boundingSphere);
      }
      if (this.isUpdateColor) {
        this._lineCommand.uniformMap.das3dColor = function () {
          return t._color;
        };
        this.isUpdateColor = false;
        if (this._lineCommand) {
          e.commandList.push(this._lineCommand);
        }
      }
    }
    //========== 对外属性 ==========
    //scene

  }, {
    key: "scene",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._scene = val;
      }
    }

    //线状态

  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      if (val) {
        this._type = val;
      }
    }

    //线颜色

  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(val) {
      if (val) {
        this._color = val;
        this.isUpdateColor = true;
      }
    }

    //线高

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      if (val) {
        this._height = Number(val);
      }
    }
  }]);

  return Drawline;
}(_DasClass2.DasClass);

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TerrainClip = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _CustomPlaneGeometry = __webpack_require__(84);

var _WellNoBottom = __webpack_require__(85);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形开挖 类 (基于地形)
var TerrainClip = exports.TerrainClip = function (_DasClass) {
  _inherits(TerrainClip, _DasClass);

  //========== 构造方法 ==========
  function TerrainClip(options, oldparam) {
    _classCallCheck(this, TerrainClip);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (TerrainClip.__proto__ || Object.getPrototypeOf(TerrainClip)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;

    if (!_this.viewer.scene.highDynamicRange) {
      _this.viewer.scene.highDynamicRange = true;
      _this._hasChangeHighDynamicRange = true;
    }

    _this.bottomImg = options.bottomImg;
    _this.wallImg = options.wallImg;

    _this.opacityImg = Cesium.defaultValue(options.opacity, 1.0);
    _this.splitNum = Cesium.defaultValue(options.splitNum, 30); //每两点之间插值个数
    _this.dig_pos_x = Cesium.defaultValue(options.dig_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.dig_pos_y = Cesium.defaultValue(options.dig_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.dig_pos_z = Cesium.defaultValue(options.dig_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.rect_dig = Cesium.defaultValue(options.rect_dig, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
    _this.excavateMinHeight = Cesium.defaultValue(options.excavateMinHeight, 9999); //最低挖掘海拔值
    _this.excavatePerPoint = Cesium.defaultValue(options.excavatePerPoint, false); //是否按插值点挖掘
    _this.dig_max_index = Cesium.defaultValue(options.dig_max_index, 0); //点选点的个数
    _this.defaultShowSelfOnly = Cesium.defaultValue(options.showSelfOnly, false); //是否只显示自己
    _this._height = Cesium.defaultValue(options.height, 0); //挖掘深度
    _this._show = Cesium.defaultValue(options.show, true);
    _this.defaultBoundingSwell = Cesium.defaultValue(options.boundingSwell, 20);
    _this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall

    if (options.positions && options.positions.length > 0) _this.setPositions(options.positions);
    return _this;
  }

  //========== 对外属性 ==========
  //参数


  _createClass(TerrainClip, [{
    key: "setPositions",

    //========== 方法 ==========

    //初始化没传顶点，后面设置顶点
    value: function setPositions(positions) {
      this._positions = positions;
      if (!positions || positions.length == 0) return;
      this._startExcavate(positions);
      this.viewer.scene.globe.material = Cesium.Material.fromType("WaJue");
      this.viewer.scene.globe.depthTestAgainstTerrain = true;
      this._effectExcavate();
    }

    //准备井数据

  }, {
    key: "_prepareWell",
    value: function _prepareWell(arr) {
      var splitNum = this.splitNum;
      var len = arr.length;
      if (len == 0) return;
      var targetHeight = this.excavateMinHeight - this.height;
      this.targetHeight = targetHeight;
      var no_height_top = [];
      var bottom_pos = [];
      var lerp_pos = [];
      for (var i = 0; i < len; i++) {
        var static_i = i == len - 1 ? 0 : i + 1;
        var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
        var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
        var pos1 = [currRad.longitude, currRad.latitude];
        var pos2 = [nextRad.longitude, nextRad.latitude];
        // if (i == 0) {
        //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
        //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
        //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
        // }
        for (var j = 0; j < splitNum; j++) {
          var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
          var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
          // if (!(i == len - 1 && j == splitNum)) {
          lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
          bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
          no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
          // }
        }
      }
      this.wellData = {
        lerp_pos: lerp_pos,
        bottom_pos: bottom_pos,
        no_height_top: no_height_top
      };
    }
    //创建井

  }, {
    key: "_createWell",
    value: function _createWell(options) {
      var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
      if (hasTerrain) {
        var self = this;
        this._createBottomSurface(options.bottom_pos);
        var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
        var maxHeight = -9999;
        Cesium.when(promise, function (updatedPositions) {
          var len = updatedPositions.length;
          var top_pos = [];
          var top_heights = [];
          for (var k = 0; k < len; k++) {
            top_heights.push(updatedPositions[k].height);
            if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
            var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
            top_pos.push(top_car);
          }
          self.maxHeight = maxHeight;
          self.top_heights = top_heights;
          self._createWellWall(options.bottom_pos, top_pos);
          self.viewer.scene.primitives.add(self.wellWall);
        });
      } else {
        this._createBottomSurface(options.bottom_pos);
        this._createWellWall(options.bottom_pos, options.no_height_top);
        this.viewer.scene.primitives.add(this.wellWall);
      }
    }
    //创建井壁

  }, {
    key: "_createWellWall",
    value: function _createWellWall(bottom, top) {
      var geo = new _WellNoBottom.WellNoBottom({
        minimumArr: bottom,
        maximumArr: top
      });
      geo = geo.createGeometry(geo, this);
      var _material = new Cesium.Material({
        fabric: {
          type: "Image",
          uniforms: {
            image: this.wallImg,
            color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
          }
        }
      });
      var _appearance = new Cesium.MaterialAppearance({
        translucent: false,
        flat: true,
        material: _material
      });
      this.wellWall = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geo,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
          },
          id: "PitWall"
        }),
        appearance: _appearance,
        asynchronous: false
      });
    }
    //创建井底

  }, {
    key: "_createBottomSurface",
    value: function _createBottomSurface(bottom_pos) {
      if (!bottom_pos.length) {
        return;
      }
      var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
        pos_arr: bottom_pos
      });
      geo = geo.createGeometry(geo);
      var _material = new Cesium.Material({
        fabric: {
          type: "Image",
          uniforms: {
            image: this.bottomImg,
            color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
          }
        }
      });
      var _appearance = new Cesium.MaterialAppearance({
        translucent: false,
        flat: true,
        material: _material
      });
      this.bottomSurface = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geo
        }),
        appearance: _appearance,
        asynchronous: false
      });
    }
    //准备挖掘

  }, {
    key: "_prepareExcavate",
    value: function _prepareExcavate(arr) {
      var len = arr.length;
      if (len == 0) return;
      this.dig_max_index = len;

      var minX = 99999999;
      var minY = 99999999;
      var minZ = 99999999;
      var maxX = -99999999;
      var maxY = -99999999;
      var maxZ = -99999999;
      for (var i = 0; i < len; i++) {
        if (arr[i]) {
          this.dig_pos_x[i] = arr[i].x;
          this.dig_pos_y[i] = arr[i].y;
          this.dig_pos_z[i] = arr[i].z;
          var rad = Cesium.Cartographic.fromCartesian(arr[i]);
          this.excavateMinHeight = this.excavateMinHeight > rad.height ? rad.height : this.excavateMinHeight;
          if (arr[i].x > maxX) {
            maxX = arr[i].x;
          }
          if (arr[i].x < minX) {
            minX = arr[i].x;
          }

          if (arr[i].y > maxY) {
            maxY = arr[i].y;
          }
          if (arr[i].y < minY) {
            minY = arr[i].y;
          }

          if (arr[i].z > maxZ) {
            maxZ = arr[i].z;
          }
          if (arr[i].z < minZ) {
            minZ = arr[i].z;
          }
        } else {
          this.dig_pos_x[i] = 0.0;
          this.dig_pos_y[i] = 0.0;
          this.dig_pos_z[i] = 0.0;
        }
      }
      var chaNum = this.boundingSwell;
      this._base_rect = this.rect_dig = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
    }
    //开始挖掘

  }, {
    key: "_startExcavate",
    value: function _startExcavate(arr) {
      this.viewer.scene.globe.material = Cesium.Material.fromType("WaJue");
      this._prepareExcavate(arr);

      if (this._showWall) {
        this._prepareWell(arr);
        if (!this.wellData) return;
        this._createWell(this.wellData);
      }
    }
    //更新挖掘深度

  }, {
    key: "_updateExcavateDepth",
    value: function _updateExcavateDepth(depth) {
      if (depth == undefined || depth == null) return;
      this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
      this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);
      var lerp_pos = this.wellData.lerp_pos;
      var bottom_pos = [];
      var len = lerp_pos.length;
      for (var i = 0; i < len; i++) {
        bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
      }
      this.wellData.bottom_pos = bottom_pos;
      this._createWell(this.wellData);

      if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);

      if (this.wellWall) this.viewer.scene.primitives.add(this.wellWall);
    }
    //挖掘生效

  }, {
    key: "_effectExcavate",
    value: function _effectExcavate() {
      this.excavateAnalysis.dig_pos_x = this.dig_pos_x;
      this.excavateAnalysis.dig_pos_y = this.dig_pos_y;
      this.excavateAnalysis.dig_pos_z = this.dig_pos_z;
      this.excavateAnalysis.dig_max_index = this.dig_max_index;
      this.excavateAnalysis.showSelfOnly = this.showSelfOnly;
      this.excavateAnalysis.rect_dig = this.rect_dig;

      if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.viewer.scene.globe.material = null;
      this.viewer.scene.globe._surface.tileProvider.resetExcavateAnalysis();

      if (this.bottomSurface) {
        this.viewer.scene.primitives.remove(this.bottomSurface);
        delete this.bottomSurface;
      }

      if (this.wellWall) {
        this.viewer.scene.primitives.remove(this.wellWall);
        delete this.wellWall;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._hasChangeHighDynamicRange) {
        this.viewer.scene.highDynamicRange = false;
        this._hasChangeHighDynamicRange = false;
      }

      this.clear();
      _get(TerrainClip.prototype.__proto__ || Object.getPrototypeOf(TerrainClip.prototype), "destroy", this).call(this);
    }
  }, {
    key: "excavateAnalysis",
    get: function get() {
      return this.viewer.scene.globe._surface.tileProvider.excavateAnalysis;
    }

    //仅显示自己

  }, {
    key: "showSelfOnly",
    get: function get() {
      return this.defaultShowSelfOnly;
    },
    set: function set(val) {
      this.defaultShowSelfOnly = val;
      this.excavateAnalysis.showSelfOnly = val;
    }

    //挖掘深度

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      this._height = val;

      if (this._showWall) {
        this._updateExcavateDepth(val);
      }
    }
    //显示和隐藏

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (val) {
        this.viewer.scene.globe.material = Cesium.Material.fromType("WaJue");

        if (this._showWall) {
          this.wellWall.show = true;
          this.bottomSurface.show = true;
        }
      } else {
        this.viewer.scene.globe.material = null;

        if (this._showWall) {
          this.wellWall.show = false;
          this.bottomSurface.show = false;
        }
      }
    }

    //点集合的包围盒膨胀数值

  }, {
    key: "boundingSwell",
    get: function get() {
      return this.defaultBoundingSwell;
    },
    set: function set(num) {
      var rect = this._base_rect;
      this.defaultBoundingSwell = Number(num);
      this.rect_dig = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] + this.boundingSwell, rect[4] + this.boundingSwell, rect[5] + this.boundingSwell, 0, 0, 0];
      this.excavateAnalysis.rect_dig = this.rect_dig;
    }
  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = val;
      this.setPositions(val);
    }
  }]);

  return TerrainClip;
}(_DasClass2.DasClass);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newTerrainClip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _PitPrimitive = __webpack_require__(158);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形开挖 类 (基于地形)
var newTerrainClip = exports.newTerrainClip = function (_DasClass) {
  _inherits(newTerrainClip, _DasClass);

  //========== 构造方法 ==========
  /**
   * TerrainClip地形挖掘
   * @param options
   */
  function newTerrainClip(options) {
    _classCallCheck(this, newTerrainClip);

    // this.options = options;
    var _this2 = _possibleConstructorReturn(this, (newTerrainClip.__proto__ || Object.getPrototypeOf(newTerrainClip)).call(this, options));

    _this2.viewer = options.viewer || null;
    _this2._areaList = [], _this2.totalCenter = null, _this2.trans = undefined, _this2.inverTrans = undefined, _this2.ratio = 0, _this2.totalRect = [], _this2.ortCamera = {};
    _this2._show = true;
    _this2.options = {
      diffHeight: options.diffHeight || 50, //井的深度
      image: options.image || './img/textures/excavate_side_min.jpg',
      imageBottom: options.imageBottom || './img/textures/excavate_bottom_min.jpg',
      splitNum: options.splitNum || 80 //井边界插值数

      // this.viewer.scene.globe.depthTestAgainstTerrain = true;//开启深度检查
    };_this2.floodVar = [0, 0, 0, 500];
    _this2._areaList = [];
    _this2._canvasWidth = 2048;
    _this2._clipOutSide = false;
    _this2.graphic = [];
    _this2._enabled = true;
    // this._addedHook(this.options);
    return _this2;
  }

  _createClass(newTerrainClip, [{
    key: "addArea",

    //创建地形开挖
    value: function addArea(_coordinate, height) {
      var coordinate = _coordinate;
      if (coordinate.length < 3) {
        return;
      }
      var options = {
        positions_original: coordinate,
        positions: this.toCartesians(coordinate), //Cartesian3
        show: true
      };
      this.options.diffHeight = height || 50;
      return this.terrainEditCtl = this.viewer.scene.globe._surface.tileProvider.excavateAnalysis,
      // this.terrainEditCtl = {
      //     enableTailor: false,
      //     excavateHeight: 0,
      //     excavateMinHeight: 9999,
      //     excavatePerPoint: false,
      //     inverTailorCenterMat: false,
      //     showElseArea: true,
      //     showTailorOnly: false,
      //     splitNum: 30,
      //     tailorArea: undefined,
      //     tailorRect: new Cesium.Cartesian4()
      // },
      this._areaList.push(options), this.computedCenter(), this._prepareFlood(), this.prepareCamera(), this.prepareFBO(), this.drawPolygon(), this.beginTailor(), this._addAreaHook(options, height), options;
    }
  }, {
    key: "toCartesians",
    value: function toCartesians(coordinate) {
      return das3d.pointconvert.lonlats2cartesians(coordinate);
      // if (!Array.isArray(coordinate))
      //     return coordinate;
      // var _0x17eb8d = [];
      // return coordinate.forEach(function(d) {
      //     var _0xc3ba94 = _0x427e95['a'].parse(d);
      //     _0xc3ba94 && _0x17eb8d['push'](_0xc3ba94['toCartesian'](true));
      // }),
      // _0x17eb8d;
    }
  }, {
    key: "_enabledHook",
    value: function _enabledHook(boolea) {
      //是否挖地
      this.viewer.scene.globe._surface.tileProvider.applyTailor = boolea, this.terrainEditCtl.enableTailor = boolea,
      // this._graphicLayer && (this._graphicLayer.show = boolea),
      this.viewer.scene.globe.material = boolea ? Cesium.Material.fromType("WaJue") : null;
    }
  }, {
    key: "enabled",
    value: function enabled(boolea) {
      this._show != boolea && (this.options.show = boolea, this._show = boolea,
      // this.layer && (Array.isArray(this.layer) ? this.layer.forEach(function(_0x4409ff) {
      //     _0x4409ff.show = boolea;
      // }) : this.layer.show = boolea),
      // this.isAdded &&
      this._showHook && this._showHook(boolea));
      // boolea ? this.fire("show", {
      //     'layer': this
      // }) : this.fire("hide", {
      //     'layer': this
      // })));
    }
  }, {
    key: "_showHook",
    value: function _showHook(boolea) {
      for (var i = 0; i < this.graphic.length; i++) {
        this.graphic[i].primitiveCollection.show = boolea;
      }
    }
    // _addedHook() {
    //     this.viewer.scene.highDynamicRange || (this.viewer.scene.highDynamicRange = true,
    //     this._hasChangeHighDynamicRange = true),
    //     this.viewer.scene.globe.depthTestAgainstTerrain || (this.viewer.scene.globe.depthTestAgainstTerrain = true,
    //     this._hasChangeDepthTestAgainstTerrain = true),
    //     this._graphicLayer = new GraphicLayer(this.options),
    //     this.viewer.addLayer(this._graphicLayer),
    //     this.terrainEditCtl.showElseArea = Cesium.defaultValue(this.options.showElseArea, !0x0)
    //     // this.options.positions && this.addArea(this.options.positions);
    //     // _0xf98977()(_0x1e778c()(_0x2ba465.prototype), "_addedHook", this).call(this);
    // }
    // _removedHook() {
    //     this.clear(),
    //     this.tailorTex && this.tailorTex.destroy && this.tailorTex.destroy(),
    //     this.yanmoFbo = null,
    //     this.viewer.scene.globe._surface.tileProvider.applyTailor = false,
    //     this.terrainEditCtl.enableTailor = false,
    //     this.terrainEditCtl.inverTailorCenterMat = Cesium.Matrix4.IDENTITY,
    //     this.terrainEditCtl.tailorArea = undefined,
    //     this.viewer.removeLayer(this._graphicLayer),
    //     delete this._graphicLayer,
    //     this._hasChangeHighDynamicRange && (this.viewer.scene.highDynamicRange = false,
    //     this._hasChangeHighDynamicRange = false),
    //     this._hasChangeDepthTestAgainstTerrain && (this.viewer.scene.globe.depthTestAgainstTerrain = false,
    //     this._hasChangeDepthTestAgainstTerrain = false);
    // }

  }, {
    key: "computedCenter",
    value: function computedCenter() {
      var that = this,
          Cartesian3_0 = new Cesium.Cartesian3();
      that._areaList.forEach(function (data) {
        var positions = data.positions;
        if (positions) {
          //创建面
          var polygon = new Cesium.PolygonGeometry({
            'polygonHierarchy': new Cesium.PolygonHierarchy(positions)
          })
          //中心点（Cartesian3）

          ,
              center = (polygon = Cesium.PolygonGeometry.createGeometry(polygon)).boundingSphere.center;
          Cesium.Cartesian3.add(Cartesian3_0, center, Cartesian3_0);
        }
        //Cartesian3
        that.totalCenter = Cesium.Cartesian3.multiplyByScalar(Cartesian3_0, 1 / that._areaList.length, new Cesium.Cartesian3());
      });
    }
  }, {
    key: "_prepareFlood",
    value: function _prepareFlood() {
      var that = this,
          context = this.viewer.scene.context;
      //trans
      this.trans = Cesium.Transforms.eastNorthUpToFixedFrame(this.totalCenter), this.inverTrans = Cesium.Matrix4.inverse(this.trans, new Cesium.Matrix4());
      var _0x460752 = 99999999,
          _0x22a6f2 = 99999999,
          _0x3dc463 = -99999999,
          _0x2dac75 = -99999999;

      this._areaList.forEach(function (data) {
        var positions = data.positions,
            _1eddb0 = new Cesium.PolygonGeometry({
          'polygonHierarchy': new Cesium.PolygonHierarchy(positions)
        }),
            _0x59e67c = (_1eddb0 = Cesium.PolygonGeometry.createGeometry(_1eddb0)).indices,
            _0x2e4fc9 = _1eddb0.attributes.position.values,
            _0x32c3a1 = _0x2e4fc9.length,
            _0xf8ba53 = [],
            tempArray = [];
        for (var index = 0; index < _0x32c3a1; index += 3) {

          var _0x5a4621 = _0x2e4fc9[index],
              _0x5d2bf9 = _0x2e4fc9[index + 1],
              _0x205406 = _0x2e4fc9[index + 2],
              _0x552726 = new Cesium.Cartesian3(_0x5a4621, _0x5d2bf9, _0x205406),
              multiplyByPoint = Cesium.Matrix4.multiplyByPoint(that.inverTrans, _0x552726, new Cesium.Cartesian3());
          multiplyByPoint['z'] = 0, _0xf8ba53.push(multiplyByPoint), tempArray.push(multiplyByPoint['x']), tempArray.push(multiplyByPoint['y']), tempArray.push(multiplyByPoint['z']), _0x460752 >= multiplyByPoint['x'] && (_0x460752 = multiplyByPoint['x']), _0x22a6f2 >= multiplyByPoint['y'] && (_0x22a6f2 = multiplyByPoint['y']), _0x3dc463 <= multiplyByPoint['x'] && (_0x3dc463 = multiplyByPoint['x']), _0x2dac75 <= multiplyByPoint['y'] && (_0x2dac75 = multiplyByPoint['y']);
        }
        data.localPos = _0xf8ba53;
        var float64Array = new Float64Array(tempArray),
            boundingSphere = Cesium.BoundingSphere.fromVertices(float64Array),
            geometry = new Cesium.Geometry({
          'attributes': {
            'position': new Cesium.GeometryAttribute({
              'componentDatatype': Cesium.ComponentDatatype.DOUBLE,
              'componentsPerAttribute': 3,
              'values': float64Array
            })
          },
          'indices': _0x59e67c,
          'primitiveType': Cesium.PrimitiveType.TRIANGLES,
          'boundingSphere': boundingSphere
        }),
            shaderProgram = Cesium.ShaderProgram.fromCache({
          'context': context,
          'vertexShaderSource': that.getVS(),
          'fragmentShaderSource': that.getFS(),
          'attributeLocations': {
            'position': 0
          }
        }),
            vertexArray = Cesium.VertexArray.fromGeometry({
          'context': context,
          'geometry': geometry,
          'attributeLocations': shaderProgram._attributeLocations,
          'bufferUsage': Cesium.BufferUsage.STATIC_DRAW,
          'interleave': true
        }),
            renderState = new Cesium.RenderState();
        renderState.depthRange.near = -1000000, renderState.depthRange.far = 1000000, data.drawAreaCommand = new Cesium.DrawCommand({
          'boundingVolume': boundingSphere,
          'primitiveType': Cesium.PrimitiveType.TRIANGLES,
          'vertexArray': vertexArray,
          'shaderProgram': shaderProgram,
          'renderState': renderState,
          'pass': Cesium.Pass.TRANSLUCENT
        });
      }), this.ratio = (_0x2dac75 - _0x22a6f2) / (_0x3dc463 - _0x460752), this.totalRect = [_0x460752, _0x22a6f2, _0x3dc463, _0x2dac75];
    }
  }, {
    key: "getVS",
    value: function getVS() {
      return "attribute vec3 position;\n" + "void main()\n" + "{\n" + "vec4 pos = vec4(position.xyz,1.0);\n" + "gl_Position = czm_projection*pos;\n" + "}\n";
    }
  }, {
    key: "getFS",
    value: function getFS() {
      return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" + "precision highp float;\n" + "#else\n" + "precision mediump float;\n" + "#endif\n" + "void main()\n" + "{\n" + "gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" + "}\n";
    }
  }, {
    key: "prepareCamera",
    value: function prepareCamera() {
      this.ortCamera = {
        'viewMatrix': Cesium.Matrix4.IDENTITY,
        'inverseViewMatrix': Cesium.Matrix4.IDENTITY,
        'frustum': new Cesium.OrthographicOffCenterFrustum(),
        'positionCartographic': {
          'height': 0,
          'latitude': 0,
          'longitude': 0
        },
        'positionWC': new Cesium.Cartesian3(0, 0, 60000),
        'directionWC': new Cesium.Cartesian3(0, 0, -1),
        'upWC': new Cesium.Cartesian3(0, 1, 0),
        'rightWC': new Cesium.Cartesian3(1, 0, 0),
        'viewProjectionMatrix': Cesium.Matrix4.IDENTITY
      }, Object.defineProperties(this.ortCamera.frustum, {
        'projectionMatrix': {
          value: this.ortCamera.frustum._orthographicMatrix,
          writable: true
        }
      }),
      // this.ortCamera.frustum.projectionMatrix = this.ortCamera.frustum._orthographicMatrix,
      this.ortCamera.frustum.infiniteProjectionMatrix = {}, this.ortCamera.frustum.left = this.totalRect[0], this.ortCamera.frustum.top = this.totalRect[3], this.ortCamera.frustum.right = this.totalRect[2], this.ortCamera.frustum.bottom = this.totalRect[1], this.ortCamera.frustum.near = 0.1, this.ortCamera.frustum.far = -120000, this.floodRect = new Cesium.Cartesian4(this.totalRect[0], this.totalRect[1], this.totalRect[2] - this.totalRect[0], this.totalRect[3] - this.totalRect[1]);
    }
  }, {
    key: "prepareFBO",
    value: function prepareFBO() {
      var context = this.viewer.scene.context,
          width = this._canvasWidth //2048

      ,
          texture = new Cesium.Texture({
        'context': context,
        'width': width,
        'height': width * this.ratio,
        'pixelFormat': Cesium.PixelFormat.RGBA,
        'pixelDatatype': Cesium.PixelDatatype.FLOAT,
        'flipY': false
      });
      this.tailorTex = texture, this.yanmoFbo = new Cesium.Framebuffer({
        'context': context,
        'colorTextures': [texture],
        'destroyAttachments': false
      }), this._fboClearCommand = new Cesium.ClearCommand({
        'color': new Cesium.Color(0, 0, 0, 0),
        'framebuffer': this.yanmoFbo
      });
    }
  }, {
    key: "drawPolygon",
    value: function drawPolygon() {
      var _this = this,
          context = this.viewer.scene.context,
          width = this._canvasWidth //2048

      ,
          _ratio = width * this.ratio,
          passState = new Cesium.PassState(context);
      passState.viewport = new Cesium.BoundingRectangle(0, 0, width, _ratio);
      var uniformState = context.uniformState;
      uniformState.updateCamera(this.ortCamera);
      this._fboClearCommand.execute(context);
      this._areaList.forEach(function (data) {
        var _drawAreaCommand = data.drawAreaCommand;
        _drawAreaCommand && data.show && (uniformState.updatePass(_drawAreaCommand.pass), _drawAreaCommand.framebuffer = _this.yanmoFbo, _drawAreaCommand.execute(context, passState));
      });
    }
  }, {
    key: "_removeAreaHook",
    value: function _removeAreaHook(data) {
      null != data && data.pitPrimitive && this._graphicLayer.removeGraphic(data.pitPrimitive);
    }
  }, {
    key: "beginTailor",
    value: function beginTailor() {
      this._enabledHook(true);

      this.viewer.scene.globe._surface.tileProvider.applyTailor = true, this.terrainEditCtl.inverTailorCenterMat = this.inverTrans, this.terrainEditCtl.tailorArea = this.yanmoFbo, this.terrainEditCtl.tailorRect = this.floodRect;

      // this.terrainEditCtl.inverFloodCenterMat = this.inverTrans,
      // this.terrainEditCtl.floodArea = this.yanmoFbo,
      // this.terrainEditCtl.enableFlood = true,
      // this.terrainEditCtl.floodRect = this.floodRect, //a0_0x2307('0x7de')
      // this.terrainEditCtl.globe = false;
      // a0_0x2307('0x553')
    }
  }, {
    key: "_addAreaHook",
    value: function _addAreaHook(option, _0x2f9474) {

      var that = this;
      // this.options.image && (
      option.pitPrimitive = new _PitPrimitive.PitPrimitive({
        'viewer': that.viewer,
        'style': that.options,
        'positions_original': option.positions_original,
        'positions': option.positions
      }), that.graphic.push(option.pitPrimitive);
    }
  }, {
    key: "diffHeight",
    value: function diffHeight(height) {
      for (var i = 0; i < this.graphic.length; i++) {
        this.graphic[i].diffHeight = height;
      }
    }
  }, {
    key: "clear",
    value: function clear() {

      for (var i = 0; i < this.graphic.length; i++) {
        this.graphic[i]._removePit();
      }
      // _0x40f6e5()(_0x3ea740()(_0x4e6bb5['prototype']), 'clear', this)[a0_0x8650('0xe0f')](this),
      // this[a0_0x8650('0xcf6')][a0_0x8650('0x7ba')]();
      // _0x40f6e5()(_0x3ea740()(_0x4e6bb5['prototype']), 'clear', this).call(this),
      // this._graphicLayer.clear();

      this.viewer.scene.globe.material = null, this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis(), this.viewer.scene.globe._surface.tileProvider.resetExcavateAnalysis(), this._areaList = [], this.graphic = [], this.tailorTex && this.tailorTex.destroy();
    }
  }, {
    key: "_0x133526",
    value: function _0x133526(option) {
      var _0x159f21;
      return _0x264c51()(this, _0x39da96), (_0x159f21 = _0x4bb5c3.call(this, option)).style.diffHeight = Cesium.defaultValue(_0x159f21.style.diffHeight, 10), _0x159f21.style.splitNum = Cesium.defaultValue(_0x159f21.style.splitNum, 50), _0x159f21;
    }
  }, {
    key: "clipOutSide",
    get: function get() {
      var _0x12654e;
      return null === (_0x12654e = this.terrainEditCtl) || void 0x0 === _0x12654e ? void 0x0 : _0x12654e.showTailorOnly;
    },
    set: function set(_0x702e3d) {
      this.terrainEditCtl.showTailorOnly = _0x702e3d;
    }
  }]);

  return newTerrainClip;
}(_DasClass2.DasClass);

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PitPrimitive = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Cesium
 * TerrainClip地形开挖依赖js
 */
var PitPrimitive = exports.PitPrimitive = function (_DasClass) {
    _inherits(PitPrimitive, _DasClass);

    /**
     * TerrainClip地形挖掘
     * @param options
     */
    function PitPrimitive(options) {
        _classCallCheck(this, PitPrimitive);

        var _this = _possibleConstructorReturn(this, (PitPrimitive.__proto__ || Object.getPrototypeOf(PitPrimitive)).call(this, options));

        _this.viewer = options.viewer || null;
        _this.style = options.style;
        _this.positions = options.positions;
        _this.positions_original = options.positions_original;
        // this.style = options.viewer ;
        // var _0x307ac9 = function(_0x3fa19f) {
        //     _0x4be8e2()(_0x39da96, _0x3fa19f);
        //     var _0x4bb5c3 = _0x36fd49(_0x39da96);
        //     function _0x39da96() {
        // var positions = {
        //     style : options.style ,
        //     positions : options.positions
        // }
        //     var _0x159f21;
        //     return _0x264c51()(this, _0x39da96),
        //     (_0x159f21 = _0x4bb5c3.call(this, positions)).style.diffHeight = Cesium.defaultValue(_0x159f21.style.diffHeight, 10),
        //     _0x159f21.style.splitNum = Cesium.defaultValue(_0x159f21.style.splitNum, 50),
        //     _0x159f21;
        _this._addedHook();
        return _this;
    }

    _createClass(PitPrimitive, [{
        key: "getMinHeight",
        value: function getMinHeight(positions) {
            var _0x1d8381 = 0;
            if (null == positions || 0x0 == positions.length) return _0x1d8381;
            var p = [];
            for (var height = _0x1d8381, _0x354cf4 = 0x0; _0x354cf4 < positions.length; _0x354cf4++) {
                var point = positions[_0x354cf4];
                var _Cartesian3 = Cesium.Cartesian3.fromDegrees(point[0], point[1], point[2]);
                p.push(_Cartesian3);
                var _0x5ca3ac = Cesium.Cartographic.fromCartesian(_Cartesian3);
                0x0 == _0x354cf4 && (height = _0x5ca3ac.height), _0x5ca3ac.height < height && (height = _0x5ca3ac.height);
            }
            this.positions = p;
            return Number(height.toFixed(2));
        }
    }, {
        key: "_getWellData",
        value: function _getWellData() {
            if (0 != this.positions_original.length) {
                this._minHeight = this.getMinHeight(this.positions_original);
                for (var h = this._minHeight - this.diffHeight, _0x6df4f2 = [], _0x3efb03 = [], _0x1e7c4c = [], generateArc = this.generateArc({
                    'scene': this.viewer.scene,
                    'positions': this.positions.concat(this.positions[0]),
                    // 'height': this.style.diffHeight,
                    'splitNum': this.style.splitNum
                }), index = 0, _0x456f85 = generateArc.length; index < _0x456f85; index++) {
                    var _0x470ccf = Cesium.Cartographic.fromCartesian(generateArc[index]);
                    _0x1e7c4c.push(new Cesium.Cartographic(_0x470ccf.longitude, _0x470ccf.latitude)), _0x3efb03.push(Cesium.Cartesian3.fromRadians(_0x470ccf.longitude, _0x470ccf.latitude, h)), _0x6df4f2.push(Cesium.Cartesian3.fromRadians(_0x470ccf.longitude, _0x470ccf.latitude, 0x0));
                }
                return {
                    'cartoList': _0x1e7c4c,
                    'bottomPositions': _0x3efb03,
                    'wallTopPositions': _0x6df4f2
                };
            }
        }
    }, {
        key: "granularity",
        value: function granularity(positions, splitNum) {
            var _0x500e28 = splitNum ? splitNum : 10,
                _0x2c3923 = Cesium.Rectangle.fromCartesianArray(positions),
                _0x1ab5aa = Math.max(_0x2c3923.height, _0x2c3923.width);
            return _0x1ab5aa /= _0x500e28;
        }
    }, {
        key: "_0x3c9d35",
        value: function _0x3c9d35(scene, _0x4d2890) {
            if (!_0x4d2890) return null;
            _0x4d2890 instanceof Cesium.Cartesian3 && (_0x4d2890 = [_0x4d2890]);
            for (var index = 0, _0x4e1154 = _0x4d2890.length; index < _0x4e1154; ++index) {
                var _0x3dfff7 = _0x4d2890[index],
                    _0x33ff0e = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, _0x3dfff7);
                if (Cesium.defined(_0x33ff0e)) {
                    var _0x397062 = scene.pick(_0x33ff0e, 10, 10);
                    if (Cesium.defined(_0x397062) && Cesium.defined(_0x397062.primitive) && _0x397062.primitive instanceof Cesium.Cesium3DTileset) return _0x397062.primitive;
                }
            }
            return null;
        }
    }, {
        key: "_0x20f7d4",
        value: function _0x20f7d4(_0x6b6712, _0x52dca5) {
            var _0x2edc8f = {
                positions: "",
                scene: "",
                splitNum: 80

            };
            // var _0x2edc8f = arguments.length > 0x2 && void 0x0 !== arguments[0x2] ? arguments[0x2] : {};
            _0x2edc8f.cartographic = _0x2edc8f.cartographic || Cesium.Cartographic.fromCartesian(_0x52dca5);
            var _0x484ba3 = _0x2edc8f.cartographic,
                _0x1d6b78 = _0x2edc8f.callback;
            if (_0x2edc8f.asyn) _0x6b6712.clampToHeightMostDetailed([_0x52dca5], _0x2edc8f.objectsToExclude, 0.2).then(function (_0x5646bd) {
                var _0x52edb1 = _0x5646bd[0x0];
                if (Cesium.defined(_0x52edb1)) {
                    var _0x3321f4 = Cesium.cartographic.fromCartesian(_0x52edb1),
                        _0x5daf34 = _0x3321f4.height;
                    if (Cesium.defined(_0x5daf34) && _0x5daf34 > -1000) return void (_0x1d6b78 && _0x1d6b78(_0x5daf34, _0x3321f4));
                }
                this._0x4c8681(_0x6b6712, _0x52dca5, _0x2edc8f);
            });else {
                var _0x29c70c = _0x6b6712.sampleHeight(_0x484ba3, _0x2edc8f.objectsToExclude, 0.2);
                if (Cesium.defined(_0x29c70c) && _0x29c70c > -1000) return _0x1d6b78 && _0x1d6b78(_0x29c70c, _0x484ba3), _0x29c70c;
            }
            return 0x0;
        }
    }, {
        key: "_0x4c8681",
        value: function _0x4c8681(_scene, _0xbdfad0, param) {
            var cartographic = param.cartographic || Cesium.Cartographic.fromCartesian(_0xbdfad0),
                callback = param.callback,
                _0x1aa501 = Boolean(_scene.terrainProvider._layers);
            if (!_0x1aa501) return callback && callback(cartographic.height, cartographic), cartographic.height;
            if (param.asyn) Cesium.when(Cesium.sampleTerrainMostDetailed(_scene.terrainProvider, [cartographic]), function (_0x4eab5d) {
                var _0xd4abc,
                    _0x27d1d9 = _0x4eab5d[0x0];
                _0xd4abc = Cesium.defined(_0x27d1d9) && Cesium.defined(_0x27d1d9.height) ? _0x27d1d9.height : _scene.globe.getHeight(cartographic), callback && callback(_0xd4abc, cartographic);
            });else {
                // var height = _scene.globe.getHeight(cartographic);
                var height = 0;
                if (Cesium.defined(height) && height > -1000) return callback && callback(height, cartographic), height;
            }
            return 0x0;
        }
    }, {
        key: "_0x25beae",
        value: function _0x25beae(_scene, _cartesian3, param) {
            if (!_cartesian3) return _cartesian3;
            var bool = Cesium.defaultValue(param.has3dtiles, Cesium.defined(this._0x3c9d35(_scene, _cartesian3)));
            return bool ? this._0x20f7d4(_scene, _cartesian3, param) : this._0x4c8681(_scene, _cartesian3, param);
        }
    }, {
        key: "generateArc",
        value: function generateArc(param) {
            var positions = param.positions,
                scene = param.scene,
                granularity = this.granularity(positions, param.splitNum || 100);
            granularity <= 0x0 && (granularity = null);
            for (var pointArray = Cesium.PolylinePipeline.generateArc({
                'positions': positions,
                'height': param.height,
                'minDistance': param.minDistance,
                'granularity': granularity
            }), _0x46ea99 = [], _0x2f9c85 = 0; _0x2f9c85 < pointArray.length; _0x2f9c85 += 3) {
                var _0x4a78a5 = Cesium.Cartesian3.unpack(pointArray, _0x2f9c85);
                if (scene && Cesium.defaultValue(param.surfaceHeight, true)) {
                    delete param.callback;
                    var height = this._0x25beae(scene, _0x4a78a5, param),
                        _0x20c0b2 = Cesium.Cartographic.fromCartesian(_0x4a78a5);
                    _0x4a78a5 = Cesium.Cartesian3.fromRadians(_0x20c0b2.longitude, _0x20c0b2.latitude, height);
                }
                _0x46ea99.push(_0x4a78a5);
            }
            return _0x46ea99;
        }
    }, {
        key: "_addedHook",
        value: function _addedHook() {
            var _0x1d88e2 = this._getWellData();
            this.wellData = _0x1d88e2, this._createPit(_0x1d88e2);
            // this.style.label && this._addLabel();
        }
    }, {
        key: "_addLabel",
        value: function _addLabel() {
            var _0x2e9acd = this.style.label;
            if (_0x2e9acd && _0x2e9acd.text) {
                Cesium.defined(this.style.clampToGround) && !Cesium.defined(_0x2e9acd.clampToGround) && (_0x2e9acd.clampToGround = this.style.clampToGround);
                var _0x58a7c2 = _0x50cc91.toCesiumVal(this.style.label, {}, this.attr);
                return _0x58a7c2.position = this._getLablePosition(), this._primitive_label = this._layer.labelCollection.add(_0x58a7c2), this._primitive_label;
            }
        }
    }, {
        key: "setPositionsHeight",
        value: function setPositionsHeight(_0x10e481) {
            var _0x231378 = arguments.length > 0x1 && void 0x0 !== arguments[0x1] ? arguments[0x1] : 0x0;
            if (!_0x10e481) return _0x10e481;
            if (Array.isArray(_0x10e481)) {
                for (var _0xf7f0b3 = [], _0x29ad1e = 0x0, _0x4119fc = _0x10e481.length; _0x29ad1e < _0x4119fc; _0x29ad1e++) {
                    var _0x18c4f5 = Cesium.Cartographic.fromCartesian(_0x10e481[_0x29ad1e]),
                        _0x24cba8 = Cesium.Cartesian3.fromRadians(_0x18c4f5.longitude, _0x18c4f5.latitude, _0x231378);
                    _0xf7f0b3['push'](_0x24cba8);
                }
                return _0xf7f0b3;
            }
            var _0x13e92b = Cesium.Cartographic.fromCartesian(_0x10e481);
            return Cesium.Cartesian3.fromRadians(_0x13e92b.longitude, _0x13e92b.latitude, _0x231378);
        }
        // _removedHook() {
        //         _0x170626()(_0x4f82d0()(_0x39da96.prototype), '_removedHook', this).call(this),
        //         this._removePit();
        //     }

    }, {
        key: "_removePit",
        value: function _removePit() {
            this._primitive && (this.primitiveCollection.remove(this._primitive), delete this._primitive), this._bottomPrimitive && (this.primitiveCollection.remove(this._bottomPrimitive), delete this._bottomPrimitive);
        }
    }, {
        key: "_createPit",
        value: function _createPit(param) {
            debugger;
            var hasTerrain = true;
            var that = this;
            if (this._createBottomSurface(param.bottomPositions), hasTerrain) {
                var _0x1c775f = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, param.cartoList);
                Cesium.when(_0x1c775f, function (_0x3f5ff9) {
                    debugger;
                    for (var _0x54c3d2 = [], _0xae3f23 = -9999, _0x2d109c = [], _0x4e9c8a = 0, _0x5309d9 = _0x3f5ff9.length; _0x4e9c8a < _0x5309d9; _0x4e9c8a++) {
                        var _0x486620 = _0x3f5ff9[_0x4e9c8a];
                        _0x54c3d2.push(_0x486620.height), _0xae3f23 = Math.max(_0x486620.height, _0xae3f23), _0x2d109c.push(Cesium.Cartesian3.fromRadians(_0x486620.longitude, _0x486620.latitude, _0x486620.height));
                    }
                    that._maxHeight = _0xae3f23, that._topHeights = _0x54c3d2, that._createWellWall(param.bottomPositions, _0x2d109c);
                });
            } else {
                this._createWellWall(param.bottomPositions, param.wallTopPositions);
            }
        }
    }, {
        key: "_createWellWall",
        value: function _createWellWall(minimumArr, maximumArr) {
            var height = this._minHeight - this.diffHeight;
            //初始化[仅执行1次]
            Cesium.Check.defined("dingmian", maximumArr), Cesium.Check.defined('dimianmian', minimumArr), Cesium.Check.typeOf.number.greaterThanOrEquals("dingmian.length", maximumArr.length, 3), Cesium.Check.typeOf.number.greaterThanOrEquals("dimian.length", minimumArr.length, 3);
            var _vertexFormat = new Cesium.VertexFormat({
                'st': true,
                'position': true,
                'bitangent': false,
                'normal': false,
                'color': false,
                'tangent': false
            });
            var _minimumArr = Cesium.clone(minimumArr),
                _maximumArr = Cesium.clone(maximumArr);
            var wellWall_geometry = this.createGeometryWell(_minimumArr, _maximumArr, _vertexFormat, this._topHeights, height, this._maxHeight);

            // var  wellWall = new WellWall();
            //     wellWall.create({
            //         'minimumArr': minimumArr,
            //         'maximumArr': maximumArr
            //     });
            // var wellWall_geometry = wellWall.createGeometry(wellWall, this._topHeights, height, this._maxHeight);
            this._primitive = new Cesium.Primitive({
                'geometryInstances': new Cesium.GeometryInstance({
                    'geometry': wellWall_geometry,
                    'attributes': {
                        'color': Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
                    }
                    // 'id': this.uuid
                    // 'id': haoutil.math.getGuid()
                }),
                'appearance': new Cesium.MaterialAppearance({
                    'translucent': false,
                    'flat': true,
                    'material': new Cesium.Material({
                        'fabric': {
                            'type': "Image",
                            'uniforms': {
                                'image': this.style.image,
                                'color': Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
                            }
                        }
                    })
                }),
                'asynchronous': false
            }),
            // this.viewer.scene.primitives.add(this._primitive)
            this.primitiveCollection.add(this._primitive);
            // this.bindPickId(this._primitive);
        }
    }, {
        key: "createGeometryWell",
        value: function createGeometryWell(_minimumArr, _maximumArr, _vertexFormat, _topHeights, height, maxHeight) {
            var _indices,
                _maximum,
                _0x6d8121,
                _0x3ec98b,
                _maxHeight = maxHeight ? maxHeight : 0,
                _attributes = new Cesium.GeometryAttributes();
            if (Cesium.defined(_vertexFormat.position) && Cesium.defined(_vertexFormat.st)) {
                if (Cesium.defined(_vertexFormat.position)) {
                    _maximum = new Float64Array(0x4 * _maximumArr.length * 0x3);
                    for (var index = 0x0; index < _maximumArr.length; index++) {
                        index == _maximumArr.length - 0x1 ? (_maximum[0xc * index + 0x0] = _maximumArr[index]['x'], _maximum[0xc * index + 0x1] = _maximumArr[index]['y'], _maximum[0xc * index + 0x2] = _maximumArr[index]['z'], _maximum[0xc * index + 0x3] = _minimumArr[index]['x'], _maximum[0xc * index + 0x4] = _minimumArr[index]['y'], _maximum[0xc * index + 0x5] = _minimumArr[index]['z'], _maximum[0xc * index + 0x9] = _minimumArr[0x0]['x'], _maximum[0xc * index + 0xa] = _minimumArr[0x0]['y'], _maximum[0xc * index + 0xb] = _minimumArr[0x0]['z'], _maximum[0xc * index + 0x6] = _maximumArr[0x0]['x'], _maximum[0xc * index + 0x7] = _maximumArr[0x0]['y'], _maximum[0xc * index + 0x8] = _maximumArr[0x0]['z']) : (_maximum[0xc * index + 0x0] = _maximumArr[index]['x'], _maximum[0xc * index + 0x1] = _maximumArr[index]['y'], _maximum[0xc * index + 0x2] = _maximumArr[index]['z'], _maximum[0xc * index + 0x3] = _minimumArr[index]['x'], _maximum[0xc * index + 0x4] = _minimumArr[index]['y'], _maximum[0xc * index + 0x5] = _minimumArr[index]['z'], _maximum[0xc * index + 0x9] = _minimumArr[index + 0x1]['x'], _maximum[0xc * index + 0xa] = _minimumArr[index + 0x1]['y'], _maximum[0xc * index + 0xb] = _minimumArr[index + 0x1]['z'], _maximum[0xc * index + 0x6] = _maximumArr[index + 0x1]['x'], _maximum[0xc * index + 0x7] = _maximumArr[index + 0x1]['y'], _maximum[0xc * index + 0x8] = _maximumArr[index + 0x1]['z']);
                    }_attributes.position = new Cesium.GeometryAttribute({
                        'componentDatatype': Cesium.ComponentDatatype.DOUBLE,
                        'componentsPerAttribute': 3,
                        'values': _maximum
                    });
                }
                if (Cesium.defined(_vertexFormat.st)) {
                    for (var _0x1445f2 = new Float32Array(0x4 * _maximumArr.length * 0x2), _0x513407 = _maximumArr.length, _0x2be444 = 0x0; _0x2be444 < _maximumArr.length; _0x2be444++) {
                        var _0x5d4855 = _0x2be444 / _0x513407,
                            _0x2cfa35 = _topHeights && _topHeights[_0x2be444] || 0x0,
                            _0x4ff144 = (_0x2cfa35 - height) / (_maxHeight - height),
                            _0x4abb65 = _0x2be444 + 0x1,
                            _0x42c6fa = _topHeights && _topHeights[_0x4abb65] || 0x0,
                            _0x124f20 = _0x4abb65 / _0x513407,
                            _0x34cd58 = (_0x42c6fa - height) / (_maxHeight - height);
                        _0x1445f2[0x8 * _0x2be444 + 0x0] = _0x5d4855, _0x1445f2[0x8 * _0x2be444 + 0x1] = _0x4ff144 - 0x0, _0x1445f2[0x8 * _0x2be444 + 0x2] = _0x5d4855, _0x1445f2[0x8 * _0x2be444 + 0x3] = _0x4ff144 - _0x4ff144, _0x1445f2[0x8 * _0x2be444 + 0x4] = _0x124f20, _0x1445f2[0x8 * _0x2be444 + 0x5] = _0x34cd58 - 0x0, _0x1445f2[0x8 * _0x2be444 + 0x6] = _0x124f20, _0x1445f2[0x8 * _0x2be444 + 0x7] = _0x34cd58 - _0x34cd58;
                    }
                    _attributes.st = new Cesium.GeometryAttribute({
                        'componentDatatype': Cesium.ComponentDatatype.FLOAT,
                        'componentsPerAttribute': 0x2,
                        'values': _0x1445f2
                    });
                }
                _indices = new Uint16Array(0x2 * _maximumArr.length * 0x3), _0x6d8121 = new Cesium.Cartesian3(9999999999999, 9999999999999, 9999999999999), _0x3ec98b = new Cesium.Cartesian3(-9999999999999, -9999999999999, -9999999999999);
                for (var _0x3f2481 = 0x0; _0x3f2481 < _maximumArr.length; _0x3f2481++) {
                    _indices[0x6 * _0x3f2481 + 0x0] = 0x4 * _0x3f2481 + 0x0, _indices[0x6 * _0x3f2481 + 0x1] = 0x4 * _0x3f2481 + 0x1, _indices[0x6 * _0x3f2481 + 0x2] = 0x4 * _0x3f2481 + 0x2, _indices[0x6 * _0x3f2481 + 0x3] = 0x4 * _0x3f2481 + 0x1, _indices[0x6 * _0x3f2481 + 0x4] = 0x4 * _0x3f2481 + 0x2, _indices[0x6 * _0x3f2481 + 0x5] = 0x4 * _0x3f2481 + 0x3, _maximumArr[_0x3f2481]['x'] >= _0x3ec98b['x'] && _maximumArr[_0x3f2481]['y'] >= _0x3ec98b['y'] && _maximumArr[_0x3f2481]['z'] >= _0x3ec98b['z'] && (_0x3ec98b = _maximumArr[_0x3f2481]), _minimumArr[_0x3f2481]['x'] <= _0x6d8121['x'] && _minimumArr[_0x3f2481]['y'] <= _0x6d8121['y'] && _minimumArr[_0x3f2481]['z'] <= _0x6d8121['z'] && (_0x6d8121 = _minimumArr[_0x3f2481]);
                }
            }
            var _0x50b4b8 = Cesium.Cartesian3.subtract(_0x3ec98b, _0x6d8121, new Cesium.Cartesian3()),
                _0x5a8355 = 0.5 * Cesium.Cartesian3.magnitude(_0x50b4b8);
            return new Cesium.Geometry({
                'attributes': _attributes,
                'indices': _indices,
                'primitiveType': Cesium.PrimitiveType.TRIANGLES,
                'boundingSphere': new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, _0x5a8355)
            });
        }
    }, {
        key: "_createBottomSurface",
        value: function _createBottomSurface(pos) {
            if (pos.length) {
                var pos_arr = Cesium.defaultValue(pos, Cesium.defaultValue.EMPTY_OBJECT);
                var _vertexFormat = new Cesium.VertexFormat({
                    'st': !0x0,
                    'position': !0x0,
                    'bitangent': !0x1,
                    'normal': !0x1,
                    'color': !0x1,
                    'tangent': !0x1
                });
                var _pos_arr = Cesium.clone(pos_arr);
                var _SERectangle = Cesium.BoundingRectangle.fromPoints(_pos_arr, new Cesium.BoundingRectangle());
                // this._workerName = "createCustomPlaneGeometry";
                var _indices,
                    _attributesVal,
                    _attributes = new Cesium.GeometryAttributes(),
                    posLength = _pos_arr.length;
                if (Cesium.defined(_vertexFormat.position)) {
                    _attributesVal = new Float64Array(0x3 * posLength);
                    for (var i = 0x0; i < posLength; i++) {
                        _attributesVal[i % posLength * 0x3 + 0x0] = _pos_arr[i]['x'], _attributesVal[i % posLength * 0x3 + 0x1] = _pos_arr[i]['y'], _attributesVal[i % posLength * 0x3 + 0x2] = _pos_arr[i]['z'];
                    }if (_attributes.position = new Cesium.GeometryAttribute({
                        'componentDatatype': Cesium.ComponentDatatype.DOUBLE,
                        'componentsPerAttribute': 3,
                        'values': _attributesVal
                    }), Cesium.defined(_vertexFormat['st'])) {
                        for (var _0x4043dd = new Float32Array(0x2 * posLength), _0xfdcf7c = _SERectangle['x'], _0x377003 = _SERectangle['y'], j = 0x0; j < posLength; j++) {
                            _0x4043dd[0x2 * j + 0x0] = Math.abs((_attributesVal[0x3 * j + 0x0] - _0xfdcf7c) / _SERectangle.width), _0x4043dd[0x2 * j + 0x1] = Math.abs((_attributesVal[0x3 * j + 0x1] - _0x377003) / _SERectangle.height);
                        }_attributes['st'] = new Cesium.GeometryAttribute({
                            'componentDatatype': Cesium.ComponentDatatype.FLOAT,
                            'componentsPerAttribute': 2,
                            'values': _0x4043dd
                        });
                    }
                    _indices = new Uint16Array(0x3 * (posLength - 0x2));
                    for (var _0x3b1878 = 0x1; _0x3b1878 < posLength - 0x1; _0x3b1878++) {
                        _indices[0x3 * (_0x3b1878 - 0x1) + 0x0] = 0x0, _indices[0x3 * (_0x3b1878 - 0x1) + 0x1] = _0x3b1878, _indices[0x3 * (_0x3b1878 - 0x1) + 0x2] = _0x3b1878 + 0x1;
                    }
                }
                var bottomSurface_geometry = new Cesium.Geometry({
                    'attributes': _attributes,
                    'indices': _indices,
                    'primitiveType': Cesium.PrimitiveType.TRIANGLE_FAN,
                    'boundingSphere': new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, Math.sqrt(2))
                });

                // var bottomSurface = new BottomSurface();
                // bottomSurface.create({'pos_arr': pos});
                // var bottomSurface_geometry = bottomSurface.createGeometry(bottomSurface);
                this._bottomPrimitive = new Cesium.Primitive({
                    'geometryInstances': new Cesium.GeometryInstance({
                        'geometry': bottomSurface_geometry
                    }),
                    'appearance': new Cesium.MaterialAppearance({
                        'translucent': false,
                        'flat': true,
                        'material': new Cesium.Material({
                            'fabric': {
                                'type': "Image",
                                'uniforms': {
                                    'image': this.style.imageBottom,
                                    'color': Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
                                }
                            }
                        })
                    }),
                    'asynchronous': false
                }),
                // this.viewer.scene.primitives.add(this._bottomPrimitive)
                this.primitiveCollection.add(this._bottomPrimitive);
                // this.bindPickId(this._bottomPrimitive);
                return Boolean(this.viewer.terrainProvider._layers);
            }
        }
    }, {
        key: "bindPickId",
        value: function bindPickId(data) {
            return data._das3d_layerId = this._layer._uuid, data._das3d_graphicId = this._uuid, this;
        }
    }, {
        key: "czmObjectEx",
        get: function get() {
            var _0x5cc947 = [];
            return this._bottomPrimitive && _0x5cc947.push(this._bottomPrimitive), this._primitive_label && _0x5cc947.push(this._primitive_label), _0x5cc947;
        }
    }, {
        key: "center",
        get: function get() {
            return this.centerOfMass;
        }
    }, {
        key: "diffHeight",
        get: function get() {
            return this.style.diffHeight;
        },
        set: function set(_0x4e4703) {
            this.style.diffHeight = _0x4e4703;
            for (var _0x5e8f76 = [], _0x22d584 = this._minHeight - _0x4e4703, _0xb0185b = this.wellData.cartoList, _0x360727 = 0, _0x439184 = _0xb0185b.length; _0x360727 < _0x439184; _0x360727++) {
                var _0x535e87 = _0xb0185b[_0x360727];
                _0x5e8f76.push(Cesium.Cartesian3.fromRadians(_0x535e87.longitude, _0x535e87.latitude, _0x22d584));
            }
            this.wellData.bottomPositions = _0x5e8f76, this._removePit(), this._createPit(this.wellData);
        }
    }, {
        key: "primitiveCollection",
        get: function get() {
            return this._primitiveCollection || (this._primitiveCollection = new Cesium.PrimitiveCollection(), this.viewer.scene.primitives.add(this._primitiveCollection)),
            // this._state == "added" && (this.viewer.scene.primitives.add(this._primitiveCollection),
            // Cesium.defined(this.options.zIndex) && (this.zIndex = this.options.zIndex))),
            this._primitiveCollection;
        }
    }]);

    return PitPrimitive;
}(_DasClass2.DasClass);

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TerrainClipPlan = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _CustomPlaneGeometry = __webpack_require__(84);

var _WellNoBottom = __webpack_require__(85);

var _measure = __webpack_require__(18);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地形开挖 类（平面 Plan原生）
var TerrainClipPlan = exports.TerrainClipPlan = function (_DasClass) {
  _inherits(TerrainClipPlan, _DasClass);

  //========== 构造方法 ==========
  function TerrainClipPlan(options, oldparam) {
    _classCallCheck(this, TerrainClipPlan);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (TerrainClipPlan.__proto__ || Object.getPrototypeOf(TerrainClipPlan)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    _this.updateData = _this.setPositions;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.options = options;
    _this.viewer = options.viewer;

    _this._height = _this.options.height || 0;
    _this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall
    _this.bottomImg = options.bottomImg;
    _this.wallImg = options.wallImg;
    _this.opacityImg = Cesium.defaultValue(options.opacity, 1.0);
    _this.splitNum = Cesium.defaultValue(options.splitNum, 50);

    if (options.positions && options.positions.length > 0) {
      _this.setPositions(options.positions);
    }
    return _this;
  }

  //========== 对外属性 ==========
  //挖掘深度


  _createClass(TerrainClipPlan, [{
    key: "setPositions",

    //========== 方法 ==========

    // 创建裁剪面
    value: function setPositions(points) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.clear();

      if (!points || points.length < 3) {
        daslog.warn("挖地坐标数据存在问题！", points);
        return;
      }
      this._positions = points;

      var clippingPlanes = [];
      var pointsLength = points.length;

      var unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切

      //是否顺时针
      var startAngle = (0, _measure.getAngle)(points[0], points[1]);
      var endAngle = (0, _measure.getAngle)(points[0], points[2]);
      var direction = startAngle < endAngle;
      if (unionClippingRegions) direction = !direction;

      this.excavateMinHeight = 9999;

      for (var i = 0; i < pointsLength; ++i) {
        var nextIndex = (i + 1) % pointsLength;
        var midpoint = Cesium.Cartesian3.midpoint(points[i], points[nextIndex], new Cesium.Cartesian3());

        var tempCarto = Cesium.Cartographic.fromCartesian(points[i]);
        var heightTerrain = this.viewer.scene.globe.getHeight(tempCarto) || tempCarto.height; //地形高度
        if (heightTerrain < this.excavateMinHeight) {
          this.excavateMinHeight = heightTerrain;
        }

        var up = Cesium.Cartesian3.normalize(midpoint, new Cesium.Cartesian3());
        var right;
        if (direction) {
          //顺时针
          right = Cesium.Cartesian3.subtract(points[i], midpoint, new Cesium.Cartesian3());
        } else {
          right = Cesium.Cartesian3.subtract(points[nextIndex], midpoint, new Cesium.Cartesian3());
        }
        right = Cesium.Cartesian3.normalize(right, right);
        var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
        normal = Cesium.Cartesian3.normalize(normal, normal);
        var originCenteredPlane = new Cesium.Plane(normal, 0.0);
        var distance = Cesium.Plane.getPointDistance(originCenteredPlane, midpoint);
        clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));
      }

      this.viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
        planes: clippingPlanes,
        edgeWidth: Cesium.defaultValue(opts.edgeWidth, 1.0),
        edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
        enabled: true,
        unionClippingRegions: unionClippingRegions
      });

      if (this._showWall) {
        this._prepareWell(points);
        this._createWell(this.wellData);
      }
    }

    //准备井数据

  }, {
    key: "_prepareWell",
    value: function _prepareWell(arr) {
      var splitNum = this.splitNum;
      var len = arr.length;
      if (len == 0) return;
      var targetHeight = this.excavateMinHeight - this.height;
      this.targetHeight = targetHeight;
      var no_height_top = [];
      var bottom_pos = [];
      var lerp_pos = [];
      for (var i = 0; i < len; i++) {
        var static_i = i == len - 1 ? 0 : i + 1;
        var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
        var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
        var pos1 = [currRad.longitude, currRad.latitude];
        var pos2 = [nextRad.longitude, nextRad.latitude];
        // if (i == 0) {
        //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
        //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
        //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
        // }
        for (var j = 0; j < splitNum; j++) {
          var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
          var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
          // if (!(i == len - 1 && j == splitNum)) {
          lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
          bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
          no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
          // }
        }
      }
      this.wellData = {
        lerp_pos: lerp_pos,
        bottom_pos: bottom_pos,
        no_height_top: no_height_top
      };
    }
    //创建井

  }, {
    key: "_createWell",
    value: function _createWell(options) {
      var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
      if (hasTerrain) {
        var self = this;
        this._createBottomSurface(options.bottom_pos);
        var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
        var maxHeight = -9999;
        Cesium.when(promise, function (updatedPositions) {
          var len = updatedPositions.length;
          var top_pos = [];
          var top_heights = [];
          for (var k = 0; k < len; k++) {
            top_heights.push(updatedPositions[k].height);
            if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
            var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
            top_pos.push(top_car);
          }
          self.maxHeight = maxHeight;
          self.top_heights = top_heights;
          self._createWellWall(options.bottom_pos, top_pos);
          // self.viewer.scene.primitives.add(self.wellWall);
        });
      } else {
        this._createBottomSurface(options.bottom_pos);
        this._createWellWall(options.bottom_pos, options.no_height_top);
        // this.viewer.scene.primitives.add(this.wellWall);
      }
    }
    //创建井壁

  }, {
    key: "_createWellWall",
    value: function _createWellWall(bottom, top) {
      var geo = new _WellNoBottom.WellNoBottom({
        minimumArr: bottom,
        maximumArr: top
      });
      geo = geo.createGeometry(geo, this);
      var _material = new Cesium.Material({
        fabric: {
          type: "Image",
          uniforms: {
            image: this.wallImg,
            color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
          }
        }
      });
      var _appearance = new Cesium.MaterialAppearance({
        translucent: false,
        flat: true,
        material: _material
      });
      this.wellWall = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geo,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
          },
          id: "PitWall"
        }),
        appearance: _appearance,
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.wellWall);
    }
    //创建井底

  }, {
    key: "_createBottomSurface",
    value: function _createBottomSurface(bottom_pos) {
      if (!bottom_pos.length) {
        return;
      }
      var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
        pos_arr: bottom_pos
      });
      geo = geo.createGeometry(geo);
      var _material = new Cesium.Material({
        fabric: {
          type: "Image",
          uniforms: {
            image: this.bottomImg,
            color: Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this.opacityImg)
          }
        }
      });
      var _appearance = new Cesium.MaterialAppearance({
        translucent: false,
        flat: true,
        material: _material
      });
      this.bottomSurface = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geo
        }),
        appearance: _appearance,
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.bottomSurface);
    }

    //切换挖掘显隐

  }, {
    key: "_switchExcavate",
    value: function _switchExcavate(val) {
      if (val) {
        if (this.wellWall) this.wellWall.show = true;
        if (this.bottomSurface) this.bottomSurface.show = true;
      } else {
        if (this.wellWall) this.wellWall.show = false;
        if (this.bottomSurface) this.bottomSurface.show = false;
      }
    }

    //更新挖掘深度

  }, {
    key: "_updateExcavateDepth",
    value: function _updateExcavateDepth(depth) {
      if (!this.wellData) return;

      this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
      this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);

      var lerp_pos = this.wellData.lerp_pos;
      var bottom_pos = [];
      var len = lerp_pos.length;
      for (var i = 0; i < len; i++) {
        bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
      }
      this.wellData.bottom_pos = bottom_pos;
      this._createWell(this.wellData);

      this.viewer.scene.primitives.add(this.bottomSurface);
      this.viewer.scene.primitives.add(this.wellWall);
    }

    //清除裁剪面

  }, {
    key: "clear",
    value: function clear() {
      if (this.viewer.scene.globe.clippingPlanes) {
        this.viewer.scene.globe.clippingPlanes.enabled = false;
        this.viewer.scene.globe.clippingPlanes.removeAll();
        // if (!this.viewer.scene.globe.clippingPlanes.isDestroyed())
        //   this.viewer.scene.globe.clippingPlanes.destroy();
      }
      this.viewer.scene.globe.clippingPlanes = undefined;

      if (this.bottomSurface) {
        this.viewer.scene.primitives.remove(this.bottomSurface);
        delete this.bottomSurface;
      }

      if (this.wellWall) {
        this.viewer.scene.primitives.remove(this.wellWall);
        delete this.wellWall;
      }
      delete this.wellData;
      this.viewer.scene.render();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(TerrainClipPlan.prototype.__proto__ || Object.getPrototypeOf(TerrainClipPlan.prototype), "destroy", this).call(this);
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;

      if (this.viewer.scene.globe.clippingPlanes) this.viewer.scene.globe.clippingPlanes.enabled = val;

      if (this._showWall) {
        this._switchExcavate(val);
      }
    }

    //裁剪距离

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      this._height = val;

      if (this._showWall) {
        this._updateExcavateDepth(val);
      }
    }
  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = val;
      this.setPositions(val);
    }
  }]);

  return TerrainClipPlan;
}(_DasClass2.DasClass);

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Underground = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//地下模式类
var Underground = exports.Underground = function (_DasClass) {
  _inherits(Underground, _DasClass);

  //========== 构造方法 ==========
  function Underground(options, oldparam) {
    _classCallCheck(this, Underground);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Underground.__proto__ || Object.getPrototypeOf(Underground)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    _this.depthTestOld = Cesium.clone(_this.viewer.scene.globe.depthTestAgainstTerrain);

    _this.viewer.scene.globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(100.0, 0.0, 900.0, 1.0);
    _this.viewer.scene.globe.translucency.backFaceAlpha = 0;

    _this.alpha = Cesium.defaultValue(options.alpha, 0.5);
    _this.enable = Cesium.defaultValue(options.enable, false);
    return _this;
  }

  //========== 对外属性 ==========
  //显示和隐藏


  _createClass(Underground, [{
    key: "clear",
    value: function clear() {
      this.enable = false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(Underground.prototype.__proto__ || Object.getPrototypeOf(Underground.prototype), "destroy", this).call(this);
    }
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = Number(val);

      this.viewer.scene.globe.translucency.frontFaceAlphaByDistance.nearValue = this._alpha;
      this.viewer.scene.globe.translucency.frontFaceAlphaByDistance.farValue = this._alpha;
    }
  }, {
    key: "enable",
    get: function get() {
      return this.viewer.scene.globe.translucency.enabled;
    },
    set: function set(value) {
      this.viewer.scene.globe.depthTestAgainstTerrain = value ? true : this.depthTestOld;
      this.viewer.scene.screenSpaceCameraController.enableCollisionDetection = !value; //相机对地形的碰撞检测状态

      this.viewer.scene.globe.translucency.enabled = value;
    }
  }]);

  return Underground;
}(_DasClass2.DasClass);

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewShed3D = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _ViewShed3D = __webpack_require__(162);

var _ViewShed3D2 = _interopRequireDefault(_ViewShed3D);

var _RectangularSensorGraphics = __webpack_require__(86);

var _point = __webpack_require__(2);

var _matrix = __webpack_require__(16);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//   可视分析 类
var ViewShed3D = exports.ViewShed3D = function (_DasClass) {
  _inherits(ViewShed3D, _DasClass);

  //========== 构造方法 ==========
  function ViewShed3D(options, oldparam) {
    _classCallCheck(this, ViewShed3D);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (ViewShed3D.__proto__ || Object.getPrototypeOf(ViewShed3D)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    if (Cesium.defined(options.debugFrustum)) options.showFrustum = options.debugFrustum;
    _this.debugFrustum = _this.showFrustum;

    if (options.calback) {
      var calbackfun = options.calback;
      delete options.calback;
      _this.on(_DasClass2.eventType.end, function (e) {
        calbackfun(e.distance, _this);
      });
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;
    _this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;

    _this.cameraPosition = options.cameraPosition; //相机位置
    _this.viewPosition = options.viewPosition; //视点位置

    _this._horizontalAngle = Cesium.defaultValue(options.horizontalAngle, 120); //水平张角
    _this._verticalAngle = Cesium.defaultValue(options.verticalAngle, 90); //垂直张角
    _this._visibleAreaColor = Cesium.defaultValue(options.visibleAreaColor, new Cesium.Color(0, 1, 0)); //可视颜色
    _this._hiddenAreaColor = Cesium.defaultValue(options.hiddenAreaColor, new Cesium.Color(1, 0, 0)); //不可视颜色
    _this._alpha = Cesium.defaultValue(options.alpha, 0.5); //混合度
    _this._distance = Cesium.defaultValue(options.distance, 100); //距离
    _this._maximumDistance = Cesium.defaultValue(options.maximumDistance, 5000.0);
    _this._offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);
    _this._debugFrustum = Cesium.defaultValue(options.showFrustum, true); //视椎体显示
    _this._show = Cesium.defaultValue(options.show, true); //可视域显示
    _this.isAdd = false; //是否添加过视口
    _this._defaultColorTexture = new Cesium.Texture({
      //默认材质
      context: _this.viewer.scene.context,
      source: {
        width: 1,
        height: 1,
        arrayBufferView: new Uint8Array([0, 0, 0, 0])
      },
      flipY: false
    });

    if (_this.cameraPosition && _this.viewPosition) {
      _this._addToScene();
    } else {
      _this._bindMourseEvent();
    }
    return _this;
  }

  //========== 对外属性 ==========
  //水平张角


  _createClass(ViewShed3D, [{
    key: "setCursor",


    //========== 方法 ==========
    value: function setCursor(val) {
      this.viewer._container.style.cursor = val ? "crosshair" : "";
    }
    //激活绑定事件

  }, {
    key: "_bindMourseEvent",
    value: function _bindMourseEvent() {
      var that = this;
      var viewer = this.viewer;
      var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
      handler.setInputAction(function (movement) {
        var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.position);
        if (!cartesian) return;

        if (!that.cameraPosition) {
          //相机位置
          cartesian = (0, _point.addPositionsHeight)(cartesian, that._offsetHeight); //加人的身高等因素，略微抬高一些

          that.cameraPosition = cartesian;
        } else if (that.cameraPosition && !that.viewPosition) {
          var len = Cesium.Cartesian3.distance(that.cameraPosition, cartesian);
          if (len > 5000) {
            cartesian = (0, _matrix.getOnLinePointByLen)(that.cameraPosition, cartesian, 5000);
          }
          that.viewPosition = cartesian;
          that._unbindMourseEvent();
          that.setCursor(false);
          that._addToScene();
        } else {
          that._unbindMourseEvent();
          that.setCursor(false);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      handler.setInputAction(function (movement) {
        var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.endPosition);
        if (!cartesian) return;
        var cp = that.cameraPosition;
        if (cp) {
          var len = Cesium.Cartesian3.distance(cp, cartesian);
          if (len > 5000) {
            cartesian = (0, _matrix.getOnLinePointByLen)(cp, cartesian, 5000);
            that.frustumQuaternion = that.getFrustumQuaternion(cp, cartesian);
            that.distance = 5000;
          } else {
            that.frustumQuaternion = that.getFrustumQuaternion(cp, cartesian);
            that.distance = Number(len.toFixed(1));
          }
          if (!that.isAdd) {
            that.viewPosition = cartesian;
            that._addToScene();
          } else {
            that.viewPosition = cartesian;
            that.viewShadowMap._lightCamera.direction = Cesium.Cartesian3.subtract(cartesian, cp, new Cesium.Cartesian3(0, 0, 0));
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this._handler = handler;

      this.setCursor(true);
    }

    //解绑事件

  }, {
    key: "_unbindMourseEvent",
    value: function _unbindMourseEvent() {
      if (this._handler) {
        this._handler.destroy();
        delete this._handler;
      }
      this.setCursor(false);
    }

    //添加到场景里

  }, {
    key: "_addToScene",
    value: function _addToScene() {
      this.frustumQuaternion = this.getFrustumQuaternion(this.cameraPosition, this.viewPosition);
      this._createShadowMap(this.cameraPosition, this.viewPosition);
      this._addPostProcess();
      if (!this.radar) this.addRadar(this.cameraPosition, this.frustumQuaternion);
      this.viewer.scene.primitives.add(this);
      this.fire(_DasClass2.eventType.end, {
        distance: this.distance,
        cameraPosition: this.cameraPosition,
        viewPosition: this.viewPosition
      });
      this.isAdd = true;
    }

    //创建ShadowMap

  }, {
    key: "_createShadowMap",
    value: function _createShadowMap(cpos, viewPosition, fq) {
      var camera_pos = cpos;
      var lookat_pos = viewPosition;
      var scene = this.viewer.scene;
      var camera1 = new Cesium.Camera(scene);
      camera1.position = camera_pos;
      camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
      camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));

      var far = Number(Cesium.Cartesian3.distance(lookat_pos, camera_pos).toFixed(1));
      this.distance = far;

      camera1.frustum = new Cesium.PerspectiveFrustum({
        fov: Cesium.Math.toRadians(120),
        aspectRatio: scene.canvas.clientWidth / scene.canvas.clientHeight,
        near: 0.1,
        far: 5000
      });

      var isSpotLight = true;
      this.viewShadowMap = new Cesium.ShadowMap({
        lightCamera: camera1,
        enable: false,
        isPointLight: !isSpotLight,
        isSpotLight: isSpotLight,
        cascadesEnabled: false,
        context: scene.context,
        pointLightRadius: far,
        maximumDistance: this._maximumDistance
      });
    }

    //获取四元数

  }, {
    key: "getFrustumQuaternion",
    value: function getFrustumQuaternion(cpos, viewPosition) {
      //获取相机四元数，用来调整视椎体摆放
      var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(viewPosition, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
      var camera = new Cesium.Camera(this.viewer.scene);
      camera.position = cpos;
      camera.direction = direction;
      camera.up = up;
      direction = camera.directionWC;
      up = camera.upWC;
      var right = camera.rightWC;
      var scratchRight = new Cesium.Cartesian3();
      var scratchRotation = new Cesium.Matrix3();
      var scratchOrientation = new Cesium.Quaternion();

      // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
      right = Cesium.Cartesian3.negate(right, scratchRight);
      var rotation = scratchRotation;
      Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
      //计算视锥姿态
      var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
      return orientation;
    }

    //添加后处理

  }, {
    key: "_addPostProcess",
    value: function _addPostProcess() {
      var that = this;
      var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
      this.postProcess = new Cesium.PostProcessStage({
        fragmentShader: _ViewShed3D2.default,
        uniforms: {
          czzj: function czzj() {
            return that.verticalAngle;
          },
          dis: function dis() {
            return that.distance;
          },
          spzj: function spzj() {
            return that.horizontalAngle;
          },
          visibleColor: function visibleColor() {
            return that.visibleAreaColor;
          },
          disVisibleColor: function disVisibleColor() {
            return that.hiddenAreaColor;
          },
          mixNum: function mixNum() {
            return that.alpha;
          },
          dasShadow: function dasShadow() {
            return that.viewShadowMap._shadowMapTexture || that._defaultColorTexture;
          },
          _shadowMap_matrix: function _shadowMap_matrix() {
            return that.viewShadowMap._shadowMapMatrix;
          },
          shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
            return that.viewShadowMap._lightPositionEC;
          },
          shadowMap_lightPositionWC: function shadowMap_lightPositionWC() {
            return that.viewShadowMap._lightCamera.position;
          },
          shadowMap_lightDirectionEC: function shadowMap_lightDirectionEC() {
            return that.viewShadowMap._lightDirectionEC;
          },
          shadowMap_lightUp: function shadowMap_lightUp() {
            return that.viewShadowMap._lightCamera.up;
          },
          shadowMap_lightDir: function shadowMap_lightDir() {
            return that.viewShadowMap._lightCamera.direction;
          },
          shadowMap_lightRight: function shadowMap_lightRight() {
            return that.viewShadowMap._lightCamera.right;
          },
          shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
            var texelStepSize = new Cesium.Cartesian2();
            texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
            texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
            return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
          },
          shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
            return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
          },
          depthTexture1: function depthTexture1() {
            return that.getSceneDepthTexture(that.viewer);
            // return that._defaultDepth;
          }
        }
      });
      this.show && this.viewer.scene.postProcessStages.add(this.postProcess);
    }
  }, {
    key: "getSceneDepthTexture",
    value: function getSceneDepthTexture(viewer) {
      var scene = viewer.scene;
      var environmentState = scene._environmentState;
      var view = scene._view;
      var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;
      var globeFramebuffer = useGlobeDepthFramebuffer ? view.globeDepth.framebuffer : undefined;
      var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();
      var depthTexture = Cesium.defaultValue(globeFramebuffer, sceneFramebuffer).depthStencilTexture; //对的

      // var depthTexture = scene._view.pickDepths[0]._depthTexture;
      // var depthTexture = scene._view.pickDepths[0]._textureToCopy;
      // var depthTexture = scene._view.pickDepths[0]._copyDepthCommand._framebuffer._colorTextures[0];
      // var depthTexture = this.wyypost&&this.wyypost._depthTexture?this.wyypost._depthTexture:scene.context.uniformState.globeDepthTexture;
      // var depthTexture = scene.context.uniformState.globeDepthTexture;//对的
      return depthTexture;
    }

    //添加雷达

  }, {
    key: "addRadar",
    value: function addRadar(cpos, frustumQuaternion) {
      var position = cpos;
      var that = this;
      this.radar = this.viewer.entities.add(new Cesium.Entity({
        position: position,
        orientation: frustumQuaternion,
        show: this._debugFrustum && this.show,
        rectangularSensor: new _RectangularSensorGraphics.RectangularSensorGraphics({
          radius: that.distance, //传感器的半径
          xHalfAngle: Cesium.Math.toRadians(that.horizontalAngle / 2), //传感器水平半角
          yHalfAngle: Cesium.Math.toRadians(that.verticalAngle / 2), //传感器垂直半角
          material: new Cesium.Color(0.0, 1.0, 1.0, 0.4), //目前用的统一材质
          lineColor: new Cesium.Color(1.0, 1.0, 1.0, 1.0), //线的颜色
          slice: 8,
          showScanPlane: false, //是否显示扫描面
          showThroughEllipsoid: false, //此参数控制深度检测，为false启用深度检测，可以解决雷达一半在地球背面时显示的问题
          showLateralSurfaces: false,
          showDomeSurfaces: false
        })
      }));
    }
    //重置雷达

  }, {
    key: "resetRadar",
    value: function resetRadar() {
      this.removeRadar();
      this.addRadar(this.cameraPosition, this.frustumQuaternion);
    }
    //删除雷达

  }, {
    key: "removeRadar",
    value: function removeRadar() {
      if (this.radar) {
        this.viewer.entities.remove(this.radar);
        delete this.radar;
      }
    }

    //更新

  }, {
    key: "update",
    value: function update(frameState) {
      this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.terrainShadows = Cesium.ShadowMode.DISABLED;
      this._unbindMourseEvent();

      if (this.postProcess) {
        this.viewer.scene.postProcessStages.remove(this.postProcess);
        delete this.postProcess;
      }
      this.removeRadar();

      _get(ViewShed3D.prototype.__proto__ || Object.getPrototypeOf(ViewShed3D.prototype), "destroy", this).call(this);
    }
  }, {
    key: "horizontalAngle",
    get: function get() {
      return this._horizontalAngle;
    },
    set: function set(val) {
      this._horizontalAngle = val;
      this.resetRadar();
    }
    //垂直张角

  }, {
    key: "verticalAngle",
    get: function get() {
      return this._verticalAngle;
    },
    set: function set(val) {
      this._verticalAngle = val;
      this.resetRadar();
    }
    //可视距离

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    },
    set: function set(val) {
      this._distance = val;
      this.resetRadar();
    }
    //可视区域颜色

  }, {
    key: "visibleAreaColor",
    get: function get() {
      return this._visibleAreaColor;
    },
    set: function set(val) {
      this._visibleAreaColor = val;
    }
    //不可视区域颜色

  }, {
    key: "hiddenAreaColor",
    get: function get() {
      return this._hiddenAreaColor;
    },
    set: function set(val) {
      this._hiddenAreaColor = val;
    }
    //混合系数0-1

  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = val;
    }
    //显示和隐藏

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (val) {
        if (!this.postProcess) this._addPostProcess();
      } else {
        if (this.postProcess) {
          this.viewer.scene.postProcessStages.remove(this.postProcess);
          delete this.postProcess;
        }
      }
      if (this.radar) this.radar.show = this._debugFrustum && this.show;
    }
  }, {
    key: "showFrustum",
    get: function get() {
      return this._debugFrustum;
    },
    set: function set(val) {
      this._debugFrustum = val;
      if (this.radar) this.radar.show = val;
    }
  }]);

  return ViewShed3D;
}(_DasClass2.DasClass);

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "uniform float czzj;\r\nuniform float dis;\r\nuniform float spzj;\r\nuniform vec3 visibleColor;\r\nuniform vec3 disVisibleColor;\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D dasShadow; \r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec3 shadowMap_lightPositionWC;\r\nuniform vec4 shadowMap_lightDirectionEC;\r\nuniform vec3 shadowMap_lightUp;\r\nuniform vec3 shadowMap_lightDir;\r\nuniform vec3 shadowMap_lightRight;\r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n\r\n    // vec4 stcc = texture2D(dasShadow, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //坐标与视点位置距离，大于最大距离则舍弃阴影效果\r\n    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);\r\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\r\n    if(distance(lw.xyz,vw.xyz)>dis){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n\r\n    //水平夹角限制\r\n    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);\r\n    directionEC = ptOnSP - lw.xyz;\r\n    float directionECMO = ptm(directionEC.xyz);\r\n    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\r\n    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);\r\n    float degJJ = acos(cosJJ)*(180.0 / PI);\r\n    degJJ = abs(degJJ);\r\n    if(degJJ>spzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //垂直夹角限制\r\n    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);\r\n    vec3 dirOnCZ = ptOnCZ - lw.xyz;\r\n    float dirOnCZMO = ptm(dirOnCZ);\r\n    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);\r\n    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);\r\n    degJJCZ = abs(degJJCZ);\r\n    if(degJJCZ>czzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(dasShadow, shadowParameters); \r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);\r\n    }else{\r\n        // if(abs(shadowPosition.z-0.0)<0.01){\r\n        //     return;\r\n        // }\r\n        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);\r\n    }\r\n} "

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sightline = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _polyline = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//通视分析 类
var Sightline = exports.Sightline = function (_DasClass) {
  _inherits(Sightline, _DasClass);

  function Sightline(options, oldparam) {
    _classCallCheck(this, Sightline);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Sightline.__proto__ || Object.getPrototypeOf(Sightline)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;

    _this.lines = [];
    _this.realTime = Cesium.defaultValue(options.realTime, true); //实时更新
    _this._visibleColor = Cesium.defaultValue(options.visibleColor, new Cesium.Color(0, 1, 0, 1)); //可视区域
    _this._hiddenColor = Cesium.defaultValue(options.hiddenColor, new Cesium.Color(1, 0, 0, 1)); //不可视区域
    _this._depthFailColor_visible = _this.realTime ? options.depthFailColor : _this._visibleColor;
    _this._depthFailColor_hidden = _this.realTime ? options.depthFailColor : _this._hiddenColor;
    _this._depthFailColor = options.depthFailColor;

    if (options.originPoint && options.targetPoint) {
      _this.add(options.originPoint, options.targetPoint);
    }
    return _this;
  }
  //========== 对外属性 ==========

  //可视区域颜色


  _createClass(Sightline, [{
    key: "add",


    //========== 方法 ==========
    value: function add(origin, target, addHeight) {
      if (addHeight) {
        origin = (0, _point.addPositionsHeight)(origin, addHeight); //加人的身高
      }

      var currDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(target, origin, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var currRay = new Cesium.Ray(origin, currDir);
      var pickRes = this.viewer.scene.drillPickFromRay(currRay, 2, this.lines);

      if (Cesium.defined(pickRes) && pickRes.length > 0 && Cesium.defined(pickRes[0]) && Cesium.defined(pickRes[0].position)) {
        var position = pickRes[0].position;

        var distance = Cesium.Cartesian3.distance(origin, target);
        var distanceFx = Cesium.Cartesian3.distance(origin, position);
        if (distanceFx < distance) {
          //存在正常分析结果
          var _arrEentity = this._showPolyline(origin, target, position);

          var _result = {
            block: true, //存在遮挡
            position: position,
            entity: _arrEentity
          };
          this.fire(_DasClass2.eventType.end, _result);
          return _result;
        }
      }

      var arrEentity = this._showPolyline(origin, target);
      var result = {
        block: false,
        entity: arrEentity
      };
      this.fire(_DasClass2.eventType.end, result);
      return result;
    }

    //插值异步分析

  }, {
    key: "add2",
    value: function add2(origin, target, options) {
      var _this2 = this;

      options = options || {};
      if (options.addHeight) {
        origin = (0, _point.addPositionsHeight)(origin, options.addHeight); //加人的身高
      }

      //插值求新路线
      var positionsNew = (0, _polyline.interLine)([origin, target], {
        splitNum: options.splitNum || 50
      });

      //求对比的贴地地面高度
      (0, _polyline.computeSurfacePoints)({
        viewer: this.viewer,
        positions: positionsNew, //需要计算的源路线坐标数组
        callback: function callback(raisedPositions, noHeight) {
          if (!noHeight) {
            for (var i = 0; i < positionsNew.length; i++) {
              var position = positionsNew[i];
              var xHeight = Cesium.Cartographic.fromCartesian(position).height; //线高度
              var dHeight = Cesium.Cartographic.fromCartesian(raisedPositions[i]).height; //地面高度

              if (xHeight <= dHeight) {
                var arrEentity = _this2._showPolyline(origin, target, position);
                _this2.fire(_DasClass2.eventType.end, {
                  block: true, //存在遮挡
                  position: position,
                  entity: arrEentity
                });
                return;
              }
            }
          }
          var arrEentity2 = _this2._showPolyline(origin, target);
          _this2.fire(_DasClass2.eventType.end, {
            block: false,
            entity: arrEentity2
          });
        }
      });
    }
  }, {
    key: "_showPolyline",
    value: function _showPolyline(origin, target, position) {
      if (position) {
        //存在正常分析结果
        var entity1 = this.viewer.entities.add(new Cesium.Entity({
          polyline: {
            positions: [origin, position],
            width: 2,
            material: this._visibleColor,
            depthFailMaterial: this._depthFailColor_visible
          }
        }));
        this.lines.push(entity1);

        var entity2 = this.viewer.entities.add(new Cesium.Entity({
          polyline: {
            positions: [position, target],
            width: 2,
            material: this._hiddenColor,
            depthFailMaterial: this._depthFailColor_hidden
          }
        }));
        this.lines.push(entity2);

        return [entity1, entity2];
      } else {
        //无正确分析结果时，直接返回
        var entity = this.viewer.entities.add(new Cesium.Entity({
          polyline: {
            positions: [origin, target],
            width: 2,
            material: this._visibleColor,
            depthFailMaterial: this._depthFailColor_visible
          }
        }));
        this.lines.push(entity);

        return [entity];
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var i = 0, len = this.lines.length; i < len; i++) {
        this.viewer.entities.remove(this.lines[i]);
      }
      this.lines = [];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(Sightline.prototype.__proto__ || Object.getPrototypeOf(Sightline.prototype), "destroy", this).call(this);
    }
  }, {
    key: "visibleColor",
    get: function get() {
      return this._visibleColor;
    },
    set: function set(val) {
      this._visibleColor = val;
    }
    //不可视区域颜色

  }, {
    key: "hiddenColor",
    get: function get() {
      return this._hiddenColor;
    },
    set: function set(val) {
      this._hiddenColor = val;
    }

    //depthFailMaterial颜色，默认为不可视区域颜色

  }, {
    key: "depthFailColor",
    get: function get() {
      return this._depthFailColor;
    },
    set: function set(val) {
      this._depthFailColor_visible = this.realTime ? val : this._visibleColor;
      this._depthFailColor_hidden = this.realTime ? val : this._hiddenColor;
      this._depthFailColor = val;
    }
  }]);

  return Sightline;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


Sightline.event = {
  end: _DasClass2.eventType.end
};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CutFillAnalysis = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _util = __webpack_require__(3);

var _index = __webpack_require__(22);

var _Attr = __webpack_require__(21);

var _rxjsUmd = __webpack_require__(165);

var rx = _interopRequireWildcard(_rxjsUmd);

var _Draw = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //挖填方计算或者体积测量(基于WebGl)


//挖填方分析
var CutFillAnalysis = exports.CutFillAnalysis = function (_DasClass) {
  _inherits(CutFillAnalysis, _DasClass);

  function CutFillAnalysis(options, oldparam) {
    _classCallCheck(this, CutFillAnalysis);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (CutFillAnalysis.__proto__ || Object.getPrototypeOf(CutFillAnalysis)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
    _this._viewer = options.viewer;
    _this.scene = options.viewer.scene;
    _this.context = _this.scene.context;
    _this.pointPrimitives = _this._viewer.scene.primitives.add(new Cesium.PointPrimitiveCollection());
    // this.labelPrimitives = viewer.scene.primitives.add(new Cesium.LabelCollection());
    _this.volumeResult = null; //测量结果
    _this.polylinePrimitives = null; //测量结果
    //引用Rxjs
    _this.rxjs = {
      of: rx.of,
      from: rx.from,
      fromEventPattern: rx.fromEventPattern,
      animationFrameScheduler: rx.animationFrameScheduler,
      operators: {
        concatMap: rx.operators.concatMap,
        observeOn: rx.operators.observeOn,
        delay: rx.operators.delay,
        map: rx.operators.map,
        first: rx.operators.first,
        toArray: rx.operators.toArray
      }
    };

    _this.drawControl = new _Draw.Draw(_this._viewer, {
      hasEdit: false
    });
    _this.resultTempR = new Cesium.Cartesian3();
    _this.resultTempO = new Cesium.Cartesian3();
    _this.resultTempK = new Cesium.Cartesian3();
    _this.NewCartographic = new Cesium.Cartographic();
    _this.cartesiansIndex0ScalarResult = new Cesium.Cartesian3();
    _this.cartesiansIndex1ScalarResult = new Cesium.Cartesian3();
    _this.resultTempB = new Cesium.Cartesian3();
    _this.differenceMatrixClone = new Cesium.Cartesian3();
    return _this;
  }
  //高度


  _createClass(CutFillAnalysis, [{
    key: "isComputing",
    value: function isComputing() {
      return !!this._subsription;
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.pointPrimitives.removeAll(); //移出所有点
      if (this.polylinePrimitives) {
        this._viewer.scene.primitives.remove(this.polylinePrimitives);
        this.polylinePrimitives = null;
      }
      if (this.volumeResult) {
        //移出测量结果
        this.volumeResult.destroy();
        this.volumeResult = null;
      }
      this._subsription = this._subsription && this._subsription.unsubscribe();
      delete this._maxHeight;
      delete this._minHeight;
      delete this._jzmHeight;
      delete this.result;
      this.drawControl.removeAll(); //移除基准面
      delete this.polygonJzm;
    }
  }, {
    key: "selecteHeight",
    value: function selecteHeight(callback) {
      //拾取高度
      var that = this;
      this.drawControl.startDraw({
        type: "point",
        style: {
          color: "#00fff2"
        },
        success: function success(entity) {
          if (!entity.point) return;
          var pos = entity._position._value;
          var height = Cesium.Cartographic.fromCartesian(pos).height;
          var newFillV = that.updateVolume(height);
          that.drawControl.deleteEntity(entity);
          var data = Object.assign({ height: height }, newFillV);
          callback && callback(data);
        }
      });
    }
  }, {
    key: "copyArray",
    value: function copyArray(arr) {
      if (Array.isArray(arr)) {
        for (var t = 0, n = Array(arr.length); t < arr.length; t++) {
          n[t] = arr[t];
        }return n;
      }
      return arr;
    }
    //开始绘制

  }, {
    key: "startDraw",
    value: function startDraw(_options) {
      var that = this;
      if (that.isComputing()) {
        that.cancel();
      }
      var options = _options || {};
      var style = options.style || {};
      var splitNum = options.splitNum || 1000;
      var isShow = options.isShowPoint || true;
      that.drawControl.startDraw({
        type: "polygon",
        style: _extends({
          color: "#007be6",
          opacity: 0.5,
          outline: true,
          outlineWidth: 1,
          outlineColor: "#ffffff"
        }, style, {
          clampToGround: false
        }),
        success: function success(entity) {
          var positions = that._viewer.das.draw.getPositions(entity);
          that.drawControl.deleteEntity(entity);
          that.compute({ cartesians: positions,
            splitNum: splitNum,
            isShowPoint: isShow
          }, function (result) {
            that.showResult(result);
          }, function (progress) {
            console.log(progress);
          });
        }
      });
    }
  }, {
    key: "getMinHeight",
    value: function getMinHeight(positions) {
      var height = 0;
      for (var index = 0; index < positions.length; index++) {
        var cartographic = Cesium.Cartographic.fromCartesian(positions[index]);
        var h = cartographic.height;
        if (index == 0) {
          height = h;
        } else if (h < height) {
          height = h;
        }
      }
      return height;
    }
  }, {
    key: "updateVolume",
    value: function updateVolume(height) {
      var that = this,
          cut = 0,
          fill = 0;
      if (!that.isComputing() || !that.polygonJzm) return {};
      var data = that.result,
          area = Number(data.area),
          itemArea = area / that.splitNum;
      for (var index = 0; index < data.diffHeights.length; index++) {
        var _height = data.diffHeights[index];
        if (height >= _height + that.minHeight) {
          cut += 0, fill += itemArea * (height - (_height + that.minHeight));
        } else if (height < _height + that.minHeight) {
          cut += itemArea * (_height + that.minHeight - height), fill += 0;
        }
      }
      //修改基准面高度
      that._jzmHeight = height;
      that.drawControl.setPositions((0, _point.setPositionsHeight)(that.positions, height), that.polygonJzm);
      var html = "";
      if (fill > 0) {
        html += "<div>填方体积：" + that.formatNum(fill) + "立方米</div>";
      }
      if (cut > 0) {
        html += "<div>挖方体积：" + that.formatNum(cut) + "立方米</div>";
      }
      html += "<div>横切面积：" + (0, _util.formatArea)(area) + "</div>";
      that.volumeResult._dom.html("<div class='das3d-popup-content-volumeResult'>" + html + "<div class='das3d-popup-volume-wrapper'></div></div>");
      return {
        fill: that.formatNum(fill) + "立方米",
        cut: that.formatNum(cut) + "立方米",
        area: (0, _util.formatArea)(area)
      };
    }
  }, {
    key: "isShowPoint",
    value: function isShowPoint(isShow) {
      if (!this.isComputing()) return;
      this.pointPrimitives._pointPrimitives.forEach(function (item) {
        item.show = isShow;
      });
      this.polylinePrimitives.show = isShow;
    }
  }, {
    key: "showResult",
    value: function showResult(result) {
      var that = this;
      if (!this.isComputing()) return;
      that._addPointAndLine(result); //加载取样点和线
      // 显示基准面
      var _polygonJzm = (0, _Attr.style2Entity)((0, _index.getDefStyle)("polygon", {
        color: "#0000ff",
        opacity: 0.8
      }), {
        hierarchy: new Cesium.PolygonHierarchy(that.positions),
        height: new Cesium.CallbackProperty(function (time, result) {
          return that.height;
        }, false)
      });
      delete _polygonJzm.perPositionHeight;
      that.polygonJzm = that.drawControl.dataSource.entities.add({
        polygon: _polygonJzm
      });
      var fillText = "";
      if (result.fill > 0) {
        fillText += "<div>填方体积：" + that.formatNum(result.fill) + "立方米</div>";
      }
      if (result.cut > 0) {
        fillText += "<div>挖方体积：" + that.formatNum(result.cut) + "立方米</div>";
      }
      fillText += "<div>横切面积：" + (0, _util.formatArea)(Number(result.area)) + "</div>";
      that.volumeResult = new das3d.DivPoint(that._viewer, {
        html: "<div class='das3d-popup-content-volumeResult'>" + fillText + "<div class='das3d-popup-volume-wrapper'></div></div>",
        position: (0, _point.setPositionsHeight)([result.ptcenter], result.maxHeight + 1)[0],
        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 30000), //按视距距离显示
        scaleByDistance: new Cesium.NearFarScalar(800, 1.0, 25000, 0.1)
      });
    }
  }, {
    key: "showResult2",
    value: function showResult2(result) {
      var that = this;
      if (!that.isComputing()) return;
      that._addPointAndLine(result); //加载取样点和线
      that.volumeResult = new das3d.DivPoint(that._viewer, {
        html: "<div class='das3d-popup-content-volumeResult'><div>\u4F53\u79EF\u6D4B\u91CF\u7ED3\u679C\uFF1A" + that.formatNum(result.cut) + "\u7ACB\u65B9\u7C73</div><div class='das3d-popup-volume-wrapper'></div></div>",
        position: (0, _point.setPositionsHeight)([result.ptcenter], result.maxHeight + 1)[0],
        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
        distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 30000), //按视距距离显示
        scaleByDistance: new Cesium.NearFarScalar(800, 1.0, 25000, 0.1)
      });
    }
  }, {
    key: "_addPointAndLine",
    value: function _addPointAndLine(result) {
      var that = this;
      //Primitive方式
      var green = Cesium.Color.fromCssColorString('#00ff00').withAlpha(0.8);
      var red = Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.8);
      var polylineinstances = [];
      for (var j = 0; j < result.diffHeights.length; ++j) {
        var item = result.diffHeights[j];
        that.pointPrimitives.add({
          pixelSize: 8,
          show: that.isShow,
          color: green,
          position: result.heightCartesians[j],
          disableDepthTestDistance: Number.POSITIVE_INFINITY //不遮挡
        });
        if (item > 0) {
          that.pointPrimitives.add({
            pixelSize: 8,
            show: that.isShow,
            color: red,
            position: result.clampCartesians[j],
            disableDepthTestDistance: Number.POSITIVE_INFINITY
          });
          var polylineinstance = new Cesium.GeometryInstance({
            geometry: new Cesium.PolylineGeometry({
              positions: [result.heightCartesians[j], result.clampCartesians[j]],
              width: 1
            }),
            vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.YELLOW.withAlpha(0.6)),
              depthFailColor: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.YELLOW.withAlpha(0.2))
            }
          });
          polylineinstances.push(polylineinstance);
        }
      }
      var _primitive = new Cesium.Primitive({
        geometryInstances: polylineinstances,
        releaseGeometryInstances: false,
        appearance: new Cesium.PolylineColorAppearance(),
        depthFailAppearance: new Cesium.PolylineColorAppearance()
      });
      that.polylinePrimitives = that._viewer.scene.primitives.add(_primitive);
      that.polylinePrimitives.show = that.isShow;
    }
  }, {
    key: "compute",
    value: function compute(options, result, progress) {
      var cartesians = options.cartesians;
      var that = this,
          scene = this._viewer.scene;
      that.positions = cartesians;
      if (that.isComputing()) {
        that.cancel();
      }
      var area = that.area(cartesians).toFixed(2);
      //求中心点
      var ptcenter = (0, _point.centerOfMass)(cartesians);
      // var gridWidth = Math.max(0.5, Math.sqrt(area / that.splitNum));
      that.splitNum = options.splitNum || 1000;
      that.isShow = options.isShowPoint || true;
      var gridWidth = Math.sqrt(area / that.splitNum);
      var finalHeight = that.getMinHeight(cartesians);
      that._minHeight = finalHeight;
      that._jzmHeight = finalHeight;
      that._maxHeight = result.maxHeight;
      this._subsription && this._subsription.unsubscribe(), this._subsription = function (cartesians, gridWidth, finalHeight, scene, result, progress) {
        if (!(cartesians.length < 3)) {
          progress && progress(0);
          var positionArr = [];
          cartesians.forEach(function (pointItem) {
            var tempPoint;
            if (finalHeight) {
              // (t = Cesium.Cartographic.fromCartesian(pointItem, void 0, that.NewCartographic)).height = finalHeight
              tempPoint = Cesium.Cartographic.fromCartesian(pointItem, void 0, that.NewCartographic);
              tempPoint.height = finalHeight;
            } else {
              tempPoint = Cesium.Cartographic.fromCartesian(pointItem, void 0, that.NewCartographic);
              finalHeight = tempPoint.height;
            }
            positionArr.push(Cesium.Cartesian3.fromRadians(tempPoint.longitude, tempPoint.latitude, tempPoint.height));
          });
          var center = Cesium.CoplanarPolygonGeometry.fromPositions({
            positions: positionArr
          });
          var cartesians = Cesium.CoplanarPolygonGeometry.createGeometry(center);
          var positionValue = cartesians.attributes.position.values;
          var indices = cartesians.indices;
          var boundingSphere = cartesians.boundingSphere;
          center = Cesium.Cartesian3.clone(boundingSphere.center);
          cartesians = Cesium.Cartographic.fromCartesian(center, void 0, that.NewCartographic);
          Cesium.Cartesian3.fromRadians(cartesians.longitude, cartesians.latitude, finalHeight, void 0, center);
          cartesians = Cesium.Transforms.eastNorthUpToFixedFrame(center);
          var cartesiansIndex0 = Cesium.Matrix4.getColumn(cartesians, 0, new Cesium.Cartesian3());
          var cartesiansIndex1 = Cesium.Matrix4.getColumn(cartesians, 1, new Cesium.Cartesian3());
          var differenceMatrix = Cesium.Cartesian3.subtract(center, Cesium.Cartesian3.multiplyByScalar(cartesiansIndex0, boundingSphere.radius, that.cartesiansIndex0ScalarResult), that.resultTempB);
          differenceMatrix = Cesium.Cartesian3.subtract(differenceMatrix, Cesium.Cartesian3.multiplyByScalar(cartesiansIndex1, boundingSphere.radius, that.cartesiansIndex1ScalarResult), differenceMatrix);
          var splitLength = Math.round(2 * boundingSphere.radius / gridWidth) + 1;
          var cellSize = gridWidth;
          var differenceMatrixClone = that.differenceMatrixClone;
          Cesium.Cartesian3.clone(differenceMatrix, differenceMatrixClone);
          for (var y = [], v = [], i = 0; i < splitLength; ++i) {
            for (var x = 0; x < splitLength; ++x) {
              if (Cesium.Cartesian3.add(differenceMatrix, Cesium.Cartesian3.multiplyByScalar(cartesiansIndex0, cellSize * i, that.cartesiansIndex0ScalarResult), differenceMatrixClone), Cesium.Cartesian3.add(differenceMatrixClone, Cesium.Cartesian3.multiplyByScalar(cartesiansIndex1, cellSize * x, that.cartesiansIndex1ScalarResult), differenceMatrixClone), !(0 < boundingSphere.distanceSquaredTo(differenceMatrixClone))) {
                for (var w = false, b = indices.length / 3, C = 0; C < b; ++C) {
                  var S = Cesium.Cartesian3.fromElements(positionValue[3 * indices[3 * C + 0] + 0], positionValue[3 * indices[3 * C + 0] + 1], positionValue[3 * indices[3 * C + 0] + 2], that.resultTempR),
                      T = Cesium.Cartesian3.fromElements(positionValue[3 * indices[3 * C + 1] + 0], positionValue[3 * indices[3 * C + 1] + 1], positionValue[3 * indices[3 * C + 1] + 2], that.resultTempO),
                      M = Cesium.Cartesian3.fromElements(positionValue[3 * indices[3 * C + 2] + 0], positionValue[3 * indices[3 * C + 2] + 1], positionValue[3 * indices[3 * C + 2] + 2], that.resultTempK);
                  if (that.D(differenceMatrixClone, S, T, M)) {
                    w = true;
                    break;
                  }
                }
                w && (v.push(Cesium.Cartesian3.clone(differenceMatrixClone)), y.push(Cesium.Ellipsoid.WGS84.scaleToGeodeticSurface(differenceMatrixClone)));
              }
            }
          }progress && progress(0.1);
          var E,
              P = 0;
          return that.rxjs.of({
            clampCartesians: y,
            heightCartesians: v
          }).pipe(that.rxjs.operators.concatMap(function (e) {
            for (var t = e.clampCartesians, n = e.heightCartesians, i = 0, r = t.length, a = []; i < r;) {
              var o = 10 < r - i ? i + 10 : r,
                  l = t.slice(i, o),
                  s = n.slice(i, o);
              a.push({
                pClampCartesians: l,
                pHeightCartesians: s
              }), i = o;
            }
            return E = a.length, that.rxjs.from(a).pipe(that.rxjs.operators.concatMap(function (e) {
              var t = e.pClampCartesians,
                  u = e.pHeightCartesians;
              return that.rxjs.fromEventPattern(function (n) {
                scene.clampToHeightMostDetailed(t).then(function (e) {
                  ++P, progress && progress(P / E * .8 + .1);
                  var t = e.some(function (e) {
                    return void 0 === e;
                  });
                  n(t ? void 0 : e);
                }).otherwise(function (e) {
                  n(void 0);
                });
              }, function (e) {}).pipe(that.rxjs.operators.observeOn(that.rxjs.animationFrameScheduler), that.rxjs.operators.delay(10), that.rxjs.operators.map(function (e) {
                if (!e) throw new Error("clampToHeightMostDetailed error!");
                for (var t = [], n = e.length, i = new Cesium.Cartesian3(), r = 0, a = 0, o = 0, mh = 0, mhNum = 0; o < n; ++o) {
                  var l = Cesium.Cartesian3.subtract(e[o], u[o], i);
                  var s = Cesium.Cartesian3.magnitude(l);
                  var sk = 0;
                  if (Cesium.Cartesian3.dot(l, u[o]) > 0) {
                    t.push(s);
                    r += s * gridWidth * gridWidth;
                    sk = s;
                  } else {
                    t.push(-s);
                    sk = -s;
                    a += s * gridWidth * gridWidth;
                  }
                  if (sk > mh) {
                    mh = sk;
                    mhNum = Cesium.Cartographic.fromCartesian(e[o]).height;
                  }
                }
                return {
                  pHeightCartesians: u,
                  pClampCartesians: e,
                  pDiffHeights: t,
                  maxHeight: mhNum,
                  fill: a,
                  cut: r,
                  total: a - r
                };
              }), that.rxjs.operators.first());
            }));
          }), that.rxjs.operators.toArray(), that.rxjs.operators.map(function (e) {
            var pHeightCartesiansList = [];
            var pClampCartesiansList = [];
            var pDiffHeightsList = [];
            var cutResult = 0;
            var fillResult = 0;
            var totalResult = 0;
            var pmaxHeight = 0;
            e.forEach(function (e) {
              pHeightCartesiansList.push.apply(pHeightCartesiansList, that.copyArray(e.pHeightCartesians));
              pClampCartesiansList.push.apply(pClampCartesiansList, that.copyArray(e.pClampCartesians));
              pDiffHeightsList.push.apply(pDiffHeightsList, that.copyArray(e.pDiffHeights));
              if (e.maxHeight > pmaxHeight) {
                pmaxHeight = e.maxHeight;
              }
              cutResult += e.cut;
              fillResult += e.fill;
              totalResult += e.total;
            });
            if (progress) {
              progress(1);
            }
            return {
              heightCartesians: pHeightCartesiansList,
              clampCartesians: pClampCartesiansList,
              diffHeights: pDiffHeightsList,
              maxHeight: pmaxHeight,
              cut: cutResult,
              fill: fillResult,
              total: totalResult
            };
          }), that.rxjs.operators.map(function (e) {
            e.area = area;
            e.ptcenter = ptcenter;
            that.result = e;
            return result(e);
          }));
        }
      }(cartesians, gridWidth, finalHeight, scene, result, progress).subscribe(function () {}, function (e) {
        that.cancel(); //,
        //  o(e)
      }, function () {});
    }
  }, {
    key: "D",
    value: function D(e, t, n, i) {
      var r = this.getMagnitude(t, n, i),
          a = this.getMagnitude(e, t, n),
          n = this.getMagnitude(e, n, i),
          t = this.getMagnitude(e, i, t);
      return Math.abs(r - a - n - t) < 1e-5 * r;
    }
  }, {
    key: "area",
    value: function area(e) {
      var h = new Cesium.Cartesian3();
      var d = new Cesium.Cartesian3();
      var f = new Cesium.Cartesian3();

      if (!(e.length <= 2)) {
        e = Cesium.CoplanarPolygonGeometry.fromPositions({
          positions: e
        }), e = Cesium.CoplanarPolygonGeometry.createGeometry(e);
        if (e) {
          for (var t = e.attributes.position.values, n = e.indices, i = n.length / 3, r = 0, a = 0; a < i; ++a) {
            var o = Cesium.Cartesian3.fromElements(t[3 * n[3 * a + 0] + 0], t[3 * n[3 * a + 0] + 1], t[3 * n[3 * a + 0] + 2], h),
                l = Cesium.Cartesian3.fromElements(t[3 * n[3 * a + 1] + 0], t[3 * n[3 * a + 1] + 1], t[3 * n[3 * a + 1] + 2], d),
                s = Cesium.Cartesian3.fromElements(t[3 * n[3 * a + 2] + 0], t[3 * n[3 * a + 2] + 1], t[3 * n[3 * a + 2] + 2], f);
            r += this.getMagnitude(o, l, s);
          }
          return r;
        }
      }
    }
  }, {
    key: "getMagnitude",
    value: function getMagnitude(e, t, n) {
      var r = new Cesium.Cartesian3();
      var a = new Cesium.Cartesian3();
      var o = new Cesium.Cartesian3();
      return t = Cesium.Cartesian3.subtract(t, e, r), e = Cesium.Cartesian3.subtract(n, e, a), e = Cesium.Cartesian3.cross(t, e, o), 0.5 * Cesium.Cartesian3.magnitude(e);
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._subsription) {
        this._subsription.unsubscribe();
        this._subsription = null;
        return Cesium.destroyObject(this);
      }
    }
    //格式化数值

  }, {
    key: "formatNum",
    value: function formatNum(num) {
      if (num > 10000) {
        return (num / 10000).toFixed(2) + "万";
      }
      return num.toFixed(2);
    }
  }, {
    key: "height",
    get: function get() {
      return this._jzmHeight;
    },
    set: function set(val) {
      if (!this.isComputing()) return;
      this._jzmHeight = val;
      var newFillV = this.updateVolume(val);
      this.fire(_DasClass2.eventType.change, _extends({
        height: val
      }, newFillV));
    }
  }, {
    key: "minHeight",
    get: function get() {
      return this._minHeight;
    }
  }, {
    key: "maxHeight",
    get: function get() {
      return this._maxHeight;
    }
  }]);

  return CutFillAnalysis;
}(_DasClass2.DasClass);

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
*****************************************************************************/
(function (k, h) {
    "object" === ( false ? undefined : _typeof(exports)) && "undefined" !== typeof module ? h(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (h),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(undefined, function (k) {
    function h(c, a) {
        function b() {
            this.constructor = c;
        }Mb(c, a);c.prototype = null === a ? Object.create(a) : (b.prototype = a.prototype, new b());
    }function Q(c) {
        return "function" === typeof c;
    }function R(c) {
        setTimeout(function () {
            throw c;
        }, 0);
    }function sa(c) {
        return null !== c && "object" === (typeof c === "undefined" ? "undefined" : _typeof(c));
    }function Ma(c) {
        Error.call(this);this.message = c ? c.length + " errors occurred during unsubscription:\n" + c.map(function (a, b) {
            return b + 1 + ") " + a.toString();
        }).join("\n  ") : "";this.name = "UnsubscriptionError";this.errors = c;return this;
    }function Na(c) {
        return c.reduce(function (a, b) {
            return a.concat(b instanceof Y ? b.errors : b);
        }, []);
    }function ta(c) {
        for (; c;) {
            var a = c.destination,
                b = c.isStopped;if (c.closed || b) return !1;c = a && a instanceof m ? a : null;
        }return !0;
    }function D() {}function ua() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }return Oa(c);
    }function Oa(c) {
        return c ? 1 === c.length ? c[0] : function (a) {
            return c.reduce(function (b, a) {
                return a(b);
            }, a);
        } : D;
    }function Pa(c) {
        c || (c = C.Promise || Promise);if (!c) throw Error("no Promise impl found");return c;
    }function E() {
        Error.call(this);this.message = "object unsubscribed";this.name = "ObjectUnsubscribedError";return this;
    }function va() {
        return function (c) {
            return c.lift(new Nb(c));
        };
    }function S(c) {
        return c ? Ob(c) : T;
    }function Ob(c) {
        return new n(function (a) {
            return c.schedule(function () {
                return a.complete();
            });
        });
    }function A(c) {
        return c && "function" === typeof c.schedule;
    }function wa(c, a) {
        return new n(function (b) {
            var d = new t(),
                e = 0;d.add(a.schedule(function () {
                e === c.length ? b.complete() : (b.next(c[e++]), b.closed || d.add(this.schedule()));
            }));return d;
        });
    }function Z(c, a) {
        return a ? wa(c, a) : new n(Qa(c));
    }function ha() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }a = c[c.length - 1];return A(a) ? (c.pop(), wa(c, a)) : Z(c);
    }function xa(c, a) {
        return a ? new n(function (b) {
            return a.schedule(Pb, 0, { error: c, subscriber: b });
        }) : new n(function (b) {
            return b.error(c);
        });
    }function Pb(c) {
        c.subscriber.error(c.error);
    }
    function J(c) {
        return c;
    }function K() {
        Error.call(this);this.message = "argument out of range";this.name = "ArgumentOutOfRangeError";return this;
    }function Ra() {
        Error.call(this);this.message = "no elements in sequence";this.name = "EmptyError";return this;
    }function ya() {
        Error.call(this);this.message = "Timeout has occurred";this.name = "TimeoutError";return this;
    }function B(c, a) {
        return function (b) {
            if ("function" !== typeof c) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return b.lift(new Qb(c, a));
        };
    }function Sa(c, a, b) {
        if (a) if (A(a)) b = a;else return function () {
            for (var d = [], e = 0; e < arguments.length; e++) {
                d[e] = arguments[e];
            }return Sa(c, b).apply(void 0, d).pipe(B(function (b) {
                return x(b) ? a.apply(void 0, b) : a(b);
            }));
        };return function () {
            for (var a = [], e = 0; e < arguments.length; e++) {
                a[e] = arguments[e];
            }var f = this,
                g,
                l = { context: f, subject: g, callbackFunc: c, scheduler: b };return new n(function (d) {
                if (b) return b.schedule(Rb, 0, { args: a, subscriber: d, params: l });if (!g) {
                    g = new U();try {
                        c.apply(f, a.concat([function () {
                            for (var b = [], a = 0; a < arguments.length; a++) {
                                b[a] = arguments[a];
                            }g.next(1 >= b.length ? b[0] : b);g.complete();
                        }]));
                    } catch (L) {
                        ta(g) ? g.error(L) : console.warn(L);
                    }
                }return g.subscribe(d);
            });
        };
    }function Rb(c) {
        var a = this,
            b = c.args,
            d = c.subscriber;c = c.params;var e = c.callbackFunc,
            f = c.context,
            g = c.scheduler,
            l = c.subject;if (!l) {
            l = c.subject = new U();try {
                e.apply(f, b.concat([function () {
                    for (var b = [], c = 0; c < arguments.length; c++) {
                        b[c] = arguments[c];
                    }a.add(g.schedule(Sb, 0, { value: 1 >= b.length ? b[0] : b, subject: l }));
                }]));
            } catch (u) {
                l.error(u);
            }
        }this.add(l.subscribe(d));
    }
    function Sb(c) {
        var a = c.subject;a.next(c.value);a.complete();
    }function Ta(c, a, b) {
        if (a) if (A(a)) b = a;else return function () {
            for (var d = [], e = 0; e < arguments.length; e++) {
                d[e] = arguments[e];
            }return Ta(c, b).apply(void 0, d).pipe(B(function (b) {
                return x(b) ? a.apply(void 0, b) : a(b);
            }));
        };return function () {
            for (var a = [], e = 0; e < arguments.length; e++) {
                a[e] = arguments[e];
            }var f = { subject: void 0, args: a, callbackFunc: c, scheduler: b, context: this };return new n(function (d) {
                var e = f.context,
                    g = f.subject;if (b) return b.schedule(Tb, 0, {
                    params: f,
                    subscriber: d, context: e
                });if (!g) {
                    g = f.subject = new U();try {
                        c.apply(e, a.concat([function () {
                            for (var b = [], a = 0; a < arguments.length; a++) {
                                b[a] = arguments[a];
                            }(a = b.shift()) ? g.error(a) : (g.next(1 >= b.length ? b[0] : b), g.complete());
                        }]));
                    } catch (L) {
                        ta(g) ? g.error(L) : console.warn(L);
                    }
                }return g.subscribe(d);
            });
        };
    }function Tb(c) {
        var a = this,
            b = c.params,
            d = c.subscriber;c = c.context;var e = b.callbackFunc,
            f = b.args,
            g = b.scheduler,
            l = b.subject;if (!l) {
            l = b.subject = new U();try {
                e.apply(c, f.concat([function () {
                    for (var b = [], c = 0; c < arguments.length; c++) {
                        b[c] = arguments[c];
                    }(c = b.shift()) ? a.add(g.schedule(Ua, 0, { err: c, subject: l })) : a.add(g.schedule(Ub, 0, { value: 1 >= b.length ? b[0] : b, subject: l }));
                }]));
            } catch (u) {
                this.add(g.schedule(Ua, 0, { err: u, subject: l }));
            }
        }this.add(l.subscribe(d));
    }function Ub(c) {
        var a = c.subject;a.next(c.value);a.complete();
    }function Ua(c) {
        c.subject.error(c.err);
    }function Va(c) {
        return !!c && "function" !== typeof c.subscribe && "function" === typeof c.then;
    }function p(c, a, b, d, e) {
        void 0 === e && (e = new H(c, b, d));if (!e.closed) return a instanceof n ? a.subscribe(e) : ia(a)(e);
    }
    function Vb(c, a) {
        return new n(function (b) {
            var d = new t();d.add(a.schedule(function () {
                var e = c[V]();d.add(e.subscribe({ next: function next(c) {
                        d.add(a.schedule(function () {
                            return b.next(c);
                        }));
                    }, error: function error(c) {
                        d.add(a.schedule(function () {
                            return b.error(c);
                        }));
                    }, complete: function complete() {
                        d.add(a.schedule(function () {
                            return b.complete();
                        }));
                    } }));
            }));return d;
        });
    }function Wb(c, a) {
        return new n(function (b) {
            var d = new t();d.add(a.schedule(function () {
                return c.then(function (c) {
                    d.add(a.schedule(function () {
                        b.next(c);d.add(a.schedule(function () {
                            return b.complete();
                        }));
                    }));
                }, function (c) {
                    d.add(a.schedule(function () {
                        return b.error(c);
                    }));
                });
            }));return d;
        });
    }function Xb(c, a) {
        if (!c) throw Error("Iterable cannot be null");return new n(function (b) {
            var d = new t(),
                e;d.add(function () {
                e && "function" === typeof e.return && e.return();
            });d.add(a.schedule(function () {
                e = c[F]();d.add(a.schedule(function () {
                    if (!b.closed) {
                        var a, c;try {
                            var d = e.next();a = d.value;c = d.done;
                        } catch (u) {
                            b.error(u);return;
                        }c ? b.complete() : (b.next(a), this.schedule());
                    }
                }));
            }));return d;
        });
    }function Wa(c, a) {
        if (null != c) {
            if (c && "function" === typeof c[V]) return Vb(c, a);if (Va(c)) return Wb(c, a);if (Xa(c)) return wa(c, a);if (c && "function" === typeof c[F] || "string" === typeof c) return Xb(c, a);
        }throw new TypeError((null !== c && (typeof c === "undefined" ? "undefined" : _typeof(c)) || c) + " is not observable");
    }function G(c, a) {
        return a ? Wa(c, a) : c instanceof n ? c : new n(ia(c));
    }function M(c, a, b) {
        void 0 === b && (b = Number.POSITIVE_INFINITY);if ("function" === typeof a) return function (d) {
            return d.pipe(M(function (b, d) {
                return G(c(b, d)).pipe(B(function (c, e) {
                    return a(b, c, d, e);
                }));
            }, b));
        };"number" === typeof a && (b = a);return function (a) {
            return a.lift(new Yb(c, b));
        };
    }function za(c) {
        void 0 === c && (c = Number.POSITIVE_INFINITY);return M(J, c);
    }function Ya() {
        return za(1);
    }function aa() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }return Ya()(ha.apply(void 0, c));
    }function Aa(c) {
        return new n(function (a) {
            var b;try {
                b = c();
            } catch (d) {
                a.error(d);return;
            }return (b ? G(b) : S()).subscribe(a);
        });
    }function ja(c, a) {
        return new n(function (b) {
            var d = c.length;if (0 === d) b.complete();else for (var e = Array(d), f = 0, g = 0, l = function l(_l) {
                var h = G(c[_l]),
                    u = !1;b.add(h.subscribe({
                    next: function next(b) {
                        u || (u = !0, g++);e[_l] = b;
                    }, error: function error(a) {
                        return b.error(a);
                    }, complete: function complete() {
                        f++;f !== d && u || (g === d && b.next(a ? a.reduce(function (b, a, c) {
                            return b[a] = e[c], b;
                        }, {}) : e), b.complete());
                    }
                }));
            }, h = 0; h < d; h++) {
                l(h);
            }
        });
    }function Za(c, a, b, d) {
        Q(b) && (d = b, b = void 0);return d ? Za(c, a, b).pipe(B(function (b) {
            return x(b) ? d.apply(void 0, b) : d(b);
        })) : new n(function (d) {
            $a(c, a, function (b) {
                1 < arguments.length ? d.next(Array.prototype.slice.call(arguments)) : d.next(b);
            }, d, b);
        });
    }function $a(c, a, b, d, e) {
        var f;if (c && "function" === typeof c.addEventListener && "function" === typeof c.removeEventListener) c.addEventListener(a, b, e), f = function f() {
            return c.removeEventListener(a, b, e);
        };else if (c && "function" === typeof c.on && "function" === typeof c.off) c.on(a, b), f = function f() {
            return c.off(a, b);
        };else if (c && "function" === typeof c.addListener && "function" === typeof c.removeListener) c.addListener(a, b), f = function f() {
            return c.removeListener(a, b);
        };else if (c && c.length) for (var g = 0, l = c.length; g < l; g++) {
            $a(c[g], a, b, d, e);
        } else throw new TypeError("Invalid event target");d.add(f);
    }function ab(c, a, b) {
        return b ? ab(c, a).pipe(B(function (a) {
            return x(a) ? b.apply(void 0, a) : b(a);
        })) : new n(function (b) {
            var d = function d() {
                for (var a = [], c = 0; c < arguments.length; c++) {
                    a[c] = arguments[c];
                }return b.next(1 === a.length ? a[0] : a);
            },
                f;try {
                f = c(d);
            } catch (g) {
                b.error(g);return;
            }if (Q(a)) return function () {
                return a(d, f);
            };
        });
    }function bc(c) {
        var a = c.subscriber,
            b = c.condition;if (!a.closed) {
            if (c.needIterate) try {
                c.state = c.iterate(c.state);
            } catch (f) {
                a.error(f);return;
            } else c.needIterate = !0;if (b) {
                var d = void 0;try {
                    d = b(c.state);
                } catch (f) {
                    a.error(f);
                    return;
                }if (!d) {
                    a.complete();return;
                }if (a.closed) return;
            }var e;try {
                e = c.resultSelector(c.state);
            } catch (f) {
                a.error(f);return;
            }if (!a.closed && (a.next(e), !a.closed)) return this.schedule(c);
        }
    }function W(c) {
        return !x(c) && 0 <= c - parseFloat(c) + 1;
    }function cc(c) {
        var a = c.subscriber,
            b = c.counter;c = c.period;a.next(b);this.schedule({ subscriber: a, counter: b + 1, period: c }, c);
    }function bb() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }var a = Number.POSITIVE_INFINITY,
            b = null,
            d = c[c.length - 1];A(d) ? (b = c.pop(), 1 < c.length && "number" === typeof c[c.length - 1] && (a = c.pop())) : "number" === typeof d && (a = c.pop());return null === b && 1 === c.length && c[0] instanceof n ? c[0] : za(a)(Z(c, b));
    }function Ba() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }if (0 === c.length) return T;var b = c[0],
            d = c.slice(1);return 1 === c.length && x(b) ? Ba.apply(void 0, b) : new n(function (a) {
            var c = function c() {
                return a.add(Ba.apply(void 0, d).subscribe(a));
            };return G(b).subscribe({ next: function next(b) {
                    a.next(b);
                }, error: c, complete: c });
        });
    }function dc(c) {
        var a = c.keys,
            b = c.index,
            d = c.subscriber,
            e = c.subscription;c = c.obj;if (!d.closed) if (b < a.length) {
            var f = a[b];d.next([f, c[f]]);e.add(this.schedule({ keys: a, index: b + 1, subscriber: d, subscription: e, obj: c }));
        } else d.complete();
    }function cb(c, a) {
        function b() {
            return !b.pred.apply(b.thisArg, arguments);
        }b.pred = c;b.thisArg = a;return b;
    }function I(c, a) {
        return function (b) {
            return b.lift(new ec(c, a));
        };
    }function db() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }if (1 === c.length) if (x(c[0])) c = c[0];else return c[0];return Z(c, void 0).lift(new fc());
    }
    function gc(c) {
        var a = c.start,
            b = c.index,
            d = c.subscriber;b >= c.count ? d.complete() : (d.next(a), d.closed || (c.index = b + 1, c.start = a + 1, this.schedule(c)));
    }function eb(c, a, b) {
        void 0 === c && (c = 0);var d = -1;W(a) ? d = 1 > Number(a) && 1 || Number(a) : A(a) && (b = a);A(b) || (b = y);return new n(function (a) {
            var e = W(c) ? c : +c - b.now();return b.schedule(hc, e, { index: 0, period: d, subscriber: a });
        });
    }function hc(c) {
        var a = c.index,
            b = c.period,
            d = c.subscriber;d.next(a);if (!d.closed) {
            if (-1 === b) return d.complete();c.index = a + 1;this.schedule(c, b);
        }
    }function fb() {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }a = c[c.length - 1];"function" === typeof a && c.pop();return Z(c, void 0).lift(new gb(a));
    }function hb(c) {
        return function (a) {
            return a.lift(new ic(c));
        };
    }function ib(c) {
        var a = c.subscriber,
            b = c.context;b && a.closeContext(b);a.closed || (c.context = a.openContext(), c.context.closeAction = this.schedule(c, c.bufferTimeSpan));
    }function jc(c) {
        var a = c.bufferCreationInterval,
            b = c.bufferTimeSpan,
            d = c.subscriber,
            e = c.scheduler,
            f = d.openContext();d.closed || (d.add(f.closeAction = e.schedule(jb, b, { subscriber: d, context: f })), this.schedule(c, a));
    }function jb(c) {
        c.subscriber.closeContext(c.context);
    }function kb(c, a) {
        return M(c, a, 1);
    }function kc(c) {
        c.debouncedNext();
    }function ba(c) {
        void 0 === c && (c = null);return function (a) {
            return a.lift(new lc(c));
        };
    }function lb(c, a) {
        return function (b) {
            return b.lift(new mc(c, a));
        };
    }function ka(c) {
        void 0 === c && (c = nc);return function (a) {
            return a.lift(new oc(c));
        };
    }function nc() {
        return new ca();
    }function Ca(c) {
        return function (a) {
            return 0 === c ? S() : a.lift(new pc(c));
        };
    }function mb(c, a) {
        return a ? function (b) {
            return b.pipe(mb(function (b, e) {
                return G(c(b, e)).pipe(B(function (c, d) {
                    return a(b, c, e, d);
                }));
            }));
        } : function (b) {
            return b.lift(new qc(c));
        };
    }function la(c) {
        return function (a) {
            return 0 === c ? S() : a.lift(new rc(c));
        };
    }function ma(c, a) {
        var b = !1;2 <= arguments.length && (b = !0);return function (d) {
            return d.lift(new sc(c, a, b));
        };
    }function na(c, a) {
        return 2 <= arguments.length ? function (b) {
            return ua(ma(c, a), la(1), ba(a))(b);
        } : function (b) {
            return ua(ma(function (b, a, f) {
                return c(b, a, f + 1);
            }), la(1))(b);
        };
    }function N(c, a) {
        return function (b) {
            var d;d = "function" === typeof c ? c : function () {
                return c;
            };if ("function" === typeof a) return b.lift(new tc(d, a));var e = Object.create(b, uc);e.source = b;e.subjectFactory = d;return e;
        };
    }function vc(c, a) {
        return function (b) {
            var d = b;for (b = 0; b < a; b++) {
                if (d = d[c[b]], "undefined" === typeof d) return;
            }return d;
        };
    }function wc(c) {
        var a = c.period;c.subscriber.notifyNext();this.schedule(c, a);
    }function xc() {
        return new v();
    }function yc(c) {
        var a = c.bufferSize,
            b = void 0 === a ? Number.POSITIVE_INFINITY : a,
            a = c.windowTime,
            d = void 0 === a ? Number.POSITIVE_INFINITY : a,
            e = c.refCount,
            f = c.scheduler,
            g,
            l = 0,
            h,
            k = !1,
            r = !1;return function (a) {
            l++;if (!g || k) k = !1, g = new X(b, d, f), h = a.subscribe({ next: function next(b) {
                    g.next(b);
                }, error: function error(b) {
                    k = !0;g.error(b);
                }, complete: function complete() {
                    r = !0;g.complete();
                } });var c = g.subscribe(this);this.add(function () {
                l--;c.unsubscribe();h && !r && e && 0 === l && (h.unsubscribe(), g = h = void 0);
            });
        };
    }function da(c, a) {
        return "function" === typeof a ? function (b) {
            return b.pipe(da(function (b, e) {
                return G(c(b, e)).pipe(B(function (c, d) {
                    return a(b, c, e, d);
                }));
            }));
        } : function (b) {
            return b.lift(new zc(c));
        };
    }function Ac(c) {
        c.subscriber.clearThrottle();
    }function nb(c, a, b) {
        void 0 === b && (b = y);return function (d) {
            var e = c instanceof Date && !isNaN(+c),
                f = e ? +c - b.now() : Math.abs(c);return d.lift(new Bc(f, e, a, b));
        };
    }function Cc(c, a, b) {
        if (0 === b) return [a];c.push(a);return c;
    }function Dc(c) {
        var a = c.subscriber,
            b = c.windowTimeSpan,
            d = c.window;d && a.closeWindow(d);c.window = a.openWindow();this.schedule(c, b);
    }function Ec(c) {
        var a = c.windowTimeSpan,
            b = c.subscriber,
            d = c.scheduler,
            e = c.windowCreationInterval,
            f = b.openWindow(),
            g = { action: this, subscription: null };g.subscription = d.schedule(ob, a, { subscriber: b, window: f, context: g });this.add(g.subscription);this.schedule(c, e);
    }function ob(c) {
        var a = c.subscriber,
            b = c.window;(c = c.context) && c.action && c.subscription && c.action.remove(c.subscription);a.closeWindow(b);
    }function pb(c, a) {
        for (var b = 0, d = a.length; b < d; b++) {
            for (var e = a[b], f = Object.getOwnPropertyNames(e.prototype), g = 0, l = f.length; g < l; g++) {
                var h = f[g];c.prototype[h] = e.prototype[h];
            }
        }
    }function Fc(c, a) {
        void 0 === a && (a = null);
        return new O({ method: "GET", url: c, headers: a });
    }function Gc(c, a, b) {
        return new O({ method: "POST", url: c, body: a, headers: b });
    }function Hc(c, a) {
        return new O({ method: "DELETE", url: c, headers: a });
    }function Ic(c, a, b) {
        return new O({ method: "PUT", url: c, body: a, headers: b });
    }function Jc(c, a, b) {
        return new O({ method: "PATCH", url: c, body: a, headers: b });
    }function Kc(c, a) {
        return Lc(new O({ method: "GET", url: c, responseType: "json", headers: a }));
    }function qb(c, a, b) {
        Error.call(this);this.message = c;this.name = "AjaxError";this.xhr = a;this.request = b;this.status = a.status;this.responseType = a.responseType || b.responseType;this.response = rb(this.responseType, a);return this;
    }function rb(c, a) {
        switch (c) {case "json":
                return c = "response" in a ? a.responseType ? a.response : JSON.parse(a.response || a.responseText || "null") : JSON.parse(a.responseText || "null"), c;case "xml":
                return a.responseXML;default:
                return "response" in a ? a.response : a.responseText;}
    }var Mb = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (c, a) {
        c.__proto__ = a;
    } || function (c, a) {
        for (var b in a) {
            a.hasOwnProperty(b) && (c[b] = a[b]);
        }
    },
        Mc = Object.assign || function (c) {
        for (var a, b = 1, d = arguments.length; b < d; b++) {
            a = arguments[b];for (var e in a) {
                Object.prototype.hasOwnProperty.call(a, e) && (c[e] = a[e]);
            }
        }return c;
    },
        Da = !1,
        C = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(c) {
            c ? console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + Error().stack) : Da && console.log("RxJS: Back to a better error behavior. Thank you. \x3c3");Da = c;
        }, get useDeprecatedSynchronousErrorHandling() {
            return Da;
        } },
        oa = { closed: !0, next: function next(c) {}, error: function error(c) {
            if (C.useDeprecatedSynchronousErrorHandling) throw c;R(c);
        }, complete: function complete() {} },
        x = Array.isArray || function (c) {
        return c && "number" === typeof c.length;
    };Ma.prototype = Object.create(Error.prototype);var Y = Ma,
        t = function () {
        function c(a) {
            this.closed = !1;this._subscriptions = this._parentOrParents = null;a && (this._unsubscribe = a);
        }c.prototype.unsubscribe = function () {
            var a;if (!this.closed) {
                var b = this._parentOrParents,
                    d = this._unsubscribe,
                    e = this._subscriptions;this.closed = !0;this._subscriptions = this._parentOrParents = null;if (b instanceof c) b.remove(this);else if (null !== b) for (var f = 0; f < b.length; ++f) {
                    b[f].remove(this);
                }if (Q(d)) try {
                    d.call(this);
                } catch (g) {
                    a = g instanceof Y ? Na(g.errors) : [g];
                }if (x(e)) for (f = -1, b = e.length; ++f < b;) {
                    if (d = e[f], sa(d)) try {
                        d.unsubscribe();
                    } catch (g) {
                        a = a || [], g instanceof Y ? a = a.concat(Na(g.errors)) : a.push(g);
                    }
                }if (a) throw new Y(a);
            }
        };c.prototype.add = function (a) {
            var b = a;if (!a) return c.EMPTY;switch (typeof a === "undefined" ? "undefined" : _typeof(a)) {
                case "function":
                    b = new c(a);case "object":
                    if (b === this || b.closed || "function" !== typeof b.unsubscribe) return b;if (this.closed) return b.unsubscribe(), b;b instanceof c || (a = b, b = new c(), b._subscriptions = [a]);break;default:
                    throw Error("unrecognized teardown " + a + " added to Subscription.");
            }a = b._parentOrParents;if (null === a) b._parentOrParents = this;else if (a instanceof c) {
                if (a === this) return b;b._parentOrParents = [a, this];
            } else if (-1 === a.indexOf(this)) a.push(this);else return b;a = this._subscriptions;null === a ? this._subscriptions = [b] : a.push(b);return b;
        };c.prototype.remove = function (a) {
            var b = this._subscriptions;b && (a = b.indexOf(a), -1 !== a && b.splice(a, 1));
        };c.EMPTY = function (a) {
            a.closed = !0;return a;
        }(new c());return c;
    }(),
        pa = "function" === typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(),
        m = function (c) {
        function a(b, d, e) {
            var f = c.call(this) || this;f.syncErrorValue = null;f.syncErrorThrown = !1;f.syncErrorThrowable = !1;f.isStopped = !1;switch (arguments.length) {
                case 0:
                    f.destination = oa;break;case 1:
                    if (!b) {
                        f.destination = oa;break;
                    }if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b))) {
                        b instanceof a ? (f.syncErrorThrowable = b.syncErrorThrowable, f.destination = b, b.add(f)) : (f.syncErrorThrowable = !0, f.destination = new sb(f, b));break;
                    }default:
                    f.syncErrorThrowable = !0, f.destination = new sb(f, b, d, e);
            }return f;
        }h(a, c);a.prototype[pa] = function () {
            return this;
        };a.create = function (b, c, e) {
            b = new a(b, c, e);b.syncErrorThrowable = !1;return b;
        };a.prototype.next = function (b) {
            this.isStopped || this._next(b);
        };a.prototype.error = function (b) {
            this.isStopped || (this.isStopped = !0, this._error(b));
        };a.prototype.complete = function () {
            this.isStopped || (this.isStopped = !0, this._complete());
        };a.prototype.unsubscribe = function () {
            this.closed || (this.isStopped = !0, c.prototype.unsubscribe.call(this));
        };a.prototype._next = function (b) {
            this.destination.next(b);
        };a.prototype._error = function (b) {
            this.destination.error(b);this.unsubscribe();
        };a.prototype._complete = function () {
            this.destination.complete();this.unsubscribe();
        };a.prototype._unsubscribeAndRecycle = function () {
            var b = this._parentOrParents;this._parentOrParents = null;this.unsubscribe();this.isStopped = this.closed = !1;this._parentOrParents = b;return this;
        };return a;
    }(t),
        sb = function (c) {
        function a(b, a, e, f) {
            var d = c.call(this) || this;d._parentSubscriber = b;var l;b = d;Q(a) ? l = a : a && (l = a.next, e = a.error, f = a.complete, a !== oa && (b = Object.create(a), Q(b.unsubscribe) && d.add(b.unsubscribe.bind(b)), b.unsubscribe = d.unsubscribe.bind(d)));d._context = b;d._next = l;d._error = e;d._complete = f;return d;
        }h(a, c);a.prototype.next = function (b) {
            if (!this.isStopped && this._next) {
                var a = this._parentSubscriber;C.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable ? this.__tryOrSetError(a, this._next, b) && this.unsubscribe() : this.__tryOrUnsub(this._next, b);
            }
        };a.prototype.error = function (b) {
            if (!this.isStopped) {
                var a = this._parentSubscriber,
                    c = C.useDeprecatedSynchronousErrorHandling;if (this._error) c && a.syncErrorThrowable ? this.__tryOrSetError(a, this._error, b) : this.__tryOrUnsub(this._error, b), this.unsubscribe();else if (a.syncErrorThrowable) c ? (a.syncErrorValue = b, a.syncErrorThrown = !0) : R(b), this.unsubscribe();else {
                    this.unsubscribe();if (c) throw b;R(b);
                }
            }
        };a.prototype.complete = function () {
            var b = this;
            if (!this.isStopped) {
                var a = this._parentSubscriber;if (this._complete) {
                    var c = function c() {
                        return b._complete.call(b._context);
                    };C.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable ? this.__tryOrSetError(a, c) : this.__tryOrUnsub(c);
                }this.unsubscribe();
            }
        };a.prototype.__tryOrUnsub = function (b, a) {
            try {
                b.call(this._context, a);
            } catch (e) {
                this.unsubscribe();if (C.useDeprecatedSynchronousErrorHandling) throw e;R(e);
            }
        };a.prototype.__tryOrSetError = function (b, a, c) {
            if (!C.useDeprecatedSynchronousErrorHandling) throw Error("bad call");
            try {
                a.call(this._context, c);
            } catch (f) {
                return C.useDeprecatedSynchronousErrorHandling ? (b.syncErrorValue = f, b.syncErrorThrown = !0) : R(f), !0;
            }return !1;
        };a.prototype._unsubscribe = function () {
            var b = this._parentSubscriber;this._parentSubscriber = this._context = null;b.unsubscribe();
        };return a;
    }(m),
        V = "function" === typeof Symbol && Symbol.observable || "@@observable",
        n = function () {
        function c(a) {
            this._isScalar = !1;a && (this._subscribe = a);
        }c.prototype.lift = function (a) {
            var b = new c();b.source = this;b.operator = a;return b;
        };c.prototype.subscribe = function (a, b, c) {
            var d = this.operator;a: {
                if (a) {
                    if (a instanceof m) break a;if (a[pa]) {
                        a = a[pa]();break a;
                    }
                }a = a || b || c ? new m(a, b, c) : new m(oa);
            }d ? a.add(d.call(a, this.source)) : a.add(this.source || C.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a));if (C.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1, a.syncErrorThrown)) throw a.syncErrorValue;return a;
        };c.prototype._trySubscribe = function (a) {
            try {
                return this._subscribe(a);
            } catch (b) {
                C.useDeprecatedSynchronousErrorHandling && (a.syncErrorThrown = !0, a.syncErrorValue = b), ta(a) ? a.error(b) : console.warn(b);
            }
        };c.prototype.forEach = function (a, b) {
            var c = this;b = Pa(b);return new b(function (b, d) {
                var e;e = c.subscribe(function (b) {
                    try {
                        a(b);
                    } catch (u) {
                        d(u), e && e.unsubscribe();
                    }
                }, d, b);
            });
        };c.prototype._subscribe = function (a) {
            var b = this.source;return b && b.subscribe(a);
        };c.prototype[V] = function () {
            return this;
        };c.prototype.pipe = function () {
            for (var a = [], b = 0; b < arguments.length; b++) {
                a[b] = arguments[b];
            }return 0 === a.length ? this : Oa(a)(this);
        };c.prototype.toPromise = function (a) {
            var b = this;a = Pa(a);return new a(function (a, c) {
                var d;b.subscribe(function (b) {
                    return d = b;
                }, function (b) {
                    return c(b);
                }, function () {
                    return a(d);
                });
            });
        };c.create = function (a) {
            return new c(a);
        };return c;
    }();E.prototype = Object.create(Error.prototype);var tb = function (c) {
        function a(b, a) {
            var d = c.call(this) || this;d.subject = b;d.subscriber = a;d.closed = !1;return d;
        }h(a, c);a.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.closed = !0;var b = this.subject,
                    a = b.observers;this.subject = null;!a || 0 === a.length || b.isStopped || b.closed || (b = a.indexOf(this.subscriber), -1 !== b && a.splice(b, 1));
            }
        };return a;
    }(t),
        ub = function (c) {
        function a(b) {
            var a = c.call(this, b) || this;a.destination = b;return a;
        }h(a, c);return a;
    }(m),
        v = function (c) {
        function a() {
            var b = c.call(this) || this;b.observers = [];b.closed = !1;b.isStopped = !1;b.hasError = !1;b.thrownError = null;return b;
        }h(a, c);a.prototype[pa] = function () {
            return new ub(this);
        };a.prototype.lift = function (b) {
            var a = new Ea(this, this);a.operator = b;return a;
        };a.prototype.next = function (b) {
            if (this.closed) throw new E();
            if (!this.isStopped) for (var a = this.observers, c = a.length, a = a.slice(), f = 0; f < c; f++) {
                a[f].next(b);
            }
        };a.prototype.error = function (b) {
            if (this.closed) throw new E();this.hasError = !0;this.thrownError = b;this.isStopped = !0;for (var a = this.observers, c = a.length, a = a.slice(), f = 0; f < c; f++) {
                a[f].error(b);
            }this.observers.length = 0;
        };a.prototype.complete = function () {
            if (this.closed) throw new E();this.isStopped = !0;for (var b = this.observers, a = b.length, b = b.slice(), c = 0; c < a; c++) {
                b[c].complete();
            }this.observers.length = 0;
        };a.prototype.unsubscribe = function () {
            this.closed = this.isStopped = !0;this.observers = null;
        };a.prototype._trySubscribe = function (b) {
            if (this.closed) throw new E();return c.prototype._trySubscribe.call(this, b);
        };a.prototype._subscribe = function (b) {
            if (this.closed) throw new E();if (this.hasError) return b.error(this.thrownError), t.EMPTY;if (this.isStopped) return b.complete(), t.EMPTY;this.observers.push(b);return new tb(this, b);
        };a.prototype.asObservable = function () {
            var b = new n();b.source = this;return b;
        };a.create = function (b, a) {
            return new Ea(b, a);
        };
        return a;
    }(n),
        Ea = function (c) {
        function a(b, a) {
            var d = c.call(this) || this;d.destination = b;d.source = a;return d;
        }h(a, c);a.prototype.next = function (b) {
            var a = this.destination;a && a.next && a.next(b);
        };a.prototype.error = function (b) {
            var a = this.destination;a && a.error && this.destination.error(b);
        };a.prototype.complete = function () {
            var b = this.destination;b && b.complete && this.destination.complete();
        };a.prototype._subscribe = function (b) {
            return this.source ? this.source.subscribe(b) : t.EMPTY;
        };return a;
    }(v),
        Nb = function () {
        function c(a) {
            this.connectable = a;
        }c.prototype.call = function (a, b) {
            var c = this.connectable;c._refCount++;a = new Nc(a, c);b = b.subscribe(a);a.closed || (a.connection = c.connect());return b;
        };return c;
    }(),
        Nc = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.connectable = a;return b;
        }h(a, c);a.prototype._unsubscribe = function () {
            var b = this.connectable;if (b) {
                this.connectable = null;var a = b._refCount;0 >= a ? this.connection = null : (b._refCount = a - 1, 1 < a ? this.connection = null : (a = this.connection, b = b._connection, this.connection = null, !b || a && b !== a || b.unsubscribe()));
            } else this.connection = null;
        };return a;
    }(m),
        vb = function (c) {
        function a(b, a) {
            var d = c.call(this) || this;d.source = b;d.subjectFactory = a;d._refCount = 0;d._isComplete = !1;return d;
        }h(a, c);a.prototype._subscribe = function (b) {
            return this.getSubject().subscribe(b);
        };a.prototype.getSubject = function () {
            var b = this._subject;if (!b || b.isStopped) this._subject = this.subjectFactory();return this._subject;
        };a.prototype.connect = function () {
            var b = this._connection;b || (this._isComplete = !1, b = this._connection = new t(), b.add(this.source.subscribe(new Oc(this.getSubject(), this))), b.closed && (this._connection = null, b = t.EMPTY));return b;
        };a.prototype.refCount = function () {
            return va()(this);
        };return a;
    }(n),
        ea = vb.prototype,
        uc = { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: ea._subscribe }, _isComplete: { value: ea._isComplete, writable: !0 }, getSubject: { value: ea.getSubject }, connect: { value: ea.connect }, refCount: { value: ea.refCount } },
        Oc = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.connectable = a;return b;
        }h(a, c);a.prototype._error = function (b) {
            this._unsubscribe();c.prototype._error.call(this, b);
        };a.prototype._complete = function () {
            this.connectable._isComplete = !0;this._unsubscribe();c.prototype._complete.call(this);
        };a.prototype._unsubscribe = function () {
            var b = this.connectable;if (b) {
                this.connectable = null;var a = b._connection;b._refCount = 0;b._subject = null;b._connection = null;a && a.unsubscribe();
            }
        };return a;
    }(ub);(function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.connectable = a;return b;
        }h(a, c);a.prototype._unsubscribe = function () {
            var b = this.connectable;if (b) {
                this.connectable = null;var a = b._refCount;0 >= a ? this.connection = null : (b._refCount = a - 1, 1 < a ? this.connection = null : (a = this.connection, b = b._connection, this.connection = null, !b || a && b !== a || b.unsubscribe()));
            } else this.connection = null;
        };return a;
    })(m);var Qc = function () {
        function c(a, b, c, e) {
            this.keySelector = a;this.elementSelector = b;this.durationSelector = c;this.subjectSelector = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Pc(a, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
        };return c;
    }(),
        Pc = function (c) {
        function a(b, a, e, f, g) {
            b = c.call(this, b) || this;b.keySelector = a;b.elementSelector = e;b.durationSelector = f;b.subjectSelector = g;b.groups = null;b.attemptedToUnsubscribe = !1;b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a;try {
                a = this.keySelector(b);
            } catch (e) {
                this.error(e);return;
            }this._group(b, a);
        };a.prototype._group = function (b, a) {
            var c = this.groups;c || (c = this.groups = new Map());var d = c.get(a),
                g;if (this.elementSelector) try {
                g = this.elementSelector(b);
            } catch (l) {
                this.error(l);
            } else g = b;if (!d && (d = this.subjectSelector ? this.subjectSelector() : new v(), c.set(a, d), b = new Fa(a, d, this), this.destination.next(b), this.durationSelector)) {
                b = void 0;try {
                    b = this.durationSelector(new Fa(a, d));
                } catch (l) {
                    this.error(l);return;
                }this.add(b.subscribe(new Rc(a, d, this)));
            }d.closed || d.next(g);
        };a.prototype._error = function (b) {
            var a = this.groups;a && (a.forEach(function (a, c) {
                a.error(b);
            }), a.clear());this.destination.error(b);
        };a.prototype._complete = function () {
            var b = this.groups;b && (b.forEach(function (b, a) {
                b.complete();
            }), b.clear());this.destination.complete();
        };a.prototype.removeGroup = function (b) {
            this.groups.delete(b);
        };a.prototype.unsubscribe = function () {
            this.closed || (this.attemptedToUnsubscribe = !0, 0 === this.count && c.prototype.unsubscribe.call(this));
        };return a;
    }(m),
        Rc = function (c) {
        function a(b, a, e) {
            var d = c.call(this, a) || this;d.key = b;d.group = a;d.parent = e;return d;
        }h(a, c);a.prototype._next = function (b) {
            this.complete();
        };a.prototype._unsubscribe = function () {
            var b = this.parent,
                a = this.key;this.key = this.parent = null;b && b.removeGroup(a);
        };
        return a;
    }(m),
        Fa = function (c) {
        function a(b, a, e) {
            var d = c.call(this) || this;d.key = b;d.groupSubject = a;d.refCountSubscription = e;return d;
        }h(a, c);a.prototype._subscribe = function (b) {
            var a = new t(),
                c = this.refCountSubscription,
                f = this.groupSubject;c && !c.closed && a.add(new Sc(c));a.add(f.subscribe(b));return a;
        };return a;
    }(n),
        Sc = function (c) {
        function a(b) {
            var a = c.call(this) || this;a.parent = b;b.count++;return a;
        }h(a, c);a.prototype.unsubscribe = function () {
            var b = this.parent;b.closed || this.closed || (c.prototype.unsubscribe.call(this), --b.count, 0 === b.count && b.attemptedToUnsubscribe && b.unsubscribe());
        };return a;
    }(t),
        wb = function (c) {
        function a(b) {
            var a = c.call(this) || this;a._value = b;return a;
        }h(a, c);Object.defineProperty(a.prototype, "value", { get: function get() {
                return this.getValue();
            }, enumerable: !0, configurable: !0 });a.prototype._subscribe = function (b) {
            var a = c.prototype._subscribe.call(this, b);a && !a.closed && b.next(this._value);return a;
        };a.prototype.getValue = function () {
            if (this.hasError) throw this.thrownError;if (this.closed) throw new E();return this._value;
        };
        a.prototype.next = function (b) {
            c.prototype.next.call(this, this._value = b);
        };return a;
    }(v),
        fa = function (c) {
        function a(b, a) {
            var d = c.call(this, b, a) || this;d.scheduler = b;d.work = a;d.pending = !1;return d;
        }h(a, c);a.prototype.schedule = function (b, a) {
            void 0 === a && (a = 0);if (this.closed) return this;this.state = b;b = this.id;var c = this.scheduler;null != b && (this.id = this.recycleAsyncId(c, b, a));this.pending = !0;this.delay = a;this.id = this.id || this.requestAsyncId(c, this.id, a);return this;
        };a.prototype.requestAsyncId = function (b, a, c) {
            void 0 === c && (c = 0);return setInterval(b.flush.bind(b, this), c);
        };a.prototype.recycleAsyncId = function (b, a, c) {
            void 0 === c && (c = 0);if (null !== c && this.delay === c && !1 === this.pending) return a;clearInterval(a);
        };a.prototype.execute = function (b, a) {
            if (this.closed) return Error("executing a cancelled action");this.pending = !1;if (b = this._execute(b, a)) return b;!1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        };a.prototype._execute = function (b, a) {
            a = !1;var c = void 0;try {
                this.work(b);
            } catch (f) {
                a = !0, c = !!f && f || Error(f);
            }if (a) return this.unsubscribe(), c;
        };a.prototype._unsubscribe = function () {
            var b = this.id,
                a = this.scheduler,
                c = a.actions,
                f = c.indexOf(this);this.state = this.work = null;this.pending = !1;this.scheduler = null;-1 !== f && c.splice(f, 1);null != b && (this.id = this.recycleAsyncId(a, b, null));this.delay = null;
        };return a;
    }(function (c) {
        function a(b, a) {
            return c.call(this) || this;
        }h(a, c);a.prototype.schedule = function (b, a) {
            return this;
        };return a;
    }(t)),
        Tc = function (c) {
        function a(b, a) {
            var d = c.call(this, b, a) || this;d.scheduler = b;d.work = a;return d;
        }h(a, c);a.prototype.schedule = function (b, a) {
            void 0 === a && (a = 0);if (0 < a) return c.prototype.schedule.call(this, b, a);this.delay = a;this.state = b;this.scheduler.flush(this);return this;
        };a.prototype.execute = function (b, a) {
            return 0 < a || this.closed ? c.prototype.execute.call(this, b, a) : this._execute(b, a);
        };a.prototype.requestAsyncId = function (b, a, e) {
            void 0 === e && (e = 0);return null !== e && 0 < e || null === e && 0 < this.delay ? c.prototype.requestAsyncId.call(this, b, a, e) : b.flush(this);
        };return a;
    }(fa),
        Ga = function () {
        function c(a, b) {
            void 0 === b && (b = c.now);this.SchedulerAction = a;this.now = b;
        }c.prototype.schedule = function (a, b, c) {
            void 0 === b && (b = 0);return new this.SchedulerAction(this, a).schedule(c, b);
        };c.now = function () {
            return Date.now();
        };return c;
    }(),
        P = function (c) {
        function a(b, d) {
            void 0 === d && (d = Ga.now);var e = c.call(this, b, function () {
                return a.delegate && a.delegate !== e ? a.delegate.now() : d();
            }) || this;e.actions = [];e.active = !1;e.scheduled = void 0;return e;
        }h(a, c);a.prototype.schedule = function (b, d, e) {
            void 0 === d && (d = 0);return a.delegate && a.delegate !== this ? a.delegate.schedule(b, d, e) : c.prototype.schedule.call(this, b, d, e);
        };a.prototype.flush = function (b) {
            var a = this.actions;if (this.active) a.push(b);else {
                var c;this.active = !0;do {
                    if (c = b.execute(b.state, b.delay)) break;
                } while (b = a.shift());this.active = !1;if (c) {
                    for (; b = a.shift();) {
                        b.unsubscribe();
                    }throw c;
                }
            }
        };return a;
    }(Ga),
        xb = new (function (c) {
        function a() {
            return null !== c && c.apply(this, arguments) || this;
        }h(a, c);return a;
    }(P))(Tc),
        T = new n(function (c) {
        return c.complete();
    }),
        Qa = function Qa(c) {
        return function (a) {
            for (var b = 0, d = c.length; b < d && !a.closed; b++) {
                a.next(c[b]);
            }a.complete();
        };
    };(function (c) {
        c.NEXT = "N";c.ERROR = "E";c.COMPLETE = "C";
    })(k.NotificationKind || (k.NotificationKind = {}));var w = function () {
        function c(a, b, c) {
            this.kind = a;this.value = b;this.error = c;this.hasValue = "N" === a;
        }c.prototype.observe = function (a) {
            switch (this.kind) {case "N":
                    return a.next && a.next(this.value);case "E":
                    return a.error && a.error(this.error);case "C":
                    return a.complete && a.complete();}
        };c.prototype.do = function (a, b, c) {
            switch (this.kind) {
                case "N":
                    return a && a(this.value);case "E":
                    return b && b(this.error);case "C":
                    return c && c();
            }
        };c.prototype.accept = function (a, b, c) {
            return a && "function" === typeof a.next ? this.observe(a) : this.do(a, b, c);
        };c.prototype.toObservable = function () {
            switch (this.kind) {case "N":
                    return ha(this.value);case "E":
                    return xa(this.error);case "C":
                    return S();}throw Error("unexpected notification kind value");
        };c.createNext = function (a) {
            return "undefined" !== typeof a ? new c("N", a) : c.undefinedValueNotification;
        };c.createError = function (a) {
            return new c("E", void 0, a);
        };c.createComplete = function () {
            return c.completeNotification;
        };c.completeNotification = new c("C");c.undefinedValueNotification = new c("N", void 0);return c;
    }(),
        Uc = function () {
        function c(a, b) {
            void 0 === b && (b = 0);this.scheduler = a;this.delay = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new yb(a, this.scheduler, this.delay));
        };return c;
    }(),
        yb = function (c) {
        function a(b, a, e) {
            void 0 === e && (e = 0);b = c.call(this, b) || this;b.scheduler = a;b.delay = e;return b;
        }h(a, c);a.dispatch = function (b) {
            b.notification.observe(b.destination);
            this.unsubscribe();
        };a.prototype.scheduleMessage = function (b) {
            this.destination.add(this.scheduler.schedule(a.dispatch, this.delay, new Vc(b, this.destination)));
        };a.prototype._next = function (b) {
            this.scheduleMessage(w.createNext(b));
        };a.prototype._error = function (b) {
            this.scheduleMessage(w.createError(b));this.unsubscribe();
        };a.prototype._complete = function () {
            this.scheduleMessage(w.createComplete());this.unsubscribe();
        };return a;
    }(m),
        Vc = function () {
        return function (c, a) {
            this.notification = c;this.destination = a;
        };
    }(),
        X = function (c) {
        function a(b, a, e) {
            void 0 === b && (b = Number.POSITIVE_INFINITY);void 0 === a && (a = Number.POSITIVE_INFINITY);var d = c.call(this) || this;d.scheduler = e;d._events = [];d._infiniteTimeWindow = !1;d._bufferSize = 1 > b ? 1 : b;d._windowTime = 1 > a ? 1 : a;a === Number.POSITIVE_INFINITY ? (d._infiniteTimeWindow = !0, d.next = d.nextInfiniteTimeWindow) : d.next = d.nextTimeWindow;return d;
        }h(a, c);a.prototype.nextInfiniteTimeWindow = function (b) {
            var a = this._events;a.push(b);a.length > this._bufferSize && a.shift();c.prototype.next.call(this, b);
        };a.prototype.nextTimeWindow = function (b) {
            this._events.push(new Wc(this._getNow(), b));this._trimBufferThenGetEvents();c.prototype.next.call(this, b);
        };a.prototype._subscribe = function (b) {
            var a = this._infiniteTimeWindow,
                c = a ? this._events : this._trimBufferThenGetEvents(),
                f = this.scheduler,
                g = c.length,
                l;if (this.closed) throw new E();this.isStopped || this.hasError ? l = t.EMPTY : (this.observers.push(b), l = new tb(this, b));f && b.add(b = new yb(b, f));if (a) for (a = 0; a < g && !b.closed; a++) {
                b.next(c[a]);
            } else for (a = 0; a < g && !b.closed; a++) {
                b.next(c[a].value);
            }this.hasError ? b.error(this.thrownError) : this.isStopped && b.complete();return l;
        };a.prototype._getNow = function () {
            return (this.scheduler || xb).now();
        };a.prototype._trimBufferThenGetEvents = function () {
            for (var b = this._getNow(), a = this._bufferSize, c = this._windowTime, f = this._events, g = f.length, l = 0; l < g && !(b - f[l].time < c);) {
                l++;
            }g > a && (l = Math.max(l, g - a));0 < l && f.splice(0, l);return f;
        };return a;
    }(v),
        Wc = function () {
        return function (c, a) {
            this.time = c;this.value = a;
        };
    }(),
        U = function (c) {
        function a() {
            var b = null !== c && c.apply(this, arguments) || this;b.value = null;b.hasNext = !1;b.hasCompleted = !1;return b;
        }h(a, c);a.prototype._subscribe = function (b) {
            return this.hasError ? (b.error(this.thrownError), t.EMPTY) : this.hasCompleted && this.hasNext ? (b.next(this.value), b.complete(), t.EMPTY) : c.prototype._subscribe.call(this, b);
        };a.prototype.next = function (b) {
            this.hasCompleted || (this.value = b, this.hasNext = !0);
        };a.prototype.error = function (b) {
            this.hasCompleted || c.prototype.error.call(this, b);
        };a.prototype.complete = function () {
            this.hasCompleted = !0;this.hasNext && c.prototype.next.call(this, this.value);c.prototype.complete.call(this);
        };return a;
    }(v),
        Xc = 1,
        Ha = {},
        zb = { setImmediate: function setImmediate(c) {
            var a = Xc++;Ha[a] = c;Promise.resolve().then(function () {
                var b = Ha[a];b && b();
            });return a;
        }, clearImmediate: function clearImmediate(c) {
            delete Ha[c];
        } },
        Yc = function (c) {
        function a(b, a) {
            var d = c.call(this, b, a) || this;d.scheduler = b;d.work = a;return d;
        }h(a, c);a.prototype.requestAsyncId = function (b, a, e) {
            void 0 === e && (e = 0);if (null !== e && 0 < e) return c.prototype.requestAsyncId.call(this, b, a, e);b.actions.push(this);return b.scheduled || (b.scheduled = zb.setImmediate(b.flush.bind(b, null)));
        };a.prototype.recycleAsyncId = function (b, a, e) {
            void 0 === e && (e = 0);if (null !== e && 0 < e || null === e && 0 < this.delay) return c.prototype.recycleAsyncId.call(this, b, a, e);0 === b.actions.length && (zb.clearImmediate(a), b.scheduled = void 0);
        };return a;
    }(fa),
        qa = new (function (c) {
        function a() {
            return null !== c && c.apply(this, arguments) || this;
        }h(a, c);a.prototype.flush = function (b) {
            this.active = !0;this.scheduled = void 0;var a = this.actions,
                c,
                f = -1,
                g = a.length;b = b || a.shift();do {
                if (c = b.execute(b.state, b.delay)) break;
            } while (++f < g && (b = a.shift()));this.active = !1;if (c) {
                for (; ++f < g && (b = a.shift());) {
                    b.unsubscribe();
                }throw c;
            }
        };return a;
    }(P))(Yc),
        y = new P(fa),
        Zc = function (c) {
        function a(b, a) {
            var d = c.call(this, b, a) || this;d.scheduler = b;d.work = a;return d;
        }h(a, c);a.prototype.requestAsyncId = function (b, a, e) {
            void 0 === e && (e = 0);if (null !== e && 0 < e) return c.prototype.requestAsyncId.call(this, b, a, e);b.actions.push(this);return b.scheduled || (b.scheduled = requestAnimationFrame(function () {
                return b.flush(null);
            }));
        };a.prototype.recycleAsyncId = function (b, a, e) {
            void 0 === e && (e = 0);if (null !== e && 0 < e || null === e && 0 < this.delay) return c.prototype.recycleAsyncId.call(this, b, a, e);0 === b.actions.length && (cancelAnimationFrame(a), b.scheduled = void 0);
        };return a;
    }(fa),
        $c = new (function (c) {
        function a() {
            return null !== c && c.apply(this, arguments) || this;
        }h(a, c);a.prototype.flush = function (b) {
            this.active = !0;this.scheduled = void 0;var a = this.actions,
                c,
                f = -1,
                g = a.length;b = b || a.shift();do {
                if (c = b.execute(b.state, b.delay)) break;
            } while (++f < g && (b = a.shift()));this.active = !1;if (c) {
                for (; ++f < g && (b = a.shift());) {
                    b.unsubscribe();
                }throw c;
            }
        };return a;
    }(P))(Zc),
        Ab = function (c) {
        function a(b, a) {
            void 0 === b && (b = Ia);void 0 === a && (a = Number.POSITIVE_INFINITY);var d = c.call(this, b, function () {
                return d.frame;
            }) || this;d.maxFrames = a;d.frame = 0;d.index = -1;return d;
        }h(a, c);a.prototype.flush = function () {
            for (var b = this.actions, a = this.maxFrames, c, f; (f = b[0]) && f.delay <= a && !(b.shift(), this.frame = f.delay, c = f.execute(f.state, f.delay));) {}if (c) {
                for (; f = b.shift();) {
                    f.unsubscribe();
                }throw c;
            }
        };a.frameTimeFactor = 10;return a;
    }(P),
        Ia = function (c) {
        function a(b, a, e) {
            void 0 === e && (e = b.index += 1);var d = c.call(this, b, a) || this;d.scheduler = b;d.work = a;d.index = e;d.active = !0;d.index = b.index = e;return d;
        }h(a, c);a.prototype.schedule = function (b, d) {
            void 0 === d && (d = 0);if (!this.id) return c.prototype.schedule.call(this, b, d);this.active = !1;var e = new a(this.scheduler, this.work);this.add(e);return e.schedule(b, d);
        };a.prototype.requestAsyncId = function (b, c, e) {
            void 0 === e && (e = 0);this.delay = b.frame + e;b = b.actions;b.push(this);b.sort(a.sortActions);return !0;
        };
        a.prototype.recycleAsyncId = function (b, a, c) {};a.prototype._execute = function (b, a) {
            if (!0 === this.active) return c.prototype._execute.call(this, b, a);
        };a.sortActions = function (b, a) {
            return b.delay === a.delay ? b.index === a.index ? 0 : b.index > a.index ? 1 : -1 : b.delay > a.delay ? 1 : -1;
        };return a;
    }(fa);K.prototype = Object.create(Error.prototype);Ra.prototype = Object.create(Error.prototype);var ca = Ra;ya.prototype = Object.create(Error.prototype);var Qb = function () {
        function c(a, b) {
            this.project = a;this.thisArg = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ad(a, this.project, this.thisArg));
        };return c;
    }(),
        ad = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.project = a;b.count = 0;b.thisArg = e || b;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a;try {
                a = this.project.call(this.thisArg, b, this.count++);
            } catch (e) {
                this.destination.error(e);return;
            }this.destination.next(a);
        };return a;
    }(m),
        q = function (c) {
        function a() {
            return null !== c && c.apply(this, arguments) || this;
        }h(a, c);a.prototype.notifyNext = function (b, a, c, f, g) {
            this.destination.next(a);
        };
        a.prototype.notifyError = function (b, a) {
            this.destination.error(b);
        };a.prototype.notifyComplete = function (b) {
            this.destination.complete();
        };return a;
    }(m),
        H = function (c) {
        function a(b, a, e) {
            var d = c.call(this) || this;d.parent = b;d.outerValue = a;d.outerIndex = e;d.index = 0;return d;
        }h(a, c);a.prototype._next = function (b) {
            this.parent.notifyNext(this.outerValue, b, this.outerIndex, this.index++, this);
        };a.prototype._error = function (b) {
            this.parent.notifyError(b, this);this.unsubscribe();
        };a.prototype._complete = function () {
            this.parent.notifyComplete(this);
            this.unsubscribe();
        };return a;
    }(m),
        bd = function bd(c) {
        return function (a) {
            c.then(function (b) {
                a.closed || (a.next(b), a.complete());
            }, function (b) {
                return a.error(b);
            }).then(null, R);return a;
        };
    },
        F;F = "function" === typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";var cd = function cd(c) {
        return function (a) {
            var b = c[F]();do {
                var d = b.next();if (d.done) {
                    a.complete();break;
                }a.next(d.value);if (a.closed) break;
            } while (1);"function" === typeof b.return && a.add(function () {
                b.return && b.return();
            });return a;
        };
    },
        dd = function dd(c) {
        return function (a) {
            var b = c[V]();if ("function" !== typeof b.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");return b.subscribe(a);
        };
    },
        Xa = function Xa(c) {
        return c && "number" === typeof c.length && "function" !== typeof c;
    },
        ia = function ia(c) {
        if (c && "function" === typeof c[V]) return dd(c);if (Xa(c)) return Qa(c);if (Va(c)) return bd(c);if (c && "function" === typeof c[F]) return cd(c);c = sa(c) ? "an invalid object" : "'" + c + "'";throw new TypeError("You provided " + c + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
    },
        Bb = {},
        Ja = function () {
        function c(a) {
            this.resultSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ed(a, this.resultSelector));
        };return c;
    }(),
        ed = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.resultSelector = a;b.active = 0;b.values = [];b.observables = [];return b;
        }h(a, c);a.prototype._next = function (b) {
            this.values.push(Bb);this.observables.push(b);
        };a.prototype._complete = function () {
            var b = this.observables,
                a = b.length;if (0 === a) this.destination.complete();else {
                this.toRespond = this.active = a;for (var c = 0; c < a; c++) {
                    var f = b[c];this.add(p(this, f, f, c));
                }
            }
        };a.prototype.notifyComplete = function (b) {
            0 === --this.active && this.destination.complete();
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            b = this.values;f = b[c];f = this.toRespond ? f === Bb ? --this.toRespond : this.toRespond : 0;b[c] = a;0 === f && (this.resultSelector ? this._tryResultSelector(b) : this.destination.next(b.slice()));
        };a.prototype._tryResultSelector = function (b) {
            var a;try {
                a = this.resultSelector.apply(this, b);
            } catch (e) {
                this.destination.error(e);return;
            }this.destination.next(a);
        };
        return a;
    }(q),
        Yb = function () {
        function c(a, b) {
            void 0 === b && (b = Number.POSITIVE_INFINITY);this.project = a;this.concurrent = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new fd(a, this.project, this.concurrent));
        };return c;
    }(),
        fd = function (c) {
        function a(b, a, e) {
            void 0 === e && (e = Number.POSITIVE_INFINITY);b = c.call(this, b) || this;b.project = a;b.concurrent = e;b.hasCompleted = !1;b.buffer = [];b.active = 0;b.index = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.active < this.concurrent ? this._tryNext(b) : this.buffer.push(b);
        };
        a.prototype._tryNext = function (b) {
            var a,
                c = this.index++;try {
                a = this.project(b, c);
            } catch (f) {
                this.destination.error(f);return;
            }this.active++;this._innerSub(a, b, c);
        };a.prototype._innerSub = function (b, a, c) {
            var d = new H(this, void 0, void 0);this.destination.add(d);p(this, b, a, c, d);
        };a.prototype._complete = function () {
            this.hasCompleted = !0;0 === this.active && 0 === this.buffer.length && this.destination.complete();this.unsubscribe();
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this.destination.next(a);
        };a.prototype.notifyComplete = function (b) {
            var a = this.buffer;this.remove(b);this.active--;0 < a.length ? this._next(a.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
        };return a;
    }(q),
        Cb = new n(D),
        ec = function () {
        function c(a, b) {
            this.predicate = a;this.thisArg = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new gd(a, this.predicate, this.thisArg));
        };return c;
    }(),
        gd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.predicate = a;b.thisArg = e;b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a;try {
                a = this.predicate.call(this.thisArg, b, this.count++);
            } catch (e) {
                this.destination.error(e);return;
            }a && this.destination.next(b);
        };return a;
    }(m),
        fc = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new hd(a));
        };return c;
    }(),
        hd = function (c) {
        function a(b) {
            b = c.call(this, b) || this;b.hasFirst = !1;b.observables = [];b.subscriptions = [];return b;
        }h(a, c);a.prototype._next = function (b) {
            this.observables.push(b);
        };a.prototype._complete = function () {
            var b = this.observables,
                a = b.length;if (0 === a) this.destination.complete();else {
                for (var c = 0; c < a && !this.hasFirst; c++) {
                    var f = b[c],
                        f = p(this, f, f, c);this.subscriptions && this.subscriptions.push(f);this.add(f);
                }this.observables = null;
            }
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            if (!this.hasFirst) {
                this.hasFirst = !0;for (b = 0; b < this.subscriptions.length; b++) {
                    b !== c && (f = this.subscriptions[b], f.unsubscribe(), this.remove(f));
                }this.subscriptions = null;
            }this.destination.next(a);
        };return a;
    }(q),
        gb = function () {
        function c(a) {
            this.resultSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new id(a, this.resultSelector));
        };
        return c;
    }(),
        id = function (c) {
        function a(b, a, e) {
            void 0 === e && (e = Object.create(null));b = c.call(this, b) || this;b.iterators = [];b.active = 0;b.resultSelector = "function" === typeof a ? a : null;b.values = e;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this.iterators;x(b) ? a.push(new jd(b)) : "function" === typeof b[F] ? a.push(new kd(b[F]())) : a.push(new ld(this.destination, this, b));
        };a.prototype._complete = function () {
            var b = this.iterators,
                a = b.length;this.unsubscribe();if (0 === a) this.destination.complete();else {
                this.active = a;for (var c = 0; c < a; c++) {
                    var f = b[c];f.stillUnsubscribed ? this.destination.add(f.subscribe(f, c)) : this.active--;
                }
            }
        };a.prototype.notifyInactive = function () {
            this.active--;0 === this.active && this.destination.complete();
        };a.prototype.checkIterators = function () {
            for (var b = this.iterators, a = b.length, c = this.destination, f = 0; f < a; f++) {
                var g = b[f];if ("function" === typeof g.hasValue && !g.hasValue()) return;
            }for (var l = !1, h = [], f = 0; f < a; f++) {
                var g = b[f],
                    k = g.next();g.hasCompleted() && (l = !0);if (k.done) {
                    c.complete();return;
                }h.push(k.value);
            }this.resultSelector ? this._tryresultSelector(h) : c.next(h);l && c.complete();
        };a.prototype._tryresultSelector = function (b) {
            var a;try {
                a = this.resultSelector.apply(this, b);
            } catch (e) {
                this.destination.error(e);return;
            }this.destination.next(a);
        };return a;
    }(m),
        kd = function () {
        function c(a) {
            this.iterator = a;this.nextResult = a.next();
        }c.prototype.hasValue = function () {
            return !0;
        };c.prototype.next = function () {
            var a = this.nextResult;this.nextResult = this.iterator.next();return a;
        };c.prototype.hasCompleted = function () {
            var a = this.nextResult;return a && a.done;
        };
        return c;
    }(),
        jd = function () {
        function c(a) {
            this.array = a;this.length = this.index = 0;this.length = a.length;
        }c.prototype[F] = function () {
            return this;
        };c.prototype.next = function (a) {
            a = this.index++;var b = this.array;return a < this.length ? { value: b[a], done: !1 } : { value: null, done: !0 };
        };c.prototype.hasValue = function () {
            return this.array.length > this.index;
        };c.prototype.hasCompleted = function () {
            return this.array.length === this.index;
        };return c;
    }(),
        ld = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.parent = a;b.observable = e;
            b.stillUnsubscribed = !0;b.buffer = [];b.isComplete = !1;return b;
        }h(a, c);a.prototype[F] = function () {
            return this;
        };a.prototype.next = function () {
            var b = this.buffer;return 0 === b.length && this.isComplete ? { value: null, done: !0 } : { value: b.shift(), done: !1 };
        };a.prototype.hasValue = function () {
            return 0 < this.buffer.length;
        };a.prototype.hasCompleted = function () {
            return 0 === this.buffer.length && this.isComplete;
        };a.prototype.notifyComplete = function () {
            0 < this.buffer.length ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
        };
        a.prototype.notifyNext = function (b, a, c, f, g) {
            this.buffer.push(a);this.parent.checkIterators();
        };a.prototype.subscribe = function (b, a) {
            return p(this, this.observable, this, a);
        };return a;
    }(q),
        ic = function () {
        function c(a) {
            this.durationSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new md(a, this.durationSelector));
        };return c;
    }(),
        md = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.durationSelector = a;b.hasValue = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.value = b;this.hasValue = !0;if (!this.throttled) {
                var a = void 0;try {
                    var c = this.durationSelector,
                        a = c(b);
                } catch (f) {
                    return this.destination.error(f);
                }b = p(this, a);!b || b.closed ? this.clearThrottle() : this.add(this.throttled = b);
            }
        };a.prototype.clearThrottle = function () {
            var b = this.value,
                a = this.hasValue,
                c = this.throttled;c && (this.remove(c), this.throttled = null, c.unsubscribe());a && (this.value = null, this.hasValue = !1, this.destination.next(b));
        };a.prototype.notifyNext = function (b, a, c, f) {
            this.clearThrottle();
        };a.prototype.notifyComplete = function () {
            this.clearThrottle();
        };return a;
    }(q),
        od = function () {
        function c(a) {
            this.closingNotifier = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new nd(a, this.closingNotifier));
        };return c;
    }(),
        nd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.buffer = [];b.add(p(b, a));return b;
        }h(a, c);a.prototype._next = function (b) {
            this.buffer.push(b);
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            b = this.buffer;this.buffer = [];this.destination.next(b);
        };return a;
    }(q),
        rd = function () {
        function c(a, b) {
            this.bufferSize = a;this.subscriberClass = (this.startBufferEvery = b) && a !== b ? pd : qd;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new this.subscriberClass(a, this.bufferSize, this.startBufferEvery));
        };return c;
    }(),
        qd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.bufferSize = a;b.buffer = [];return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this.buffer;a.push(b);a.length == this.bufferSize && (this.destination.next(a), this.buffer = []);
        };a.prototype._complete = function () {
            var b = this.buffer;0 < b.length && this.destination.next(b);c.prototype._complete.call(this);
        };return a;
    }(m),
        pd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.bufferSize = a;b.startBufferEvery = e;b.buffers = [];b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this.bufferSize,
                c = this.startBufferEvery,
                f = this.buffers,
                g = this.count;this.count++;0 === g % c && f.push([]);for (c = f.length; c--;) {
                g = f[c], g.push(b), g.length === a && (f.splice(c, 1), this.destination.next(g));
            }
        };a.prototype._complete = function () {
            for (var b = this.buffers, a = this.destination; 0 < b.length;) {
                var e = b.shift();0 < e.length && a.next(e);
            }c.prototype._complete.call(this);
        };
        return a;
    }(m),
        td = function () {
        function c(a, b, c, e) {
            this.bufferTimeSpan = a;this.bufferCreationInterval = b;this.maxBufferSize = c;this.scheduler = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new sd(a, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
        };return c;
    }(),
        ud = function () {
        return function () {
            this.buffer = [];
        };
    }(),
        sd = function (c) {
        function a(b, a, e, f, g) {
            b = c.call(this, b) || this;b.bufferTimeSpan = a;b.bufferCreationInterval = e;b.maxBufferSize = f;b.scheduler = g;b.contexts = [];f = b.openContext();
            b.timespanOnly = null == e || 0 > e;if (b.timespanOnly) b.add(f.closeAction = g.schedule(ib, a, { subscriber: b, context: f, bufferTimeSpan: a }));else {
                var d = { bufferTimeSpan: a, bufferCreationInterval: e, subscriber: b, scheduler: g };b.add(f.closeAction = g.schedule(jb, a, { subscriber: b, context: f }));b.add(g.schedule(jc, e, d));
            }return b;
        }h(a, c);a.prototype._next = function (b) {
            for (var a = this.contexts, c = a.length, f, g = 0; g < c; g++) {
                var l = a[g],
                    h = l.buffer;h.push(b);h.length == this.maxBufferSize && (f = l);
            }if (f) this.onBufferFull(f);
        };a.prototype._error = function (b) {
            this.contexts.length = 0;c.prototype._error.call(this, b);
        };a.prototype._complete = function () {
            for (var b = this.contexts, a = this.destination; 0 < b.length;) {
                var e = b.shift();a.next(e.buffer);
            }c.prototype._complete.call(this);
        };a.prototype._unsubscribe = function () {
            this.contexts = null;
        };a.prototype.onBufferFull = function (b) {
            this.closeContext(b);b = b.closeAction;b.unsubscribe();this.remove(b);if (!this.closed && this.timespanOnly) {
                b = this.openContext();var a = this.bufferTimeSpan;this.add(b.closeAction = this.scheduler.schedule(ib, a, { subscriber: this, context: b, bufferTimeSpan: a }));
            }
        };a.prototype.openContext = function () {
            var b = new ud();this.contexts.push(b);return b;
        };a.prototype.closeContext = function (b) {
            this.destination.next(b.buffer);var a = this.contexts;0 <= (a ? a.indexOf(b) : -1) && a.splice(a.indexOf(b), 1);
        };return a;
    }(m),
        wd = function () {
        function c(a, b) {
            this.openings = a;this.closingSelector = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new vd(a, this.openings, this.closingSelector));
        };return c;
    }(),
        vd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.openings = a;b.closingSelector = e;b.contexts = [];b.add(p(b, a));return b;
        }h(a, c);a.prototype._next = function (b) {
            for (var a = this.contexts, c = a.length, f = 0; f < c; f++) {
                a[f].buffer.push(b);
            }
        };a.prototype._error = function (b) {
            for (var a = this.contexts; 0 < a.length;) {
                var e = a.shift();e.subscription.unsubscribe();e.buffer = null;e.subscription = null;
            }this.contexts = null;c.prototype._error.call(this, b);
        };a.prototype._complete = function () {
            for (var b = this.contexts; 0 < b.length;) {
                var a = b.shift();this.destination.next(a.buffer);
                a.subscription.unsubscribe();a.buffer = null;a.subscription = null;
            }this.contexts = null;c.prototype._complete.call(this);
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            b ? this.closeBuffer(b) : this.openBuffer(a);
        };a.prototype.notifyComplete = function (b) {
            this.closeBuffer(b.context);
        };a.prototype.openBuffer = function (b) {
            try {
                var a = this.closingSelector.call(this, b);a && this.trySubscribe(a);
            } catch (e) {
                this._error(e);
            }
        };a.prototype.closeBuffer = function (b) {
            var a = this.contexts;if (a && b) {
                var c = b.subscription;this.destination.next(b.buffer);
                a.splice(a.indexOf(b), 1);this.remove(c);c.unsubscribe();
            }
        };a.prototype.trySubscribe = function (b) {
            var a = this.contexts,
                c = new t(),
                f = { buffer: [], subscription: c };a.push(f);b = p(this, b, f);!b || b.closed ? this.closeBuffer(f) : (b.context = f, this.add(b), c.add(b));
        };return a;
    }(q),
        yd = function () {
        function c(a) {
            this.closingSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new xd(a, this.closingSelector));
        };return c;
    }(),
        xd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.closingSelector = a;b.subscribing = !1;b.openBuffer();
            return b;
        }h(a, c);a.prototype._next = function (b) {
            this.buffer.push(b);
        };a.prototype._complete = function () {
            var b = this.buffer;b && this.destination.next(b);c.prototype._complete.call(this);
        };a.prototype._unsubscribe = function () {
            this.buffer = null;this.subscribing = !1;
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this.openBuffer();
        };a.prototype.notifyComplete = function () {
            this.subscribing ? this.complete() : this.openBuffer();
        };a.prototype.openBuffer = function () {
            var b = this.closingSubscription;b && (this.remove(b), b.unsubscribe());
            (b = this.buffer) && this.destination.next(b);this.buffer = [];var a;try {
                var c = this.closingSelector;a = c();
            } catch (f) {
                return this.error(f);
            }this.closingSubscription = b = new t();this.add(b);this.subscribing = !0;b.add(p(this, a));this.subscribing = !1;
        };return a;
    }(q),
        Ad = function () {
        function c(a) {
            this.selector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new zd(a, this.selector, this.caught));
        };return c;
    }(),
        zd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.selector = a;b.caught = e;return b;
        }h(a, c);a.prototype.error = function (b) {
            if (!this.isStopped) {
                var a = void 0;try {
                    a = this.selector(b, this.caught);
                } catch (e) {
                    c.prototype.error.call(this, e);return;
                }this._unsubscribeAndRecycle();b = new H(this, void 0, void 0);this.add(b);p(this, a, void 0, void 0, b);
            }
        };return a;
    }(q),
        Cd = function () {
        function c(a, b) {
            this.predicate = a;this.source = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Bd(a, this.predicate, this.source));
        };return c;
    }(),
        Bd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.predicate = a;b.source = e;b.count = 0;b.index = 0;
            return b;
        }h(a, c);a.prototype._next = function (b) {
            this.predicate ? this._tryPredicate(b) : this.count++;
        };a.prototype._tryPredicate = function (b) {
            var a;try {
                a = this.predicate(b, this.index++, this.source);
            } catch (e) {
                this.destination.error(e);return;
            }a && this.count++;
        };a.prototype._complete = function () {
            this.destination.next(this.count);this.destination.complete();
        };return a;
    }(m),
        Ed = function () {
        function c(a) {
            this.durationSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Dd(a, this.durationSelector));
        };return c;
    }(),
        Dd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.durationSelector = a;b.hasValue = !1;b.durationSubscription = null;return b;
        }h(a, c);a.prototype._next = function (b) {
            try {
                var a = this.durationSelector.call(this, b);a && this._tryNext(b, a);
            } catch (e) {
                this.destination.error(e);
            }
        };a.prototype._complete = function () {
            this.emitValue();this.destination.complete();
        };a.prototype._tryNext = function (b, a) {
            var c = this.durationSubscription;this.value = b;this.hasValue = !0;c && (c.unsubscribe(), this.remove(c));(c = p(this, a)) && !c.closed && this.add(this.durationSubscription = c);
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this.emitValue();
        };a.prototype.notifyComplete = function () {
            this.emitValue();
        };a.prototype.emitValue = function () {
            if (this.hasValue) {
                var b = this.value,
                    a = this.durationSubscription;a && (this.durationSubscription = null, a.unsubscribe(), this.remove(a));this.value = null;this.hasValue = !1;c.prototype._next.call(this, b);
            }
        };return a;
    }(q),
        Gd = function () {
        function c(a, b) {
            this.dueTime = a;this.scheduler = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Fd(a, this.dueTime, this.scheduler));
        };return c;
    }(),
        Fd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.dueTime = a;b.scheduler = e;b.debouncedSubscription = null;b.lastValue = null;b.hasValue = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.clearDebounce();this.lastValue = b;this.hasValue = !0;this.add(this.debouncedSubscription = this.scheduler.schedule(kc, this.dueTime, this));
        };a.prototype._complete = function () {
            this.debouncedNext();this.destination.complete();
        };a.prototype.debouncedNext = function () {
            this.clearDebounce();
            if (this.hasValue) {
                var b = this.lastValue;this.lastValue = null;this.hasValue = !1;this.destination.next(b);
            }
        };a.prototype.clearDebounce = function () {
            var b = this.debouncedSubscription;null !== b && (this.remove(b), b.unsubscribe(), this.debouncedSubscription = null);
        };return a;
    }(m),
        lc = function () {
        function c(a) {
            this.defaultValue = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Hd(a, this.defaultValue));
        };return c;
    }(),
        Hd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.defaultValue = a;b.isEmpty = !0;return b;
        }h(a, c);
        a.prototype._next = function (b) {
            this.isEmpty = !1;this.destination.next(b);
        };a.prototype._complete = function () {
            this.isEmpty && this.destination.next(this.defaultValue);this.destination.complete();
        };return a;
    }(m),
        Jd = function () {
        function c(a, b) {
            this.delay = a;this.scheduler = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Id(a, this.delay, this.scheduler));
        };return c;
    }(),
        Id = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.delay = a;b.scheduler = e;b.queue = [];b.active = !1;b.errored = !1;return b;
        }h(a, c);a.dispatch = function (b) {
            for (var a = b.source, c = a.queue, f = b.scheduler, g = b.destination; 0 < c.length && 0 >= c[0].time - f.now();) {
                c.shift().notification.observe(g);
            }0 < c.length ? (a = Math.max(0, c[0].time - f.now()), this.schedule(b, a)) : (this.unsubscribe(), a.active = !1);
        };a.prototype._schedule = function (b) {
            this.active = !0;this.destination.add(b.schedule(a.dispatch, this.delay, { source: this, destination: this.destination, scheduler: b }));
        };a.prototype.scheduleNotification = function (b) {
            if (!0 !== this.errored) {
                var a = this.scheduler;b = new Kd(a.now() + this.delay, b);this.queue.push(b);!1 === this.active && this._schedule(a);
            }
        };a.prototype._next = function (b) {
            this.scheduleNotification(w.createNext(b));
        };a.prototype._error = function (b) {
            this.errored = !0;this.queue = [];this.destination.error(b);this.unsubscribe();
        };a.prototype._complete = function () {
            this.scheduleNotification(w.createComplete());this.unsubscribe();
        };return a;
    }(m),
        Kd = function () {
        return function (c, a) {
            this.time = c;this.notification = a;
        };
    }(),
        Db = function () {
        function c(a) {
            this.delayDurationSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ld(a, this.delayDurationSelector));
        };return c;
    }(),
        Ld = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.delayDurationSelector = a;b.completed = !1;b.delayNotifierSubscriptions = [];b.index = 0;return b;
        }h(a, c);a.prototype.notifyNext = function (b, a, c, f, g) {
            this.destination.next(b);this.removeSubscription(g);this.tryComplete();
        };a.prototype.notifyError = function (b, a) {
            this._error(b);
        };a.prototype.notifyComplete = function (b) {
            (b = this.removeSubscription(b)) && this.destination.next(b);
            this.tryComplete();
        };a.prototype._next = function (b) {
            var a = this.index++;try {
                var c = this.delayDurationSelector(b, a);c && this.tryDelay(c, b);
            } catch (f) {
                this.destination.error(f);
            }
        };a.prototype._complete = function () {
            this.completed = !0;this.tryComplete();this.unsubscribe();
        };a.prototype.removeSubscription = function (b) {
            b.unsubscribe();var a = this.delayNotifierSubscriptions.indexOf(b);-1 !== a && this.delayNotifierSubscriptions.splice(a, 1);return b.outerValue;
        };a.prototype.tryDelay = function (b, a) {
            (b = p(this, b, a)) && !b.closed && (this.destination.add(b), this.delayNotifierSubscriptions.push(b));
        };a.prototype.tryComplete = function () {
            this.completed && 0 === this.delayNotifierSubscriptions.length && this.destination.complete();
        };return a;
    }(q),
        Nd = function (c) {
        function a(b, a) {
            var d = c.call(this) || this;d.source = b;d.subscriptionDelay = a;return d;
        }h(a, c);a.prototype._subscribe = function (b) {
            this.subscriptionDelay.subscribe(new Md(b, this.source));
        };return a;
    }(n),
        Md = function (c) {
        function a(b, a) {
            var d = c.call(this) || this;d.parent = b;d.source = a;d.sourceSubscribed = !1;return d;
        }h(a, c);a.prototype._next = function (b) {
            this.subscribeToSource();
        };a.prototype._error = function (b) {
            this.unsubscribe();this.parent.error(b);
        };a.prototype._complete = function () {
            this.unsubscribe();this.subscribeToSource();
        };a.prototype.subscribeToSource = function () {
            this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
        };return a;
    }(m),
        Pd = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new Od(a));
        };return c;
    }(),
        Od = function (c) {
        function a(b) {
            return c.call(this, b) || this;
        }h(a, c);a.prototype._next = function (b) {
            b.observe(this.destination);
        };return a;
    }(m),
        Rd = function () {
        function c(a, b) {
            this.keySelector = a;this.flushes = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Qd(a, this.keySelector, this.flushes));
        };return c;
    }(),
        Qd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.keySelector = a;b.values = new Set();e && b.add(p(b, e));return b;
        }h(a, c);a.prototype.notifyNext = function (b, a, c, f, g) {
            this.values.clear();
        };a.prototype.notifyError = function (b, a) {
            this._error(b);
        };a.prototype._next = function (b) {
            this.keySelector ? this._useKeySelector(b) : this._finalizeNext(b, b);
        };a.prototype._useKeySelector = function (b) {
            var a,
                c = this.destination;try {
                a = this.keySelector(b);
            } catch (f) {
                c.error(f);return;
            }this._finalizeNext(a, b);
        };a.prototype._finalizeNext = function (b, a) {
            var c = this.values;c.has(b) || (c.add(b), this.destination.next(a));
        };return a;
    }(q),
        mc = function () {
        function c(a, b) {
            this.compare = a;this.keySelector = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Sd(a, this.compare, this.keySelector));
        };return c;
    }(),
        Sd = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.keySelector = e;b.hasKey = !1;"function" === typeof a && (b.compare = a);return b;
        }h(a, c);a.prototype.compare = function (b, a) {
            return b === a;
        };a.prototype._next = function (b) {
            var a;try {
                var c = this.keySelector;a = c ? c(b) : b;
            } catch (g) {
                return this.destination.error(g);
            }c = !1;if (this.hasKey) try {
                var f = this.compare,
                    c = f(this.key, a);
            } catch (g) {
                return this.destination.error(g);
            } else this.hasKey = !0;c || (this.key = a, this.destination.next(b));
        };return a;
    }(m),
        oc = function () {
        function c(a) {
            this.errorFactory = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Td(a, this.errorFactory));
        };return c;
    }(),
        Td = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.errorFactory = a;b.hasValue = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.hasValue = !0;this.destination.next(b);
        };a.prototype._complete = function () {
            if (this.hasValue) return this.destination.complete();var b = void 0;try {
                b = this.errorFactory();
            } catch (d) {
                b = d;
            }this.destination.error(b);
        };return a;
    }(m),
        pc = function () {
        function c(a) {
            this.total = a;if (0 > this.total) throw new K();
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ud(a, this.total));
        };return c;
    }(),
        Ud = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.total = a;b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this.total,
                c = ++this.count;c <= a && (this.destination.next(b), c === a && (this.destination.complete(), this.unsubscribe()));
        };return a;
    }(m),
        Wd = function () {
        function c(a, b, c) {
            this.predicate = a;this.thisArg = b;this.source = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Vd(a, this.predicate, this.thisArg, this.source));
        };return c;
    }(),
        Vd = function (c) {
        function a(b, a, e, f) {
            b = c.call(this, b) || this;b.predicate = a;b.thisArg = e;b.source = f;b.index = 0;b.thisArg = e || b;return b;
        }h(a, c);a.prototype.notifyComplete = function (b) {
            this.destination.next(b);this.destination.complete();
        };a.prototype._next = function (b) {
            var a = !1;try {
                a = this.predicate.call(this.thisArg, b, this.index++, this.source);
            } catch (e) {
                this.destination.error(e);return;
            }a || this.notifyComplete(!1);
        };a.prototype._complete = function () {
            this.notifyComplete(!0);
        };return a;
    }(m),
        Yd = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new Xd(a));
        };return c;
    }(),
        Xd = function (c) {
        function a(b) {
            b = c.call(this, b) || this;b.hasCompleted = !1;b.hasSubscription = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.hasSubscription || (this.hasSubscription = !0, this.add(p(this, b)));
        };a.prototype._complete = function () {
            this.hasCompleted = !0;this.hasSubscription || this.destination.complete();
        };a.prototype.notifyComplete = function (b) {
            this.remove(b);this.hasSubscription = !1;this.hasCompleted && this.destination.complete();
        };return a;
    }(q),
        qc = function () {
        function c(a) {
            this.project = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Zd(a, this.project));
        };return c;
    }(),
        Zd = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.project = a;b.hasSubscription = !1;b.hasCompleted = !1;b.index = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.hasSubscription || this.tryNext(b);
        };a.prototype.tryNext = function (b) {
            var a,
                c = this.index++;try {
                a = this.project(b, c);
            } catch (f) {
                this.destination.error(f);return;
            }this.hasSubscription = !0;this._innerSub(a, b, c);
        };a.prototype._innerSub = function (b, a, c) {
            var d = new H(this, void 0, void 0);this.destination.add(d);p(this, b, a, c, d);
        };a.prototype._complete = function () {
            this.hasCompleted = !0;this.hasSubscription || this.destination.complete();this.unsubscribe();
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this.destination.next(a);
        };a.prototype.notifyError = function (b) {
            this.destination.error(b);
        };a.prototype.notifyComplete = function (b) {
            this.destination.remove(b);this.hasSubscription = !1;this.hasCompleted && this.destination.complete();
        };return a;
    }(q),
        ae = function () {
        function c(a, b, c) {
            this.project = a;this.concurrent = b;this.scheduler = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new $d(a, this.project, this.concurrent, this.scheduler));
        };return c;
    }(),
        $d = function (c) {
        function a(b, a, e, f) {
            b = c.call(this, b) || this;b.project = a;b.concurrent = e;b.scheduler = f;b.index = 0;b.active = 0;b.hasCompleted = !1;e < Number.POSITIVE_INFINITY && (b.buffer = []);return b;
        }h(a, c);a.dispatch = function (b) {
            b.subscriber.subscribeToProjection(b.result, b.value, b.index);
        };a.prototype._next = function (b) {
            var c = this.destination;if (c.closed) this._complete();else {
                var e = this.index++;if (this.active < this.concurrent) {
                    c.next(b);try {
                        var f = this.project,
                            g = f(b, e);this.scheduler ? this.destination.add(this.scheduler.schedule(a.dispatch, 0, { subscriber: this, result: g, value: b, index: e })) : this.subscribeToProjection(g, b, e);
                    } catch (l) {
                        c.error(l);
                    }
                } else this.buffer.push(b);
            }
        };a.prototype.subscribeToProjection = function (b, a, c) {
            this.active++;this.destination.add(p(this, b, a, c));
        };a.prototype._complete = function () {
            (this.hasCompleted = !0, 0 === this.active) && this.destination.complete();this.unsubscribe();
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this._next(a);
        };a.prototype.notifyComplete = function (b) {
            var a = this.buffer;this.destination.remove(b);this.active--;a && 0 < a.length && this._next(a.shift());this.hasCompleted && 0 === this.active && this.destination.complete();
        };return a;
    }(q),
        ce = function () {
        function c(a) {
            this.callback = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new be(a, this.callback));
        };return c;
    }(),
        be = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.add(new t(a));return b;
        }h(a, c);return a;
    }(m),
        Eb = function () {
        function c(a, b, c, e) {
            this.predicate = a;this.source = b;this.yieldIndex = c;this.thisArg = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new de(a, this.predicate, this.source, this.yieldIndex, this.thisArg));
        };return c;
    }(),
        de = function (c) {
        function a(b, a, e, f, g) {
            b = c.call(this, b) || this;b.predicate = a;b.source = e;b.yieldIndex = f;b.thisArg = g;b.index = 0;return b;
        }h(a, c);a.prototype.notifyComplete = function (b) {
            var a = this.destination;a.next(b);a.complete();this.unsubscribe();
        };a.prototype._next = function (b) {
            var a = this.predicate,
                c = this.thisArg,
                f = this.index++;try {
                a.call(c || this, b, f, this.source) && this.notifyComplete(this.yieldIndex ? f : b);
            } catch (g) {
                this.destination.error(g);
            }
        };a.prototype._complete = function () {
            this.notifyComplete(this.yieldIndex ? -1 : void 0);
        };return a;
    }(m),
        fe = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new ee(a));
        };return c;
    }(),
        ee = function (c) {
        function a() {
            return null !== c && c.apply(this, arguments) || this;
        }h(a, c);a.prototype._next = function (b) {};return a;
    }(m),
        he = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new ge(a));
        };return c;
    }(),
        ge = function (c) {
        function a(b) {
            return c.call(this, b) || this;
        }h(a, c);a.prototype.notifyComplete = function (b) {
            var a = this.destination;a.next(b);a.complete();
        };a.prototype._next = function (b) {
            this.notifyComplete(!1);
        };a.prototype._complete = function () {
            this.notifyComplete(!0);
        };return a;
    }(m),
        rc = function () {
        function c(a) {
            this.total = a;if (0 > this.total) throw new K();
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ie(a, this.total));
        };return c;
    }(),
        ie = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.total = a;b.ring = [];b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this.ring,
                c = this.total,
                f = this.count++;a.length < c ? a.push(b) : a[f % c] = b;
        };a.prototype._complete = function () {
            var b = this.destination,
                a = this.count;if (0 < a) for (var c = this.count >= this.total ? this.total : this.count, f = this.ring, g = 0; g < c; g++) {
                var l = a++ % c;b.next(f[l]);
            }b.complete();
        };return a;
    }(m),
        ke = function () {
        function c(a) {
            this.value = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new je(a, this.value));
        };return c;
    }(),
        je = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.value = a;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.destination.next(this.value);
        };return a;
    }(m),
        me = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new le(a));
        };return c;
    }(),
        le = function (c) {
        function a(b) {
            return c.call(this, b) || this;
        }h(a, c);a.prototype._next = function (b) {
            this.destination.next(w.createNext(b));
        };
        a.prototype._error = function (b) {
            var a = this.destination;a.next(w.createError(b));a.complete();
        };a.prototype._complete = function () {
            var b = this.destination;b.next(w.createComplete());b.complete();
        };return a;
    }(m),
        sc = function () {
        function c(a, b, c) {
            void 0 === c && (c = !1);this.accumulator = a;this.seed = b;this.hasSeed = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ne(a, this.accumulator, this.seed, this.hasSeed));
        };return c;
    }(),
        ne = function (c) {
        function a(b, a, e, f) {
            b = c.call(this, b) || this;b.accumulator = a;b._seed = e;b.hasSeed = f;b.index = 0;return b;
        }h(a, c);Object.defineProperty(a.prototype, "seed", { get: function get() {
                return this._seed;
            }, set: function set(b) {
                this.hasSeed = !0;this._seed = b;
            }, enumerable: !0, configurable: !0 });a.prototype._next = function (b) {
            if (this.hasSeed) return this._tryNext(b);this.seed = b;this.destination.next(b);
        };a.prototype._tryNext = function (b) {
            var a = this.index++,
                c;try {
                c = this.accumulator(this.seed, b, a);
            } catch (f) {
                this.destination.error(f);
            }this.seed = c;this.destination.next(c);
        };return a;
    }(m),
        pe = function () {
        function c(a, b, c) {
            this.accumulator = a;this.seed = b;this.concurrent = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new oe(a, this.accumulator, this.seed, this.concurrent));
        };return c;
    }(),
        oe = function (c) {
        function a(b, a, e, f) {
            b = c.call(this, b) || this;b.accumulator = a;b.acc = e;b.concurrent = f;b.hasValue = !1;b.hasCompleted = !1;b.buffer = [];b.active = 0;b.index = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            if (this.active < this.concurrent) {
                var a = this.index++,
                    c = this.destination,
                    f = void 0;try {
                    var g = this.accumulator,
                        f = g(this.acc, b, a);
                } catch (l) {
                    return c.error(l);
                }this.active++;
                this._innerSub(f, b, a);
            } else this.buffer.push(b);
        };a.prototype._innerSub = function (b, a, c) {
            var d = new H(this, void 0, void 0);this.destination.add(d);p(this, b, a, c, d);
        };a.prototype._complete = function () {
            this.hasCompleted = !0;0 === this.active && 0 === this.buffer.length && (!1 === this.hasValue && this.destination.next(this.acc), this.destination.complete());this.unsubscribe();
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            b = this.destination;this.acc = a;this.hasValue = !0;b.next(a);
        };a.prototype.notifyComplete = function (b) {
            var a = this.buffer;this.destination.remove(b);this.active--;0 < a.length ? this._next(a.shift()) : 0 === this.active && this.hasCompleted && (!1 === this.hasValue && this.destination.next(this.acc), this.destination.complete());
        };return a;
    }(q),
        tc = function () {
        function c(a, b) {
            this.subjectFactory = a;this.selector = b;
        }c.prototype.call = function (a, b) {
            var c = this.selector,
                e = this.subjectFactory();a = c(e).subscribe(a);a.add(b.subscribe(e));return a;
        };return c;
    }(),
        re = function () {
        function c(a) {
            this.nextSources = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new qe(a, this.nextSources));
        };return c;
    }(),
        qe = function (c) {
        function a(b, a) {
            var d = c.call(this, b) || this;d.destination = b;d.nextSources = a;return d;
        }h(a, c);a.prototype.notifyError = function (b, a) {
            this.subscribeToNextSource();
        };a.prototype.notifyComplete = function (b) {
            this.subscribeToNextSource();
        };a.prototype._error = function (b) {
            this.subscribeToNextSource();this.unsubscribe();
        };a.prototype._complete = function () {
            this.subscribeToNextSource();this.unsubscribe();
        };a.prototype.subscribeToNextSource = function () {
            var b = this.nextSources.shift();
            if (b) {
                var a = new H(this, void 0, void 0);this.destination.add(a);p(this, b, void 0, void 0, a);
            } else this.destination.complete();
        };return a;
    }(q),
        te = function () {
        function c() {}c.prototype.call = function (a, b) {
            return b.subscribe(new se(a));
        };return c;
    }(),
        se = function (c) {
        function a(b) {
            b = c.call(this, b) || this;b.hasPrev = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            var a;this.hasPrev ? a = [this.prev, b] : this.hasPrev = !0;this.prev = b;a && this.destination.next(a);
        };return a;
    }(m),
        Fb = function () {
        function c(a, b) {
            this.count = a;this.source = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ue(a, this.count, this.source));
        };return c;
    }(),
        ue = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.count = a;b.source = e;return b;
        }h(a, c);a.prototype.complete = function () {
            if (!this.isStopped) {
                var b = this.source,
                    a = this.count;if (0 === a) return c.prototype.complete.call(this);-1 < a && (this.count = a - 1);b.subscribe(this._unsubscribeAndRecycle());
            }
        };return a;
    }(m),
        we = function () {
        function c(a) {
            this.notifier = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ve(a, this.notifier, b));
        };return c;
    }(),
        ve = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.notifier = a;b.source = e;b.sourceIsBeingSubscribedTo = !0;return b;
        }h(a, c);a.prototype.notifyNext = function (b, a, c, f, g) {
            this.sourceIsBeingSubscribedTo = !0;this.source.subscribe(this);
        };a.prototype.notifyComplete = function (b) {
            if (!1 === this.sourceIsBeingSubscribedTo) return c.prototype.complete.call(this);
        };a.prototype.complete = function () {
            this.sourceIsBeingSubscribedTo = !1;if (!this.isStopped) {
                this.retries || this.subscribeToRetries();
                if (!this.retriesSubscription || this.retriesSubscription.closed) return c.prototype.complete.call(this);this._unsubscribeAndRecycle();this.notifications.next();
            }
        };a.prototype._unsubscribe = function () {
            var b = this.notifications,
                a = this.retriesSubscription;b && (b.unsubscribe(), this.notifications = null);a && (a.unsubscribe(), this.retriesSubscription = null);this.retries = null;
        };a.prototype._unsubscribeAndRecycle = function () {
            var b = this._unsubscribe;this._unsubscribe = null;c.prototype._unsubscribeAndRecycle.call(this);
            this._unsubscribe = b;return this;
        };a.prototype.subscribeToRetries = function () {
            this.notifications = new v();var b;try {
                var a = this.notifier;b = a(this.notifications);
            } catch (e) {
                return c.prototype.complete.call(this);
            }this.retries = b;this.retriesSubscription = p(this, b);
        };return a;
    }(q),
        ye = function () {
        function c(a, b) {
            this.count = a;this.source = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new xe(a, this.count, this.source));
        };return c;
    }(),
        xe = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.count = a;b.source = e;return b;
        }
        h(a, c);a.prototype.error = function (b) {
            if (!this.isStopped) {
                var a = this.source,
                    e = this.count;if (0 === e) return c.prototype.error.call(this, b);-1 < e && (this.count = e - 1);a.subscribe(this._unsubscribeAndRecycle());
            }
        };return a;
    }(m),
        Ae = function () {
        function c(a, b) {
            this.notifier = a;this.source = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ze(a, this.notifier, this.source));
        };return c;
    }(),
        ze = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.notifier = a;b.source = e;return b;
        }h(a, c);a.prototype.error = function (b) {
            if (!this.isStopped) {
                var a = this.errors,
                    e = this.retries,
                    f = this.retriesSubscription;if (e) this.retriesSubscription = this.errors = null;else {
                    a = new v();try {
                        var g = this.notifier,
                            e = g(a);
                    } catch (l) {
                        return c.prototype.error.call(this, l);
                    }f = p(this, e);
                }this._unsubscribeAndRecycle();this.errors = a;this.retries = e;this.retriesSubscription = f;a.next(b);
            }
        };a.prototype._unsubscribe = function () {
            var b = this.errors,
                a = this.retriesSubscription;b && (b.unsubscribe(), this.errors = null);a && (a.unsubscribe(), this.retriesSubscription = null);this.retries = null;
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            b = this._unsubscribe;this._unsubscribe = null;this._unsubscribeAndRecycle();this._unsubscribe = b;this.source.subscribe(this);
        };return a;
    }(q),
        Ce = function () {
        function c(a) {
            this.notifier = a;
        }c.prototype.call = function (a, b) {
            a = new Be(a);b = b.subscribe(a);b.add(p(a, this.notifier));return b;
        };return c;
    }(),
        Be = function (c) {
        function a() {
            var b = null !== c && c.apply(this, arguments) || this;b.hasValue = !1;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.value = b;this.hasValue = !0;
        };a.prototype.notifyNext = function (b, a, c, f, g) {
            this.emitValue();
        };a.prototype.notifyComplete = function () {
            this.emitValue();
        };a.prototype.emitValue = function () {
            this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
        };return a;
    }(q),
        Ee = function () {
        function c(a, b) {
            this.period = a;this.scheduler = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new De(a, this.period, this.scheduler));
        };return c;
    }(),
        De = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.period = a;b.scheduler = e;b.hasValue = !1;b.add(e.schedule(wc, a, { subscriber: b, period: a }));
            return b;
        }h(a, c);a.prototype._next = function (b) {
            this.lastValue = b;this.hasValue = !0;
        };a.prototype.notifyNext = function () {
            this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
        };return a;
    }(m),
        Ge = function () {
        function c(a, b) {
            this.compareTo = a;this.comparator = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Fe(a, this.compareTo, this.comparator));
        };return c;
    }(),
        Fe = function (c) {
        function a(b, a, e) {
            var d = c.call(this, b) || this;d.compareTo = a;d.comparator = e;d._a = [];d._b = [];d._oneComplete = !1;d.destination.add(a.subscribe(new He(b, d)));return d;
        }h(a, c);a.prototype._next = function (b) {
            this._oneComplete && 0 === this._b.length ? this.emit(!1) : (this._a.push(b), this.checkValues());
        };a.prototype._complete = function () {
            this._oneComplete ? this.emit(0 === this._a.length && 0 === this._b.length) : this._oneComplete = !0;this.unsubscribe();
        };a.prototype.checkValues = function () {
            for (var b = this._a, a = this._b, c = this.comparator; 0 < b.length && 0 < a.length;) {
                var f = b.shift(),
                    g = a.shift(),
                    l = !1;try {
                    l = c ? c(f, g) : f === g;
                } catch (u) {
                    this.destination.error(u);
                }l || this.emit(!1);
            }
        };a.prototype.emit = function (b) {
            var a = this.destination;a.next(b);a.complete();
        };a.prototype.nextB = function (b) {
            this._oneComplete && 0 === this._a.length ? this.emit(!1) : (this._b.push(b), this.checkValues());
        };a.prototype.completeB = function () {
            this._oneComplete ? this.emit(0 === this._a.length && 0 === this._b.length) : this._oneComplete = !0;
        };return a;
    }(m),
        He = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.parent = a;return b;
        }h(a, c);a.prototype._next = function (b) {
            this.parent.nextB(b);
        };a.prototype._error = function (b) {
            this.parent.error(b);this.unsubscribe();
        };
        a.prototype._complete = function () {
            this.parent.completeB();this.unsubscribe();
        };return a;
    }(m),
        Je = function () {
        function c(a, b) {
            this.predicate = a;this.source = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ie(a, this.predicate, this.source));
        };return c;
    }(),
        Ie = function (c) {
        function a(b, a, e) {
            b = c.call(this, b) || this;b.predicate = a;b.source = e;b.seenValue = !1;b.index = 0;return b;
        }h(a, c);a.prototype.applySingleValue = function (b) {
            this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = b);
        };a.prototype._next = function (b) {
            var a = this.index++;this.predicate ? this.tryNext(b, a) : this.applySingleValue(b);
        };a.prototype.tryNext = function (b, a) {
            try {
                this.predicate(b, a, this.source) && this.applySingleValue(b);
            } catch (e) {
                this.destination.error(e);
            }
        };a.prototype._complete = function () {
            var b = this.destination;0 < this.index ? (b.next(this.seenValue ? this.singleValue : void 0), b.complete()) : b.error(new ca());
        };return a;
    }(m),
        Le = function () {
        function c(a) {
            this.total = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ke(a, this.total));
        };return c;
    }(),
        Ke = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.total = a;b.count = 0;return b;
        }h(a, c);a.prototype._next = function (b) {
            ++this.count > this.total && this.destination.next(b);
        };return a;
    }(m),
        Ne = function () {
        function c(a) {
            this._skipCount = a;if (0 > this._skipCount) throw new K();
        }c.prototype.call = function (a, b) {
            return 0 === this._skipCount ? b.subscribe(new m(a)) : b.subscribe(new Me(a, this._skipCount));
        };return c;
    }(),
        Me = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b._skipCount = a;b._count = 0;
            b._ring = Array(a);return b;
        }h(a, c);a.prototype._next = function (b) {
            var a = this._skipCount,
                c = this._count++;if (c < a) this._ring[c] = b;else {
                var a = c % a,
                    c = this._ring,
                    f = c[a];c[a] = b;this.destination.next(f);
            }
        };return a;
    }(m),
        Pe = function () {
        function c(a) {
            this.notifier = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Oe(a, this.notifier));
        };return c;
    }(),
        Oe = function (c) {
        function a(b, a) {
            b = c.call(this, b) || this;b.hasValue = !1;var d = new H(b, void 0, void 0);b.add(d);b.innerSubscription = d;p(b, a, void 0, void 0, d);return b;
        }h(a, c);a.prototype._next = function (a) {
            this.hasValue && c.prototype._next.call(this, a);
        };a.prototype.notifyNext = function (a, c, e, f, g) {
            this.hasValue = !0;this.innerSubscription && this.innerSubscription.unsubscribe();
        };a.prototype.notifyComplete = function () {};return a;
    }(q),
        Re = function () {
        function c(a) {
            this.predicate = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Qe(a, this.predicate));
        };return c;
    }(),
        Qe = function (c) {
        function a(a, d) {
            a = c.call(this, a) || this;a.predicate = d;a.skipping = !0;a.index = 0;return a;
        }h(a, c);a.prototype._next = function (a) {
            var b = this.destination;this.skipping && this.tryCallPredicate(a);this.skipping || b.next(a);
        };a.prototype.tryCallPredicate = function (a) {
            try {
                this.skipping = !!this.predicate(a, this.index++);
            } catch (d) {
                this.destination.error(d);
            }
        };return a;
    }(m),
        Se = function (c) {
        function a(a, d, e) {
            void 0 === d && (d = 0);void 0 === e && (e = qa);var b = c.call(this) || this;b.source = a;b.delayTime = d;b.scheduler = e;if (!W(d) || 0 > d) b.delayTime = 0;e && "function" === typeof e.schedule || (b.scheduler = qa);return b;
        }h(a, c);a.create = function (b, c, e) {
            void 0 === c && (c = 0);void 0 === e && (e = qa);return new a(b, c, e);
        };a.dispatch = function (a) {
            return this.add(a.source.subscribe(a.subscriber));
        };a.prototype._subscribe = function (b) {
            return this.scheduler.schedule(a.dispatch, this.delayTime, { source: this.source, subscriber: b });
        };return a;
    }(n),
        Te = function () {
        function c(a, b) {
            this.scheduler = a;this.delay = b;
        }c.prototype.call = function (a, b) {
            return new Se(b, this.delay, this.scheduler).subscribe(a);
        };return c;
    }(),
        zc = function () {
        function c(a) {
            this.project = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ue(a, this.project));
        };return c;
    }(),
        Ue = function (c) {
        function a(a, d) {
            a = c.call(this, a) || this;a.project = d;a.index = 0;return a;
        }h(a, c);a.prototype._next = function (a) {
            var b,
                c = this.index++;try {
                b = this.project(a, c);
            } catch (f) {
                this.destination.error(f);return;
            }this._innerSub(b, a, c);
        };a.prototype._innerSub = function (a, c, e) {
            var b = this.innerSubscription;b && b.unsubscribe();b = new H(this, void 0, void 0);this.destination.add(b);this.innerSubscription = p(this, a, c, e, b);
        };a.prototype._complete = function () {
            var a = this.innerSubscription;a && !a.closed || c.prototype._complete.call(this);this.unsubscribe();
        };a.prototype._unsubscribe = function () {
            this.innerSubscription = null;
        };a.prototype.notifyComplete = function (a) {
            this.destination.remove(a);this.innerSubscription = null;this.isStopped && c.prototype._complete.call(this);
        };a.prototype.notifyNext = function (a, c, e, f, g) {
            this.destination.next(c);
        };return a;
    }(q),
        We = function () {
        function c(a) {
            this.notifier = a;
        }c.prototype.call = function (a, b) {
            a = new Ve(a);var c = p(a, this.notifier);return c && !a.seenValue ? (a.add(c), b.subscribe(a)) : a;
        };return c;
    }(),
        Ve = function (c) {
        function a(a) {
            a = c.call(this, a) || this;a.seenValue = !1;return a;
        }h(a, c);a.prototype.notifyNext = function (a, c, e, f, g) {
            this.seenValue = !0;this.complete();
        };a.prototype.notifyComplete = function () {};return a;
    }(q),
        Ye = function () {
        function c(a, b) {
            this.predicate = a;this.inclusive = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Xe(a, this.predicate, this.inclusive));
        };return c;
    }(),
        Xe = function (c) {
        function a(a, d, e) {
            a = c.call(this, a) || this;a.predicate = d;a.inclusive = e;a.index = 0;return a;
        }h(a, c);a.prototype._next = function (a) {
            var b = this.destination,
                c;try {
                c = this.predicate(a, this.index++);
            } catch (f) {
                b.error(f);return;
            }this.nextOrComplete(a, c);
        };a.prototype.nextOrComplete = function (a, c) {
            var b = this.destination;c ? b.next(a) : (this.inclusive && b.next(a), b.complete());
        };return a;
    }(m),
        $e = function () {
        function c(a, b, c) {
            this.nextOrObserver = a;this.error = b;this.complete = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new Ze(a, this.nextOrObserver, this.error, this.complete));
        };return c;
    }(),
        Ze = function (c) {
        function a(a, d, e, f) {
            a = c.call(this, a) || this;a._tapNext = D;a._tapError = D;a._tapComplete = D;a._tapError = e || D;a._tapComplete = f || D;Q(d) ? (a._context = a, a._tapNext = d) : d && (a._context = d, a._tapNext = d.next || D, a._tapError = d.error || D, a._tapComplete = d.complete || D);return a;
        }h(a, c);a.prototype._next = function (a) {
            try {
                this._tapNext.call(this._context, a);
            } catch (d) {
                this.destination.error(d);return;
            }this.destination.next(a);
        };a.prototype._error = function (a) {
            try {
                this._tapError.call(this._context, a);
            } catch (d) {
                this.destination.error(d);return;
            }this.destination.error(a);
        };
        a.prototype._complete = function () {
            try {
                this._tapComplete.call(this._context);
            } catch (b) {
                this.destination.error(b);return;
            }return this.destination.complete();
        };return a;
    }(m),
        Gb = { leading: !0, trailing: !1 },
        bf = function () {
        function c(a, b, c) {
            this.durationSelector = a;this.leading = b;this.trailing = c;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new af(a, this.durationSelector, this.leading, this.trailing));
        };return c;
    }(),
        af = function (c) {
        function a(a, d, e, f) {
            var b = c.call(this, a) || this;b.destination = a;b.durationSelector = d;b._leading = e;b._trailing = f;b._hasValue = !1;return b;
        }h(a, c);a.prototype._next = function (a) {
            this._hasValue = !0;this._sendValue = a;this._throttled || (this._leading ? this.send() : this.throttle(a));
        };a.prototype.send = function () {
            var a = this._sendValue;this._hasValue && (this.destination.next(a), this.throttle(a));this._hasValue = !1;this._sendValue = null;
        };a.prototype.throttle = function (a) {
            (a = this.tryDurationSelector(a)) && this.add(this._throttled = p(this, a));
        };a.prototype.tryDurationSelector = function (a) {
            try {
                return this.durationSelector(a);
            } catch (d) {
                return this.destination.error(d), null;
            }
        };a.prototype.throttlingDone = function () {
            var a = this._throttled,
                c = this._trailing;a && a.unsubscribe();this._throttled = null;c && this.send();
        };a.prototype.notifyNext = function (a, c, e, f, g) {
            this.throttlingDone();
        };a.prototype.notifyComplete = function () {
            this.throttlingDone();
        };return a;
    }(q),
        df = function () {
        function c(a, b, c, e) {
            this.duration = a;this.scheduler = b;this.leading = c;this.trailing = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new cf(a, this.duration, this.scheduler, this.leading, this.trailing));
        };return c;
    }(),
        cf = function (c) {
        function a(a, d, e, f, g) {
            a = c.call(this, a) || this;a.duration = d;a.scheduler = e;a.leading = f;a.trailing = g;a._hasTrailingValue = !1;a._trailingValue = null;return a;
        }h(a, c);a.prototype._next = function (a) {
            this.throttled ? this.trailing && (this._trailingValue = a, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(Ac, this.duration, { subscriber: this })), this.leading ? this.destination.next(a) : this.trailing && (this._trailingValue = a, this._hasTrailingValue = !0));
        };a.prototype._complete = function () {
            this._hasTrailingValue && this.destination.next(this._trailingValue);this.destination.complete();
        };a.prototype.clearThrottle = function () {
            var a = this.throttled;a && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), a.unsubscribe(), this.remove(a), this.throttled = null);
        };return a;
    }(m),
        ef = function () {
        return function (c, a) {
            this.value = c;this.interval = a;
        };
    }(),
        Bc = function () {
        function c(a, b, c, e) {
            this.waitFor = a;this.absoluteTimeout = b;this.withObservable = c;this.scheduler = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new ff(a, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
        };return c;
    }(),
        ff = function (c) {
        function a(a, d, e, f, g) {
            a = c.call(this, a) || this;a.absoluteTimeout = d;a.waitFor = e;a.withObservable = f;a.scheduler = g;a.action = null;a.scheduleTimeout();return a;
        }h(a, c);a.dispatchTimeout = function (a) {
            var b = a.withObservable;a._unsubscribeAndRecycle();a.add(p(a, b));
        };a.prototype.scheduleTimeout = function () {
            var b = this.action;b ? this.action = b.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(a.dispatchTimeout, this.waitFor, this));
        };a.prototype._next = function (a) {
            this.absoluteTimeout || this.scheduleTimeout();c.prototype._next.call(this, a);
        };a.prototype._unsubscribe = function () {
            this.withObservable = this.scheduler = this.action = null;
        };return a;
    }(q),
        gf = function () {
        return function (c, a) {
            this.value = c;this.timestamp = a;
        };
    }(),
        jf = function () {
        function c(a) {
            this.windowBoundaries = a;
        }c.prototype.call = function (a, b) {
            a = new hf(a);b = b.subscribe(a);b.closed || a.add(p(a, this.windowBoundaries));return b;
        };return c;
    }(),
        hf = function (c) {
        function a(a) {
            var b = c.call(this, a) || this;b.window = new v();a.next(b.window);return b;
        }h(a, c);a.prototype.notifyNext = function (a, c, e, f, g) {
            this.openWindow();
        };a.prototype.notifyError = function (a, c) {
            this._error(a);
        };a.prototype.notifyComplete = function (a) {
            this._complete();
        };a.prototype._next = function (a) {
            this.window.next(a);
        };a.prototype._error = function (a) {
            this.window.error(a);this.destination.error(a);
        };a.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
        };a.prototype._unsubscribe = function () {
            this.window = null;
        };a.prototype.openWindow = function () {
            var a = this.window;a && a.complete();var a = this.destination,
                c = this.window = new v();a.next(c);
        };return a;
    }(q),
        lf = function () {
        function c(a, b) {
            this.windowSize = a;this.startWindowEvery = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new kf(a, this.windowSize, this.startWindowEvery));
        };return c;
    }(),
        kf = function (c) {
        function a(a, d, e) {
            var b = c.call(this, a) || this;b.destination = a;b.windowSize = d;b.startWindowEvery = e;b.windows = [new v()];b.count = 0;a.next(b.windows[0]);return b;
        }h(a, c);a.prototype._next = function (a) {
            for (var b = 0 < this.startWindowEvery ? this.startWindowEvery : this.windowSize, c = this.destination, f = this.windowSize, g = this.windows, l = g.length, h = 0; h < l && !this.closed; h++) {
                g[h].next(a);
            }a = this.count - f + 1;0 <= a && 0 === a % b && !this.closed && g.shift().complete();0 !== ++this.count % b || this.closed || (b = new v(), g.push(b), c.next(b));
        };a.prototype._error = function (a) {
            var b = this.windows;if (b) for (; 0 < b.length && !this.closed;) {
                b.shift().error(a);
            }this.destination.error(a);
        };a.prototype._complete = function () {
            var a = this.windows;if (a) for (; 0 < a.length && !this.closed;) {
                a.shift().complete();
            }this.destination.complete();
        };a.prototype._unsubscribe = function () {
            this.count = 0;this.windows = null;
        };return a;
    }(m),
        nf = function () {
        function c(a, b, c, e) {
            this.windowTimeSpan = a;this.windowCreationInterval = b;this.maxWindowSize = c;this.scheduler = e;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new mf(a, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
        };
        return c;
    }(),
        of = function (c) {
        function a() {
            var a = null !== c && c.apply(this, arguments) || this;a._numberOfNextedValues = 0;return a;
        }h(a, c);a.prototype.next = function (a) {
            this._numberOfNextedValues++;c.prototype.next.call(this, a);
        };Object.defineProperty(a.prototype, "numberOfNextedValues", { get: function get() {
                return this._numberOfNextedValues;
            }, enumerable: !0, configurable: !0 });return a;
    }(v),
        mf = function (c) {
        function a(a, d, e, f, g) {
            var b = c.call(this, a) || this;b.destination = a;b.windowTimeSpan = d;b.windowCreationInterval = e;b.maxWindowSize = f;b.scheduler = g;b.windows = [];a = b.openWindow();null !== e && 0 <= e ? (f = { windowTimeSpan: d, windowCreationInterval: e, subscriber: b, scheduler: g }, b.add(g.schedule(ob, d, { subscriber: b, window: a, context: null })), b.add(g.schedule(Ec, e, f))) : b.add(g.schedule(Dc, d, { subscriber: b, window: a, windowTimeSpan: d }));return b;
        }h(a, c);a.prototype._next = function (a) {
            for (var b = this.windows, c = b.length, f = 0; f < c; f++) {
                var g = b[f];g.closed || (g.next(a), g.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(g));
            }
        };a.prototype._error = function (a) {
            for (var b = this.windows; 0 < b.length;) {
                b.shift().error(a);
            }this.destination.error(a);
        };a.prototype._complete = function () {
            for (var a = this.windows; 0 < a.length;) {
                var c = a.shift();c.closed || c.complete();
            }this.destination.complete();
        };a.prototype.openWindow = function () {
            var a = new of();this.windows.push(a);this.destination.next(a);return a;
        };a.prototype.closeWindow = function (a) {
            a.complete();var b = this.windows;b.splice(b.indexOf(a), 1);
        };return a;
    }(m),
        qf = function () {
        function c(a, b) {
            this.openings = a;this.closingSelector = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new pf(a, this.openings, this.closingSelector));
        };return c;
    }(),
        pf = function (c) {
        function a(a, d, e) {
            a = c.call(this, a) || this;a.openings = d;a.closingSelector = e;a.contexts = [];a.add(a.openSubscription = p(a, d, d));return a;
        }h(a, c);a.prototype._next = function (a) {
            var b = this.contexts;if (b) for (var c = b.length, f = 0; f < c; f++) {
                b[f].window.next(a);
            }
        };a.prototype._error = function (a) {
            var b = this.contexts;this.contexts = null;if (b) for (var e = b.length, f = -1; ++f < e;) {
                var g = b[f];g.window.error(a);g.subscription.unsubscribe();
            }c.prototype._error.call(this, a);
        };a.prototype._complete = function () {
            var a = this.contexts;this.contexts = null;if (a) for (var d = a.length, e = -1; ++e < d;) {
                var f = a[e];f.window.complete();f.subscription.unsubscribe();
            }c.prototype._complete.call(this);
        };a.prototype._unsubscribe = function () {
            var a = this.contexts;this.contexts = null;if (a) for (var c = a.length, e = -1; ++e < c;) {
                var f = a[e];f.window.unsubscribe();f.subscription.unsubscribe();
            }
        };a.prototype.notifyNext = function (a, c, e, f, g) {
            if (a === this.openings) {
                a = void 0;try {
                    var b = this.closingSelector;a = b(c);
                } catch (u) {
                    return this.error(u);
                }c = new v();b = new t();e = { window: c, subscription: b };this.contexts.push(e);a = p(this, a, e);a.closed ? this.closeWindow(this.contexts.length - 1) : (a.context = e, b.add(a));this.destination.next(c);
            } else this.closeWindow(this.contexts.indexOf(a));
        };a.prototype.notifyError = function (a) {
            this.error(a);
        };a.prototype.notifyComplete = function (a) {
            a !== this.openSubscription && this.closeWindow(this.contexts.indexOf(a.context));
        };a.prototype.closeWindow = function (a) {
            if (-1 !== a) {
                var b = this.contexts,
                    c = b[a],
                    f = c.window,
                    c = c.subscription;b.splice(a, 1);f.complete();c.unsubscribe();
            }
        };return a;
    }(q),
        sf = function () {
        function c(a) {
            this.closingSelector = a;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new rf(a, this.closingSelector));
        };return c;
    }(),
        rf = function (c) {
        function a(a, d) {
            var b = c.call(this, a) || this;b.destination = a;b.closingSelector = d;b.openWindow();return b;
        }h(a, c);a.prototype.notifyNext = function (a, c, e, f, g) {
            this.openWindow(g);
        };a.prototype.notifyError = function (a, c) {
            this._error(a);
        };a.prototype.notifyComplete = function (a) {
            this.openWindow(a);
        };a.prototype._next = function (a) {
            this.window.next(a);
        };a.prototype._error = function (a) {
            this.window.error(a);this.destination.error(a);this.unsubscribeClosingNotification();
        };a.prototype._complete = function () {
            this.window.complete();this.destination.complete();this.unsubscribeClosingNotification();
        };a.prototype.unsubscribeClosingNotification = function () {
            this.closingNotification && this.closingNotification.unsubscribe();
        };a.prototype.openWindow = function (a) {
            void 0 === a && (a = null);a && (this.remove(a), a.unsubscribe());(a = this.window) && a.complete();a = this.window = new v();this.destination.next(a);var b;try {
                var c = this.closingSelector;b = c();
            } catch (f) {
                this.destination.error(f);this.window.error(f);return;
            }this.add(this.closingNotification = p(this, b));
        };return a;
    }(q),
        uf = function () {
        function c(a, b) {
            this.observables = a;this.project = b;
        }c.prototype.call = function (a, b) {
            return b.subscribe(new tf(a, this.observables, this.project));
        };return c;
    }(),
        tf = function (c) {
        function a(a, d, e) {
            a = c.call(this, a) || this;a.observables = d;a.project = e;a.toRespond = [];e = d.length;
            a.values = Array(e);for (var b = 0; b < e; b++) {
                a.toRespond.push(b);
            }for (b = 0; b < e; b++) {
                var g = d[b];a.add(p(a, g, g, b));
            }return a;
        }h(a, c);a.prototype.notifyNext = function (a, c, e, f, g) {
            this.values[e] = c;a = this.toRespond;0 < a.length && (e = a.indexOf(e), -1 !== e && a.splice(e, 1));
        };a.prototype.notifyComplete = function () {};a.prototype._next = function (a) {
            0 === this.toRespond.length && (a = [a].concat(this.values), this.project ? this._tryProject(a) : this.destination.next(a));
        };a.prototype._tryProject = function (a) {
            var b;try {
                b = this.project.apply(this, a);
            } catch (e) {
                this.destination.error(e);return;
            }this.destination.next(b);
        };return a;
    }(q),
        vf = Object.freeze({
        audit: hb, auditTime: function auditTime(c, a) {
            void 0 === a && (a = y);return hb(function () {
                return eb(c, a);
            });
        }, buffer: function buffer(c) {
            return function (a) {
                return a.lift(new od(c));
            };
        }, bufferCount: function bufferCount(c, a) {
            void 0 === a && (a = null);return function (b) {
                return b.lift(new rd(c, a));
            };
        }, bufferTime: function bufferTime(c) {
            var a = arguments.length,
                b = y;A(arguments[arguments.length - 1]) && (b = arguments[arguments.length - 1], a--);var d = null;2 <= a && (d = arguments[1]);
            var e = Number.POSITIVE_INFINITY;3 <= a && (e = arguments[2]);return function (a) {
                return a.lift(new td(c, d, e, b));
            };
        }, bufferToggle: function bufferToggle(c, a) {
            return function (b) {
                return b.lift(new wd(c, a));
            };
        }, bufferWhen: function bufferWhen(c) {
            return function (a) {
                return a.lift(new yd(c));
            };
        }, catchError: function catchError(c) {
            return function (a) {
                var b = new Ad(c);a = a.lift(b);return b.caught = a;
            };
        }, combineAll: function combineAll(c) {
            return function (a) {
                return a.lift(new Ja(c));
            };
        }, combineLatest: function combineLatest() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }var b = null;
            "function" === typeof c[c.length - 1] && (b = c.pop());1 === c.length && x(c[0]) && (c = c[0].slice());return function (a) {
                return a.lift.call(G([a].concat(c)), new Ja(b));
            };
        }, concat: function concat() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                return a.lift.call(aa.apply(void 0, [a].concat(c)));
            };
        }, concatAll: Ya, concatMap: kb, concatMapTo: function concatMapTo(c, a) {
            return kb(function () {
                return c;
            }, a);
        }, count: function count(c) {
            return function (a) {
                return a.lift(new Cd(c, a));
            };
        }, debounce: function debounce(c) {
            return function (a) {
                return a.lift(new Ed(c));
            };
        },
        debounceTime: function debounceTime(c, a) {
            void 0 === a && (a = y);return function (b) {
                return b.lift(new Gd(c, a));
            };
        }, defaultIfEmpty: ba, delay: function delay(c, a) {
            void 0 === a && (a = y);var b = c instanceof Date && !isNaN(+c) ? +c - a.now() : Math.abs(c);return function (c) {
                return c.lift(new Jd(b, a));
            };
        }, delayWhen: function delayWhen(c, a) {
            return a ? function (b) {
                return new Nd(b, a).lift(new Db(c));
            } : function (a) {
                return a.lift(new Db(c));
            };
        }, dematerialize: function dematerialize() {
            return function (c) {
                return c.lift(new Pd());
            };
        }, distinct: function distinct(c, a) {
            return function (b) {
                return b.lift(new Rd(c, a));
            };
        }, distinctUntilChanged: lb, distinctUntilKeyChanged: function distinctUntilKeyChanged(c, a) {
            return lb(function (b, d) {
                return a ? a(b[c], d[c]) : b[c] === d[c];
            });
        }, elementAt: function elementAt(c, a) {
            if (0 > c) throw new K();var b = 2 <= arguments.length;return function (d) {
                return d.pipe(I(function (a, b) {
                    return b === c;
                }), Ca(1), b ? ba(a) : ka(function () {
                    return new K();
                }));
            };
        }, endWith: function endWith() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                return aa(a, ha.apply(void 0, c));
            };
        }, every: function every(c, a) {
            return function (b) {
                return b.lift(new Wd(c, a, b));
            };
        }, exhaust: function exhaust() {
            return function (c) {
                return c.lift(new Yd());
            };
        }, exhaustMap: mb, expand: function expand(c, a, b) {
            void 0 === a && (a = Number.POSITIVE_INFINITY);void 0 === b && (b = void 0);a = 1 > (a || 0) ? Number.POSITIVE_INFINITY : a;return function (d) {
                return d.lift(new ae(c, a, b));
            };
        }, filter: I, finalize: function finalize(c) {
            return function (a) {
                return a.lift(new ce(c));
            };
        }, find: function find(c, a) {
            if ("function" !== typeof c) throw new TypeError("predicate is not a function");return function (b) {
                return b.lift(new Eb(c, b, !1, a));
            };
        }, findIndex: function findIndex(c, a) {
            return function (b) {
                return b.lift(new Eb(c, b, !0, a));
            };
        }, first: function first(c, a) {
            var b = 2 <= arguments.length;return function (d) {
                return d.pipe(c ? I(function (a, b) {
                    return c(a, b, d);
                }) : J, Ca(1), b ? ba(a) : ka(function () {
                    return new ca();
                }));
            };
        }, groupBy: function groupBy(c, a, b, d) {
            return function (e) {
                return e.lift(new Qc(c, a, b, d));
            };
        }, ignoreElements: function ignoreElements() {
            return function (c) {
                return c.lift(new fe());
            };
        }, isEmpty: function isEmpty() {
            return function (c) {
                return c.lift(new he());
            };
        }, last: function last(c, a) {
            var b = 2 <= arguments.length;return function (d) {
                return d.pipe(c ? I(function (a, b) {
                    return c(a, b, d);
                }) : J, la(1), b ? ba(a) : ka(function () {
                    return new ca();
                }));
            };
        }, map: B, mapTo: function mapTo(c) {
            return function (a) {
                return a.lift(new ke(c));
            };
        }, materialize: function materialize() {
            return function (c) {
                return c.lift(new me());
            };
        }, max: function max(c) {
            return na("function" === typeof c ? function (a, b) {
                return 0 < c(a, b) ? a : b;
            } : function (a, b) {
                return a > b ? a : b;
            });
        }, merge: function merge() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                return a.lift.call(bb.apply(void 0, [a].concat(c)));
            };
        }, mergeAll: za, mergeMap: M,
        flatMap: M, mergeMapTo: function mergeMapTo(c, a, b) {
            void 0 === b && (b = Number.POSITIVE_INFINITY);if ("function" === typeof a) return M(function () {
                return c;
            }, a, b);"number" === typeof a && (b = a);return M(function () {
                return c;
            }, b);
        }, mergeScan: function mergeScan(c, a, b) {
            void 0 === b && (b = Number.POSITIVE_INFINITY);return function (d) {
                return d.lift(new pe(c, a, b));
            };
        }, min: function min(c) {
            return na("function" === typeof c ? function (a, b) {
                return 0 > c(a, b) ? a : b;
            } : function (a, b) {
                return a < b ? a : b;
            });
        }, multicast: N, observeOn: function observeOn(c, a) {
            void 0 === a && (a = 0);return function (b) {
                return b.lift(new Uc(c, a));
            };
        }, onErrorResumeNext: function onErrorResumeNext() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }1 === c.length && x(c[0]) && (c = c[0]);return function (a) {
                return a.lift(new re(c));
            };
        }, pairwise: function pairwise() {
            return function (c) {
                return c.lift(new te());
            };
        }, partition: function partition(c, a) {
            return function (b) {
                return [I(c, a)(b), I(cb(c, a))(b)];
            };
        }, pluck: function pluck() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }var b = c.length;if (0 === b) throw Error("list of properties cannot be empty.");return function (a) {
                return B(vc(c, b))(a);
            };
        },
        publish: function publish(c) {
            return c ? N(function () {
                return new v();
            }, c) : N(new v());
        }, publishBehavior: function publishBehavior(c) {
            return function (a) {
                return N(new wb(c))(a);
            };
        }, publishLast: function publishLast() {
            return function (c) {
                return N(new U())(c);
            };
        }, publishReplay: function publishReplay(c, a, b, d) {
            b && "function" !== typeof b && (d = b);var e = "function" === typeof b ? b : void 0,
                f = new X(c, a, d);return function (a) {
                return N(function () {
                    return f;
                }, e)(a);
            };
        }, race: function race() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                1 === c.length && x(c[0]) && (c = c[0]);
                return a.lift.call(db.apply(void 0, [a].concat(c)));
            };
        }, reduce: na, repeat: function repeat(c) {
            void 0 === c && (c = -1);return function (a) {
                return 0 === c ? S() : 0 > c ? a.lift(new Fb(-1, a)) : a.lift(new Fb(c - 1, a));
            };
        }, repeatWhen: function repeatWhen(c) {
            return function (a) {
                return a.lift(new we(c));
            };
        }, retry: function retry(c) {
            void 0 === c && (c = -1);return function (a) {
                return a.lift(new ye(c, a));
            };
        }, retryWhen: function retryWhen(c) {
            return function (a) {
                return a.lift(new Ae(c, a));
            };
        }, refCount: va, sample: function sample(c) {
            return function (a) {
                return a.lift(new Ce(c));
            };
        }, sampleTime: function sampleTime(c, a) {
            void 0 === a && (a = y);return function (b) {
                return b.lift(new Ee(c, a));
            };
        }, scan: ma, sequenceEqual: function sequenceEqual(c, a) {
            return function (b) {
                return b.lift(new Ge(c, a));
            };
        }, share: function share() {
            return function (c) {
                return va()(N(xc)(c));
            };
        }, shareReplay: function shareReplay(c, a, b) {
            var d;d = c && "object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) ? c : { bufferSize: c, windowTime: a, refCount: !1, scheduler: b };return function (a) {
                return a.lift(yc(d));
            };
        }, single: function single(c) {
            return function (a) {
                return a.lift(new Je(c, a));
            };
        }, skip: function skip(c) {
            return function (a) {
                return a.lift(new Le(c));
            };
        }, skipLast: function skipLast(c) {
            return function (a) {
                return a.lift(new Ne(c));
            };
        },
        skipUntil: function skipUntil(c) {
            return function (a) {
                return a.lift(new Pe(c));
            };
        }, skipWhile: function skipWhile(c) {
            return function (a) {
                return a.lift(new Re(c));
            };
        }, startWith: function startWith() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }var b = c[c.length - 1];return A(b) ? (c.pop(), function (a) {
                return aa(c, a, b);
            }) : function (a) {
                return aa(c, a);
            };
        }, subscribeOn: function subscribeOn(c, a) {
            void 0 === a && (a = 0);return function (b) {
                return b.lift(new Te(c, a));
            };
        }, switchAll: function switchAll() {
            return da(J);
        }, switchMap: da, switchMapTo: function switchMapTo(c, a) {
            return a ? da(function () {
                return c;
            }, a) : da(function () {
                return c;
            });
        }, take: Ca, takeLast: la, takeUntil: function takeUntil(c) {
            return function (a) {
                return a.lift(new We(c));
            };
        }, takeWhile: function takeWhile(c, a) {
            void 0 === a && (a = !1);return function (b) {
                return b.lift(new Ye(c, a));
            };
        }, tap: function tap(c, a, b) {
            return function (d) {
                return d.lift(new $e(c, a, b));
            };
        }, throttle: function throttle(c, a) {
            void 0 === a && (a = Gb);return function (b) {
                return b.lift(new bf(c, a.leading, a.trailing));
            };
        }, throttleTime: function throttleTime(c, a, b) {
            void 0 === a && (a = y);void 0 === b && (b = Gb);return function (d) {
                return d.lift(new df(c, a, b.leading, b.trailing));
            };
        }, throwIfEmpty: ka, timeInterval: function timeInterval(c) {
            void 0 === c && (c = y);return function (a) {
                return Aa(function () {
                    return a.pipe(ma(function (a, d) {
                        a = a.current;return { value: d, current: c.now(), last: a };
                    }, { current: c.now(), value: void 0, last: void 0 }), B(function (a) {
                        return new ef(a.value, a.current - a.last);
                    }));
                });
            };
        }, timeout: function timeout(c, a) {
            void 0 === a && (a = y);return nb(c, xa(new ya()), a);
        }, timeoutWith: nb, timestamp: function timestamp(c) {
            void 0 === c && (c = y);return B(function (a) {
                return new gf(a, c.now());
            });
        }, toArray: function toArray() {
            return na(Cc, []);
        }, window: function window(c) {
            return function (a) {
                return a.lift(new jf(c));
            };
        }, windowCount: function windowCount(c, a) {
            void 0 === a && (a = 0);return function (b) {
                return b.lift(new lf(c, a));
            };
        }, windowTime: function windowTime(c, a, b, d) {
            var e = y,
                f = null,
                g = Number.POSITIVE_INFINITY;A(d) && (e = d);A(b) ? e = b : W(b) && (g = b);A(a) ? e = a : W(a) && (f = a);return function (a) {
                return a.lift(new nf(c, f, g, e));
            };
        }, windowToggle: function windowToggle(c, a) {
            return function (b) {
                return b.lift(new qf(c, a));
            };
        }, windowWhen: function windowWhen(c) {
            return function (a) {
                return a.lift(new sf(c));
            };
        }, withLatestFrom: function withLatestFrom() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                var b;"function" === typeof c[c.length - 1] && (b = c.pop());return a.lift(new uf(c, b));
            };
        }, zip: function zip() {
            for (var c = [], a = 0; a < arguments.length; a++) {
                c[a] = arguments[a];
            }return function (a) {
                return a.lift.call(fb.apply(void 0, [a].concat(c)));
            };
        }, zipAll: function zipAll(c) {
            return function (a) {
                return a.lift(new gb(c));
            };
        }
    }),
        ga = function () {
        return function (c, a) {
            void 0 === a && (a = Number.POSITIVE_INFINITY);this.subscribedFrame = c;this.unsubscribedFrame = a;
        };
    }(),
        Hb = function () {
        function c() {
            this.subscriptions = [];
        }c.prototype.logSubscribedFrame = function () {
            this.subscriptions.push(new ga(this.scheduler.now()));return this.subscriptions.length - 1;
        };c.prototype.logUnsubscribedFrame = function (a) {
            var b = this.subscriptions;b[a] = new ga(b[a].subscribedFrame, this.scheduler.now());
        };return c;
    }(),
        Ka = function (c) {
        function a(a, d) {
            var b = c.call(this, function (a) {
                var b = this,
                    c = b.logSubscribedFrame(),
                    d = new t();d.add(new t(function () {
                    b.logUnsubscribedFrame(c);
                }));b.scheduleMessages(a);return d;
            }) || this;b.messages = a;b.subscriptions = [];
            b.scheduler = d;return b;
        }h(a, c);a.prototype.scheduleMessages = function (a) {
            for (var b = this.messages.length, c = 0; c < b; c++) {
                var f = this.messages[c];a.add(this.scheduler.schedule(function (a) {
                    a.message.notification.observe(a.subscriber);
                }, f.frame, { message: f, subscriber: a }));
            }
        };return a;
    }(n);pb(Ka, [Hb]);var Ib = function (c) {
        function a(a, d) {
            var b = c.call(this) || this;b.messages = a;b.subscriptions = [];b.scheduler = d;return b;
        }h(a, c);a.prototype._subscribe = function (a) {
            var b = this,
                e = b.logSubscribedFrame(),
                f = new t();f.add(new t(function () {
                b.logUnsubscribedFrame(e);
            }));
            f.add(c.prototype._subscribe.call(this, a));return f;
        };a.prototype.setup = function () {
            for (var a = this, c = a.messages.length, e = 0; e < c; e++) {
                (function () {
                    var b = a.messages[e];a.scheduler.schedule(function () {
                        b.notification.observe(a);
                    }, b.frame);
                })();
            }
        };return a;
    }(v);pb(Ib, [Hb]);var xf = function (c) {
        function a(a) {
            var b = c.call(this, Ia, 750) || this;b.assertDeepEqual = a;b.hotObservables = [];b.coldObservables = [];b.flushTests = [];b.runMode = !1;return b;
        }h(a, c);a.prototype.createTime = function (b) {
            b = b.indexOf("|");if (-1 === b) throw Error('marble diagram for time should have a completion marker "|"');
            return b * a.frameTimeFactor;
        };a.prototype.createColdObservable = function (b, c, e) {
            if (-1 !== b.indexOf("^")) throw Error('cold observable cannot have subscription offset "^"');if (-1 !== b.indexOf("!")) throw Error('cold observable cannot have unsubscription marker "!"');b = a.parseMarbles(b, c, e, void 0, this.runMode);b = new Ka(b, this);this.coldObservables.push(b);return b;
        };a.prototype.createHotObservable = function (b, c, e) {
            if (-1 !== b.indexOf("!")) throw Error('hot observable cannot have unsubscription marker "!"');b = a.parseMarbles(b, c, e, void 0, this.runMode);b = new Ib(b, this);this.hotObservables.push(b);return b;
        };a.prototype.materializeInnerObservable = function (a, c) {
            var b = this,
                d = [];a.subscribe(function (a) {
                d.push({ frame: b.frame - c, notification: w.createNext(a) });
            }, function (a) {
                d.push({ frame: b.frame - c, notification: w.createError(a) });
            }, function () {
                d.push({ frame: b.frame - c, notification: w.createComplete() });
            });return d;
        };a.prototype.expectObservable = function (b, c) {
            var d = this;void 0 === c && (c = null);var f = [],
                g = { actual: f, ready: !1 };c = a.parseMarblesAsSubscriptions(c, this.runMode);var h = c.unsubscribedFrame,
                k;this.schedule(function () {
                k = b.subscribe(function (a) {
                    var b = a;a instanceof n && (b = d.materializeInnerObservable(b, d.frame));f.push({ frame: d.frame, notification: w.createNext(b) });
                }, function (a) {
                    f.push({ frame: d.frame, notification: w.createError(a) });
                }, function () {
                    f.push({ frame: d.frame, notification: w.createComplete() });
                });
            }, c.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : c.subscribedFrame);h !== Number.POSITIVE_INFINITY && this.schedule(function () {
                return k.unsubscribe();
            }, h);this.flushTests.push(g);
            var m = this.runMode;return { toBe: function toBe(b, c, d) {
                    g.ready = !0;g.expected = a.parseMarbles(b, c, d, !0, m);
                } };
        };a.prototype.expectSubscriptions = function (b) {
            var c = { actual: b, ready: !1 };this.flushTests.push(c);var e = this.runMode;return { toBe: function toBe(b) {
                    b = "string" === typeof b ? [b] : b;c.ready = !0;c.expected = b.map(function (b) {
                        return a.parseMarblesAsSubscriptions(b, e);
                    });
                } };
        };a.prototype.flush = function () {
            for (var a = this, d = this.hotObservables; 0 < d.length;) {
                d.shift().setup();
            }c.prototype.flush.call(this);this.flushTests = this.flushTests.filter(function (b) {
                return b.ready ? (a.assertDeepEqual(b.actual, b.expected), !1) : !0;
            });
        };a.parseMarblesAsSubscriptions = function (a, c) {
            var b = this;void 0 === c && (c = !1);if ("string" !== typeof a) return new ga(Number.POSITIVE_INFINITY);for (var d = a.length, g = -1, h = Number.POSITIVE_INFINITY, k = Number.POSITIVE_INFINITY, m = 0, r = function r(d) {
                var e = m,
                    f = function f(a) {
                    e += a * b.frameTimeFactor;
                },
                    l = a[d];switch (l) {
                    case " ":
                        c || f(1);break;case "-":
                        f(1);break;case "(":
                        g = m;f(1);break;case ")":
                        g = -1;f(1);break;case "^":
                        if (h !== Number.POSITIVE_INFINITY) throw Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");
                        h = -1 < g ? g : m;f(1);break;case "!":
                        if (k !== Number.POSITIVE_INFINITY) throw Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");k = -1 < g ? g : m;break;default:
                        if (c && l.match(/^[0-9]$/) && (0 === d || " " === a[d - 1])) {
                            var r = a.slice(d).match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if (r) {
                                d += r[0].length - 1;var l = parseFloat(r[1]),
                                    u = void 0;switch (r[2]) {case "ms":
                                        u = l;break;case "s":
                                        u = 1E3 * l;break;case "m":
                                        u = 6E4 * l;}f(u / n.frameTimeFactor);break;
                            }
                        }throw Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '" + l + "'.");
                }m = e;p = d;
            }, n = this, p, q = 0; q < d; q++) {
                r(q), q = p;
            }return 0 > k ? new ga(h) : new ga(h, k);
        };a.parseMarbles = function (a, c, e, f, g) {
            var b = this;void 0 === f && (f = !1);void 0 === g && (g = !1);if (-1 !== a.indexOf("!")) throw Error('conventional marble diagrams cannot have the unsubscription marker "!"');for (var d = a.length, h = [], k = g ? a.replace(/^[ ]+/, "").indexOf("^") : a.indexOf("^"), m = -1 === k ? 0 : k * -this.frameTimeFactor, n = "object" !== (typeof c === "undefined" ? "undefined" : _typeof(c)) ? function (a) {
                return a;
            } : function (a) {
                return f && c[a] instanceof Ka ? c[a].messages : c[a];
            }, p = -1, k = function k(c) {
                var d = m,
                    f = function f(a) {
                    d += a * b.frameTimeFactor;
                },
                    l = void 0,
                    k = a[c];switch (k) {
                    case " ":
                        g || f(1);break;case "-":
                        f(1);break;case "(":
                        p = m;f(1);break;case ")":
                        p = -1;f(1);break;case "|":
                        l = w.createComplete();f(1);break;case "^":
                        f(1);break;case "#":
                        l = w.createError(e || "error");f(1);break;default:
                        if (g && k.match(/^[0-9]$/) && (0 === c || " " === a[c - 1])) {
                            var u = a.slice(c).match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if (u) {
                                c += u[0].length - 1;var k = parseFloat(u[1]),
                                    r = void 0;switch (u[2]) {
                                    case "ms":
                                        r = k;break;case "s":
                                        r = 1E3 * k;break;case "m":
                                        r = 6E4 * k;
                                }f(r / q.frameTimeFactor);break;
                            }
                        }l = w.createNext(n(k));f(1);
                }l && h.push({ frame: -1 < p ? p : m, notification: l });m = d;t = c;
            }, q = this, t, v = 0; v < d; v++) {
                k(v), v = t;
            }return h;
        };a.prototype.run = function (b) {
            var c = a.frameTimeFactor,
                e = this.maxFrames;a.frameTimeFactor = 1;this.maxFrames = Number.POSITIVE_INFINITY;this.runMode = !0;P.delegate = this;var f = { cold: this.createColdObservable.bind(this), hot: this.createHotObservable.bind(this), flush: this.flush.bind(this), expectObservable: this.expectObservable.bind(this), expectSubscriptions: this.expectSubscriptions.bind(this) };
            try {
                var g = b(f);this.flush();return g;
            } finally {
                a.frameTimeFactor = c, this.maxFrames = e, this.runMode = !1, P.delegate = void 0;
            }
        };return a;
    }(Ab),
        yf = Object.freeze({ TestScheduler: xf }),
        zf = "undefined" !== typeof self && "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
        Af = "undefined" !== typeof global && global,
        z = "undefined" !== typeof window && window || Af || zf;if (!z) throw Error("RxJS could not find any global context (window, self, global)");var Lc = B(function (c, a) {
        return c.response;
    }),
        O = function (c) {
        function a(a) {
            var b = c.call(this) || this,
                e = {
                async: !0, createXHR: function createXHR() {
                    var a;if (this.crossDomain) {
                        if (z.XMLHttpRequest) a = new z.XMLHttpRequest();else if (z.XDomainRequest) a = new z.XDomainRequest();else throw Error("CORS is not supported by your browser");
                    } else if (z.XMLHttpRequest) a = new z.XMLHttpRequest();else {
                        var b = void 0;try {
                            for (var c = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"], d = 0; 3 > d; d++) {
                                try {
                                    b = c[d];new z.ActiveXObject(b);break;
                                } catch (r) {}
                            }a = new z.ActiveXObject(b);
                        } catch (r) {
                            throw Error("XMLHttpRequest is not supported by your browser");
                        }
                    }return a;
                }, crossDomain: !0, withCredentials: !1, headers: {}, method: "GET", responseType: "json", timeout: 0
            };if ("string" === typeof a) e.url = a;else for (var f in a) {
                a.hasOwnProperty(f) && (e[f] = a[f]);
            }b.request = e;return b;
        }h(a, c);a.prototype._subscribe = function (a) {
            return new Bf(a, this.request);
        };a.create = function () {
            var b = function b(_b) {
                return new a(_b);
            };b.get = Fc;b.post = Gc;b.delete = Hc;b.put = Ic;b.patch = Jc;b.getJSON = Kc;return b;
        }();return a;
    }(n),
        Bf = function (c) {
        function a(a, d) {
            a = c.call(this, a) || this;a.request = d;a.done = !1;var b = d.headers = d.headers || {};d.crossDomain || a.getHeader(b, "X-Requested-With") || (b["X-Requested-With"] = "XMLHttpRequest");a.getHeader(b, "Content-Type") || z.FormData && d.body instanceof z.FormData || "undefined" === typeof d.body || (b["Content-Type"] = "application/x-www-form-urlencoded; charset\x3dUTF-8");d.body = a.serializeBody(d.body, a.getHeader(d.headers, "Content-Type"));a.send();return a;
        }h(a, c);a.prototype.next = function (a) {
            this.done = !0;var b = this.xhr,
                c = this.request,
                f = this.destination,
                g;try {
                g = new Jb(a, b, c);
            } catch (l) {
                return f.error(l);
            }f.next(g);
        };
        a.prototype.send = function () {
            var a = this.request,
                c = this.request,
                e = c.user,
                f = c.method,
                g = c.url,
                h = c.async,
                k = c.password,
                m = c.headers,
                c = c.body;try {
                var r = this.xhr = a.createXHR();this.setupEvents(r, a);e ? r.open(f, g, h, e, k) : r.open(f, g, h);h && (r.timeout = a.timeout, r.responseType = a.responseType);"withCredentials" in r && (r.withCredentials = !!a.withCredentials);this.setHeaders(r, m);c ? r.send(c) : r.send();
            } catch (Zb) {
                this.error(Zb);
            }
        };a.prototype.serializeBody = function (a, c) {
            if (!a || "string" === typeof a || z.FormData && a instanceof z.FormData) return a;if (c) {
                var b = c.indexOf(";");-1 !== b && (c = c.substring(0, b));
            }switch (c) {case "application/x-www-form-urlencoded":
                    return Object.keys(a).map(function (b) {
                        return encodeURIComponent(b) + "\x3d" + encodeURIComponent(a[b]);
                    }).join("\x26");case "application/json":
                    return JSON.stringify(a);default:
                    return a;}
        };a.prototype.setHeaders = function (a, c) {
            for (var b in c) {
                c.hasOwnProperty(b) && a.setRequestHeader(b, c[b]);
            }
        };a.prototype.getHeader = function (a, c) {
            for (var b in a) {
                if (b.toLowerCase() === c.toLowerCase()) return a[b];
            }
        };
        a.prototype.setupEvents = function (a, c) {
            function b(a) {
                var c = b.subscriber,
                    d = b.progressSubscriber,
                    e = b.request;d && d.error(a);var f;try {
                    f = new Kb(this, e);
                } catch (La) {
                    f = La;
                }c.error(f);
            }function d(a) {}function g(a) {
                var b = g.subscriber,
                    c = g.progressSubscriber,
                    d = g.request;if (4 === this.readyState) {
                    var e = 1223 === this.status ? 204 : this.status,
                        f = "text" === this.responseType ? this.response || this.responseText : this.response;0 === e && (e = f ? 200 : 0);if (400 > e) c && c.complete(), b.next(a), b.complete();else {
                        c && c.error(a);a = void 0;try {
                            a = new ra("ajax error " + e, this, d);
                        } catch (wf) {
                            a = wf;
                        }b.error(a);
                    }
                }
            }var h = c.progressSubscriber;a.ontimeout = b;b.request = c;b.subscriber = this;b.progressSubscriber = h;if (a.upload && "withCredentials" in a) {
                if (h) {
                    var _k;_k = function k(a) {
                        _k.progressSubscriber.next(a);
                    };z.XDomainRequest ? a.onprogress = _k : a.upload.onprogress = _k;_k.progressSubscriber = h;
                }var _m;_m = function m(a) {
                    var b = _m.progressSubscriber,
                        c = _m.subscriber,
                        d = _m.request;b && b.error(a);var e;try {
                        e = new ra("ajax error", this, d);
                    } catch (La) {
                        e = La;
                    }c.error(e);
                };a.onerror = _m;_m.request = c;_m.subscriber = this;_m.progressSubscriber = h;
            }a.onreadystatechange = d;d.subscriber = this;d.progressSubscriber = h;d.request = c;a.onload = g;g.subscriber = this;g.progressSubscriber = h;g.request = c;
        };a.prototype.unsubscribe = function () {
            var a = this.xhr;!this.done && a && 4 !== a.readyState && "function" === typeof a.abort && a.abort();c.prototype.unsubscribe.call(this);
        };return a;
    }(m),
        Jb = function () {
        return function (c, a, b) {
            this.originalEvent = c;this.xhr = a;this.request = b;this.status = a.status;this.responseType = a.responseType || b.responseType;this.response = rb(this.responseType, a);
        };
    }();qb.prototype = Object.create(Error.prototype);var ra = qb,
        Kb = function Kb(c, a) {
        ra.call(this, "ajax timeout", c, a);this.name = "AjaxTimeoutError";return this;
    },
        Cf = Object.freeze({ ajax: O.create, AjaxResponse: Jb, AjaxError: ra, AjaxTimeoutError: Kb }),
        Df = { url: "", deserializer: function deserializer(c) {
            return JSON.parse(c.data);
        }, serializer: function serializer(c) {
            return JSON.stringify(c);
        } },
        Lb = function (c) {
        function a(a, d) {
            var b = c.call(this) || this;if (a instanceof n) b.destination = d, b.source = a;else {
                d = b._config = Mc({}, Df);b._output = new v();if ("string" === typeof a) d.url = a;else for (var f in a) {
                    a.hasOwnProperty(f) && (d[f] = a[f]);
                }if (!d.WebSocketCtor && WebSocket) d.WebSocketCtor = WebSocket;else if (!d.WebSocketCtor) throw Error("no WebSocket constructor can be found");b.destination = new X();
            }return b;
        }h(a, c);a.prototype.lift = function (b) {
            var c = new a(this._config, this.destination);c.operator = b;c.source = this;return c;
        };a.prototype._resetState = function () {
            this._socket = null;this.source || (this.destination = new X());this._output = new v();
        };a.prototype.multiplex = function (a, c, e) {
            var b = this;return new n(function (d) {
                try {
                    b.next(a());
                } catch (u) {
                    d.error(u);
                }var f = b.subscribe(function (a) {
                    try {
                        e(a) && d.next(a);
                    } catch (L) {
                        d.error(L);
                    }
                }, function (a) {
                    return d.error(a);
                }, function () {
                    return d.complete();
                });return function () {
                    try {
                        b.next(c());
                    } catch (u) {
                        d.error(u);
                    }f.unsubscribe();
                };
            });
        };a.prototype._connectSocket = function () {
            var a = this,
                c = this._config,
                e = c.WebSocketCtor,
                f = c.protocol,
                g = c.url,
                c = c.binaryType,
                h = this._output,
                k = null;try {
                this._socket = k = f ? new e(g, f) : new e(g), c && (this._socket.binaryType = c);
            } catch (r) {
                h.error(r);
                return;
            }var n = new t(function () {
                a._socket = null;k && 1 === k.readyState && k.close();
            });k.onopen = function (b) {
                if (a._socket) {
                    var c = a._config.openObserver;c && c.next(b);b = a.destination;a.destination = m.create(function (b) {
                        if (1 === k.readyState) try {
                            var c = a._config.serializer;k.send(c(b));
                        } catch (ac) {
                            a.destination.error(ac);
                        }
                    }, function (b) {
                        var c = a._config.closingObserver;c && c.next(void 0);b && b.code ? k.close(b.code, b.reason) : h.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }"));
                        a._resetState();
                    }, function () {
                        var b = a._config.closingObserver;b && b.next(void 0);k.close();a._resetState();
                    });b && b instanceof X && n.add(b.subscribe(a.destination));
                } else k.close(), a._resetState();
            };k.onerror = function (b) {
                a._resetState();h.error(b);
            };k.onclose = function (b) {
                a._resetState();var c = a._config.closeObserver;c && c.next(b);b.wasClean ? h.complete() : h.error(b);
            };k.onmessage = function (b) {
                try {
                    var c = a._config.deserializer;h.next(c(b));
                } catch ($b) {
                    h.error($b);
                }
            };
        };a.prototype._subscribe = function (a) {
            var b = this,
                c = this.source;if (c) return c.subscribe(a);this._socket || this._connectSocket();this._output.subscribe(a);a.add(function () {
                var a = b._socket;0 === b._output.observers.length && (a && 1 === a.readyState && a.close(), b._resetState());
            });return a;
        };a.prototype.unsubscribe = function () {
            var a = this._socket;a && 1 === a.readyState && a.close();this._resetState();c.prototype.unsubscribe.call(this);
        };return a;
    }(Ea),
        Ef = Object.freeze({ webSocket: function webSocket(c) {
            return new Lb(c);
        }, WebSocketSubject: Lb }),
        Ff = Object.freeze({
        fromFetch: function fromFetch(c, a) {
            return new n(function (b) {
                var d = new AbortController(),
                    e = d.signal,
                    f = !0,
                    g = !1;a ? (a.signal && a.signal.addEventListener("abort", function () {
                    e.aborted || d.abort();
                }), a.signal = e) : a = { signal: e };fetch(c, a).then(function (a) {
                    f = !1;b.next(a);b.complete();
                }).catch(function (a) {
                    f = !1;g || b.error(a);
                });return function () {
                    g = !0;f && d.abort();
                };
            });
        }
    });k.operators = vf;k.testing = yf;k.ajax = Cf;k.webSocket = Ef;k.fetch = Ff;k.Observable = n;k.ConnectableObservable = vb;k.GroupedObservable = Fa;k.observable = V;k.Subject = v;k.BehaviorSubject = wb;k.ReplaySubject = X;k.AsyncSubject = U;k.asapScheduler = qa;k.asyncScheduler = y;k.queueScheduler = xb;k.animationFrameScheduler = $c;k.VirtualTimeScheduler = Ab;k.VirtualAction = Ia;k.Scheduler = Ga;k.Subscription = t;k.Subscriber = m;k.Notification = w;k.pipe = ua;k.noop = D;k.identity = J;k.isObservable = function (c) {
        return !!c && (c instanceof n || "function" === typeof c.lift && "function" === typeof c.subscribe);
    };k.ArgumentOutOfRangeError = K;k.EmptyError = ca;k.ObjectUnsubscribedError = E;k.UnsubscriptionError = Y;k.TimeoutError = ya;k.bindCallback = Sa;k.bindNodeCallback = Ta;k.combineLatest = function () {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }var b = a = null;A(c[c.length - 1]) && (b = c.pop());"function" === typeof c[c.length - 1] && (a = c.pop());1 === c.length && x(c[0]) && (c = c[0]);return Z(c, b).lift(new Ja(a));
    };k.concat = aa;k.defer = Aa;k.empty = S;k.forkJoin = function () {
        for (var c = [], a = 0; a < arguments.length; a++) {
            c[a] = arguments[a];
        }if (1 === c.length) {
            var b = c[0];if (x(b)) return ja(b, null);if (sa(b) && Object.getPrototypeOf(b) === Object.prototype) return c = Object.keys(b), ja(c.map(function (a) {
                return b[a];
            }), c);
        }if ("function" === typeof c[c.length - 1]) {
            var d = c.pop(),
                c = 1 === c.length && x(c[0]) ? c[0] : c;return ja(c, null).pipe(B(function (a) {
                return d.apply(void 0, a);
            }));
        }return ja(c, null);
    };k.from = G;k.fromEvent = Za;k.fromEventPattern = ab;k.generate = function (c, a, b, d, e) {
        var f, g;1 == arguments.length ? (g = c.initialState, a = c.condition, b = c.iterate, f = c.resultSelector || J, e = c.scheduler) : void 0 === d || A(d) ? (g = c, f = J, e = d) : (g = c, f = d);return new n(function (c) {
            var d = g;if (e) return e.schedule(bc, 0, { subscriber: c, iterate: b, condition: a, resultSelector: f, state: d });do {
                if (a) {
                    var h = void 0;
                    try {
                        h = a(d);
                    } catch (r) {
                        c.error(r);break;
                    }if (!h) {
                        c.complete();break;
                    }
                }h = void 0;try {
                    h = f(d);
                } catch (r) {
                    c.error(r);break;
                }c.next(h);if (c.closed) break;try {
                    d = b(d);
                } catch (r) {
                    c.error(r);break;
                }
            } while (1);
        });
    };k.iif = function (c, a, b) {
        void 0 === a && (a = T);void 0 === b && (b = T);return Aa(function () {
            return c() ? a : b;
        });
    };k.interval = function (c, a) {
        void 0 === c && (c = 0);void 0 === a && (a = y);if (!W(c) || 0 > c) c = 0;a && "function" === typeof a.schedule || (a = y);return new n(function (b) {
            b.add(a.schedule(cc, c, { subscriber: b, counter: 0, period: c }));return b;
        });
    };k.merge = bb;k.never = function () {
        return Cb;
    };k.of = ha;k.onErrorResumeNext = Ba;k.pairs = function (c, a) {
        return a ? new n(function (b) {
            var d = Object.keys(c),
                e = new t();e.add(a.schedule(dc, 0, { keys: d, index: 0, subscriber: b, subscription: e, obj: c }));return e;
        }) : new n(function (a) {
            for (var b = Object.keys(c), e = 0; e < b.length && !a.closed; e++) {
                var f = b[e];c.hasOwnProperty(f) && a.next([f, c[f]]);
            }a.complete();
        });
    };k.partition = function (c, a, b) {
        return [I(a, b)(new n(ia(c))), I(cb(a, b))(new n(ia(c)))];
    };k.race = db;k.range = function (c, a, b) {
        void 0 === c && (c = 0);
        return new n(function (d) {
            void 0 === a && (a = c, c = 0);var e = 0,
                f = c;if (b) return b.schedule(gc, 0, { index: e, count: a, start: c, subscriber: d });do {
                if (e++ >= a) {
                    d.complete();break;
                }d.next(f++);if (d.closed) break;
            } while (1);
        });
    };k.throwError = xa;k.timer = eb;k.using = function (c, a) {
        return new n(function (b) {
            var d;try {
                d = c();
            } catch (g) {
                b.error(g);return;
            }var e;try {
                e = a(d);
            } catch (g) {
                b.error(g);return;
            }var f = (e ? G(e) : T).subscribe(b);return function () {
                f.unsubscribe();d && d.unsubscribe();
            };
        });
    };k.zip = fb;k.scheduled = Wa;k.EMPTY = T;k.NEVER = Cb;k.config = C;Object.defineProperty(k, "__esModule", { value: !0 });
});
//# sourceMappingURL=rxjs.umd.min.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(58)))

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContourLine = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//等高线分析 类
var ContourLine = exports.ContourLine = function (_DasClass) {
  _inherits(ContourLine, _DasClass);

  //========== 构造方法 ==========
  function ContourLine(options, oldparam) {
    _classCallCheck(this, ContourLine);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (ContourLine.__proto__ || Object.getPrototypeOf(ContourLine)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = options.viewer;

    //地球材质相关
    _this._contourShow = Cesium.defaultValue(options.show, true); //是否显示等高线
    _this._contourSpacing = Cesium.defaultValue(options.spacing, 100.0);
    _this._contourWidth = Cesium.defaultValue(options.width, 1.5);
    _this._contourColor = Cesium.defaultValue(options.color, Cesium.Color.RED.clone());

    //地表渲染效果类型:无nono, 高程 elevation, 坡度slope, 坡向aspect
    _this._shadingType = Cesium.defaultValue(options.shadingType, "none");
    _this.elevationRamp = [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0];
    _this.slopeRamp = [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0];
    _this.aspectRamp = [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0];
    _this.minHeight = -414.0; // approximate dead sea elevation
    _this.maxHeight = 8777.0; // approximate everest elevation

    //裁剪区域相关
    _this.floodVar = Cesium.defaultValue(options.floodVar, [0, 0, 0, 500]); //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
    _this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);
    _this.rect_flood = Cesium.defaultValue(options.rect_flood, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]); //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
    _this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
    _this._show = Cesium.defaultValue(options.show, true);

    if (options.positions && options.positions.length > 0) _this.setPositions(options.positions);
    return _this;
  }

  //========== 对外属性 ==========
  //分析参数


  _createClass(ContourLine, [{
    key: "setPositions",

    //========== 方法 ==========

    //初始化没传顶点，后面设置顶点
    value: function setPositions(positions) {
      this._positions = positions;

      if (!positions || positions.length == 0) return;

      this._prepareFlood(positions);
      this._setFloodVar();
      this._startFlood();

      this.updateMaterial();
    }

    //与处理顶点数组

  }, {
    key: "_prepareFlood",
    value: function _prepareFlood(arr) {
      this.ym_pos_arr = arr;
      var len = arr.length;
      if (len == 0) return;

      this.ym_max_index = len;
      var minX = arr[0].x;
      var minY = arr[0].y;
      var minZ = arr[0].z;
      var maxX = arr[0].x;
      var maxY = arr[0].y;
      var maxZ = arr[0].z;
      for (var i = 0; i < len; i++) {
        if (arr[i]) {
          this.ym_pos_x[i] = arr[i].x;
          this.ym_pos_y[i] = arr[i].y;
          this.ym_pos_z[i] = arr[i].z;

          if (arr[i].x > maxX) {
            maxX = arr[i].x;
          }
          if (arr[i].x < minX) {
            minX = arr[i].x;
          }

          if (arr[i].y > maxY) {
            maxY = arr[i].y;
          }
          if (arr[i].y < minY) {
            minY = arr[i].y;
          }

          if (arr[i].z > maxZ) {
            maxZ = arr[i].z;
          }
          if (arr[i].z < minZ) {
            minZ = arr[i].z;
          }
        } else {
          this.ym_pos_x[i] = 0.0;
          this.ym_pos_y[i] = 0.0;
          this.ym_pos_z[i] = 0.0;
        }
      }
      var chaNum = this._boundingSwell;
      this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
    }
    //设置高度

  }, {
    key: "_setFloodVar",
    value: function _setFloodVar() {
      this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
    }
    //开始

  }, {
    key: "_startFlood",
    value: function _startFlood() {
      this.globeAnalysis.floodVar[0] = this.floodVar[0];
      this.globeAnalysis.floodVar[1] = this.floodVar[1];
      this.globeAnalysis.ym_pos_x = this.ym_pos_x;
      this.globeAnalysis.ym_pos_y = this.ym_pos_y;
      this.globeAnalysis.ym_pos_z = this.ym_pos_z;
      this.globeAnalysis.rect_flood = this.rect_flood;
      this.globeAnalysis.ym_pos_arr = this.ym_pos_arr;
      this.globeAnalysis.ym_max_index = this.ym_max_index;
      this.globeAnalysis.globe = false;
      this.globeAnalysis.showElseArea = true;
      this.viewer.scene.globe.material = Cesium.Material.fromType("ElevationContour");
    }

    //===================

  }, {
    key: "updateMaterial",
    value: function updateMaterial() {
      if (!this.positions || this.positions.length == 0) return;

      var material;
      var contourUniforms;
      var shadingUniforms;

      var _shadingType = this._shadingType;
      if (this._contourShow) {
        if (_shadingType === "elevation") {
          material = this.getElevationContourMaterial();
          shadingUniforms = material.materials.elevationRampMaterial.uniforms;
          shadingUniforms.minimumHeight = this.minHeight;
          shadingUniforms.maximumHeight = this.maxHeight;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType === "slope") {
          material = this.getSlopeContourMaterial();
          shadingUniforms = material.materials.slopeRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType === "aspect") {
          material = this.getAspectContourMaterial();
          shadingUniforms = material.materials.aspectRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else {
          material = Cesium.Material.fromType("ElevationContour");
          contourUniforms = material.uniforms;
        }
        contourUniforms.width = this._contourWidth;
        contourUniforms.spacing = this._contourSpacing;
        contourUniforms.color = this._contourColor;
      } else if (_shadingType === "elevation") {
        material = Cesium.Material.fromType("ElevationRamp");
        shadingUniforms = material.uniforms;
        shadingUniforms.minimumHeight = this.minHeight;
        shadingUniforms.maximumHeight = this.maxHeight;
      } else if (_shadingType === "slope") {
        material = Cesium.Material.fromType("SlopeRamp");
        shadingUniforms = material.uniforms;
      } else if (_shadingType === "aspect") {
        material = Cesium.Material.fromType("AspectRamp");
        shadingUniforms = material.uniforms;
      }
      if (_shadingType !== "none") {
        shadingUniforms.image = this.getColorRamp(_shadingType);

        if (!this.viewer.scene.globe.enableLighting) {
          this.viewer.scene.globe.enableLighting = true;
          var now = new Date();
          now.setHours(10);
          this.viewer.clock.currentTime = Cesium.JulianDate.fromDate(new Date(now));
          this.hasResetEnableLighting = true;
        }
      }
      this.contourUniforms = contourUniforms;
      this.viewer.scene.globe.material = material;
    }
  }, {
    key: "getColorRamp",
    value: function getColorRamp(_shadingType) {
      var ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;
      var ctx = ramp.getContext("2d");

      var values;
      if (_shadingType === "elevation") {
        values = this.elevationRamp;
      } else if (_shadingType === "slope") {
        values = this.slopeRamp;
      } else if (_shadingType === "aspect") {
        values = this.aspectRamp;
      }

      var grd = ctx.createLinearGradient(0, 0, 100, 0);
      grd.addColorStop(values[0], "#000000"); //black
      grd.addColorStop(values[1], "#2747E0"); //blue
      grd.addColorStop(values[2], "#D33B7D"); //pink
      grd.addColorStop(values[3], "#D33038"); //red
      grd.addColorStop(values[4], "#FF9742"); //orange
      grd.addColorStop(values[5], "#ffd700"); //yellow
      grd.addColorStop(values[6], "#ffffff"); //white

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);

      return ramp;
    }
  }, {
    key: "getElevationContourMaterial",
    value: function getElevationContourMaterial() {
      // Creates a composite material with both elevation shading and contour lines
      return new Cesium.Material({
        fabric: {
          type: "ElevationColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            elevationRampMaterial: {
              type: "ElevationRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }, {
    key: "getSlopeContourMaterial",
    value: function getSlopeContourMaterial() {
      // Creates a composite material with both slope shading and contour lines
      return new Cesium.Material({
        fabric: {
          type: "SlopeColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            slopeRampMaterial: {
              type: "SlopeRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? slopeRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, slopeRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }, {
    key: "getAspectContourMaterial",
    value: function getAspectContourMaterial() {
      // Creates a composite material with both aspect shading and contour lines
      return new Cesium.Material({
        fabric: {
          type: "AspectColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            aspectRampMaterial: {
              type: "AspectRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? aspectRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, aspectRampMaterial.alpha)"
          }
        },
        translucent: false
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.positions = null;
      this.contourUniforms = null;
      this.viewer.scene.globe.material = null;
      this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();

      if (this.hasResetEnableLighting) {
        this.viewer.scene.globe.enableLighting = false;
        this.viewer.clock.currentTime = Cesium.JulianDate.now();
        delete this.hasResetEnableLighting;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      _get(ContourLine.prototype.__proto__ || Object.getPrototypeOf(ContourLine.prototype), "destroy", this).call(this);
    }
  }, {
    key: "globeAnalysis",
    get: function get() {
      return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
    }
  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this._positions = val;
      this.setPositions(val);
    }

    //地表渲染效果类型:无nono, 高程 elevation, 坡度slope, 坡向aspect

  }, {
    key: "shadingType",
    get: function get() {
      return this._shadingType;
    },
    set: function set(val) {
      this._shadingType = val;
      this.updateMaterial();
    }

    //是否显示等高线

  }, {
    key: "show",
    get: function get() {
      return this._contourShow;
    },
    set: function set(val) {
      this._contourShow = val;
      this.updateMaterial();
    }

    //等高线 线宽

  }, {
    key: "width",
    get: function get() {
      return this._contourWidth;
    },
    set: function set(val) {
      this._contourWidth = val;
      if (this.contourUniforms) this.contourUniforms.width = val;
    }
    //等高线 间隔

  }, {
    key: "spacing",
    get: function get() {
      return this._contourSpacing;
    },
    set: function set(val) {
      this._contourSpacing = val;
      if (this.contourUniforms) this.contourUniforms.spacing = val;
    }
    //等高线 颜色

  }, {
    key: "color",
    get: function get() {
      return this._contourColor;
    },
    set: function set(val) {
      this._contourColor = val;
      if (this.contourUniforms) this.contourUniforms.color = val;
    }
  }]);

  return ContourLine;
}(_DasClass2.DasClass);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShadowAnalyse = undefined;

var _extends2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _pShineTexture = __webpack_require__(168);

var _voxel = __webpack_require__(169);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //阴影率分析类


var ShadowAnalyse = exports.ShadowAnalyse = function (_DasClass) {
  _inherits(ShadowAnalyse, _DasClass);

  function ShadowAnalyse(options, oldparam) {
    _classCallCheck(this, ShadowAnalyse);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (ShadowAnalyse.__proto__ || Object.getPrototypeOf(ShadowAnalyse)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends2({
        viewer: options
      }, oldparam);
    }
    _this._positions = options.positions;
    _this._viewer = options.viewer;
    _this._scene = _this._viewer.scene;
    _this._options = options;
    _this._currentDate = Cesium.defaultValue(options.currentDate, new Date("2021-05-20"));
    _this._startTime = Cesium.defaultValue(options.startTime, 0);
    _this._endTime = Cesium.defaultValue(options.endTime, 8);
    _this._timeSpacing = Cesium.defaultValue(options.timeSpacing, 30);
    _this._width = Cesium.defaultValue(options.width, 2);
    _this._radius = Cesium.defaultValue(options.radius, 2);
    _this._spacing = Cesium.defaultValue(options.spacing, 0.1 * _this._width);
    _this._extrudeHeight = Cesium.defaultValue(options.extrudeHeight, 20);
    _this._baseHeight = Cesium.defaultValue(options.baseHeight, 20);
    _this._depthStep = Cesium.defaultValue(options.depthStep, 40);
    _this._widthStep = Cesium.defaultValue(options.widthStep, 40);
    _this._heightStep = Cesium.defaultValue(options.heightStep, 4);
    _this.textureState = false;
    _this._bound = new Cesium.BoundingRectangle();
    _this._type = Cesium.defaultValue(options.type, "point");
    _this._showAnimate = Cesium.defaultValue(options.showAnimate, true);
    _this._alpha = Cesium.defaultValue(options.alpha, false);
    _this._showCurrent = Cesium.defaultValue(options.showCurrent, false);
    _this._alpha = Cesium.defaultValue(options.alpha, false);
    _this._filterValue = Cesium.defaultValue(options.filterValue, 0);
    _this._oitEnable = Cesium.defaultValue(options.oitEnable, false);
    _this._alphaScale = Cesium.defaultValue(options.alphaScale, 1);
    _this.initlize();
    return _this;
  }

  _createClass2(ShadowAnalyse, [{
    key: "_extends",
    value: function _extends(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }, {
    key: "getdf",
    value: function getdf(target) {
      if (target) {
        if (target.__esModule) {
          return target;
        } else {
          return { default: target };
        }
      }
    }
  }, {
    key: "setbinddf",
    value: function setbinddf(e, t, n) {
      return t in e ? getdf(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = n, e;
    }
  }, {
    key: "polygonMannage",
    value: function polygonMannage() {
      function createPosition() {
        this.viewMatrix = Cesium.Matrix4.IDENTITY, this.inverseViewMatrix = Cesium.Matrix4.IDENTITY, this.frustum = new Cesium.OrthographicOffCenterFrustum(), this.positionCartographic = new Cesium.Cartographic(), this.positionWC = new Cesium.Cartesian3(), this.directionWC = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Z), this.upWC = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y), this.rightWC = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_X), this.viewProjectionMatrix = Cesium.Matrix4.IDENTITY;
      }
      function CreateFramebuffer(polygon, context, width, height) {
        width = parseInt(width), height = parseInt(height);
        var colorTexture = polygon._colorTexture,
            differentType = !Cesium.defined(colorTexture) || colorTexture.width !== width || colorTexture.height !== height;
        Cesium.defined(polygon.framebuffer) && !differentType || (destroyDepthStencilTexture(polygon), destroyBuffer(polygon), addTexture(polygon, context, width, height), addFramebuffer(polygon, context));
      }
      function destroyDepthStencilTexture(polygon) {
        !(polygon._colorTexture && !polygon._colorTexture.isDestroyed() && polygon._colorTexture.destroy()) && polygon._colorTexture && (polygon._colorTexture.destroy = function () {
          console.log("ddd");
        }, polygon._colorTexture = void 0), polygon._depthStencilTexture = polygon._depthStencilTexture && !polygon._depthStencilTexture.isDestroyed() && polygon._depthStencilTexture.destroy();
      }
      function destroyBuffer(polygon) {
        polygon._framebuffer = polygon._framebuffer && !polygon._framebuffer.isDestroyed() && polygon._framebuffer.destroy();
      }
      function addTexture(polygon, context, width, height) {
        polygon._clearPassState = new Cesium.PassState(context), polygon._colorTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.RGBA,
          pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
          sampler: new Cesium.Sampler({
            minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
            magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
          })
        }), polygon._depthStencilTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
          pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8,
          sampler: new Cesium.Sampler({
            minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
            magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
          })
        });
      }
      function addFramebuffer(polygon, context) {
        polygon.framebuffer = new Cesium.Framebuffer({
          context: context,
          colorTextures: [polygon._colorTexture],
          depthStencilTexture: polygon._depthStencilTexture,
          destroyAttachments: false
        });
      }
      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
          }
        }return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
      }();
      createPosition.prototype.clone = function (position) {
        Cesium.Matrix4.clone(position.viewMatrix, this.viewMatrix);
        Cesium.Matrix4a.clone(position.inverseViewMatrix, this.inverseViewMatrix);
        this.frustum = position.frustum.clone(this.frustum);
        Cesium.Cartographic.clone(position.positionCartographic, this.positionCartographic);
        Cesium.Cartesian3.clone(position.positionWC, this.positionWC);
        Cesium.Cartesian3.clone(position.directionWC, this.directionWC);
        Cesium.Cartesian3.clone(position.upWC, this.upWC);
        Cesium.Cartesian3.clone(position.rightWC, this.rightWC);
      };
      var p = function () {
        var e = function e() {
          this._framebuffer = void 0;
          this._colorTexture = void 0;
          this._depthStencilTexture = void 0;
          this._clearPassState = void 0;
          this._passState = void 0;
          this.canvas = void 0;
          this._polygons = [];
          this._polygonDrawCommands = [];
          this._clearCommand = new Cesium.ClearCommand({
            depth: 1,
            color: new Cesium.Color(0, 0, 0, 0)
          });
          this._clearPassState = void 0;
          this._width = 4096;
          this._height = 4096;
          this._textureChangedEvent = new Cesium.Event();
          this._viewport = new Cesium.BoundingRectangle();
          this._bound = new Cesium.Cartesian4();
          this._camera = new createPosition();
          this.canvas = void 0;
          this._polygonDirty = false;
          this._PolygonDirtyEvent = new Cesium.Event();
          this._matrix = void 0;
          this._scratchBS = new Cesium.BoundingSphere();
          this._autoMatrix = void 0;
          this._globe = [];
          this._uniforMap = {};
          this._drawCommand = null;
        };
        return (0, _createClass)(e, [{
          key: "getTextureChangedEvent",
          value: function value() {
            return this._textureChangedEvent;
          }
        }, {
          key: "update",
          value: function value(context, t, n) {
            this._polygonDirty && (this._autoMatrixDirty && (this._computeAutoMatrix(), this._autoMatrixDirty = false), this._PolygonDirtyEvent.raiseEvent(), this._polygonDirty = false, this.updateCommands(context), this.executeCommands(this, context, t, n));
          }
        }, {
          key: "updateCommands",
          value: function value(context) {
            if (0 != this._polygons.length) {
              this._polygonDrawCommands = [];
              var Locations = {
                position: 0
              },
                  MatrixClone = Cesium.Matrix4.clone(this.getMatrix());
              Cesium.Matrix4.inverse(MatrixClone, MatrixClone);
              for (var BoundingRectangle = new Cesium.BoundingRectangle(), PositionArr = [], polygonIndex = 0; polygonIndex < this._polygons.length; polygonIndex++) {
                var polygonItem = this._polygons[polygonIndex],
                    tempGeometry = Cesium.PolygonGeometry.createGeometry(polygonItem);
                if (tempGeometry) {
                  for (var positionValue = tempGeometry.attributes.position.values, positionIndex = 0; positionIndex < positionValue.length / 3; positionIndex++) {
                    var tempPosition = new Cesium.Cartesian3(0, 0, 0);
                    tempPosition.x = positionValue[3 * positionIndex], tempPosition.y = positionValue[3 * positionIndex + 1], tempPosition.z = positionValue[3 * positionIndex + 2], Cesium.Matrix4.multiplyByPoint(MatrixClone, tempPosition, tempPosition), PositionArr.push(tempPosition), tempGeometry.attributes.position.values[3 * positionIndex] = tempPosition.x, tempGeometry.attributes.position.values[3 * positionIndex + 1] = tempPosition.y, tempGeometry.attributes.position.values[3 * positionIndex + 2] = tempPosition.z;
                  }
                  var boundingSphere = Cesium.BoundingSphere.transform(tempGeometry.boundingSphere, MatrixClone, boundingSphere);
                  tempGeometry.boundingSphere = boundingSphere;
                  var fromGeometry = Cesium.VertexArray.fromGeometry({
                    context: context,
                    geometry: tempGeometry,
                    attributeLocations: Locations,
                    bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
                    interleave: !0
                  }),
                      fromCache = Cesium.ShaderProgram.fromCache({
                    context: context,
                    vertexShaderSource: "attribute vec3 position; \n                                                                    varying float das3d_depth; \n                                                                    void main() \n                                                                    { \n                                                                        das3d_depth = position.z; \n                                                                        gl_Position = czm_projection*vec4(position.xy, 0.0, 1.0); \n                                                                    }",
                    fragmentShaderSource: "vec3 das3d_packDepth(float depth) \n                                                                        { \n                                                                        vec3 enc = vec3(1.0, 255.0, 65025.0) * depth; \n                                                                        enc = fract(enc); \n                                                                        enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0); \n                                                                        return enc; \n                                                                        } \n \n                                                                        varying float das3d_depth; \n                                                                        void main() \n                                                                        { \n                                                                        // das3d_depth_range -3000.0 - 3000.0;  \n                                                                        float fDepth = (das3d_depth + 3000.0) / 6000.0; \n                                                                        gl_FragColor.rgb = vec3(1.0,1.0,0.0); \n                                                                        gl_FragColor.a = 1.0; \n                                                                        }"
                  }),
                      renderState = new Cesium.RenderState();
                  renderState.depthTest.enabled = !0, renderState.cull.enabled = !0, renderState.cull.face = Cesium.CullFace.BACK;
                  var uniforMap = this._uniforMap,
                      polygonDrawCommandItem = new Cesium.DrawCommand({
                    boundingVolume: boundingSphere,
                    modelMatrix: new Cesium.Matrix4(),
                    primitiveType: Cesium.PrimitiveType.TRIANGLES,
                    vertexArray: fromGeometry,
                    shaderProgram: fromCache,
                    uniformMap: uniforMap,
                    renderState: renderState,
                    pass: Cesium.Pass.COMPUTE
                  });
                  this._polygonDrawCommands.push(polygonDrawCommandItem), this._drawCommand = polygonDrawCommandItem;
                }
              }
              Cesium.BoundingRectangle.fromPoints(PositionArr, BoundingRectangle), this._bound.x = BoundingRectangle.x, this._bound.y = BoundingRectangle.y + BoundingRectangle.height, this._bound.z = BoundingRectangle.x + BoundingRectangle.width, this._bound.w = BoundingRectangle.y, this.updateFrustum(this._bound.x, this._bound.y, this._bound.z, this._bound.w);
            } else this.updateFrustum(0, 0, 0, 0);
          }
        }, {
          key: "getMatrix",
          value: function value() {
            return this._matrix ? this._matrix : (this._autoMatrixDirty && (this._computeAutoMatrix(), this._autoMatrixDirty = !1), this._autoMatrix);
          }
        }, {
          key: "_computeAutoMatrix",
          value: function value() {
            var pointsArr = [];
            if (this._polygons.forEach(function (polygonItem) {
              var polygonPositions = polygonItem._polygonHierarchy.positions;
              Array.prototype.push.apply(pointsArr, polygonPositions);
            }), pointsArr.length > 0) {
              var t = Cesium.BoundingSphere.fromPoints(pointsArr, this._scratchBS);
              pointsArr.length = 0;
              var ellipsoid = this._ellipsoid || Cesium.Ellipsoid.WGS84,
                  scaleToGeodeticSurface = ellipsoid.scaleToGeodeticSurface(t.center);
              this._scratchAutoMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(scaleToGeodeticSurface, ellipsoid, this._scratchAutoElevationMatrix), this._autoMatrix = this._scratchAutoMatrix;
            } else this._autoMatrix = void 0;
          }
        }, {
          key: "updateFrustum",
          value: function value(frustumLeft, frustumTop, frustumRight, frustumBottom) {
            this._camera.frustum.left = frustumLeft, this._camera.frustum.top = frustumTop, this._camera.frustum.right = frustumRight, this._camera.frustum.bottom = frustumBottom;
          }
        }, {
          key: "addPolygon",
          value: function value(polygon) {
            return this._polygons.push(polygon), this.refreshPolygons(), this._polygons.length - 1;
          }
        }, {
          key: "removePolygon",
          value: function value(polygon) {
            var t = this._polygons.indexOf(polygon);
            t > -1 && (this._polygons.splice(t, 1), this.refreshPolygons());
          }
        }, {
          key: "removeAllPolygon",
          value: function value() {
            this._polygonDrawCommands = [], this._polygons = [], this.refreshPolygons();
          }
        }, {
          key: "refreshPolygons",
          value: function value() {
            this._polygonDirty = true, this._autoMatrixDirty = true;
          }
        }, {
          key: "executeCommands",
          value: function value(polygon, context, width, height) {
            var colorTexture = polygon._colorTexture,
                TextureType = !Cesium.defined(colorTexture) || colorTexture.width !== width || colorTexture.height !== height;
            Cesium.defined(polygon._framebuffer) && !TextureType || (CreateFramebuffer(polygon, context, width, height), polygon._textureChangedEvent.raiseEvent(polygon._colorTexture)), Cesium.defined(this._passState) || (this._passState = new Cesium.PassState(context), this._passState.framebuffer = this.framebuffer, this._passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height));
            var uniformState = context.uniformState;
            uniformState.updateCamera(this._camera), this._clearCommand.framebuffer = this.framebuffer, this._clearCommand.execute(context, this._clearPassState);
            for (var l = 0; l < this._polygonDrawCommands.length; l++) {
              var polygonDrawCommandItem = this._polygonDrawCommands[l];
              uniformState.updatePass(polygonDrawCommandItem.pass), polygonDrawCommandItem.framebuffer = this.framebuffer, polygonDrawCommandItem.execute(context, this._passState);
            }
          }
        }, {
          key: "isDestroyed",
          value: function value() {
            return false;
          }
        }, {
          key: "destroy",
          value: function value() {
            return destroyDepthStencilTexture(this), destroyBuffer(this), Cesium.destroyObject(this);
          }
        }, {
          key: "attachTileset",
          value: function value(polygon) {
            -1 === this._globe.indexOf(polygon) && (polygon._PolygonTexture = this, this._globe.push(polygon));
          }
        }, {
          key: "detachTileset",
          value: function value(tileset) {
            var hasTileset = this._globe.indexOf(tileset);
            if (-1 !== hasTileset) return tileset._flattenedPolygonTexture = void 0, void this._globe.splice(hasTileset, 1);
          }
        }]), e;
      }();
      return p;
    }
  }, {
    key: "initlize",
    value: function initlize() {
      this.offsetTime = this._timeSpacing / 60;
      this._totalNumber = (this._endTime - this._startTime) / this.offsetTime;
      this.setOit();
      this._polygonTextureW = 256;
      this._polygonTextureH = 256;
      this.computeRectangle();
      this.getRange();
      this.createVoxel();
      this._viewer.scene.primitives.add(this);
    }
  }, {
    key: "setTime",
    value: function setTime() {
      var that = this,
          sTime = this._startTime - 8,
          eTime = this._endTime - 8;
      this.julianDate = Cesium.JulianDate.fromDate(new Date(this._currentDate.toJSON())), Cesium.JulianDate.addHours(this.julianDate, sTime, this.julianDate), this._viewer.clock.currentTime = this.julianDate;
      var i = 0;
      var r = setInterval(function () {
        sTime < eTime ? (i += 1, i > 60 && (i = 0), sTime += that.offsetTime, that.setCurrenTime()) : (clearInterval(r), that.sunshineTexture && that.sunshineTexture.stop());
      }, 10);
    }
  }, {
    key: "setCurrenTime",
    value: function setCurrenTime() {
      Cesium.JulianDate.addHours(this.julianDate, this.offsetTime, this.julianDate), this._viewer.clock.currentTime = this.julianDate, this.sunshineTexture && this.sunshineTexture.setUpdateState();
    }
  }, {
    key: "setOit",
    value: function setOit() {
      this._oitEnable ? this._viewer.scene.view.oit || (this._viewer.scene.view.oit = new Cesium.OIT(this._viewer.scene.context)) : this._viewer.scene.view.oit = void 0;
    }
  }, {
    key: "getRange",
    value: function getRange() {
      var plgfbo = new this.polygonMannage();
      this._plgfbo = new plgfbo(), this._plgfbo.removeAllPolygon();
      var e = Cesium.PolygonGeometry.fromPositions({
        positions: this._positions
      });
      this._plgfbo.addPolygon(e), this._plgfbo.attachTileset(this._scene.globe);
    }
  }, {
    key: "computeRectangle",
    value: function computeRectangle() {
      for (var positions = this._positions, t = null, n = null, i = null, r = null, positionsIndex = 0; positionsIndex < positions.length; positionsIndex++) {
        var a = Cesium.Cartographic.fromCartesian(positions[positionsIndex]),
            s = [Cesium.Math.toDegrees(a.longitude), Cesium.Math.toDegrees(a.latitude)];
        t ? (t = Math.min(t, s[0]), n = Math.max(n, s[0]), i = Math.min(i, s[1]), r = Math.max(r, s[1])) : (t = s[0], n = s[0], i = s[1], r = s[1]);
      }
      this._boundingSphere = new Cesium.BoundingSphere();
      var l = Cesium.Ellipsoid.WGS84,
          u = (n + t) / 2,
          h = (r + i) / 2,
          c = this._baseHeight + this._extrudeHeight / 2,
          d = new Cesium.Cartesian3.fromDegrees(u, h, c),
          f = new Cesium.Cartesian3.fromDegrees(t, i, this._baseHeight);
      Cesium.Cartesian3.clone(d, this._boundingSphere.center), this._boundingSphere.radius = .5 * Cesium.Cartesian3.magnitude(d);
      var p = Cesium.Transforms.eastNorthUpToFixedFrame(f, l, new Cesium.Matrix4()),
          m = Cesium.Matrix4.inverse(p, new Cesium.Matrix4());
      this.locPos = [];
      for (var positionsIndex = 0; positionsIndex < positions.length; positionsIndex++) {
        var g = Cesium.Matrix4.multiplyByPoint(m, positions[positionsIndex], new Cesium.Cartesian3());
        this.locPos.push(g);
      }
      var v = Cesium.BoundingRectangle.fromPoints(this.locPos, new Cesium.BoundingRectangle());
      this._bound = v, this._matrix = p;
    }
  }, {
    key: "getShadowRate",
    value: function getShadowRate(e) {
      var t = Cesium.Matrix4.inverse(this._matrix, new Cesium.Matrix4()),
          n = Cesium.Matrix4.multiplyByPoint(t, e, new Cesium.Cartesian3()),
          i = this._viewer.scene.context.readPixels({
        x: 0,
        y: 0,
        width: this.sunshineTexture._textureWidth,
        height: this.sunshineTexture._textureHeight,
        framebuffer: this.sunshineTexture._framebuffer
      }),
          r = [];
      this.maxDistance = this.voxel.maxDistance / 2;
      for (var o = new Cesium.Cartesian4(1, 1 / 255, 1 / 65025, 1 / 16581375), a = {
        minDis: this.voxel.maxDistance,
        currentPos: null,
        shadowRate: null,
        num: 0
      }, s = this.voxel._coordPositions.length, l = 0; l < 4 * s; l += 4) {
        var u = new Cesium.Cartesian4(i[l], i[l + 1], i[l + 2], i[l + 3]),
            h = Cesium.Cartesian4.dot(u, o) / 255,
            c = Cesium.Cartesian3.distance(n, this.voxel._coordPositions[l / 4]);
        c < a.minDis && (a.minDis = c, a.currentPos = this.voxel._coordPositions[l / 4], a.shadowRate = 1 - h, a.num = l / 4), r.push(h);
      }
      var d = -1;
      return null !== a.currentPos && (Cesium.Matrix4.multiplyByPoint(this._matrix, a.currentPos, a.currentPos), d = a), d;
    }
  }, {
    key: "createVoxel",
    value: function createVoxel() {
      var that = this;
      //var vvvpbobj= new vvvpb();
      this.voxelOptions = that._extends(this._options, {
        bound: this._bound,
        matrix: this._matrix,
        plgfbo: this._plgfbo,
        baseHeight: this._baseHeight,
        extrudeHeight: this._extrudeHeight,
        boundingSphere: this._boundingSphere
      }), this.voxel = new _voxel.voxel(this.voxelOptions);
    }
  }, {
    key: "getShadowRateTexture",
    value: function getShadowRateTexture() {
      var that = this;
      var e = that._extends(this.voxelOptions, {
        showCurrent: this._showCurrent
      });
      //var sTexture = new pShineTexture();
      //this.sunshineTexture = new wwwpb.default(e),
      this.sunshineTexture = new _pShineTexture.pShineTexture(e), this.sunshineTexture.spacing = this._totalNumber, this.sunshineTexture.getVertexArray(this.voxel), this.setTime();
    }
  }, {
    key: "getIJKRange",
    value: function getIJKRange() {
      var that = this;
      return new c.default(function (t, n) {
        that.voxel ? t(1) : n(-1);
      });
    }
  }, {
    key: "update",
    value: function update(e) {
      this._plgfbo.update(this._viewer.scene.context, this._polygonTextureW, this._polygonTextureH), this.voxel && this.voxel.isDestroyed || this.sunshineTexture && this.sunshineTexture.isDestroyed || (this.voxel && this.voxel._computePositionFinish && !this.sunshineTexture && this.getShadowRateTexture(), this.sunshineTexture && this.voxel && (this._showAnimate ? (this.voxel.dataTexture = this.sunshineTexture, this.voxelUpdate = !0) : this.sunshineTexture._isFinish && !this.voxelUpdate && (console.log("纹理赋值给体素"), this.voxel.dataTexture = this.sunshineTexture, this.voxelUpdate = !0)), this.voxel && this.voxelUpdate && !this.voxel.isDestroyed && this.sunshineTexture && !this.sunshineTexture.isDestroyed && (this.voxel._changeState && ("point" == this.voxel._type ? this.sunshineTexture._sunshineCommand.vertexArray = this.voxel.lineVertexArrayPoint : this.sunshineTexture._sunshineCommand.vertexArray = this.voxel.lineVertexArrayCube), this.voxel.update(e)), !this.sunshineTexture || this.sunshineTexture._isFinish || this.sunshineTexture.isDestroyed || this.sunshineTexture.update(e));
    }
  }, {
    key: "remove",
    value: function remove() {
      this.voxel && (this.voxel.destroy(), this.voxel = null), this.sunshineTexture && (this.sunshineTexture.destroy(), this.sunshineTexture = null);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.remove();
      this.initlize();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.oitEnable = false;
      this.voxel && (this.voxel.destroy(), this.voxel = null), this.sunshineTexture && (this.sunshineTexture.destroy(), this.sunshineTexture = null), this._viewer.scene.primitives.remove(this);
    }

    //对外属性

  }, {
    key: "scene",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._scene = val;
      }
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      if (val) {
        this._height = Number(val);
      }
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    },
    set: function set(val) {
      if (val) {
        this._startTime = Number(val);
        this.reset();
      }
    }
  }, {
    key: "endTime",
    get: function get() {
      return this._endTime;
    },
    set: function set(val) {
      if (val) {
        this._endTime = Number(val);
        this.reset();
      }
    }
  }, {
    key: "showAnimate",
    get: function get() {
      return this._showAnimate;
    },
    set: function set(val) {
      if (val) {
        this._showAnimate = Boolean(val);
      }
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      if (val) {
        this._type = val;
        if (this.voxel) {
          this.voxel.type = val;
        }
      }
    }
  }, {
    key: "showCurrent",
    get: function get() {
      return this._showCurrent;
    },
    set: function set(val) {
      if (val) {
        this._showCurrent = Boolean(val);
        if (this.sunshineTexture) {
          this.sunshineTexture.showCurrent = val;
        }
      }
    }
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      if (val) {
        this._alpha = Boolean(val);
        if (this.voxel) {
          this.voxel.alpha = this._alpha;
        }
      }
    }
  }, {
    key: "filterValue",
    get: function get() {
      return this._filterValue;
    },
    set: function set(val) {
      if (val) {
        this._filterValue = Number(val);
        if (this.voxel) {
          this.voxel.filterValue = this._filterValue;
        }
      }
    }
  }, {
    key: "extrudeHeight",
    get: function get() {
      return this._extrudeHeight;
    },
    set: function set(val) {
      if (val) {
        this._extrudeHeight = Number(val);
        if (this.voxel) {
          this.voxel.extrudeHeight = this._extrudeHeight;
        }
        this.reset();
      }
    }
  }, {
    key: "ijk",
    get: function get() {
      return this._ijk;
    },
    set: function set(val) {
      this._ijk = val;
      if (this.voxel) {
        this.voxel.ijk = this._ijk;
      }
    }
  }, {
    key: "baseHeight",
    get: function get() {
      return this._baseHeight;
    },
    set: function set(val) {
      this._baseHeight = val;
      this.reset();
    }
  }, {
    key: "currentDate",
    get: function get() {
      return this._extrudeHeight;
    },
    set: function set(val) {
      this._extrudeHeight = val;
      this.reset();
    }
  }, {
    key: "oitEnable",
    get: function get() {
      return this._oitEnable;
    },
    set: function set(val) {
      this._oitEnable = val;
      this.setOit();
    }
  }, {
    key: "alphaScale",
    get: function get() {
      return this._alphaScale;
    },
    set: function set(val) {
      if (this.voxel) {
        this.voxel.alphaScale = Number(val);
      }
    }
  }]);

  return ShadowAnalyse;
}(_DasClass2.DasClass);

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pShineTexture = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //polygon管理对象,用于阴影分析


var pShineTexture = exports.pShineTexture = function (_DasClass) {
  _inherits(pShineTexture, _DasClass);

  function pShineTexture(options, oldparam) {
    _classCallCheck(this, pShineTexture);

    var _this = _possibleConstructorReturn(this, (pShineTexture.__proto__ || Object.getPrototypeOf(pShineTexture)).call(this, options));

    if (!Cesium.defined(options.viewer)) {
      throw new Cesium.DeveloperError("options.viewer is required.");
    }
    if (!Cesium.defined(options.matrix)) {
      throw new Cesium.DeveloperError("options.matrix is required.");
    }
    _this._viewer = options.viewer;
    _this._scene = _this._viewer.scene;
    _this.isUpdateColor = false;
    _this.context = _this._scene.context;
    _this._matrix = options.matrix;
    _this._textureWidth = Cesium.defaultValue(options.textureWidth, 1024);
    _this._textureHeight = Cesium.defaultValue(options.textureHeight, 1024);
    _this._modelMatrix = Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY);
    _this.modelMatrix = new Cesium.Matrix4();
    _this.vertexArrayFinished = false;
    _this._spacing = Cesium.defaultValue(options.spacing, 10);
    _this._showCurrent = Cesium.defaultValue(options.showCurrent, false);
    _this._export3DDataFile = Cesium.defaultValue(options.export3DDataFile, false);
    _this._isUpdate = false;
    _this._isFinish = false;
    _this.a = 0;
    return _this;
  }

  _createClass(pShineTexture, [{
    key: "setbinddf",
    value: function setbinddf(e, t, n) {
      var getdf = function getdf(e, t, n) {
        return Object.defineProperty(e, t, n);
      };
      return t in e ? getdf(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = n, e;
    }
  }, {
    key: "getVertexArray",
    value: function getVertexArray(e) {
      "point" == e._type ? (this.aPositionTypedArray = e.aPositionTypedArrayPoint, this.rangeTypedArray = e.rangeTypedArrayPoint, this.indexTypedArray = e.indexTypedArrayPoint, this.a_coordTypedArray = e.a_coordTypedArrayPoint, this.lineVertexArray = e.lineVertexArrayPoint) : (this.aPositionTypedArray = e.aPositionTypedArrayCube, this.rangeTypedArray = e.rangeTypedArrayCube, this.indexTypedArray = e.indexTypedArrayCube, this.a_coordTypedArray = e.a_coordTypedArrayCube, this.lineVertexArray = e.lineVertexArrayCube);
      for (var t = this.lineVertexArray.indexBuffer._buffer.buffer.length, n = 1; t / Math.pow(256 * n, 2) > 1;) {
        n++;
      }this._textureWidth = 256 * n, this._textureHeight = 256 * n, this.attributeLocations = e.attributeLocations, this.vertexArrayFinished = !0, this.createCommand();
    }
  }, {
    key: "createCommand",
    value: function createCommand() {
      var e,
          that = this,
          n = this._scene.context,
          i = Cesium.RenderState.fromCache({
        cull: {
          enabled: !1
        },
        depthTest: {
          enabled: !0
        }
      }),
          r = (e = {
        u_matrix: function u_matrix() {
          return that._matrix;
        },
        shadowMap_texture: function shadowMap_texture() {
          return that._viewer.shadowMap._shadowMapTexture;
        },
        shadowMap_cascadeSplits: function shadowMap_cascadeSplits() {
          return that._viewer.shadowMap._shadowMapTexture;
        },
        shadowMap_textureCube: function shadowMap_textureCube() {
          return that._viewer.shadowMap._shadowMapTexture;
        },
        shadowMap_matrix: function shadowMap_matrix() {
          return that._viewer.shadowMap._shadowMapMatrix;
        }
      }, (0, this.setbinddf)(e, "shadowMap_cascadeSplits", function () {
        return that._viewer.shadowMap._cascadeSplits;
      }), (0, this.setbinddf)(e, "shadowMap_cascadeMatrices", function () {
        return that._viewer.shadowMap._cascadeMatrices;
      }), (0, this.setbinddf)(e, "shadowMap_lightDirectionEC", function () {
        return that._viewer.shadowMap._lightDirectionEC;
      }), (0, this.setbinddf)(e, "shadowMap_lightPositionEC", function () {
        return that._viewer.shadowMap._lightPositionEC;
      }), (0, this.setbinddf)(e, "shadowMap_cascadeDistances", function () {
        return that._viewer.shadowMap._cascadeDistances;
      }), (0, this.setbinddf)(e, "u_shadowRateTex", function () {
        return that._shadowRateTexture;
      }), (0, this.setbinddf)(e, "u_showCurrent", function () {
        return that._showCurrent;
      }), (0, this.setbinddf)(e, "u_spaceing", function () {
        return that._spacing;
      }), e),
          a = Cesium.ShaderProgram.fromCache({
        context: n,
        vertexShaderSource: "uniform mat4 u_matrix;\n                                                  attribute vec4 aPosition;\n                                                  attribute vec4 a_range;\n                                                  attribute vec2 a_coord;\n                                                  varying vec4 v_positionEC;\n                                                  varying vec4 v_range;\n                                                  varying vec2 v_coord;\n                                                  void main() \n                                                  {\n                                                      gl_Position = vec4(a_coord*2.0-1.0,0.5,1.0);\n                                                      // v_positionEC = czm_modelView * u_matrix * aPosition;\n                                                      v_positionEC = czm_view*czm_model*u_matrix * aPosition;\n                                                      v_coord = a_coord;\n                                                      gl_PointSize = 1.0;\n                                                  }",
        fragmentShaderSource: "#ifdef GL_EXT_frag_depth\n                              #extension GL_EXT_frag_depth:enable\n                              #endif\n                              #ifdef GL_OES_standard_derivatives\n                              #extension GL_OES_standard_derivatives:enable\n                              #endif\n                              varying vec4 v_positionEC;\n                              varying vec2 v_coord;\n                              uniform sampler2D shadowMap_texture;\n                              uniform sampler2D u_shadowRateTex;\n                              uniform bool u_showCurrent;\n                              uniform float u_spaceing;\n                              float unpackDepth(const in vec4 rgba_depth) {\n                                const vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0));\n                                float depth = dot(rgba_depth, bitShifts);\n                                return depth;\n                              }\n                              vec4 packDepth(float depth) {\n                                  const vec4 bias = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n                                  float r = depth;\n                                  float g = fract(r * 255.0);\n                                  float b = fract(g * 255.0);\n                                  float a = fract(b * 255.0);\n                                  vec4 color = vec4(r, g, b, a);\n                                  return color - (color.yzww * bias);\n                                }\n                              void main()\n                              {\n                                  vec2 vTexcoord = v_coord;\n                                  gl_FragColor = texture2D(u_shadowRateTex,vTexcoord);\n                                  vec4 positionEC = v_positionEC;\n                                  float depth = -positionEC.z; //Get the cascade based on the eye-space depth\n                                  float maxDepth = shadowMap_cascadeSplits[1].w; //Stop early if the eye depth exceeds the last cascad\n                                  if(depth > maxDepth)\n                                  {\n                                     return;\n                                  }\n                                  vec4 weights = czm_cascadeWeights(depth); //Transform position into the cascade\n                                  vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC;\n                                  vec2 texCoords = shadowPosition.xy;\n                                  float shadowDepth = shadowPosition.z;\n                                  float visibility = czm_shadowDepthCompare(shadowMap_texture,texCoords,shadowDepth);   // Get visibility\n                                  if(u_showCurrent){\n                                    if(visibility < 0.001){\n                                      gl_FragColor = packDepth(0.99);//\u8FD9\u4E2A\u662F\u6709\u9634\u5F71\u7684\n                                    }\n                                    else{\n                                       gl_FragColor = packDepth(0.01);//\u8FD9\u4E2A\u662F\u6CA1\u6709\u9634\u5F71\u7684\n                                      }\n                                  }else{\n                                    if(visibility > .001)//\u7D2F\u8BA1\u7684\u5149\u7167\u7167\u5C04\u7684\u6B21\u6570\n                                    {\n                                        float oldRate = unpackDepth(gl_FragColor);\n                                        float shadowRate = clamp(oldRate,0.0,1.0) + 3.8/u_spaceing;\n                                        gl_FragColor = packDepth(shadowRate);\n                                    }\n                                  }\n                              }",
        attributeLocations: this.attributeLocations
      });
      this._shaderprogram = a, this.sunshineVertexArray = this.lineVertexArray, this._initBoundingSphere = Cesium.BoundingSphere.fromVertices(this.aPositionTypedArray);
      var s = Cesium.PrimitiveType.POINTS,
          l = this._scene.frameState,
          u = l.mapProjection.ellipsoid;
      this._sunshineCommand = new Cesium.DrawCommand({
        vertexArray: this.sunshineVertexArray,
        primitiveType: s,
        renderState: i,
        shaderProgram: a,
        uniformMap: r,
        owner: this,
        pass: Cesium.Pass.OPAQUE,
        modelMatrix: new Cesium.Matrix4(),
        boundingVolume: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, u.maximumRadius),
        cull: !0
      });
    }
  }, {
    key: "createFrameBuffer",
    value: function createFrameBuffer() {
      this._framebuffer = new Cesium.Framebuffer({
        context: this.context,
        colorTextures: [this._colorTexture],
        depthStencilTexture: this._depthStencilTexture,
        destroyAttachments: !1
      });
    }
  }, {
    key: "destroyTexture",
    value: function destroyTexture() {
      !(this._colorTexture && !this._colorTexture.isDestroyed() && this._colorTexture.destroy()) && this._colorTexture && (this._colorTexture.destroy = function () {
        console.log("已销毁");
      }, this._colorTexture = void 0);
    }
  }, {
    key: "destroyFramebuffer",
    value: function destroyFramebuffer() {
      this._framebuffer = this._framebuffer && !this._framebuffer.isDestroyed() && this._framebuffer.destroy();
    }
  }, {
    key: "createTexture",
    value: function createTexture(e, t) {
      this._colorTexture = new Cesium.Texture({
        context: this.context,
        width: e,
        height: t,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      }), this._depthStencilTexture = new Cesium.Texture({
        context: this.context,
        width: e,
        height: t,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      }), this._shadowRateTexture = new Cesium.Texture({
        context: this.context,
        width: e,
        height: t,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        }),
        flipY: !1
      });
    }
  }, {
    key: "updateTextureAndFrameBuffer",
    value: function updateTextureAndFrameBuffer(width, height) {
      var n = this._colorTexture,
          i = !Cesium.defined(n) || n.width !== width || n.height !== height;
      Cesium.defined(this._framebuffer) && !i || (this.destroyTexture(), this.destroyFramebuffer(), this.createTexture(this._textureWidth, this._textureHeight), this.createFrameBuffer(), this._clear());
    }
  }, {
    key: "_clear",
    value: function _clear() {
      this._clearCommand = new Cesium.ClearCommand({
        depth: 1,
        color: new Cesium.Color(0, 0, 0, 0)
      }), this._clearPassState = new Cesium.PassState(this.context);
    }
  }, {
    key: "setUpdateState",
    value: function setUpdateState() {
      this._isUpdate = true;
    }
    //a = 0;

  }, {
    key: "stop",
    value: function stop() {
      this._export3DDataFile && this.makeUpShdowRateJson();
    }
  }, {
    key: "makeUpShdowRateJson",
    value: function makeUpShdowRateJson() {
      this.shadowRatepixels ? (this.content = this.shadowRatepixels, this.fileName = e || "shadowRateAnliles", this.makeUpJsonFile()) : console.error("请先生成阴影数据");
    }
  }, {
    key: "makeUpJsonFile",
    value: function makeUpJsonFile() {
      var e = document.createElement("a");
      e.download = this.fileName;
      var t = new Blob([this.content], {
        type: "application/octet-stream"
      });
      e.href = URL.createObjectURL(t), document.body.appendChild(e), e.click(), document.body.removeChild(e);
    }
  }, {
    key: "executeCommands",
    value: function executeCommands() {
      var e = this.context,
          t = this._textureWidth,
          n = this._textureHeight,
          i = this._colorTexture,
          r = !Cesium.defined(i) || i.width !== t || i.height !== n;
      Cesium.defined(this._framebuffer) && !r || this.updateTextureAndFrameBuffer(this._textureWidth, this._textureHeight), Cesium.defined(this._passState) || (this._passState = new Cesium.PassState(e), this._passState.framebuffer = this._framebuffer, this._passState.viewport = new Cesium.BoundingRectangle(0, 0, this._textureWidth, this._textureHeight));
      var o = e.uniformState;
      this._clearCommand.framebuffer = this._framebuffer, this._clearCommand.execute(e, this._clearPassState), Cesium.Matrix4.equals(this.modelMatrix, this._modelMatrix) || (Cesium.Matrix4.clone(this.modelMatrix, this._modelMatrix), this._sunshineCommand.modelMatrix = Cesium.Matrix4.IDENTITY), o.updatePass(Cesium.Pass.OPAQUE), this._sunshineCommand.execute(e, this._passState), this._sunshineCommand.framebuffer = this._framebuffer;
      var s = e.readPixels({
        x: 0,
        y: 0,
        width: this._textureWidth,
        height: this._textureHeight,
        framebuffer: this._framebuffer
      });
      this.shadowRatepixels = s, this._shadowRateTexture.copyFrom({
        width: this._textureWidth,
        height: this._textureHeight,
        arrayBufferView: s
      }), this.a++;
    }
  }, {
    key: "update",
    value: function update() {
      this._isUpdate && (this.executeCommands(), this._isUpdate = !1);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return this.destroyTexture(), this.destroyFramebuffer(), this._shadowRateTexture.destroy(), Cesium.destroyObject(this);
    }
    //========== 对外属性 ==========
    //scene

  }, {
    key: "scene",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._scene = val;
      }
    }

    //height

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      if (val) {
        this._height = Number(val);
      }
    }
  }, {
    key: "spacing",
    get: function get() {
      return this._spacing;
    },
    set: function set(val) {
      if (val !== 0) {
        this._spacing = Number(val);
      }
    }
  }, {
    key: "showCurrent",
    get: function get() {
      return this._showCurrent;
    },
    set: function set(val) {
      this._showCurrent = Boolean(val);
    }
  }]);

  return pShineTexture;
}(_DasClass2.DasClass);

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.voxel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //体素对象,用于阴影分析


var voxel = exports.voxel = function (_DasClass) {
  _inherits(voxel, _DasClass);

  function voxel(options, oldparam) {
    _classCallCheck(this, voxel);

    var _this = _possibleConstructorReturn(this, (voxel.__proto__ || Object.getPrototypeOf(voxel)).call(this, options));

    if (!Cesium.defined(options.viewer)) {
      throw new Cesium.DeveloperError("options.viewer is required.");
    }
    if (!Cesium.defined(options.bound)) {
      throw new Cesium.DeveloperError("options.bound is required.");
    }
    if (!Cesium.defined(options.matrix)) {
      throw new Cesium.DeveloperError("options.matrix is required.");
    }
    _this.options = options;
    _this._positions = options.positions;
    _this._viewer = options.viewer;
    _this._bound = options.bound;
    _this._matrix = options.matrix;
    _this._type = Cesium.defaultValue(options.type, "point");
    _this._radius = Cesium.defaultValue(options.radius, 10);
    _this._show = Cesium.defaultValue(options.show, true);
    _this._showAnimate = Cesium.defaultValue(options.showAnimate, true);
    _this._width = Cesium.defaultValue(options.width, 2);
    _this._depth = Cesium.defaultValue(options.depth, 2);
    _this._height = Cesium.defaultValue(options.height, 2);
    _this._extrudeHeight = Cesium.defaultValue(options.extrudeHeight, 20);
    _this._spacing = Cesium.defaultValue(options.spacing, 0);
    _this._widthNumber = Cesium.defaultValue(options.widthNumber, null);
    _this._heightNumber = Cesium.defaultValue(options.heightNumber, null);
    _this._depthNumber = Cesium.defaultValue(options.depthNumber, null);
    _this._heightStep = Cesium.defaultValue(options.heightStep, 2);
    _this._baseHeight = Cesium.defaultValue(options.baseHeight, 4);
    _this._textureWidth = Cesium.defaultValue(options.textureWidth, 1024);
    _this._textureHeight = Cesium.defaultValue(options.textureHidth, 1024);
    _this._ijkHide = Cesium.defaultValue(options.ijkHide, []);
    _this._ijk = Cesium.defaultValue(options.ijk, {
      i: new Cesium.Cartesian2(0, 1),
      j: new Cesium.Cartesian2(0, 1),
      k: new Cesium.Cartesian2(0, 1)
    });
    _this._i = Cesium.defaultValue(_this._ijk.i, new Cesium.Cartesian2(0, 1));
    _this._j = Cesium.defaultValue(_this._ijk.j, new Cesium.Cartesian2(0, 1));
    _this._k = Cesium.defaultValue(_this._ijk.k, new Cesium.Cartesian2(0, 1));
    _this._customColor = Cesium.defaultValue(options.customColor, false);
    _this._alpha = Cesium.defaultValue(options.alpha, false);
    _this._filterValue = Cesium.defaultValue(options.filterValue, 0);
    _this._plgfbo = Cesium.defaultValue(options.plgfbo, {});
    _this._boundingSphere = Cesium.defaultValue(options.boundingSphere, new Cesium.Matrix4());
    _this._alphaScale = Cesium.defaultValue(options.alphaScale, 1);
    _this._export3DDataFile = Cesium.defaultValue(options.export3DDataFile, false);
    _this.ppb2 = "uniform mat4  u_matrix;\n                            uniform sampler2D u_image;\n                            uniform vec4 u_max;\n                            uniform bool u_show;\n                            uniform float u_pointSize;\n                            uniform vec3 u_IJK;\n                            uniform bool u_fifterIJk;\n                            uniform vec2 u_I;\n                            uniform vec2 u_J;\n                            uniform vec2 u_K;\n                            attribute vec4 aPosition;\n                            attribute vec4 a_color;\n                            attribute vec4 a_range;\n                            attribute vec3 a_normal;\n                            attribute vec2 a_coord;\n                            varying vec4 v_color;\n                            varying vec4 v_positionEC;\n                            varying vec4 v_range;\n                            varying vec3 v_normalEC;\n                            varying vec2 v_st;\n                            uniform sampler2D u_polygon;\n                            void main() \n                            {\n                                if(u_show){\n                                    vec2 st;\n                                    st.x = (a_range.x/u_max.x);\n                                    st.y = (a_range.y/u_max.y);\n                                    vec2 vTexcoord = a_coord.xy;\n                                    vec4 ijkshow = a_range;\n                                    v_normalEC = czm_normal * a_normal;\n                                    v_color = a_color;\n                                    v_range = ijkshow;\n                                    v_st = vTexcoord;\n                                    //ijkshow.w != 1.0; //\u5355\u4E2A\u7684\u9ED8\u8BA4\u4E0D\u663E\u793A        \n                                    if(u_fifterIJk){\n                                        bool isVisible = true;\n                                        if(u_I.x != -1.0 && u_I.y != -1.0){\n                                            if(ijkshow.x < u_I.x || ijkshow.x > u_I.y){\n                                                isVisible = false;\n                                            }\n                                        }\n                                        if(u_J.x != -1.0 && u_J.y != -1.0){\n                                            if(ijkshow.y < u_J.x || ijkshow.y > u_J.y){\n                                                isVisible = false;\n                                            }\n                                        }\n                                        if(u_K.x != -1.0 && u_K.y != -1.0){\n                                            if(ijkshow.z < u_K.x || ijkshow.z > u_K.y){\n                                                isVisible = false;\n                                            }\n                                        }\n                                        // if(ijkshow.x != u_IJK.x && ijkshow.y != u_IJK.y && ijkshow.z != u_IJK.z){\n                                        if(isVisible){\n                                            gl_Position =  u_matrix *  aPosition;\n                                            v_positionEC =   u_matrix *  aPosition;\n                                        }\n                                    }else{\n                                        gl_Position =  u_matrix *  aPosition;\n                                        v_positionEC =   u_matrix *  aPosition;\n                                        // gl_Position = czm_depthClampFarPlane(czm_modelViewProjection * u_matrix * aPosition) ;\n                                        // v_positionEC = (czm_modelView * u_matrix * aPosition);\n                                    }\n                                    #ifdef EXTRUDED_POINT \n                                        gl_PointSize = u_pointSize;//\u5207\u6362cube \u548Cpoint \u7684\u65F6\u5019\u9700\u8981\u6CE8\u610F\n                                    #endif\n                                }\n                            } ";
    _this.gpb2 = "#ifdef GL_EXT_frag_depth\n                        #extension GL_EXT_frag_depth:enable\n                        #endif\n                        #ifdef GL_OES_standard_derivatives\n                        #extension GL_OES_standard_derivatives:enable\n                        #endif\n                        uniform vec3 u_originalPosition;\n                        uniform vec4 u_cellConfig;\n                        varying vec4 v_color;\n                        varying vec4 v_positionEC;\n                        varying vec4 v_range;\n                        varying vec2 v_st;\n                        varying vec3 v_normalEC;\n                        uniform bool u_customColor;\n                        uniform sampler2D shadowMap_texture;\n                        uniform sampler2D u_image;\n                        uniform bool u_alphaState;\n                        uniform float u_filterValue;\n                        uniform float u_alphaScale;\n\n                        float unpackDepth(const in vec4 rgba_depth) {\n                            const vec4 bitShifts = vec4(1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0));\n                            float depth = dot(rgba_depth, bitShifts);\n                            return depth;\n                        }\n                        void main()\n                        {\n                            float dist = distance(gl_PointCoord,vec2(0.5,0.5));\n                            float shadowRate = unpackDepth(texture2D(shadowMap_texture,v_st));\n                            vec4 color = v_color;\n                            if(!u_customColor){\n                                color = texture2D(u_image, vec2(clamp(shadowRate,0.0,1.0),0.5)); \n                            }\n                            // #ifdef EXTRUDED_DATATEXTURE \n                            // color = texture2D(u_image, vec2(clamp(shadowRate,0.01,0.99),0.5)); \n                            // #endif\n                            #ifdef EXTRUDED_POINT \n                            if(dist < 0.5 ){//\u6B64\u5904\u9700\u8981\u5904\u7406\n                            #endif  \n                                vec3 positionToEyeEC = v_positionEC.xyz;\n                                vec3 normalEC = normalize(-v_normalEC);\n                            #ifdef FACE_FORWARD\n                                normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n                            #endif\n                                czm_materialInput materialInput;\n                                materialInput.normalEC = normalEC;\n                                materialInput.positionToEyeEC = positionToEyeEC;\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                material.diffuse = color.rgb;\n                            #ifdef FLAT\n                                gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n                                #else\n                                gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n                                #endif\n                                if(u_alphaState){//\u662F\u5426\u5F00\u542Falpha\n                                    gl_FragColor.a = 1.0 - clamp(shadowRate,0.0,1.0);\n                                    gl_FragColor.a *= u_alphaScale;\n                                    gl_FragColor.a = clamp(gl_FragColor.a,0.0,1.0);\n                                    if(gl_FragColor.a < u_filterValue){\n                                        discard;\n                                    }\n                                    if(u_filterValue == 1.0){\n                                        discard;\n                                    }\n                                }else{\n                                    float filterValue = 1.0 - clamp(shadowRate,0.0,1.0);\n                                    if( filterValue < u_filterValue){\n                                        discard;\n                                    }\n                                    if( u_filterValue == 1.0){\n                                        discard;\n                                    }\n                                }\n                            #ifdef EXTRUDED_POINT\n                            }else{\n                                discard;\n                            }\n                            #endif   \n \n                        }";
    _this.initParams();
    return _this;
  }

  _createClass(voxel, [{
    key: "initParams",
    value: function initParams() {
      var that = this;
      this.lookatDirect = "leftFront";
      this.indexarray = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
      this._modelMatrix = Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY);
      this.modelMatrix = new Cesium.Matrix4();
      this._height = this._depth = this._width;
      this._scene = this._viewer.scene;
      this.options.ijk ? this._fifterIJk = true : this._fifterIJk = false;
      this.dataTexture = {};
      this._image = Cesium.buildModuleUrl("Assets/Images/colors1.png");
      this._coordPositions = [];
      this.getColor();
      this._scratchBS = new Cesium.BoundingSphere();
      this.originalPosition = this._positions[0];
      this.showIJK = new Cesium.Cartesian4(1, 1, 2, 1);
      this.boundX = this._bound.x;
      this.boundY = this._bound.y;
      this.boundW = this._bound.width;
      this.boundH = this._bound.height;
      var t = [1, 0, 0];
      var n = [-1, 0, 0];
      var i = [0, 1, 0];
      var r = [0, -1, 0];
      var o = [0, 0, 1];
      var a = [0, 0, -1];
      this.normals = [].concat(a, a, a, a, r, r, r, r, i, i, i, i, n, n, n, n, t, t, t, t, o, o, o, o);
      this.attributeLocations = {
        aPosition: 0,
        aColor: 1,
        a_range: 2,
        a_normal: 3,
        a_coord: 4,
        a_positionCenter: 5
      };
      this._isUpdate = false;
      this._computePositionFinish = false;
      this._hideArray = [];
      if (this._ijkHide.length > 0) {
        this._hideArray = this._ijkHide.map(function (t) {
          return t[0] + t[1] * that._widthStep + t[2] * (that._widthStep * that._depthStep);
        });
      }
      this._polygonTextureW = 256;
      this._polygonTextureH = 256;
      var timer = setInterval(function () {
        if (that._plgfbo._colorTexture) {
          clearInterval(timer);
          that._polygonPixel = that._viewer.scene.context.readPixels({
            x: 0,
            y: 0,
            width: that._polygonTextureW,
            height: that._polygonTextureH,
            framebuffer: that._plgfbo.framebuffer
          });
          if (that._type == "point") {
            that.computePointPositions();
          }
          if (that._type == "cube") {
            that.computeVoxelPositions();
          }
        }
      }, 30);
    }
  }, {
    key: "setTextureWidthHeight",
    value: function setTextureWidthHeight() {
      var e = 0;
      if (this._type == "point") {
        e = this._depthStep * this._widthStep * this._heightStep;
      } else {
        e = this._depthStep * this._widthStep * this._heightStep * 36;
      }
      for (var t = 1; e / Math.pow(256 * t, 2) > 1;) {
        t++;
      }
      this._textureWidth = 256 * t;
      this._textureHeight = 256 * t;
    }
  }, {
    key: "isPolygon",
    value: function isPolygon(e) {
      var point = new Cesium.Cartesian2();
      point.x = (e.x - this.boundX) / this.boundW;
      point.y = (e.y - this.boundY) / this.boundH;
      var n = false;
      var i = parseInt(point.x * this._polygonTextureW) + parseInt(point.y * this._polygonTextureH) * this._polygonTextureW;
      return point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 && this._polygonPixel[4 * i + 4] > 0 && (n = !0), this._export3DDataFile && (n = !0), n;
    }
  }, {
    key: "computeVoxelPositions",
    value: function computeVoxelPositions() {
      this._widthStep = Cesium.defaultValue(this._widthNumber, parseInt(this._bound.width / (this._width + this._spacing)));
      this._depthStep = Cesium.defaultValue(this._depthNumber, parseInt(this._bound.height / (this._depth + this._spacing)));
      this._heightStep = parseInt(this._extrudeHeight / (this._height + this._spacing));
      var _spacing = this._spacing;
      this.setTextureWidthHeight();
      var aPositionTypedArrayCube = null,
          aPositionCenterTypedArrayCube = null,
          aColorTypedArrayCube = null,
          rangeTypedArrayCube = null,
          indexTypedArrayCube = null,
          a_coordTypedArrayCube = null,
          aNormaltypedArrayCube = null;
      var Step = this._depthStep * this._widthStep * this._heightStep * 24;
      aPositionTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * Step);
      aPositionCenterTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * Step);
      aColorTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * Step);
      rangeTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * Step);
      aNormaltypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 3 * this.normals.length * this._depthStep * this._widthStep * this._heightStep);
      a_coordTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 2 * Step);
      var StepSoc = 36 * this._depthStep * this._widthStep * this._heightStep;
      if (StepSoc >= Cesium.Math.SIXTY_FOUR_KILOBYTES) {
        indexTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_INT, StepSoc);
      } else {
        indexTypedArrayCube = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_SHORT, StepSoc);
      }

      // indexTypedArrayCube = StepSoc >= Cesium.Math.SIXTY_FOUR_KILOBYTES ? Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_INT, StepSoc) : Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_SHORT, StepSoc);
      var StepCartesian = new Cesium.Cartesian4(this._widthStep, this._depthStep, this._heightStep);
      var itemIndex = 0;
      this.maxDistance = this._width + _spacing;
      for (var heightStepIndex = 0; heightStepIndex < this._heightStep; heightStepIndex++) {
        for (var heightSh = (this._height + _spacing) * heightStepIndex, depthStepIndex = 0; depthStepIndex < this._depthStep; depthStepIndex++) {
          for (var depthSh = (this._depth + _spacing) * depthStepIndex, widthStepIndex = 0; widthStepIndex < this._widthStep; widthStepIndex++) {
            var Swidth = (this._width + _spacing) * widthStepIndex,
                y = this._hideArray.indexOf(itemIndex) < 0 ? 1 : 0,
                basePosition = new Cesium.Cartesian4(widthStepIndex, depthStepIndex, heightStepIndex, y),
                positionList = [];
            positionList[0] = new Cesium.Cartesian3(Swidth + this._width, depthSh, heightSh + this._height), positionList[1] = new Cesium.Cartesian3(Swidth, depthSh, heightSh + this._height), positionList[2] = new Cesium.Cartesian3(Swidth, depthSh, heightSh), positionList[3] = new Cesium.Cartesian3(Swidth + this._width, depthSh, heightSh), positionList[4] = new Cesium.Cartesian3(Swidth + this._width, depthSh + this._depth, heightSh), positionList[5] = new Cesium.Cartesian3(Swidth + this._width, depthSh + this._depth, heightSh + this._height), positionList[6] = new Cesium.Cartesian3(Swidth, depthSh + this._depth, heightSh + this._height), positionList[7] = new Cesium.Cartesian3(Swidth, depthSh + this._depth, heightSh);
            var w = Cesium.Cartesian3.midpoint(positionList[2], positionList[5], new Cesium.Cartesian3());
            if (this.isPolygon(w)) {
              for (var b = [positionList[7], positionList[4], positionList[3], positionList[2], positionList[2], positionList[3], positionList[0], positionList[1], positionList[4], positionList[7], positionList[6], positionList[5], positionList[7], positionList[2], positionList[1], positionList[6], positionList[3], positionList[4], positionList[5], positionList[0], positionList[1], positionList[0], positionList[5], positionList[6]], C = 0; C < b.length; C++) {
                var M = 4 * (itemIndex * b.length + C),
                    S = b[C],
                    T = S;
                aPositionTypedArrayCube[M] = T.x;
                aPositionTypedArrayCube[M + 1] = T.y;
                aPositionTypedArrayCube[M + 2] = T.z;
                aPositionTypedArrayCube[M + 3] = 1;
                aPositionCenterTypedArrayCube[M] = w.x;
                aPositionCenterTypedArrayCube[M + 1] = w.y;
                aPositionCenterTypedArrayCube[M + 2] = w.z;
                aPositionCenterTypedArrayCube[M + 3] = 1;
                rangeTypedArrayCube[M] = basePosition.x;
                rangeTypedArrayCube[M + 1] = basePosition.y;
                rangeTypedArrayCube[M + 2] = basePosition.z;
                rangeTypedArrayCube[M + 3] = basePosition.w;
                aColorTypedArrayCube[M] = basePosition.x / StepCartesian.x;
                aColorTypedArrayCube[M + 1] = basePosition.y / StepCartesian.y;
                aColorTypedArrayCube[M + 2] = 0;
                aColorTypedArrayCube[M + 3] = basePosition.x / StepCartesian.x;
                var E = 2 * (itemIndex * b.length + C);
                a_coordTypedArrayCube[E] = itemIndex % this._textureWidth / this._textureWidth + 1 / this._textureWidth * 0.5;
                a_coordTypedArrayCube[E + 1] = parseInt(itemIndex / this._textureWidth) / this._textureHeight + 1 / this._textureWidth * 0.5;
              }
              this._coordPositions[itemIndex] = w;
              for (var A = 0; A < this.indexarray.length; A++) {
                var itemA = itemIndex * this.indexarray.length + A;
                indexTypedArrayCube[itemA] = this.indexarray[A] + itemIndex * b.length;
              }
              for (var L = 0; L < this.normals.length; L++) {
                var itemL = itemIndex * this.normals.length + L;
                aNormaltypedArrayCube[itemL] = this.normals[L];
              }
              itemIndex++;
            }
          }
        }
      }this.aColorTypedArrayCube = aColorTypedArrayCube, this.aPositionTypedArrayCube = aPositionTypedArrayCube, this.aPositionCenterTypedArrayCube = aPositionCenterTypedArrayCube, this.rangeTypedArrayCube = rangeTypedArrayCube, this.indexTypedArrayCube = indexTypedArrayCube, this.aNormaltypedArrayCube = aNormaltypedArrayCube, this.a_coordTypedArrayCube = a_coordTypedArrayCube, this.updateCommand = true, this.cubesVao();
    }
  }, {
    key: "computePointPositions",
    value: function computePointPositions() {
      var spacing = this._spacing <= 0.1 ? 0.1 : this._spacing;
      this._widthStep = Cesium.defaultValue(this._widthNumber, parseInt(this._bound.width / spacing)), this._depthStep = Cesium.defaultValue(this._depthNumber, parseInt(this._bound.height / spacing)), this._heightStep = parseInt(this._extrudeHeight / spacing), this.maxDistance = spacing / 2, console.log(this._widthStep + ",this._widthStep", this._depthStep + ",this._depthStep", this._heightStep + ",this._heightStep"), this.setTextureWidthHeight();
      var t = null,
          n = null,
          i = null,
          r = null,
          o = null,
          a = null,
          s = null,
          l = this._depthStep * this._widthStep * this._heightStep;
      t = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * l), n = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * l), i = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * l), r = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 4 * l), s = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 3 * l), a = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 2 * l);
      var u = this._depthStep * this._widthStep * this._heightStep;
      o = u >= Cesium.Math.SIXTY_FOUR_KILOBYTES ? Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_INT, u) : Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.UNSIGNED_SHORT, u);
      for (var h = new Cesium.Cartesian4(this._widthStep, this._depthStep, this._heightStep), c = 0, f = !0, p = 0; p < this._heightStep; p++) {
        for (var m = 0; m < this._depthStep; m++) {
          for (var g = 0; g < this._widthStep; g++) {
            var v = this._hideArray.indexOf(c) < 0 ? 1 : 0,
                y = new Cesium.Cartesian4(g, m, p, v),
                _ = new Cesium.Cartesian3(spacing * g, spacing * m, spacing * p);
            if (this.isPolygon(_)) {
              f && (f = !1), a[2 * c] = (0, Math.fround)(c % this._textureWidth / this._textureWidth + 1 / this._textureWidth * .5), a[2 * c + 1] = (0, Math.fround)(parseInt(c / this._textureWidth) / this._textureHeight + 1 / this._textureHeight * .5);
              var x = 4 * c;
              t[x] = (0, Math.fround)(_.x), t[x + 1] = (0, Math.fround)(_.y), t[x + 2] = (0, Math.fround)(_.z), t[x + 3] = 1, n[x] = (0, Math.fround)(_.x), n[x + 1] = (0, Math.fround)(_.y), n[x + 2] = (0, Math.fround)(_.z), n[x + 3] = 1, this._coordPositions[c] = _, r[x] = y.x, r[x + 1] = y.y, r[x + 2] = y.z, r[x + 3] = y.w, i[x] = y.x / h.x, i[x + 1] = y.y / h.y, i[x + 2] = 0, i[x + 3] = y.x / h.x, o[c] = c, s[c] = this.normals[0], c++;
            }
          }
        }
      }this.aColorTypedArrayPoint = i;
      this.aPositionTypedArrayPoint = t;
      this.aPositionCenterTypedArrayPoint = n;
      this.rangeTypedArrayPoint = r;
      this.indexTypedArrayPoint = o;
      this.aNormaltypedArrayPoint = s;
      this.a_coordTypedArrayPoint = a;
      this.updateCommand = true;
      this.pointsVao();
    }
  }, {
    key: "transparentSort",
    value: function transparentSort() {
      var e, t, n, i;
      this.currentLookatDirect = null;
      var r = new Cesium.Cartesian3(this.boundX + this.boundW / 2, this.boundY + this.boundH / 2, 0),
          n = new Cesium.Cartesian3(this.boundX, this.boundY + this.boundH / 2, 0),
          e = new Cesium.Cartesian3(this.boundX + this.boundW, this.boundY + this.boundH / 2, 0),
          i = new Cesium.Cartesian3(this.boundX + this.boundW / 2, this.boundY, 0),
          t = new Cesium.Cartesian3(this.boundX + this.boundW / 2, this.boundY + this.boundH, 0),
          o = Cesium.Cartesian3.subtract(e, n, new Cesium.Cartesian3());
      o = Cesium.Cartesian3.normalize(o, new Cesium.Cartesian3());
      var a = Cesium.Cartesian3.subtract(t, i, new Cesium.Cartesian3());
      a = Cesium.Cartesian3.normalize(a, new Cesium.Cartesian3());
      var s = Cesium.Matrix4.inverse(this._matrix, new Cesium.Matrix4()),
          l = Cesium.Matrix4.multiplyByPoint(s, this._viewer.scene.camera.position, new Cesium.Cartesian3()),
          u = Cesium.Cartesian3.subtract(l, r, new Cesium.Cartesian3());
      u = Cesium.Cartesian3.normalize(u, new Cesium.Cartesian3());
      var h = Cesium.Cartesian3.dot(o, u),
          c = Cesium.Cartesian3.dot(a, u);
      return h < 0 && c < 0 && (this.currentLookatDirect = "leftFront"), h > 0 && c < 0 && (this.currentLookatDirect = "rightFront"), h > 0 && c > 0 && (this.currentLookatDirect = "rightBack"), h < 0 && c > 0 && (this.currentLookatDirect = "leftBack"), c < 0 && Math.abs(h) < 0.25 && (this.currentLookatDirect = "front"), c > 0 && Math.abs(h) < 0.25 && (this.currentLookatDirect = "back"), h < 0 && Math.abs(c) < 0.09 && (this.currentLookatDirect = "left"), h > 0 && Math.abs(c) < 0.09 && (this.currentLookatDirect = "right"), this.currentLookatDirect;
    }
  }, {
    key: "initindexBuffer",
    value: function initindexBuffer() {
      var e = this._depthStep * this._widthStep * this._heightStep;
      "cube" == this._type && (e *= 36);
      var t,
          n,
          i,
          r,
          o,
          a,
          s,
          l,
          u = null,
          c = null;
      if (!this.indexBuffer) {
        e >= Cesium.Math.SIXTY_FOUR_KILOBYTES ? (c = Cesium.ComponentDatatype.UNSIGNED_INT, u = Cesium.IndexDatatype.UNSIGNED_INT) : (c = Cesium.ComponentDatatype.UNSIGNED_SHORT, u = Cesium.IndexDatatype.UNSIGNED_SHORT), t = Cesium.ComponentDatatype.createTypedArray(c, e), n = Cesium.ComponentDatatype.createTypedArray(c, e), i = Cesium.ComponentDatatype.createTypedArray(c, e), r = Cesium.ComponentDatatype.createTypedArray(c, e), o = Cesium.ComponentDatatype.createTypedArray(c, e), a = Cesium.ComponentDatatype.createTypedArray(c, e), s = Cesium.ComponentDatatype.createTypedArray(c, e), l = Cesium.ComponentDatatype.createTypedArray(c, e);
        for (var dddpb2 = 0, f = 0; f < this._heightStep; f++) {
          for (var p = this._depthStep - 1, m = 0; m < this._depthStep; m++) {
            for (var g = this._widthStep - 1, v = 0; v < this._widthStep; v++) {
              var y = f * this._depthStep * this._widthStep + p * this._widthStep + g,
                  _ = f * this._depthStep * this._widthStep + p * this._widthStep + v,
                  x = f * this._depthStep * this._widthStep + m * this._widthStep + g,
                  w = f * this._depthStep * this._widthStep + m * this._widthStep + v,
                  b = 0,
                  C = 0,
                  M = 0,
                  S = 0,
                  T = parseInt(this._widthStep / 2),
                  E = parseInt(this._depthStep / 2);
              if (v < T) b = _, C = w;else {
                var A = this._widthStep - 1 - (v - T);
                b = f * this._depthStep * this._widthStep + p * this._widthStep + A, C = f * this._depthStep * this._widthStep + m * this._widthStep + A;
              }
              if (m < E) M = x, S = w;else {
                var P = this._depthStep - 1 - (m - E);
                M = f * this._depthStep * this._widthStep + P * this._widthStep + g, S = f * this._depthStep * this._widthStep + P * this._widthStep + v;
              }
              if ("cube" == this._type) for (var L = 0; L < this.indexarray.length; L++) {
                var D = dddpb2 * this.indexarray.length + L;
                t[D] = this.indexarray[L] + 24 * y, n[D] = this.indexarray[L] + 24 * _, i[D] = this.indexarray[L] + 24 * x, r[D] = this.indexarray[L] + 24 * w, o[D] = this.indexarray[L] + 24 * b, a[D] = this.indexarray[L] + 24 * C, s[D] = this.indexarray[L] + 24 * M, l[D] = this.indexarray[L] + 24 * S;
              } else {
                var I = dddpb2;
                t[I] = y, n[I] = _, i[I] = x, r[I] = w, o[I] = b, a[I] = C, s[I] = M, l[I] = S;
              }
              dddpb2++, g--;
            }
            p--;
          }
        }var R = this._scene.context;
        this.indexBuffer = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: t,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer1 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: n,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer2 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: i,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer3 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: r,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer4 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: o,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer5 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: a,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer6 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: s,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.indexBuffer7 = Cesium.Buffer.createIndexBuffer({
          context: R,
          typedArray: l,
          usage: Cesium.BufferUsage.STATIC_DRAW,
          indexDatatype: u
        });
        this.VertexArray = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer
        });
        this.VertexArray1 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer1
        });
        this.VertexArray2 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer2
        });
        this.VertexArray3 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer3
        });
        this.VertexArray4 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer4
        });
        this.VertexArray5 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer5
        });
        this.VertexArray6 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer6
        });
        this.VertexArray7 = new Cesium.VertexArray({
          context: R,
          attributes: this._drawVoxelCommand.vertexArray._attributes,
          indexBuffer: this.indexBuffer7
        });
      }
      var N = null;
      "leftFront" == this.lookatDirect && (N = this.VertexArray), "rightFront" == this.lookatDirect && (N = this.VertexArray1), "leftBack" == this.lookatDirect && (N = this.VertexArray2), "rightBack" == this.lookatDirect && (N = this.VertexArray3), "front" == this.lookatDirect && (N = this.VertexArray4), "back" == this.lookatDirect && (N = this.VertexArray5), "left" == this.lookatDirect && (N = this.VertexArray6), "right" == this.lookatDirect && (N = this.VertexArray7), "cube" == this._type ? (this.lineVertexArrayCube = N, this._drawVoxelCommand.vertexArray = this.lineVertexArrayCube) : (this.lineVertexArrayPoint = N, this._drawVoxelCommand.vertexArray = this.lineVertexArrayPoint);
    }
  }, {
    key: "pointsVao",
    value: function pointsVao() {
      var sceneContext = this._scene.context;
      var t = new Cesium.ShaderSource({
        defines: ["EXTRUDED_POINT"],
        sources: [this.ppb2]
      });
      var n = new Cesium.ShaderSource({
        defines: ["EXTRUDED_POINT"],
        sources: [this.gpb2]
      });
      this.shaderProgramPoint = Cesium.ShaderProgram.fromCache({
        context: sceneContext,
        vertexShaderSource: t,
        fragmentShaderSource: n,
        attributeLocations: this.attributeLocations
      });
      var i,
          r = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.aPositionTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          o = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.aPositionCenterTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          a = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.aColorTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          s = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.rangeTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          l = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.aNormaltypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          u = Cesium.Buffer.createVertexBuffer({
        context: sceneContext,
        typedArray: this.a_coordTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW
      });
      i = this.indexTypedArrayPoint.length >= Cesium.Math.SIXTY_FOUR_KILOBYTES ? Cesium.Buffer.createIndexBuffer({
        context: sceneContext,
        typedArray: this.indexTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_INT
      }) : Cesium.Buffer.createIndexBuffer({
        context: sceneContext,
        typedArray: this.indexTypedArrayPoint,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_SHORT
      }), this.lineVertexArrayPoint = new Cesium.VertexArray({
        context: sceneContext,
        attributes: [{
          index: 0,
          vertexBuffer: r,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 1,
          vertexBuffer: a,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 2,
          vertexBuffer: s,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 3,
          vertexBuffer: l,
          componentsPerAttribute: 3,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 4,
          vertexBuffer: u,
          componentsPerAttribute: 2,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 5,
          vertexBuffer: o,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }],
        indexBuffer: i
      }), this._computePositionFinish = true;
    }
  }, {
    key: "cubesVao",
    value: function cubesVao() {
      var e = this._scene.context;
      this.shaderProgramCube = Cesium.ShaderProgram.replaceCache({
        context: e,
        vertexShaderSource: new Cesium.ShaderSource({
          defines: [""],
          sources: [this.ppb2]
        }),
        fragmentShaderSource: new Cesium.ShaderSource({
          defines: [""],
          sources: [this.gpb2]
        }),
        attributeLocations: this.attributeLocations
      });
      var t,
          n = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.aPositionTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          i = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.aPositionCenterTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          r = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.aColorTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          o = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.rangeTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          a = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.aNormaltypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      }),
          s = Cesium.Buffer.createVertexBuffer({
        context: e,
        typedArray: this.a_coordTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW
      });
      t = this.indexTypedArrayCube.length >= Cesium.Math.SIXTY_FOUR_KILOBYTES ? Cesium.Buffer.createIndexBuffer({
        context: e,
        typedArray: this.indexTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_INT
      }) : Cesium.Buffer.createIndexBuffer({
        context: e,
        typedArray: this.indexTypedArrayCube,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_SHORT
      }), this.lineVertexArrayCube = new Cesium.VertexArray({
        context: e,
        attributes: [{
          index: 0,
          vertexBuffer: n,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 1,
          vertexBuffer: r,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 2,
          vertexBuffer: o,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 3,
          vertexBuffer: a,
          componentsPerAttribute: 3,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 4,
          vertexBuffer: s,
          componentsPerAttribute: 2,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }, {
          index: 5,
          vertexBuffer: i,
          componentsPerAttribute: 4,
          componentDatatype: Cesium.ComponentDatatype.FLOAT
        }],
        indexBuffer: t
      }), this._initBoundingSphere = Cesium.BoundingSphere.fromVertices(this.aPositionTypedArray), this._computePositionFinish = true;
    }
  }, {
    key: "updateAlpha",
    value: function updateAlpha() {
      this._alpha ? (this.renderState = this.renderState2, this.pass = Cesium.Pass.TRANSLUCENT) : (this.renderState = this.renderState, this.pass = Cesium.Pass.OPAQUE), this._drawVoxelCommand.renderState = this.renderState, this._drawVoxelCommand.pass = this.pass;
    }
  }, {
    key: "createVoxelCommand",
    value: function createVoxelCommand(e) {
      var t = this,
          n = this._scene.context,
          i = n.uniformState;
      this.renderState = Cesium.RenderState.fromCache({
        cull: {
          enabled: !0
        },
        depthTest: {
          enabled: !0
        },
        depthMask: !0
      }), this.renderState2 = Cesium.RenderState.fromCache({
        cull: {
          enabled: !0
        },
        depthTest: {
          enabled: !0
        },
        blending: Cesium.BlendingState.ALPHA_BLEND
      }), this._alpha ? (this.renderState = this.renderState2, this.pass = Cesium.Pass.TRANSLUCENT) : (this.renderState = this.renderState, this.pass = Cesium.Pass.OPAQUE);
      var r,
          o,
          a,
          s = {
        u_IJK: function u_IJK() {
          return t._ijk;
        },
        u_alphaScale: function u_alphaScale() {
          return t._alphaScale;
        },
        u_I: function u_I() {
          return t._ijk.i;
        },
        u_J: function u_J() {
          return t._ijk.j;
        },
        u_K: function u_K() {
          return t._ijk.k;
        },
        u_image: function u_image() {
          return t._texture;
        },
        u_max: function u_max() {
          return new Cesium.Cartesian3(t._widthStep, t._depthStep, t._heightStep);
        },
        shadowMap_texture: function shadowMap_texture() {
          return t.dataTexture._colorTexture || t._scene.context.defaultTexture;
        },
        u_matrix: function u_matrix() {
          return Cesium.Matrix4.multiply(i.viewProjection, t._matrix, new Cesium.Matrix4());
        },
        u_show: function u_show() {
          return t._show;
        },
        u_pointSize: function u_pointSize() {
          return t._radius;
        },
        u_customColor: function u_customColor() {
          return t._customColor;
        },
        u_alphaState: function u_alphaState() {
          return t._alpha;
        },
        u_filterValue: function u_filterValue() {
          return t._filterValue;
        },
        u_fifterIJk: function u_fifterIJk() {
          return t._fifterIJk;
        }
      };
      e.mapProjection.ellipsoid;
      "point" == this._type ? (r = this.lineVertexArrayPoint, o = Cesium.PrimitiveType.POINTS, a = this.shaderProgramPoint) : (r = this.lineVertexArrayCube, o = Cesium.PrimitiveType.TRIANGLES, a = this.shaderProgramCube), this._drawVoxelCommand = new Cesium.DrawCommand({
        vertexArray: r,
        primitiveType: o,
        renderState: this.renderState,
        shaderProgram: a,
        uniformMap: s,
        owner: this,
        pass: this.pass,
        modelMatrix: new Cesium.Matrix4(),
        boundingVolume: this._boundingSphere
      }), this._export3DDataFile && this.createConfigFile();
    }
  }, {
    key: "changeType",
    value: function changeType() {
      "point" == this._type && this._drawVoxelCommand && (this.lineVertexArrayPoint || (this.updateCommand = !1, this.computePointPositions()), this._drawVoxelCommand.vertexArray = this.lineVertexArrayPoint, this._drawVoxelCommand.shaderProgram = this.shaderProgramPoint, this._drawVoxelCommand.primitiveType = Cesium.PrimitiveType.POINTS, this._changeState = !0), "cube" == this._type && this._drawVoxelCommand && (this.lineVertexArrayCube || (this.updateCommand = !1, this.computeVoxelPositions()), this._drawVoxelCommand.vertexArray = this.lineVertexArrayCube, this._drawVoxelCommand.shaderProgram = this.shaderProgramCube, this._drawVoxelCommand.primitiveType = Cesium.PrimitiveType.TRIANGLES, this._changeState = !0);
    }
  }, {
    key: "getIJKRange",
    value: function getIJKRange() {
      var e,
          t,
          n,
          i = new Cesium.Cartesian3(this._bound.x, this._bound.y, this._baseHeight),
          r = this._bound.x + (this._width + this._spacing) * this._widthStep,
          o = this._bound.y + (this._depth + this._spacing) * this._depthStep,
          a = this._heightStep * (this._height + this._spacing) + this._baseHeight,
          s = new Cesium.Cartesian3(r, o, a),
          u = Cesium.Matrix4.multiplyByPoint(this._matrix, i, new Cesium.Cartesian3()),
          h = new Cesium.Cartographic.fromCartesian(u),
          c = Cesium.Matrix4.multiplyByPoint(this._matrix, s, new Cesium.Cartesian3()),
          d = new Cesium.Cartographic.fromCartesian(c);
      return {
        i: (e = {
          name: "lon",
          0: h.longitude
        }, (0, l.default)(e, this._widthStep - 1, d.longitude), (0, l.default)(e, "length", this._widthStep), e),
        j: (t = {
          name: "lat",
          0: h.latitude
        }, (0, l.default)(t, this._depthStep - 1, d.latitude), (0, l.default)(t, "length", this._depthStep), t),
        k: (n = {
          name: "height",
          0: this._baseHeight
        }, (0, l.default)(n, this._heightStep - 1, a), (0, l.default)(n, "length", this._heightStep), n)
      };
    }
  }, {
    key: "update",
    value: function update(e) {
      !Cesium.defined(this._drawVoxelCommand) && this.textureState && this.updateCommand && this.createVoxelCommand(e), Cesium.defined(this._drawVoxelCommand) && this.updateCommand && (Cesium.defined(this._drawVoxelCommand) && (Cesium.Matrix4.equals(this.modelMatrix, this._modelMatrix) || (Cesium.Matrix4.clone(this.modelMatrix, this._modelMatrix), this._drawVoxelCommand.modelMatrix = Cesium.Matrix4.IDENTITY), this._drawVoxelCommand && e.commandList.push(this._drawVoxelCommand), this._changeState && (this._changeState = !1)), this.lookatDirect !== this.transparentSort() && (this.lookatDirect = this.currentLookatDirect, this.initindexBuffer()));
    }
  }, {
    key: "getColor",
    value: function getColor() {
      var that = this;
      this._colorImage = this._image, Cesium.Resource.fetchImage(this._colorImage).then(function (t) {
        var n = t.width,
            i = t.height;
        that._texture = new Cesium.Texture({
          context: that._scene.context,
          width: n,
          height: i,
          source: t
        }), that.frameBuffer = new Cesium.Framebuffer({
          context: that._scene.context,
          colorTextures: [that._texture],
          destroyAttachments: !1
        }), that.textureState = !0;
      }).otherwise(function (e) {
        console.log(e);
      });
    }
  }, {
    key: "createConfigFilefunction",
    value: function createConfigFilefunction(fileName) {
      new Cesium.Cartographic.fromCartesian(this._boundingSphere.center).height = 0, this.content = (0, a.default)({
        textureWidth: this._widthStep,
        textureHeight: this._depthStep,
        textureDepth: this._heightStep,
        volumeWidth: this._bound.width,
        volumeHeight: this._extrudeHeight,
        volumeDepth: this._bound.height,
        center: this._boundingSphere.center
      }, null, 2), this.fileName = fileName || "shadowRateAnlilesConfig";
      var tempHref = document.createElement("a");
      tempHref.download = this.fileName;
      var n = new Blob([this.content], {
        type: "application/json"
      });
      tempHref.href = URL.createObjectURL(n);
      document.body.appendChild(tempHref);
      tempHref.click();
      document.body.removeChild(tempHref);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return this.VertexArray = this.VertexArray && !this.VertexArray.isDestroyed() && this.VertexArray.destroy(), this.VertexArray1 = this.VertexArray1 && !this.VertexArray1.isDestroyed() && this.VertexArray1.destroy(), this.VertexArray2 = this.VertexArray2 && !this.VertexArray2.isDestroyed() && this.VertexArray2.destroy(), this.VertexArray3 = this.VertexArray3 && !this.VertexArray3.isDestroyed() && this.VertexArray3.destroy(), this.VertexArray4 = this.VertexArray4 && !this.VertexArray4.isDestroyed() && this.VertexArray4.destroy(), this.VertexArray5 = this.VertexArray5 && !this.VertexArray5.isDestroyed() && this.VertexArray5.destroy(), this.VertexArray6 = this.VertexArray6 && !this.VertexArray6.isDestroyed() && this.VertexArray6.destroy(), this.VertexArray7 = this.VertexArray7 && !this.VertexArray7.isDestroyed() && this.VertexArray7.destroy(), this.lineVertexArrayCube = this.lineVertexArrayCube && !this.lineVertexArrayCube.isDestroyed() && this.lineVertexArrayCube.destroy(), this.lineVertexArrayPoint = this.lineVertexArrayPoint && !this.lineVertexArrayPoint.isDestroyed() && this.lineVertexArrayPoint.destroy(), this.dataTexture._colorTexture = this.dataTexture._colorTexture && !this.dataTexture._colorTexture.isDestroyed() && this.dataTexture._colorTexture.destroy(), Cesium.destroyObject(this);
    }
    //========== 对外属性 ==========
    //scene

  }, {
    key: "scene",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._scene = val;
      }
    }

    //type

  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(val) {
      if (val) {
        if (this._type !== val) {
          this._type = val;
          this.changeType();
        }
      }
    }

    //height

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      if (val) {
        this._scene = Number(val);
      }
    }

    //show

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = Boolean(val);
    }

    //image

  }, {
    key: "image",
    get: function get() {
      return this._image;
    },
    set: function set(val) {
      if (val) {
        this._image = val;
      }
    }

    //ijkHide

  }, {
    key: "ijkHide",
    get: function get() {
      return this._ijkHide;
    },
    set: function set(val) {
      if (val) {
        this._ijkHide = val;
      }
    }

    //ijk

  }, {
    key: "ijk",
    get: function get() {
      return this._ijk;
    },
    set: function set(val) {
      if (val) {
        this._ijk = val;
        this._fifterIJk = 10;
      }
    }

    //alpha

  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      if (val) {
        this._alpha = Boolean(val);
        this.updateAlpha();
      }
    }

    //filterValue

  }, {
    key: "filterValue",
    get: function get() {
      return this._filterValue;
    },
    set: function set(val) {
      if (val) {
        this._filterValue = Number(val);
      }
    }

    //heightStep

  }, {
    key: "heightStep",
    get: function get() {
      return this._heightStep;
    },
    set: function set(val) {
      this._heightStep = val;
    }

    //widthtStep

  }, {
    key: "widthtStep",
    get: function get() {
      return this._widthtStep;
    },
    set: function set(val) {
      this._widthtStep = val;
    }

    //depthStep

  }, {
    key: "depthStep",
    get: function get() {
      return this._depthStep;
    },
    set: function set(val) {
      this._depthStep = val;
    }

    //extrudeHeight

  }, {
    key: "extrudeHeight",
    get: function get() {
      return this._extrudeHeight;
    },
    set: function set(val) {
      this._extrudeHeight = Number(val);
    }

    //alphaScale

  }, {
    key: "alphaScale",
    get: function get() {
      return this._alphaScale;
    },
    set: function set(val) {
      this._alphaScale = Number(val);
    }
    //export3DDataFile

  }, {
    key: "export3DDataFile",
    get: function get() {
      return this._export3DDataFile;
    },
    set: function set(val) {
      this._alpha = Boolean(val);
    }
  }]);

  return voxel;
}(_DasClass2.DasClass);

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProfileAnalysis = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _Draw = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*剖面分析*/


//剖面分析 类
var ProfileAnalysis = exports.ProfileAnalysis = function (_DasClass) {
  _inherits(ProfileAnalysis, _DasClass);

  function ProfileAnalysis(options, oldparam) {
    _classCallCheck(this, ProfileAnalysis);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (ProfileAnalysis.__proto__ || Object.getPrototypeOf(ProfileAnalysis)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    if (!Cesium.defined(options.viewer)) {
      throw new Cesium.DeveloperError("options.viewer is required.");
    }
    _this._positions = Cesium.defaultValue(options.elevation, []);
    _this._viewer = options.viewer;
    _this._scene = _this._viewer.scene;
    _this._height = Cesium.defaultValue(options.height, options.viewer.scene.drawingBufferWidth * 0.8);
    _this._width = Cesium.defaultValue(options.width, options.viewer.scene.drawingBufferWidth);
    _this._frustumH = Cesium.defaultValue(options.frustumH, 100);
    _this._extendWidth = Cesium.defaultValue(options.extendWidth, 0.1);
    _this._context = _this._scene.context;
    _this.uniformState = _this._context.uniformState;
    _this._isShowDown = Cesium.defaultValue(options.isShowDown, !1);
    _this.customCamera = null;
    _this._angle = Cesium.defaultValue(options.angle, 30);
    _this._angleHeight = Cesium.defaultValue(options.angleHeight, 10);
    _this._elevation = options.elevation;
    _this.initialize();
    return _this;
  }

  _createClass(ProfileAnalysis, [{
    key: "initialize",
    value: function initialize() {
      this._createTexture();
      this._createFramebuffer();
      this._clear();
      this.updateBuffer();
    }
  }, {
    key: "_createTexture",
    value: function _createTexture() {
      this.colorTexture = new Cesium.Texture({
        context: this._context,
        width: this._width,
        height: this._height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });
      this.depthStencilTexture = new Cesium.Texture({
        context: this._context,
        width: this._width,
        height: this._height,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8,
        sampler: new Cesium.Sampler({
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });
    }
  }, {
    key: "_createFramebuffer",
    value: function _createFramebuffer() {
      this.frameBuffer = new Cesium.Framebuffer({
        context: this._context,
        colorTextures: [this.colorTexture],
        depthStencilTexture: this.depthStencilTexture,
        destroyAttachments: false
      });
      this.passState = new Cesium.PassState(this._context);
      this.passState.framebuffer = this.frameBuffer;
      this.passState.viewport = new Cesium.BoundingRectangle(0, 0, this.width, this.height);
    }
  }, {
    key: "_destroyTexture",
    value: function _destroyTexture() {
      this.colorTexture = this.colorTexture;
      if (!this.colorTexture.isDestroyed()) {
        this.colorTexture.destroy();
      }
      this.depthStencilTexture = this.depthStencilTexture;
      if (!this.depthStencilTexture.isDestroyed()) {
        this.depthStencilTexture.destroy();
      }
    }
  }, {
    key: "_destroyFrameBuffer",
    value: function _destroyFrameBuffer() {
      if (!this.frameBuffer.isDestroyed()) {
        this.frameBuffer.destroy();
      }
    }
  }, {
    key: "_clear",
    value: function _clear() {
      this.clearCommand = new Cesium.ClearCommand({
        depth: 1,
        color: new Cesium.Color(1, 1, 1, 0)
      });
      this.clearPassState = new Cesium.PassState(this._context);
      this.clearCommand.framebuffer = this.frameBuffer;
    }
  }, {
    key: "_newCommand",
    value: function _newCommand() {
      this.clearCommand.execute(this._context, this.clearPassState);
      this._computeCameraCP();
      this._updateCustomCamera();
      this.uniformState.updateCamera(this.camera);
      this.passState.viewport = new Cesium.BoundingRectangle(0, 0, this.width, this.height);
      var renderState = new Cesium.RenderState();
      renderState.depthTest.enabled = true;
      renderState.cull.enabled = false;
      for (var frustumCommandsList = this._scene._view.frustumCommandsList, frustumCommandsIndex = frustumCommandsList.length, commandsItem = void 0, indicesItem = void 0, indicesItemIndex = void 0, tiles = [Cesium.Pass.CESIUM_3D_TILE], s = 0; s < frustumCommandsIndex; ++s) {
        var l = frustumCommandsIndex - s - 1,
            u = frustumCommandsList[l];
        this.uniformState.updateFrustum(this.camera.frustum);
        for (var h = 0; h < tiles.length; h++) {
          for (this.uniformState.updatePass(tiles[h]), commandsItem = u.commands[tiles[h]], indicesItem = u.indices[tiles[h]], indicesItemIndex = 0; indicesItemIndex < indicesItem; ++indicesItemIndex) {
            commandsItem[indicesItemIndex]._framebuffer;
            commandsItem[indicesItemIndex].renderState = renderState;
            commandsItem[indicesItemIndex].execute(this._context, this.passState);
          }
        }
      }
    }
  }, {
    key: "_computeCameraCP",
    value: function _computeCameraCP() {
      this.bs = Cesium.Cartesian3.add(this._positions[0], this._positions[1], new Cesium.Cartesian3());
      var Scalar = Cesium.Cartesian3.divideByScalar(this.bs, 2, new Cesium.Cartesian3()),
          t = Cesium.Cartesian3.distance(this._positions[0], this._positions[1]);
      this._frustumW = t / 2, this._offsetPos = Math.abs(Math.tan(this._angle * Math.PI / 180) * t / 2), this._offsetPos = this._offsetPos > 20 ? this._offsetPos : 20, this._offsetHeight = Math.abs(Math.tan(this._angleHeight * Math.PI / 180) * this._offsetPos / 2), this.boundingCP = Scalar;
    }
  }, {
    key: "_updateCustomCamera",
    value: function _updateCustomCamera() {
      var scene = this._scene;
      if (!this.customCamera) {
        this.customCamera = new Cesium.Camera(scene);
      }
      this._cartographic = Cesium.Cartographic.fromCartesian(this.boundingCP);
      this._perspectiveOffCenterFrustum();
    }
  }, {
    key: "_perspectiveOffCenterFrustum",
    value: function _perspectiveOffCenterFrustum() {
      this.customCamera.frustum = new Cesium.PerspectiveOffCenterFrustum();
      this.customCamera.frustum.near = this._offsetPos - this._extendWidth / 2;
      this.customCamera.frustum.far = this._offsetPos + this._extendWidth / 2;
      this.customCamera.frustum.left = -this._frustumW;

      var startPointHeight = das3d.point.formatPosition(this._positions[0]).z;
      var endPointHeight = das3d.point.formatPosition(this._positions[1]).z;
      var offset = startPointHeight > endPointHeight ? endPointHeight : startPointHeight;

      if (this._isShowDown) {
        this.customCamera.frustum.top = this._offsetHeight - this._frustumH;
        this.customCamera.frustum.bottom = this._offsetHeight + this._frustumH;
      } else {
        this.customCamera.frustum.bottom = this._offsetHeight;
        this.customCamera.frustum.top = this._frustumH + this._offsetHeight + offset;
      }
      this.customCamera.frustum.right = this._frustumW;
      this.customCamera.direction = this.cameraDir;
      this.customCamera.up = this.cameraUp;
      this.customCamera.right = this.cameraRight;
      var point = Cesium.Cartesian3.fromRadians(this._cartographic.longitude, this._cartographic.latitude, this._offsetHeight);
      var multiply = Cesium.Cartesian3.multiplyByScalar(this.cameraDir, this._offsetPos, new Cesium.Cartesian3());
      Cesium.Cartesian3.subtract(point, multiply, point);
      this.customCamera.position = point;
      this.camera = this.customCamera;
    }
  }, {
    key: "_getBuffer",
    value: function _getBuffer() {
      var context = this._context;
      var width = this.width;
      var height = this.height;
      var pixels = context.readPixels({
        x: this.passState.viewport.x,
        y: this.passState.viewport.y,
        width: width,
        height: height,
        framebuffer: this.frameBuffer
      });
      var pointsArr = [];
      this._data = {
        x: [],
        y: [],
        xys: [],
        xysAll: [],
        pixels: []
      };
      for (var pixel = 0; pixel < pixels.length; pixel += 4) {
        var a = pixels[pixel];
        var s = pixels[pixel + 1];
        var l = pixels[pixel + 2];
        var u = pixels[pixel + 3];
        var h = pixel / 4 % width;
        var c = Math.floor(pixel / (4 * width));
        var d = new Cesium.Cartesian2(h, c);
        if (u > 0) {
          pointsArr.push(0, 255, 255, u);
          this._data.pixels.push([a, s, l, u]);
          this._data.xys.push(d);
        } else {
          pointsArr.push(a, s, l, u);
          this._data.xysAll.push(d);
        }
      }
      var worldPoints = this.computeWorldPositions(this._data.xys);
      this.worldPoints = this._filterWorldPoints(worldPoints);
    }

    /**
     * 过滤结果点
     * @private
     */

  }, {
    key: "_filterWorldPoints",
    value: function _filterWorldPoints(arr) {
      var arrDegree = this._toDegrees(arr);
      var drawPoints = this._filterByXYZ(arrDegree);

      // 位置不对，直接返回
      if (drawPoints.drawPoints && drawPoints.drawPoints.length == 0) {
        return [];
      }

      return this._concatStartAndEnd(drawPoints.drawPoints, drawPoints.arrMinZ); // 第四步：前后各加一个点，高度为arrMinZ
    }

    /**
     * 将原始点转成经纬度
     * @param arr
     * @private
     */

  }, {
    key: "_toDegrees",
    value: function _toDegrees(arr) {
      return arr.map(function (item) {
        // 先把坐标转成经纬度，相同经纬度的点取高度最高的那个点
        var cartesian3 = new Cesium.Cartesian3(item.x, item.y, item.z);
        var carto = Cesium.Cartographic.fromCartesian(cartesian3);

        var x = Math.floor(Cesium.Math.toDegrees(carto.longitude) * 10000000) / 10000000;
        var y = Math.floor(Cesium.Math.toDegrees(carto.latitude) * 10000000) / 10000000;
        var z = Math.floor(carto.height * 100000000) / 100000000;

        return { x: x, y: y, z: z };
      });
    }

    /**
     * 过滤结果点
     * @param arr
     * @private
     */

  }, {
    key: "_filterByXYZ",
    value: function _filterByXYZ(arrDegree) {
      var tempData = {};
      var arrMinZ = 10000;
      for (var i = 0, len = arrDegree.length; i < len; i++) {
        var item = arrDegree[i];
        var keyName = item.x + "_" + item.y;
        var height = item.z;
        arrMinZ = arrMinZ > height ? height : arrMinZ;
        if (!tempData[keyName]) {
          tempData[keyName] = height;
        } else {
          tempData[keyName] = tempData[keyName] > height ? tempData[keyName] : height;
        }
      }
      var tempArr = [];
      for (var m in tempData) {
        var pointItem = m.split("_");
        tempArr.push({
          "x": Number(pointItem[0]),
          "y": Number(pointItem[1]),
          "z": tempData[m]
        });
      }
      function sortNumber(a, b) {
        return a.x * a.y - b.x * b.y;
      }
      tempArr.sort(sortNumber);

      return {
        drawPoints: tempArr,
        arrMinZ: arrMinZ
      };
    }

    /**
     * 首尾加一个点
     * @param directionPoints
     * @private
     */

  }, {
    key: "_concatStartAndEnd",
    value: function _concatStartAndEnd(drawPointsSort, arrMinZ) {
      var len = drawPointsSort.length - 1;
      var resultPoints = [{
        x: drawPointsSort[0].x,
        y: drawPointsSort[0].y,
        z: arrMinZ
      }].concat(drawPointsSort).concat([{
        x: drawPointsSort[len].x,
        y: drawPointsSort[len].y,
        z: arrMinZ
      }]);

      return resultPoints;
    }
  }, {
    key: "_computerDirction",
    value: function _computerDirction() {
      if (this._positions.length >= 2) {
        var statePoint = this._elevation[0];
        var endPoint = this._elevation[1];
        var centerHeight = Math.abs((statePoint.height + endPoint.height) / 2);
        var stateCenterPoint = Cesium.Cartesian3.fromDegrees(statePoint.longitude, statePoint.latitude, centerHeight);
        var stateBottomPoint = Cesium.Cartesian3.fromDegrees(statePoint.longitude, statePoint.latitude, 0);
        var endCenterPoint = Cesium.Cartesian3.fromDegrees(endPoint.longitude, endPoint.latitude, centerHeight);
        var stateDvalue = Cesium.Cartesian3.subtract(stateCenterPoint, stateBottomPoint, new Cesium.Cartesian3());
        var wholeDvalue = Cesium.Cartesian3.subtract(stateCenterPoint, endCenterPoint, new Cesium.Cartesian3());
        var sctDvalue = Cesium.Cartesian3.cross(wholeDvalue, stateDvalue, new Cesium.Cartesian3());
        var normalsctPoint = Cesium.Cartesian3.normalize(sctDvalue, new Cesium.Cartesian3());
        var normalStartPoint = Cesium.Cartesian3.normalize(stateDvalue, new Cesium.Cartesian3());
        var normalWholePoint = Cesium.Cartesian3.normalize(wholeDvalue, new Cesium.Cartesian3());
        this.cameraDir = normalsctPoint;
        this.cameraUp = normalStartPoint;
        this.cameraRight = normalWholePoint;
        this._newCommand();
        this._getBuffer();
      }
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer() {
      var positionArr = [];
      return this._elevation.forEach(function (t) {
        positionArr.push(t[0] || t.longitude, t[1] || t.latitude, t[2] || t.height);
      }), this._positions = Cesium.Cartesian3.fromDegreesArrayHeights(positionArr), this._computerDirction();
    }
  }, {
    key: "computeWorldPositions",
    value: function computeWorldPositions(dataXys) {
      for (var t = this._data.xys.length, n = (this.customCamera.frustum.near, this.customCamera.frustum.far, this.uniformState), VectorMultiplyArr = [], width = this.width, height = this.height, a = 0; a < t; a++) {
        var tempPoint = new Cesium.Cartesian4();
        tempPoint.x = dataXys[a].x / width * 2 - 1;
        tempPoint.y = dataXys[a].y / height * 2 - 1;
        tempPoint.z = 2;
        tempPoint.w = 1;
        var multiply = Cesium.Matrix4.multiply(this.customCamera.inverseViewMatrix, n.inverseProjection, new Cesium.Matrix4());
        var VectorMultiply = Cesium.Matrix4.multiplyByVector(multiply, tempPoint, new Cesium.Cartesian4());
        var VectorMultiplyW = 1 / VectorMultiply.w;
        Cesium.Cartesian3.multiplyByScalar(VectorMultiply, VectorMultiplyW, VectorMultiply);
        VectorMultiplyArr.push(VectorMultiply);
      }
      return VectorMultiplyArr;
    }
  }, {
    key: "clearBuffer",
    value: function clearBuffer() {
      return new Uint8ClampedArray(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return this._destroyTexture(), this._destroyFrameBuffer(), Cesium.destroyObject(this);
    }

    //========== 对外属性 ==========

  }, {
    key: "viewer",
    get: function get() {
      return this._viewer;
    },
    set: function set(val) {
      if (val) {
        this._viewer = val;
      }
    }
  }, {
    key: "elevation",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      if (val) {
        this._elevation = val;
      }
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      if (this._height) {
        this._height = val;
      }
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    },
    set: function set(val) {
      if (this._width) {
        this._width = val;
      }
    }
  }, {
    key: "frustumH",
    get: function get() {
      return this._frustumH;
    },
    set: function set(val) {
      if (val) {
        this._frustumH = val;
      }
    }
  }, {
    key: "extendWidth",
    get: function get() {
      return this._extendWidth;
    },
    set: function set(val) {
      if (val) {
        this._extendWidth = val;
      }
    }
  }, {
    key: "type",
    get: function get() {
      return "profileAnalysis";
    }
  }]);

  return ProfileAnalysis;
}(_DasClass2.DasClass);

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MixedOcclusion = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _MixedOcclusion = __webpack_require__(172);

var _MixedOcclusion2 = _interopRequireDefault(_MixedOcclusion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 建筑物混合遮挡
// 原理：自己创建FBO，把收集到的所有瓦片绘制指令，都绘制到这个FBO里，开启深度检测，然后再贴屏
// 1.楼块不能遮挡道路、水系、绿地和标注等地图元素；
// 2.楼快之间，需要实现不透明的实际遮挡效果。
var MixedOcclusion = exports.MixedOcclusion = function () {
  //========== 构造方法 ==========
  function MixedOcclusion(options, oldparam) {
    _classCallCheck(this, MixedOcclusion);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (oldparam) {
      oldparam.viewer = options;
      options = oldparam;
    }
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    this.viewer = options.viewer;

    this._enabled = Cesium.defaultValue(options.enabled, true);
    this._alpha = Cesium.defaultValue(options.alpha, 0.5);

    this.init();
  }

  //========== 对外属性 ==========
  //透明度


  _createClass(MixedOcclusion, [{
    key: "init",


    //========== 方法 ==========

    value: function init() {
      var context = this.viewer.scene.context;
      var width = this.viewer.scene.drawingBufferWidth;
      var height = this.viewer.scene.drawingBufferHeight;

      this.width = width;
      this.height = height;

      this.colorTexture = new Cesium.Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.FLOAT,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });

      this.depthStencilTexture = new Cesium.Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      });

      Cesium.ExpandByDas.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
        context: context,
        colorTextures: [this.colorTexture],
        depthStencilTexture: this.depthStencilTexture,
        destroyAttachments: false
      });

      Cesium.ExpandByDas.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
        color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
        framebuffer: Cesium.ExpandByDas.mixedOcclusion.tilesFbo,
        depth: 2.0,
        stencil: 2.0
      });

      this.viewer.scene._preUpdate.addEventListener(this._preUpdateHandler, this);
      this.setEnabled(this._enabled);
    }
  }, {
    key: "_preUpdateHandler",
    value: function _preUpdateHandler(e) {
      Cesium.ExpandByDas.mixedOcclusion.newFrame = true;

      var newWidth = this.viewer.scene.drawingBufferWidth;
      var newHeight = this.viewer.scene.drawingBufferHeight;
      if (newWidth != this.width || newHeight != this.height) {
        var context = this.viewer.scene.context;
        var width = newWidth;
        var height = newHeight;

        this.width = width;
        this.height = height;

        this.depthTexture && this.depthTexture.destroy();
        this.depthStencilTexture && this.depthStencilTexture.destroy();
        this.colorTexture && this.colorTexture.destroy();
        Cesium.ExpandByDas.mixedOcclusion.tilesFbo && Cesium.ExpandByDas.mixedOcclusion.tilesFbo.destroy();

        this.colorTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.RGBA,
          pixelDatatype: Cesium.PixelDatatype.FLOAT,
          sampler: new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
            magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
          })
        });

        this.depthStencilTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
          pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
        });

        this.depthTexture = new Cesium.Texture({
          context: context,
          width: width,
          height: height,
          pixelFormat: Cesium.PixelFormat.RGBA,
          pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
          sampler: new Cesium.Sampler({
            wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
            wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
            magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
          })
        });

        Cesium.ExpandByDas.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
          context: context,
          colorTextures: [this.colorTexture],
          depthStencilTexture: this.depthStencilTexture,
          destroyAttachments: false
        });
        Cesium.ExpandByDas.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
          color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
          framebuffer: Cesium.ExpandByDas.mixedOcclusion.tilesFbo,
          depth: 2.0,
          stencil: 2.0
        });
      }
    }
  }, {
    key: "setEnabled",
    value: function setEnabled(val) {
      var that = this;

      Cesium.ExpandByDas.mixedOcclusion.enable = val;

      if (val) {
        this.postProcess = new Cesium.PostProcessStage({
          fragmentShader: _MixedOcclusion2.default,
          uniforms: {
            mergeTexture: function mergeTexture() {
              return Cesium.ExpandByDas.mixedOcclusion.tilesFbo._colorTextures[0];
            },
            alpha: function alpha() {
              return that._alpha;
            }
          }
        });
        this.viewer.scene.postProcessStages.add(this.postProcess);
      } else {
        Cesium.ExpandByDas.mixedOcclusion.tilesFboClear.execute(this.viewer.scene.context);
        if (this.postProcess) this.viewer.scene.postProcessStages.remove(this.postProcess);
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.setEnabled(false);
      this.viewer.scene._preUpdate.removeEventListener(this._preUpdateHandler, this);

      if (this.depthTexture) {
        this.depthTexture.destroy();
        delete this.depthTexture;
      }
      if (this.depthStencilTexture) {
        this.depthStencilTexture.destroy();
        delete this.depthStencilTexture;
      }
      if (this.colorTexture) {
        this.colorTexture.destroy();
        delete this.colorTexture;
      }

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = val;
    }

    //开启关闭

  }, {
    key: "enabled",
    get: function get() {
      return this._enabled;
    },
    set: function set(val) {
      this._enabled = val;
      this.setEnabled(val);
    }
  }]);

  return MixedOcclusion;
}();

/***/ }),
/* 172 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;\nuniform sampler2D mergeTexture; \nuniform float alpha;\nvarying vec2 v_textureCoordinates;\nvoid main(){\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n    vec4 mergeColor =  texture2D(mergeTexture, v_textureCoordinates);\n    if(length(mergeColor.rgb)>0.01){\n        gl_FragColor = mix(color,mergeColor,alpha);\n    }else{\n        gl_FragColor = color;\n    }\n} "

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesClip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(51);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 模型裁剪 类
var TilesClip = exports.TilesClip = function (_TilesBase) {
  _inherits(TilesClip, _TilesBase);

  //========== 构造方法 ==========
  function TilesClip(options) {
    _classCallCheck(this, TilesClip);

    var _this = _possibleConstructorReturn(this, (TilesClip.__proto__ || Object.getPrototypeOf(TilesClip)).call(this, options));

    _this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);

    if (_this.drawCommand) {
      _this.activeEdit();
    }
    return _this;
  }

  //========== 对外属性 ==========

  _createClass(TilesClip, [{
    key: "activeEdit",
    value: function activeEdit() {
      this.tileset.dasEditor.fbo = this.fbo;
      this.tileset.dasEditor.polygonBounds = this.polygonBounds;
      this.tileset.dasEditor.IsYaPing[0] = true;
      this.tileset.dasEditor.IsYaPing[2] = true;
      this.tileset.dasEditor.editVar[0] = this.clipOutSide;
      this.addToScene();
    }
  }, {
    key: "clipOutSide",
    get: function get() {
      return this._clipOutSide;
    },
    set: function set(val) {
      this._clipOutSide = Boolean(val);
      this.tileset.dasEditor.editVar[0] = this.clipOutSide;
    }
  }]);

  return TilesClip;
}(_TilesBase2.TilesBase);

/***/ }),
/* 174 */
/***/ (function(module, exports) {

module.exports = "uniform mat4 myPorjection;\r\nattribute vec3 position;\r\nvarying vec2 depth;\r\nvoid main()\r\n{\r\n    vec4 pos = vec4(position.xyz,1.0);\r\n    depth = pos.zw;\r\n    pos.z = 0.0;\r\n    gl_Position = czm_projection*pos;\r\n}"

/***/ }),
/* 175 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\n#define OES_texture_float_linear\r\n\r\nvarying vec2 depth;\r\n\r\nvec4 packDepth(float depth)\r\n{\r\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\r\n    enc = fract(enc);\r\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    return enc;\r\n}\r\n\r\nvoid main()\r\n{\r\n    float fDepth = (depth.x / 5000.0)/2.0 + 0.5;\r\n    gl_FragColor = packDepth(fDepth);\r\n}"

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesFlat = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(51);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//默认压平至所选取的最低点高度，由flatHeight变量控制压平高度的变化
// 模型压平 类
var TilesFlat = exports.TilesFlat = function (_TilesBase) {
  _inherits(TilesFlat, _TilesBase);

  //========== 构造方法 ==========
  function TilesFlat(options) {
    _classCallCheck(this, TilesFlat);

    var _this = _possibleConstructorReturn(this, (TilesFlat.__proto__ || Object.getPrototypeOf(TilesFlat)).call(this, options));

    _this._flatHeight = options.flatHeight || 0;

    if (_this.drawCommand) {
      _this.activeEdit();
    }
    return _this;
  }

  //========== 对外属性 ==========

  //偏移量


  _createClass(TilesFlat, [{
    key: "activeEdit",
    value: function activeEdit() {
      this.tileset.dasEditor.fbo = this.fbo;
      this.tileset.dasEditor.polygonBounds = this.polygonBounds;
      this.tileset.dasEditor.IsYaPing[0] = true;
      this.tileset.dasEditor.IsYaPing[1] = true;
      this.tileset.dasEditor.heightVar[0] = this.minLocalPos.z;
      this.tileset.dasEditor.heightVar[1] = this.flatHeight;
      this.addToScene();
    }
  }, {
    key: "flatHeight",
    get: function get() {
      return this._flatHeight;
    },
    set: function set(val) {
      this._flatHeight = Number(val);
      this.tileset.dasEditor.heightVar[1] = this._flatHeight;
    }
  }]);

  return TilesFlat;
}(_TilesBase2.TilesBase);

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TilesFlood = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TilesBase2 = __webpack_require__(51);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 模型淹没 类
var TilesFlood = exports.TilesFlood = function (_TilesBase) {
  _inherits(TilesFlood, _TilesBase);

  //========== 构造方法 ==========
  function TilesFlood(options) {
    _classCallCheck(this, TilesFlood);

    var _this = _possibleConstructorReturn(this, (TilesFlood.__proto__ || Object.getPrototypeOf(TilesFlood)).call(this, options));

    _this.floodColor = options.floodColor || [0.15, 0.7, 0.95, 0.5];
    _this.floodSpeed = options.floodSpeed || 5.5; //淹没速度，米/秒（默认刷新频率为55Hz）
    _this._floodAll = options.floodAll;
    _this.maxFloodDepth = options.maxFloodDepth || 200;
    _this.ableFlood = true;
    if (_this.drawCommand || _this._floodAll) {
      _this.activeEdit();
    }
    return _this;
  }

  //========== 对外属性 ==========

  _createClass(TilesFlood, [{
    key: "bindSpeed",
    value: function bindSpeed() {
      var that = this;
      this.speedFun = function () {
        if (that.ableFlood) {
          that.tileset.dasEditor.floodVar[1] += that.floodSpeed / 55;
          if (that.tileset.dasEditor.floodVar[1] >= that.tileset.dasEditor.floodVar[2]) {
            that.tileset.dasEditor.floodVar[1] = that.tileset.dasEditor.floodVar[2];
          }
        }
      };
      this.viewer.clock.onTick.addEventListener(this.speedFun);
    }
  }, {
    key: "resetFlood",
    value: function resetFlood() {
      this.tileset.dasEditor.floodVar[1] = this.tileset.dasEditor.floodVar[0];
    }
  }, {
    key: "activeEdit",
    value: function activeEdit() {
      this.bindSpeed();
      this.tileset.dasEditor.fbo = this.fbo;
      this.tileset.dasEditor.polygonBounds = this.polygonBounds;
      this.tileset.dasEditor.IsYaPing[0] = true;
      this.tileset.dasEditor.IsYaPing[3] = true;
      this.tileset.dasEditor.floodVar = [this.minLocalPos.z, this.minLocalPos.z, this.minLocalPos.z + this.maxFloodDepth, 200];
      this.tileset.dasEditor.floodColor = this.floodColor;
      this.tileset.dasEditor.editVar[1] = this.floodAll || false;
      !this.floodAll && this.addToScene();
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.clock.onTick.removeEventListener(this.speedFun);
      _get(TilesFlood.prototype.__proto__ || Object.getPrototypeOf(TilesFlood.prototype), "destroy", this).call(this);
    }
  }, {
    key: "floodAll",
    get: function get() {
      return this._floodAll;
    },
    set: function set(val) {
      this._floodAll = Boolean(val);
      this.tileset.dasEditor.editVar[1] = this.floodAll;
    }
  }]);

  return TilesFlood;
}(_TilesBase2.TilesBase);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GltfClipPlan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

var _TilesClipPlan2 = __webpack_require__(87);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//模型剖切(平面)类
var GltfClipPlan = exports.GltfClipPlan = function (_TilesClipPlan) {
  _inherits(GltfClipPlan, _TilesClipPlan);

  function GltfClipPlan() {
    _classCallCheck(this, GltfClipPlan);

    return _possibleConstructorReturn(this, (GltfClipPlan.__proto__ || Object.getPrototypeOf(GltfClipPlan)).apply(this, arguments));
  }

  _createClass(GltfClipPlan, [{
    key: "getInverseTransform",


    //========== 方法 ==========

    value: function getInverseTransform() {
      if (!this._inverseTransform) {
        var transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.position.getValue((0, _util.currentTime)()));
        this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
      }
      return this._inverseTransform;
    }
  }, {
    key: "setPlanes",
    value: function setPlanes(planes, opts) {
      opts = opts || {};

      this.clear();
      if (!planes) return;

      var clippingPlanes = new Cesium.ClippingPlaneCollection({
        planes: planes,
        edgeWidth: Cesium.defaultValue(opts.edgeWidth, 0.0),
        edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
        unionClippingRegions: Cesium.defaultValue(opts.unionClippingRegions, false)
      });
      this.clippingPlanes = clippingPlanes;
      this._tileset.model.clippingPlanes = clippingPlanes;
    }

    //清除裁剪面

  }, {
    key: "clear",
    value: function clear() {
      if (this._tileset.model.clippingPlanes) {
        this._tileset.model.clippingPlanes.enabled = false;
        this._tileset.model.clippingPlanes = undefined;
      }

      if (this.clippingPlanes) {
        delete this.clippingPlanes;
      }
    }
  }, {
    key: "entity",

    //========== 对外属性 ==========
    get: function get() {
      return this._tileset;
    },
    set: function set(val) {
      this._tileset = val;
      this._inverseTransform = null;
    }
  }]);

  return GltfClipPlan;
}(_TilesClipPlan2.TilesClipPlan);

/**
 * 裁剪模型 类型 枚举
 *@enum {Number}
 */


_TilesClipPlan2.TilesClipPlan.Type = {
  /** z水平面,水平切底部 */
  Z: 1,
  /** z水平面，水平切顶部 */
  ZR: 2,
  /** x垂直面,水平切底部 */
  X: 3,
  /** x垂直面,东西方向切 */
  XR: 4,
  /** y垂直面, 南北方向切 */
  Y: 5,
  /** y垂直面，南北方向切*/
  YR: 6
};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlyLine = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _point = __webpack_require__(2);

var _polyline = __webpack_require__(23);

var _matrix = __webpack_require__(16);

var _BaseFlyLine2 = __webpack_require__(88);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//飞行路线管理类【静态一次性传入的数据】
var FlyLine = exports.FlyLine = function (_BaseFlyLine) {
  _inherits(FlyLine, _BaseFlyLine);

  function FlyLine() {
    _classCallCheck(this, FlyLine);

    return _possibleConstructorReturn(this, (FlyLine.__proto__ || Object.getPrototypeOf(FlyLine)).apply(this, arguments));
  }

  _createClass(FlyLine, [{
    key: "init",


    //========== 方法 ==========
    value: function init() {
      this._isStart = false;

      if (this.options.points) this.createPath(this.options.points, this.options);
    }

    //创建并计算飞行时间及坐标

  }, {
    key: "createPath",
    value: function createPath(lonlats, options) {
      if (!lonlats || lonlats.length < 2) {
        daslog.warn("路线无坐标数据，无法漫游！", lonlats);
        return;
      }
      this.points = lonlats; //坐标

      options = options || {};

      var offsetHeight = Cesium.defaultValue(options.offsetHeight, 0);

      var startTime; //飞行开始时间
      var stopTime; //飞行结束时间
      if (options.startTime) startTime = Cesium.JulianDate.fromDate(new Date(options.startTime));else startTime = this.viewer.clock.currentTime;

      var arrSpeed = options.speed;
      var isSpeedArray = !(0, _util.isNumber)(arrSpeed);
      if (lonlats.length == 2) {
        //2个点时，需要插值，否则穿地
        var centerPt = [(lonlats[0][0] + lonlats[1][0]) / 2, (lonlats[0][1] + lonlats[1][1]) / 2, lonlats[0][2]];
        lonlats.splice(1, 0, centerPt);
        if (arrSpeed && isSpeedArray) arrSpeed.splice(1, 0, arrSpeed[0]);
      }

      var property = new Cesium.SampledPositionProperty();
      this.positions = [];
      this.times = [];

      var defSpeed = 100; //无速度值时的 默认速度  单位：千米/小时
      var speedsNew = [];

      var alltimes = 0; //总时长,单位：秒
      var alllen = 0; //总长度,单位：米
      var stepLen = {}; //每一步的距离长度
      var stepTime = {}; //每一步的时长
      var lastPoint;
      for (var i = 0, length = lonlats.length; i < length; i++) {
        var lonlat = lonlats[i];
        var item = Cesium.Cartesian3.fromDegrees(lonlat[0], lonlat[1], (lonlat[2] || 0) + offsetHeight);
        item.lonlat = lonlat;

        var sTime;
        if (i == 0) {
          //起点
          sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
          item.time = sTime;
          item.second = alltimes;
          property.addSample(sTime, item);
        } else {
          var speed = isSpeedArray ? arrSpeed ? arrSpeed[i - 1] : defSpeed : arrSpeed || defSpeed;
          speedsNew.push(speed);

          speed = speed / 3.6; //速度：km/h换算m/s

          var len = Cesium.Cartesian3.distance(item, lastPoint);
          var stime = len / speed;
          if (stime < 0.01) stime = 0.01; //限定为最小值，防止速度值设置太大时，为0的错误

          alltimes += stime;
          alllen += len;

          sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
          item.time = sTime;
          item.second = alltimes;
          property.addSample(sTime, item);

          if (options.pauseTime) {
            if (typeof options.pauseTime === "function") {
              alltimes += options.pauseTime(i, item);
            } else {
              alltimes += options.pauseTime;
            }
            sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
            property.addSample(sTime, (0, _matrix.getOnLinePointByLen)(lastPoint, item, 0.01, true));
          }
        }
        lastPoint = item;
        this.positions.push(item);
        this.times.push(sTime);

        stepLen[i] = alllen;
        stepTime[i] = alltimes;
      }
      this.arrSpeed = speedsNew;

      this.lastItem = {
        position: this.positions[this.positions.length - 1],
        time: this.times[this.times.length - 1]
      };

      stopTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());

      this.alltimes = alltimes;
      this.alllen = alllen;
      this.stepLen = stepLen;
      this.stepTime = stepTime;

      this.startTime = startTime;
      this.stopTime = stopTime;

      this.property = property;
      this.velocityOrientation = new Cesium.VelocityOrientationProperty(this.property); //基于移动位置自动计算方位

      //插值，使折线边平滑 ,并且长距离下不穿地
      if (options.interpolation) {
        this.property.setInterpolationOptions({
          interpolationDegree: options.interpolationDegree || 2,
          interpolationAlgorithm: Cesium.LagrangePolynomialApproximation //HermitePolynomialApproximation
        });
      }
    }
  }, {
    key: "start",
    value: function start(opts) {
      if (!Cesium.defined(this.positions) || this.positions.length == 0) {
        daslog.warn("没有坐标数据，飞行路线启动失败", this.positions);
        return;
      }

      if (this._isStart) this.stop();
      this._isStart = true;

      this._createEntity();

      //=====================绑定clock timeline====================
      if (Cesium.defined(this.options.multiplier)) {
        //飞行速度
        this._bak_multiplier = this.viewer.clock.multiplier;
        this.viewer.clock.multiplier = this.options.multiplier;
      }

      this.viewer.clock.shouldAnimate = true;
      this.viewer.clock.currentTime = this.startTime.clone();

      if (this.options.clockRange === Cesium.ClockRange.LOOP_STOP || this.options.clockLoop) {
        //循环播放
        this._bak_clockRange = this.viewer.clock.clockRange;
        this._bak_startTime = this.viewer.clock.startTime;
        this._bak_stopTime = this.viewer.clock.stopTime;

        //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放
        this.viewer.clock.clockRange = Cesium.defaultValue(this.options.clockRange, Cesium.ClockRange.LOOP_STOP);
        this.viewer.clock.startTime = this.startTime.clone();
        this.viewer.clock.stopTime = this.stopTime.clone();
      }

      if (this.viewer.timeline) this.viewer.timeline.zoomTo(this.startTime, this.stopTime);

      //加投影
      if (this.options.shadow && this.options.shadow.length > 0) {
        this._addArrShading();
      }

      this._flyok_point_index = 0; //优化查询效率，飞行过的点id
      this.fire(_DasClass.eventType.endItem, {
        index: this._flyok_point_index,
        counts: this.positions.length
      });
      this.fire(_DasClass.eventType.start);
      this.viewer.scene.preRender.addEventListener(this.preRender_eventHandler, this);
    }

    //停止，结束漫游

  }, {
    key: "stop",
    value: function stop() {
      this.viewer.trackedEntity = undefined;
      this.viewer.scene.preRender.removeEventListener(this.preRender_eventHandler, this);

      if (this.entity) {
        this.viewer.entities.remove(this.entity);
        delete this.entity;
      }
      if (this.arrShowingEntity) {
        for (var i = 0, len = this.arrShowingEntity.length; i < len; i++) {
          this.viewer.entities.remove(this.arrShowingEntity[i]);
        }
        delete this.arrShowingEntity;
      }

      if (this._bak_startTime) {
        this.viewer.clock.startTime = this._bak_startTime;
        delete this._bak_startTime;
      }
      if (this._bak_stopTime) {
        this.viewer.clock.stopTime = this._bak_stopTime;
        delete this._bak_stopTime;
      }
      if (this._bak_multiplier) {
        this.viewer.clock.multiplier = this._bak_multiplier;
        delete this._bak_multiplier;
      }
      if (this._bak_clockRange) {
        this.viewer.clock.clockRange = this._bak_clockRange;
        delete this._bak_clockRange;
      }

      // this._flyok_point_index = 0;
      // this._isStart = false;
      // this.fire(eventType.end);
    }

    //实时监控事件

  }, {
    key: "preRender_eventHandler",
    value: function preRender_eventHandler(e) {
      if (!this._isStart || this.entity == null) return;

      if (this.viewer.clock.shouldAnimate && Cesium.JulianDate.greaterThanOrEquals(this.viewer.clock.currentTime, this.stopTime)) {
        this._flyok_point_index = this.positions.length - 1;

        //Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放

        if (this.options.autoStop || this.viewer.clock.clockRange == Cesium.ClockRange.UNBOUNDED) this.stop();

        if (!this._onStepTempBS) {
          this.fire(_DasClass.eventType.endItem, {
            index: this._flyok_point_index,
            counts: this.positions.length
          });

          this._isStart = false;
          this._flyok_point_index = 0;

          this.fire(_DasClass.eventType.end);
          this._onStepTempBS = true; //为了标识只回调一次
        }

        return;
      }

      //当前点
      var _position = this.position;
      if (Cesium.defined(_position)) {
        switch (this.options.camera.type //视角处理
        ) {default:
            //无
            if (this.viewer.trackedEntity != undefined) {
              this.viewer.trackedEntity = undefined;
              this.flyTo(this.options.camera);
            }
            break;
          case "gs":
            //跟随视角
            if (this.viewer.trackedEntity != this.entity) {
              this.viewer.trackedEntity = this.entity;
              this.flyTo(this.options.camera);
            }
            break;
          case "dy":
            //锁定第一视角
            if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

            var matrix = this.getModelMatrix();

            var transformX = this.options.camera.followedX; //距离运动点的距离（后方）
            var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
            this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-transformX, 0, transformZ));

            break;
          case "sd":
            //锁定上帝视角
            if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

            this.viewer.scene.camera.lookAtTransform(this.getModelMatrix(), new Cesium.Cartesian3(-1, 0, this.options.camera.followedZ) //followedZ 距离运动点的高度（上方）
            );
            break;
        }

        //实时监控
        if (this.viewer.clock.shouldAnimate) this.realTime(_position);
      }
    }
  }, {
    key: "realTime",
    value: function realTime(position) {
      var time = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.startTime); //已飞行时间
      var point = (0, _point.formatPosition)(position);

      var currIndex = this.getCurrIndex();
      var lineLength = this.positions.length;
      // if (currIndex < 0) currIndex = 0;
      // if (currIndex >= lineLength) currIndex = lineLength - 1;

      var thislen = this.stepLen[currIndex];

      var lastPosition = this.positions[currIndex];
      if (Cesium.defined(lastPosition)) thislen += Cesium.Cartesian3.distance(position, lastPosition);

      if (thislen >= this.alllen) {
        currIndex = lineLength - 1;
        thislen = this.alllen;
      }

      if (currIndex != this._flyok_point_index) {
        // daslog.log('已飞行过点：' + currIndex);
        this.fire(_DasClass.eventType.endItem, {
          index: currIndex,
          counts: lineLength
        });
      }
      this._flyok_point_index = currIndex;

      this.timeinfo = {
        time: time, //已飞行时间
        len: thislen, //已飞行距离
        x: point.x,
        y: point.y,
        z: point.z
      };

      if (this.options.shadow && this.options.shadow.length > 0) {
        //投影
        this._updateArrShading(position);
      }

      //求概略的 地面海拔 和 离地高度
      var carto = Cesium.Cartographic.fromCartesian(position);
      var heightTerrain = this.viewer.scene.globe.getHeight(carto); //地形高度
      if (heightTerrain != null && heightTerrain > 0) {
        this.timeinfo.hbgd = heightTerrain;
        this.timeinfo.ldgd = point.z - heightTerrain;
      }

      //求准确的 地面海拔 和 离地高度 (没有此需求时可以关闭，提高效率)
      if (this.options.showGroundHeight) {
        var that = this;
        (0, _polyline.computeSurfaceLine)({
          viewer: that.viewer,
          positions: [position, position],
          callback: function callback(raisedPositions, noHeight) {
            if (raisedPositions == null || raisedPositions.length == 0 || noHeight) {
              return;
            }

            var hbgd = (0, _point.formatPosition)(raisedPositions[0]).z; //地面高程
            var ldgd = point.z - hbgd; //离地高度

            that.timeinfo.hbgd = hbgd;
            that.timeinfo.ldgd = ldgd;

            if (that.entity.label) {
              var fxgd_str = (0, _util.formatLength)(that.timeinfo.z);
              var ldgd_str = (0, _util.formatLength)(that.timeinfo.ldgd);
              that.entity.label.text = that.name + "\n" + "漫游高程：" + fxgd_str + "\n离地距离：" + ldgd_str;
            }
          }
        });
      }
    }

    //计算贴地线

  }, {
    key: "clampToGround",
    value: function clampToGround(onEnd, opts) {
      opts = opts || {};

      //贴地线
      var lonlats = this.points;
      var arrSpeed = this.arrSpeed || this.options.speed;
      var lonlatsNew = [];
      var speedsNew = [];

      //剖面的数据
      var alllen = 0;
      var arrLength = [];
      var arrHbgd = [];
      var arrFxgd = [];
      var arrPoint = [];

      var that = this;
      (0, _polyline.computeStepSurfaceLine)({
        viewer: this.viewer,
        positions: this.positions,
        has3dtiles: opts.has3dtiles,
        splitNum: opts.splitNum,
        offset: opts.offset,
        //计算每个分段后的回调方法
        endItem: function endItem(raisedPositions, noHeight, index) {
          var speed = arrSpeed[index];

          if (noHeight) {
            lonlatsNew.push(lonlats[index]);
            speedsNew.push(speed);
          } else {
            for (var i = 0; i < raisedPositions.length; i++) {
              var position = raisedPositions[i];
              var carto = Cesium.Cartographic.fromCartesian(position);

              lonlatsNew.push([Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude), carto.height]);
              speedsNew.push(speed);
            }
          }

          //剖面的数据
          var h1 = lonlats[index][2] || 0;
          var h2 = lonlats[index + 1][2] || 0;
          var hstep = (h2 - h1) / raisedPositions.length;

          for (var _i = 0; _i < raisedPositions.length; _i++) {
            //已飞行长度
            if (_i != 0) {
              alllen += Cesium.Cartesian3.distance(raisedPositions[_i], raisedPositions[_i - 1]);
            }
            arrLength.push(Number(alllen.toFixed(1)));

            //坐标
            var point = (0, _point.formatPosition)(raisedPositions[_i]);
            arrPoint.push(point);

            //海拔高度
            var hbgd = noHeight ? 0 : point.z;
            arrHbgd.push(hbgd);

            //飞行高度
            var fxgd = Number((h1 + hstep * _i).toFixed(1));
            arrFxgd.push(fxgd);
          }
        },
        //计算全部完成的回调方法
        end: function end() {
          //剖面的数据(记录下，提高效率，避免多次计算)
          that.terrainHeight = {
            arrLength: arrLength,
            arrFxgd: arrFxgd,
            arrHbgd: arrHbgd,
            arrPoint: arrPoint
          };

          that.createPath(lonlatsNew, _extends({}, that.options, {
            speed: speedsNew
          }));

          if (onEnd) {
            onEnd({ lonlats: lonlatsNew, speed: speedsNew });
          }
        }
      });
    }

    //获取剖面数据

  }, {
    key: "getTerrainHeight",
    value: function getTerrainHeight(callback, opts) {
      if (this.terrainHeight) {
        callback(this.terrainHeight);
        return this.terrainHeight;
      } else {
        opts = opts || {};

        var lonlats = this.points;

        //剖面的数据
        var alllen = 0;
        var arrLength = [];
        var arrHbgd = [];
        var arrFxgd = [];
        var arrPoint = [];

        var that = this;
        (0, _polyline.computeStepSurfaceLine)({
          viewer: this.viewer,
          positions: this.positions,
          has3dtiles: opts.has3dtiles,
          splitNum: opts.splitNum,
          offset: opts.offset,
          //计算每个分段后的回调方法
          endItem: function endItem(raisedPositions, noHeight, index) {
            //剖面的数据
            var h1 = lonlats[index][2] || 0;
            var h2 = lonlats[index + 1][2] || 0;
            var hstep = (h2 - h1) / raisedPositions.length;

            for (var i = 0; i < raisedPositions.length; i++) {
              //已飞行长度
              if (i != 0) {
                alllen += Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              }
              arrLength.push(Number(alllen.toFixed(1)));

              //坐标
              var point = (0, _point.formatPosition)(raisedPositions[i]);
              arrPoint.push(point);

              //海拔高度
              var hbgd = noHeight ? 0 : point.z;
              arrHbgd.push(hbgd);

              //飞行高度
              var fxgd = Number((h1 + hstep * i).toFixed(1));
              arrFxgd.push(fxgd);
            }
          },
          //计算全部完成的回调方法
          end: function end() {
            //剖面的数据(记录下，提高效率，避免多次计算)
            that.terrainHeight = {
              arrLength: arrLength,
              arrFxgd: arrFxgd,
              arrHbgd: arrHbgd,
              arrPoint: arrPoint
            };
            callback(that.terrainHeight);
          }
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.options;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.stop();
      _get(FlyLine.prototype.__proto__ || Object.getPrototypeOf(FlyLine.prototype), "destroy", this).call(this);
    }
  }, {
    key: "info",

    //========== 对外属性 ==========
    //当前信息
    get: function get() {
      return this.timeinfo;
    }
  }]);

  return FlyLine;
}(_BaseFlyLine2.BaseFlyLine);

//[静态属性]本类中支持的事件类型常量


FlyLine.event = {
  start: _DasClass.eventType.start,
  endItem: _DasClass.eventType.endItem,
  end: _DasClass.eventType.end
};

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DynamicFlyLine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _BaseFlyLine2 = __webpack_require__(88);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//飞行路线管理类 【动态传入的数据】
var DynamicFlyLine = exports.DynamicFlyLine = function (_BaseFlyLine) {
  _inherits(DynamicFlyLine, _BaseFlyLine);

  function DynamicFlyLine() {
    _classCallCheck(this, DynamicFlyLine);

    return _possibleConstructorReturn(this, (DynamicFlyLine.__proto__ || Object.getPrototypeOf(DynamicFlyLine)).apply(this, arguments));
  }

  _createClass(DynamicFlyLine, [{
    key: "init",


    //========== 方法 ==========
    value: function init() {
      this._maxCount = Cesium.defaultValue(this.options.maxCount, 50); //保留的坐标点数量

      this.property = new Cesium.SampledPositionProperty();
      this.velocityOrientation = new Cesium.VelocityOrientationProperty(this.property); //基于移动位置自动计算方位

      delete this.options.path; //动态时非直接property，但path需要property，所以去掉path，可以用 "shadow": [{ "show": true, "type": "polyline", "color": "#ff0000" }]
      this._createEntity();

      this.entity.show = true;
      this.viewer.clock.shouldAnimate = true;

      //加投影
      if (this.options.shadow && this.options.shadow.length > 0) {
        this._addArrShading();
      }
      this.viewer.scene.preRender.addEventListener(this.preRender_eventHandler, this);
    }
    //根据传入的坐标数组，构造路线。

  }, {
    key: "updatePath",
    value: function updatePath(points) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!points || points.length === 0) return;

      if (!this.property) {
        this.property = new Cesium.SampledPositionProperty();
        this.entity.orientation = new Cesium.VelocityOrientationProperty(this.property); // 方向
        this.entity.show = true;
      }

      var position, time;
      for (var i = 0, len = points.length; i < len; i++) {
        var item = points[i];
        time = Cesium.JulianDate.fromDate(new Date(item[options.timeColumn || "time"]));
        position = item.position || options.getPosition(item, i);
        this.property.addSample(time, position);

        this.positions.push(position);
        this.times.push(time);
      }

      this.lastItem = {
        position: position,
        time: time
      };

      var duoyu = this.positions.length - this._maxCount;
      if (duoyu > 0) {
        var _starttime = this.times[0];
        var _endtime = this.times[duoyu - 1];
        this.property.removeSamples(new Cesium.TimeInterval({
          start: _starttime,
          stop: _endtime
        }));

        this.positions.splice(0, duoyu);
        this.times.splice(0, duoyu);
      }

      this.position;
    }

    //实时监控事件

  }, {
    key: "preRender_eventHandler",
    value: function preRender_eventHandler(e) {
      if (this.positions.length == 0) return;

      //当前点
      var _position = this.position;
      if (Cesium.defined(_position)) {
        //视角处理
        switch (this.options.camera && this.options.camera.type) {
          default:
            //无
            if (this.viewer.trackedEntity != undefined) {
              this.viewer.trackedEntity = undefined;
              this.flyTo(this.options.camera);
            }
            break;
          case "gs":
            //跟随视角
            if (this.viewer.trackedEntity != this.entity) {
              this.viewer.trackedEntity = this.entity;
              this.flyTo(this.options.camera);
            }
            break;
          case "dy":
            //锁定第一视角
            if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

            var matrix = this.getModelMatrix();

            var transformX = this.options.camera.followedX; //距离运动点的距离（后方）
            var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
            this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-transformX, 0, transformZ));

            break;
          case "sd":
            //锁定上帝视角
            if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

            this.viewer.scene.camera.lookAtTransform(this.getModelMatrix(), new Cesium.Cartesian3(-1, 0, this.options.camera.followedZ) //followedZ距离运动点的高度（上方）
            );
            break;
        }

        //实时监控
        if (this.viewer.clock.shouldAnimate) this.realTime(_position);
      }
    }
  }, {
    key: "realTime",
    value: function realTime(position) {
      this._flyok_point_index = this.getCurrIndex();

      if (this.options.shadow && this.options.shadow.length > 0) {
        //投影
        this._updateArrShading(position);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.preRender.removeEventListener(this.preRender_eventHandler, this);
      _get(DynamicFlyLine.prototype.__proto__ || Object.getPrototypeOf(DynamicFlyLine.prototype), "destroy", this).call(this);
    }
  }, {
    key: "defConfig",

    //参数默认值
    get: function get() {
      return {
        model: { show: false, scale: 1, minimumPixelSize: 50 },
        label: {
          show: false,
          color: "#ffffff",
          opacity: 1,
          font_family: "楷体",
          font_size: 20,
          border: true,
          border_color: "#000000",
          border_width: 3,
          background: false,
          hasPixelOffset: true,
          pixelOffsetX: 30,
          pixelOffsetY: -30,
          scaleByDistance: true,
          scaleByDistance_far: 10000000,
          scaleByDistance_farValue: 0.4,
          scaleByDistance_near: 5000,
          scaleByDistance_nearValue: 1
        },
        camera: { type: "", followedX: 50, followedZ: 10 },
        showGroundHeight: false
      };
    }
  }]);

  return DynamicFlyLine;
}(_BaseFlyLine2.BaseFlyLine);

// function removeSamplesAll(property) {
//   var startIndex = 0,
//     numberToRemove = property._times.length;

//   var packedLength = property._packedLength;
//   property._times.splice(startIndex, numberToRemove);
//   property._values.splice(startIndex * packedLength, numberToRemove * packedLength);
//   property._updateTableLength = true;
//   property._definitionChanged.raiseEvent(property);
// }

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FirstPersonRoam = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//第一人称贴地漫游
var FirstPersonRoam = exports.FirstPersonRoam = function () {
  function FirstPersonRoam(options) {
    _classCallCheck(this, FirstPersonRoam);

    this.options = options;
    this.viewer = options.viewer;
    this.camera = this.viewer.camera;
    this.moveX = 0;
    this.moveY = 0;
    this.oldPosition = 0;
    this.heightType = "free"; // "fixed",//free  固定视角高度 or 自由移动
    this._rotateStep = Cesium.defaultValue(options.rotateStep, 0.05); // 相机围绕当前点旋转速率
    this._moveStep = Cesium.defaultValue(options.moveStep, 0.5); // 平移步长(米)
    this.scene = this.viewer.scene;
    this.canvas = this.viewer.canvas;
    this.ellipsoid = this.scene.globe.ellipsoid;
    this.element = this.viewer.container;
    this.flags = {
      looking: false,
      moveForward: false,
      moveBackward: false,
      moveUp: false,
      moveDown: false,
      moveLeft: false,
      moveRight: false,
      oldHeight: 0
    };

    this.elementClickHandler = this.elementClick.bind(this);
    this.documentPointerlockchangeHandler = this.documentPointerlockchange.bind(this);
    this.documentKyeDownHandler = this.documentKyeDown.bind(this);
    this.documentKyeUpHandler = this.documentKyeUp.bind(this);
    this.preRenderListenerHandler = this.preRenderListener.bind(this);
    this.rotate3DHandler = this.rotate3D.bind(this);
  }

  //========== 方法 ==========


  _createClass(FirstPersonRoam, [{
    key: "init",
    value: function init() {
      this.element.addEventListener('click', this.elementClickHandler, false);
      document.addEventListener('pointerlockchange', this.documentPointerlockchangeHandler, false);
    }
  }, {
    key: "elementClick",
    value: function elementClick() {
      var element = this.element;
      element.requestPointerLock();
      var scene = this.viewer.scene;
      var canvas = this.viewer.canvas;
      canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
      canvas.onclick = function () {
        canvas.focus();
      };
      //碰撞检测?
      scene.screenSpaceCameraController.enableIndoorColliDetection = true;
      scene.screenSpaceCameraController.enableRotate = false;
      scene.screenSpaceCameraController.enableTranslate = false;
      scene.screenSpaceCameraController.enableTilt = false;
      scene.screenSpaceCameraController.enableLook = false;
      //先删除事件,防止多次注册事件
      document.removeEventListener('keydown', this.documentKyeDownHandler, false);
      document.removeEventListener('keyup', this.documentKyeUpHandler, false);
      this.viewer.scene.preRender.removeEventListener(this.preRenderListenerHandler, this);
      //再添加事件
      document.addEventListener('keydown', this.documentKyeDownHandler, false);
      document.addEventListener('keyup', this.documentKyeUpHandler, false);
      this.viewer.scene.preRender.addEventListener(this.preRenderListenerHandler, this);
    }
  }, {
    key: "documentKyeDown",
    value: function documentKyeDown(event) {
      var flagName = this.getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== 'undefined') {
        this.flags[flagName] = true;
      }
    }
  }, {
    key: "documentKyeUp",
    value: function documentKyeUp(event) {
      var flagName = this.getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== 'undefined') {
        this.flags[flagName] = false;
      }
    }
  }, {
    key: "preRenderListener",
    value: function preRenderListener() {
      var camera = this.camera;
      var moveRate = this._moveStep;
      if (this.flags.moveForward) {
        //W
        camera.move(camera.direction, moveRate);
        //camera.moveForward(moveRate);
      }
      if (this.flags.moveBackward) {
        //S
        camera.moveBackward(moveRate);
      }
      if (this.flags.moveUp) {
        //Q
        camera.moveUp(moveRate > 2 ? 2 : moveRate);
      }
      if (this.flags.moveDown) {
        //E
        camera.moveDown(moveRate);
      }
      if (this.flags.moveLeft) {
        //D
        camera.moveLeft(moveRate * 0.7);
      }
      if (this.flags.moveRight) {
        //A
        camera.moveRight(moveRate * 0.7);
      }
      var split = this._rotateStep;
      var x = this.moveX * split;
      var y = -this.moveY * split;
      var cartographic = Cesium.Cartographic.fromCartesian(this.viewer.camera.position);
      var newPosition = Cesium.clone(cartographic);
      //如果是固定视高,就给固定高度
      if (this.heightType == "fixed") {
        var baseHeight = this.scene.sampleHeight(cartographic);
        if (baseHeight < 0) {
          baseHeight = this.scene.globe.getHeight(cartographic);
        }
        newPosition.height = baseHeight + 1.75;
      }
      if (this.oldPosition == 0) {
        this.oldPosition = newPosition;
      } else {
        this.flags.oldHeight = this.oldPosition.height;
        if (newPosition.height - this.oldPosition.height >= 2) {
          if (!this.isCollision(this, this.ellipsoid)) {
            newPosition = this.oldPosition;
          } else {
            newPosition.height = flags.oldHeight;
            this.oldPosition = newPosition;
          }
        } else {
          this.oldPosition = newPosition;
        }
      }
      newPosition = this.ellipsoid.cartographicToCartesian(newPosition);
      this.viewer.camera.setView({
        destination: newPosition,
        orientation: {
          heading: Cesium.Math.toRadians(x), // 方向
          pitch: Cesium.Math.toRadians(y), // 倾斜角度
          roll: Cesium.Math.toRadians(0.0)
        }
      });
    }
  }, {
    key: "documentPointerlockchange",
    value: function documentPointerlockchange() {
      var element = this.viewer.container;
      if (document.pointerLockElement == element) {
        document.addEventListener("mousemove", this.rotate3DHandler, false);
      } else {
        document.removeEventListener("mousemove", this.rotate3DHandler, false);
      }
    }
  }, {
    key: "rotate3D",
    value: function rotate3D(event) {
      this.moveX += event.movementX;
      this.moveY += event.movementY;
    }
  }, {
    key: "isCollision",
    value: function isCollision(that, ellipsoid) {
      var camera = that.camera;
      var direction = camera.direction;
      //建立射线
      var ray = new Cesium.Ray(camera.position, direction);
      var result = that.viewer.scene.pickFromRay(ray);
      var point1cartographic = Cesium.Cartographic.fromCartesian(camera.position);
      var point2cartographic = Cesium.Cartographic.fromCartesian(result.position);
      point1cartographic.height = 0;
      point2cartographic.height = 0;
      point1cartographic = Cesium.Cartographic.toCartesian(point1cartographic, ellipsoid);
      point2cartographic = Cesium.Cartographic.toCartesian(point2cartographic, ellipsoid);
      var distance = Cesium.Cartesian3.distance(point1cartographic, point2cartographic);
      if (distance > 0.5) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "getFlagForKeyCode",
    value: function getFlagForKeyCode(keyCode) {
      switch (keyCode) {
        case 'W'.charCodeAt(0):
          return 'moveForward';
        case 'S'.charCodeAt(0):
          return 'moveBackward';
        case 'Q'.charCodeAt(0):
          return 'moveUp';
        case 'E'.charCodeAt(0):
          return 'moveDown';
        case 'D'.charCodeAt(0):
          return 'moveRight';
        case 'A'.charCodeAt(0):
          return 'moveLeft';
        //case 13:
        //    return "enter";
        default:
          return undefined;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      //先删除子事件
      var that = this;
      document.removeEventListener('keydown', that.documentKyeDownHandler, false);
      document.removeEventListener('keyup', that.documentKyeUpHandler, false);
      that.viewer.scene.preRender.removeEventListener(that.preRenderListenerHandler, that);
      //再删除父事件
      this.viewer.container.removeEventListener('click', that.elementClickHandler, false);
      document.removeEventListener("mousemove", that.rotate3DHandler, false);
      document.removeEventListener('pointerlockchange', that.documentPointerlockchangeHandler, false);

      // 注册左键平移地图事件
      this.viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
      this.viewer.scene.screenSpaceCameraController.enableZoom = false;
    }

    //========== 对外属性 ==========

  }, {
    key: "moveStep",
    get: function get() {
      return this._moveStep;
    },
    set: function set(value) {
      this._moveStep = value;
    }
  }, {
    key: "rotateStep",
    get: function get() {
      return this._rotateStep;
    },
    set: function set(value) {
      this._rotateStep = value;
    }
  }]);

  return FirstPersonRoam;
}();

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreetCameraController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MAX_PITCH_IN_DEGREE = 88;

//街景视角模式控制
// 1、右键拖拽，以相机视角为中心进行旋转。
// 2、中键拖拽，可以升高或降低相机高度。
// 3、左键双击，飞行定位到该点。
// 4、右键双击，围绕该点旋转。

var StreetCameraController = exports.StreetCameraController = function () {
  function StreetCameraController(options) {
    _classCallCheck(this, StreetCameraController);

    this.viewer = options.viewer;
    this.enable = Cesium.defaultValue(options.enable, false);
    this.rotateSpeed = Cesium.defaultValue(options.rotateSpeed, 30); //旋转的方向和速度，正负控制方向。

    this.heightStep = Cesium.defaultValue(options.heightStep, 0.2);
    this.moveStep = Cesium.defaultValue(options.moveStep, 0.1);

    this.options = options;
  }

  //========== 对外属性 ==========


  _createClass(StreetCameraController, [{
    key: "_init",


    //========== 方法 ==========

    value: function _init() {
      var _this = this;

      var that = this;
      var canvas = this.viewer.canvas;

      //按住右键不松手，拖拽，就可以以当前相机为中心旋转角度
      this._handler = new Cesium.ScreenSpaceEventHandler(canvas);
      this._handler.setInputAction(function (event) {
        _point.windingPoint.stop();

        _this._isMouseLeftButtonPressed = true;
        _this._mousePosition = _this._startMousePosition = Cesium.Cartesian3.clone(event.position);

        _this._headingWhenLeftClicked = Cesium.Math.toDegrees(_this.viewer.camera.heading);
        _this._pitchWhenLeftClicked = Cesium.Math.toDegrees(_this.viewer.camera.pitch);
      }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

      this._handler.setInputAction(function (event) {
        that._onMouseMove(event);
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      this._handler.setInputAction(function (event) {
        _this._isMouseLeftButtonPressed = false;
      }, Cesium.ScreenSpaceEventType.RIGHT_UP);

      //按住中键不松手，上下拖拽，可以“升高或降低”相机高度
      this._handler.setInputAction(function (event) {
        _point.windingPoint.stop();

        _this._isMouseUpdownPressed = true;
        _this._mousePosition = _this._startMousePosition = Cesium.Cartesian3.clone(event.position);
      }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);

      this._handler.setInputAction(function (event) {
        _this._isMouseUpdownPressed = false;
      }, Cesium.ScreenSpaceEventType.MIDDLE_UP);

      //左键双击一个点，就飞过去
      this._handler.setInputAction(function (event) {
        _point.windingPoint.stop();
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this._handler.setInputAction(function (event) {
        _point.windingPoint.stop();

        _this._move(event);
      }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

      //右键双击一个点，就围绕这个点旋转
      var time;
      this._handler.setInputAction(function (event) {
        if (time) {
          var delTime = Cesium.JulianDate.secondsDifference(_this.viewer.clock.currentTime, time);
          if (delTime < 0.5) {
            if (_this.viewer.das.contextmenu) _this.viewer.das.contextmenu.close();

            var position = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.position);
            position.time = _this.options.windingPointTime;
            position.autoStopAngle = _this.options.windingPointAngle;
            position.direction = _this.options.windingPointDirection;
            _point.windingPoint.start(_this.viewer, position);
          }
        }
        time = _this.viewer.clock.currentTime.clone();
      }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

      canvas.setAttribute("tabindex", "0");
      canvas.onclick = function () {
        canvas.focus();
      };
    }
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(event) {
      this._mousePosition = event.endPosition;

      if (this._isMouseLeftButtonPressed) {
        var width = this.viewer.canvas.clientWidth;
        var height = this.viewer.canvas.clientHeight;

        // Coordinate (0.0, 0.0) will be where the mouse was clicked.
        var deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
        var deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;

        if (Cesium.Math.equalsEpsilon(deltaX, 0, Cesium.Math.EPSILON6) && Cesium.Math.equalsEpsilon(deltaY, 0, Cesium.Math.EPSILON6)) return;

        var deltaHeadingInDegree = deltaX * this.rotateSpeed;
        var newHeadingInDegree = this._headingWhenLeftClicked + deltaHeadingInDegree;

        var deltaPitchInDegree = deltaY * this.rotateSpeed;
        var newPitchInDegree = this._pitchWhenLeftClicked + deltaPitchInDegree;

        if (newPitchInDegree > MAX_PITCH_IN_DEGREE * 2 && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
          newPitchInDegree = 360 - MAX_PITCH_IN_DEGREE;
        } else {
          if (newPitchInDegree > MAX_PITCH_IN_DEGREE && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
            newPitchInDegree = MAX_PITCH_IN_DEGREE;
          }
        }

        this.viewer.camera.setView({
          orientation: {
            heading: Cesium.Math.toRadians(newHeadingInDegree),
            pitch: Cesium.Math.toRadians(newPitchInDegree),
            roll: this.viewer.camera.roll
          }
        });
      } else if (this._isMouseUpdownPressed) {
        var deltaHei = -(this._mousePosition.y - this._startMousePosition.y) / this.viewer.canvas.clientHeight;

        var lookFactor = this.viewer.camera.positionCartographic.height * this.heightStep;

        this.viewer.camera.moveDown(deltaHei * lookFactor);
      }
    }
  }, {
    key: "_move",
    value: function _move(event) {
      var position = (0, _point.getCurrentMousePosition)(this.viewer.scene, event.position);
      if (position) {
        var camera_distance = Cesium.Cartesian3.distance(position, this.viewer.camera.positionWC) * this.moveStep;
        // if (camera_distance > 5000) camera_distance = 5000;

        this.viewer.das.centerPoint(position, {
          radius: camera_distance, //距离目标点的距离
          maximumHeight: this.viewer.camera.positionCartographic.height,
          duration: this.options.moveDuration
        });
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._handler.destroy();
      delete this._handler;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(value) {
      if (this._enable == value) return;

      this._enable = value;
      if (this.viewer.das.mouseZoom) this.viewer.das.mouseZoom.enable = !value;

      if (value) {
        //去掉Cesium默认的中右键的操作
        this._default_zoomEventTypes = this.viewer.scene.screenSpaceCameraController.zoomEventTypes;
        this._default_tiltEventTypes = this.viewer.scene.screenSpaceCameraController.tiltEventTypes;
        this.viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH, {
          eventType: Cesium.CameraEventType.RIGHT_DRAG,
          modifier: Cesium.KeyboardEventModifier.CTRL
        }];
        this.viewer.scene.screenSpaceCameraController.tiltEventTypes = [{
          eventType: Cesium.CameraEventType.MIDDLE_DRAG,
          modifier: Cesium.KeyboardEventModifier.CTRL
        }];

        this._init();
      } else {
        //还原Cesium默认的中右键的操作
        if (this._default_zoomEventTypes) {
          this.viewer.scene.screenSpaceCameraController.zoomEventTypes = this._default_zoomEventTypes;
          delete this._default_zoomEventTypes;
        }
        if (this._default_tiltEventTypes) {
          this.viewer.scene.screenSpaceCameraController.tiltEventTypes = this._default_tiltEventTypes;
          delete this._default_tiltEventTypes;
        }

        this.clear();
      }
    }
  }]);

  return StreetCameraController;
}();

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CameraViewController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 相机视角控制
var CameraViewController = exports.CameraViewController = function () {
  function CameraViewController(options) {
    _classCallCheck(this, CameraViewController);

    this.viewer = options.viewer;

    this.position = (0, _point.pickCenterPoint)(viewer.scene);

    this.minViewingAngle = viewer.das.config.operation.minViewingAngle;
    this.maxViewingAngle = viewer.das.config.operation.maxViewingAngle;
    this.PitchAngleReversal = viewer.das.config.operation.PitchAngleReversal;
    this.lowHeight = viewer.das.config.operation.lowHeight;
  }

  /**
   * 向左旋转
   * @param speed
   */


  _createClass(CameraViewController, [{
    key: "turnLeft",
    value: function turnLeft(speed) {
      var _speed = Cesium.defaultValue(speed, 0.01);
      this._rotateAroundPoint(this.position, this.position, _speed);
    }

    /**
     * 向右旋转
     * @param speed
     */

  }, {
    key: "turnRight",
    value: function turnRight(speed) {
      var _speed = Cesium.defaultValue(speed, 0.01);
      this._rotateAroundPoint(this.position, this.position, -_speed);
    }

    /**
     * 向上看
     * @param speed
     */

  }, {
    key: "lookUp",
    value: function lookUp(speed) {
      var speed = Cesium.defaultValue(speed, 0.01);
      this._lookUpOrDown(speed, true);
    }

    /**
     * 向下看
     * @param speed
     */

  }, {
    key: "lookDown",
    value: function lookDown(speed) {
      var speed = Cesium.defaultValue(speed, 0.01);
      this._lookUpOrDown(-speed, false);
    }

    /**
     * 上下方向旋转
     * @param speed
     * @param isUp 默认为true
     */

  }, {
    key: "_lookUpOrDown",
    value: function _lookUpOrDown(speed, isUp) {
      var viewer = this.viewer;
      var d = Cesium.Cartesian3.angleBetween(viewer.camera.position, viewer.camera.up);

      var minViewingAngle = this.minViewingAngle;
      var maxViewingAngle = this.maxViewingAngle;
      var PitchAngleReversal = this.PitchAngleReversal;
      var position = this.position;

      var canMove = true;

      if (isUp) {
        if (PitchAngleReversal) {
          //俯仰角是否反转
          if (d >= Cesium.Math.toRadians(maxViewingAngle)) {
            canMove = false;
          }
        } else {
          if (d <= Cesium.Math.toRadians(minViewingAngle) || viewer.camera.pitch > 0) {
            canMove = false;
          }
        }

        if (d < Cesium.Math.toRadians(90)) {
          viewer.camera.rotateAroundPoint(position, viewer.camera.right, 0.01); //俯仰角移动
        }
      } else {
        if (PitchAngleReversal) {
          //俯仰角是否反转
          if (d <= Cesium.Math.toRadians(minViewingAngle) || viewer.camera.pitch > 0) {
            canMove = false;
          }
        } else {
          if (d >= Cesium.Math.toRadians(maxViewingAngle)) {
            canMove = false;
          }
        }
      }

      if (canMove) {
        viewer.camera.rotateAroundPoint(position, viewer.camera.right, speed); //俯仰角移动
      }
    }

    /**
     * 相机旋转
     * @param e
     * @param t
     * @param n
     * @private
     */

  }, {
    key: "_rotateAroundPoint",
    value: function _rotateAroundPoint(e, t, n) {
      var viewer = this.viewer;

      var i = new Cesium.Cartesian3();
      var lowHeight = this.lowHeight; //最低高度
      Cesium.Cartesian3.subtract(viewer.camera.position, e, i); //计算两个笛卡尔分量差(left, right, result)
      var s,
          o,
          u = Cesium.defaultValue(n, viewer.camera.defaultRotateAmount),
          a = Cesium.Quaternion.fromAxisAngle(t, -u, s),
          //a为围绕这个z轴旋转d度的四元数
      f = Cesium.Matrix3.fromQuaternion(a, o); //从提供的四元数计算3x3旋转矩阵。

      Cesium.Matrix3.multiplyByVector(f, i, i); //计算矩阵和列向量的乘积。  矩阵, 列, 结果

      var cc = {
        x: 0,
        y: 0,
        z: 0
      };
      Cesium.Cartesian3.add(i, e, cc); //计算两个笛卡尔的分量和
      var mbPosition = viewer.scene.globe.ellipsoid.cartesianToCartographic(cc);
      mbPosition.longitude = Cesium.Math.toDegrees(mbPosition.longitude);
      mbPosition.latitude = Cesium.Math.toDegrees(mbPosition.latitude);
      var xx = Cesium.Cartographic.fromDegrees(mbPosition.longitude, mbPosition.latitude);
      var height = viewer.scene.globe.getHeight(xx);

      if (mbPosition.height - height > lowHeight) {
        this.position = cc;
      } else {
        this.position = Cesium.Cartesian3.fromDegrees(mbPosition.longitude, mbPosition.latitude, height + lowHeight);
      }
      Cesium.Matrix3.multiplyByVector(f, viewer.camera.direction, viewer.camera.direction);
      Cesium.Matrix3.multiplyByVector(f, viewer.camera.up, viewer.camera.up);
      Cesium.Matrix3.multiplyByVector(f, viewer.camera.right, viewer.camera.right);
    }
  }]);

  return CameraViewController;
}();

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MouseOperationController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MouseOperationController = exports.MouseOperationController = function () {
  function MouseOperationController(options) {
    _classCallCheck(this, MouseOperationController);

    this.viewer = options.viewer;
    this.viewer.scene.screenSpaceCameraController.inertiaSpin = 0.7; //限制左键惯性
    this.operation = Cesium.defaultValue(this.viewer.das.config.operation, {});
    this.minViewingAngle = Cesium.defaultValue(this.operation.minViewingAngle, 1); //摄像机最低角度
    this.maxViewingAngle = Cesium.defaultValue(this.operation.maxViewingAngle, 89); //摄像机最高角度
    this.PitchAngleReversal = Cesium.defaultValue(this.operation.PitchAngleReversal, false); //俯仰角是否翻转
    this.lowHeight = Cesium.defaultValue(this.operation.lowHeight, 10); //摄像机距离地面最低高度
    this.isCenterRotation = Cesium.defaultValue(this.operation.CenterRotation, false); //是否是中心旋转
    this.LRRotationSpeed = 0.005; // Cesium.defaultValue(this.operation.LRRotationSpeed, 0.005); //左右旋转速度
    this.TDRotationSpeed = 0.005; // Cesium.defaultValue(this.operation.TDRotationSpeed, 0.005); //上下旋转速度
    this.rotateKey = "right"; //设置旋转的按钮(left,center,right)
    this.MAX_ALTITUDE = 100000000;
    if (!this.operation.MouseRightRotate) {
      this.rotateKey = "center";
    }
    this._downMousePosition = null; //鼠标按下原始位置
    this._downTranslationPosition = null; //拖拽平移按下的原始位置
    this.icon = null; //旋转中心点图标
    this.rotateCenter = Cesium.defaultValue(this.operation.rotateCenter, "mouse");
    //是否锁定旋转
    this._rotationLock = false;
    this._preCameraAngle = 0;
  }
  //启动


  _createClass(MouseOperationController, [{
    key: "init",
    value: function init() {
      /*先把原生鼠标操作都禁止了*/
      this.viewer.scene.screenSpaceCameraController.maximumZoomDistance = this.MAX_ALTITUDE; //设置个最高的高度
      this.viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
      this.viewer.scene.screenSpaceCameraController.enableZoom = true;
      this.viewer.scene.screenSpaceCameraController.enableTilt = false;
      var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas); //获取地图对象

      this.handler = handler;
      this.maximumZoomDistance = this.viewer.scene.screenSpaceCameraController.maximumZoomDistance;

      var that = this;
      this.viewer.camera.rotateAroundPoint = this._rotateAroundPoint;
      //如果是右键旋转
      if (this.rotateKey == "right") {
        this.viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.MIDDLE_DRAG, Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
        //右键按下
        handler.setInputAction(function (event) {
          that.initMouseDownParameters(event);
        }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
        //右键抬起
        handler.setInputAction(function (event) {
          that.resetMouseDownParameters(event);
        }, Cesium.ScreenSpaceEventType.RIGHT_UP);
        //左键按下
        handler.setInputAction(function (event) {
          that.initMouseTranslationDown(event);
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        //左键抬起
        handler.setInputAction(function (event) {
          that.initMouseTranslationUp(event);
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
      } else if (this.rotateKey == "center") {
        //如果是中键旋转
        this.viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.RIGHT_DRAG, Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
        //中键按下
        handler.setInputAction(function (event) {
          that.initMouseDownParameters(event);
        }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
        //中键抬起
        handler.setInputAction(function (event) {
          that.resetMouseDownParameters(event);
        }, Cesium.ScreenSpaceEventType.MIDDLE_UP);
        //左键按下
        handler.setInputAction(function (event) {
          //  that.initMouseTranslationDown(event);
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        //左键抬起
        handler.setInputAction(function (event) {
          // that.initMouseTranslationUp(event);
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
      }
      //鼠标移动
      handler.setInputAction(function (event) {
        that.mouseMoveParameters(event);
        // that.cameraTranslation(event);
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      //原生的zoom事件不简单,可以有效预防roll错误的情况
      // handler.setInputAction(function(event) {
      //   that.mouseZoom(event);
      // }, Cesium.ScreenSpaceEventType.WHEEL);
    }
    //鼠标旋转按下事件

  }, {
    key: "initMouseDownParameters",
    value: function initMouseDownParameters(e) {
      if (this.rotateCenter == "mouse") {
        this._downMousePosition = das3d.point.getCurrentMousePosition(this.viewer.scene, e.position);
      } else {
        var canvas = viewer.scene.canvas;
        var center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);
        this._downMousePosition = das3d.point.getCurrentMousePosition(this.viewer.scene, center);
      }

      if (!this.icon) {
        //如果没有图标entity就创建一个图标
        this.createIcon(this._downMousePosition);
      } else {
        //如果有图标entity则移到对应的位置
        this.icon.show = true;
        this.icon.position = this._downMousePosition;
      }
      this.setCursor("CloseHandDragRotate");
    }
    //鼠标旋转抬起事件

  }, {
    key: "resetMouseDownParameters",
    value: function resetMouseDownParameters(e) {
      this._downMousePosition = null;
      this.icon.show = false;
      this.setCursor("OpenHand");
    }
    //鼠标拖拽平移按下事件

  }, {
    key: "initMouseTranslationDown",
    value: function initMouseTranslationDown(e) {
      //   this._downTranslationPosition = das3d.point.getCurrentMousePosition(this.viewer.scene, event.position);
      this.setCursor("CloseHand");
    }
    //鼠标拖拽平移抬起事件

  }, {
    key: "initMouseTranslationUp",
    value: function initMouseTranslationUp(e) {
      // this._downTranslationPosition = null;
      this.setCursor("OpenHand");
    }
    //鼠标中键缩放

  }, {
    key: "mouseZoom",
    value: function mouseZoom(e) {
      //如果取屏幕中心点,可以用注释的代码
      // var canvasWidth = viewer.scene.canvas.width / 2;
      // var canvasHeight = viewer.scene.canvas.height / 2;
      // var canvasCenter=Cesium.Cartesian2.fromElements(canvasWidth, canvasHeight)
      var centerPoint = das3d.point.getCurrentMousePosition(this.viewer.scene, this.mousePosition);
      if (centerPoint != undefined) {
        var distance = Cesium.Cartesian3.distance(centerPoint, viewer.camera.position); //获取缩放点和摄像机的距离
        var SplitDistance = Cesium.Math.sign(e) * distance / 10;
        SplitDistance = Cesium.Math.sign(e) * Math.abs(SplitDistance);
        if (SplitDistance < 0.5 && e > 0) {
          return;
        }
        this.viewer.camera.position = das3d.matrix.getOnLinePointByLen(centerPoint, this.viewer.camera.position, -SplitDistance, true);
      }
    }
    //旋转

  }, {
    key: "mouseMoveParameters",
    value: function mouseMoveParameters(event) {
      //如果有值说明鼠标是按下状态
      if (this._downMousePosition && !this.rotationLock) {
        var startPosition = event.startPosition;
        var endPosition = event.endPosition;
        //是否是右移
        var LRspeed = Cesium.Math.clamp(startPosition.x - endPosition.x, -40, 40);
        var TDspeed = Cesium.Math.clamp(startPosition.y - endPosition.y, -20, 20);
        if (this.PitchAngleReversal) {
          TDspeed = -TDspeed;
        }
        this.viewer.camera.rotateAroundPoint(this._downMousePosition, this._downMousePosition, -LRspeed * this.LRRotationSpeed, this);
        this.viewer.camera.rotateAroundPoint(this._downMousePosition, this.viewer.camera.right, TDspeed * this.TDRotationSpeed, this);
      }
      this.mousePosition = event.endPosition;
    }
    //拖拽平移

  }, {
    key: "cameraTranslation",
    value: function cameraTranslation(event) {
      //如果有值说明鼠标是按下状态
      if (this._downTranslationPosition) {
        var HeightAboveGround = this.viewer.camera.positionCartographic.height;
        var crossVal = new Cesium.Cartesian3();
        Cesium.Cartesian3.cross(this.viewer.camera.position, this.viewer.camera.right, crossVal);
        this.viewer.camera.rotateAroundPoint(Cesium.Cartesian3.ZERO, crossVal, HeightAboveGround, this);
      }
    }
  }, {
    key: "_rotateAroundPoint",
    value: function _rotateAroundPoint(position, cameraAngle, speed, that) {

      var result = new Cesium.Cartesian3();
      var speedValue = Cesium.defaultValue(speed, this.defaultRotateAmount);
      var angleResult = Cesium.Quaternion.fromAxisAngle(cameraAngle, -speedValue);
      var result1 = Cesium.Matrix3.fromQuaternion(angleResult); //从提供的四元数计算3x3旋转矩阵。
      Cesium.Cartesian3.subtract(this.position, position, result); //计算两个笛卡尔分量差(left, right, result)
      Cesium.Matrix3.multiplyByVector(result1, result, result); //计算矩阵和列向量的乘积。  矩阵, 列, 结果
      var newCameraPosition = new Cesium.Cartesian3();
      Cesium.Cartesian3.add(result, position, newCameraPosition); //计算两个笛卡尔的分量和
      //提前判断一下摄像机可能移动到的位置和角度
      var orientationUp = this.up.clone();
      Cesium.Matrix3.multiplyByVector(result1.clone(), orientationUp, orientationUp);
      //得到下一次摄像机会移动到的角度
      var cameraAngle = Cesium.Cartesian3.angleBetween(newCameraPosition, orientationUp);
      //如果角度在设定的最高和最低角度之间, 允许移动
      //如果预测角度大于限制角度(只能向下移动,不许向上移动)
      var newPositionHeight = das3d.point.formatPosition(newCameraPosition).z;
      var centerPositionHeight = das3d.point.formatPosition(position).z;
      if (cameraAngle >= Cesium.Math.toRadians(that.maxViewingAngle) && speedValue > 0) {
        return;
      }
      //如果预测角度小于限制角度(只能向上移动,不许向下移动)
      else if (cameraAngle <= Cesium.Math.toRadians(that.minViewingAngle) && speedValue < 0) {
          return;
        } else if (newPositionHeight < 0 || newPositionHeight < centerPositionHeight + 2) {
          if (speedValue < 0) {
            return;
          }
        }

      this.position = newCameraPosition;
      Cesium.Matrix3.multiplyByVector(result1, this.direction, this.direction);
      Cesium.Matrix3.multiplyByVector(result1, this.up, this.up);
      Cesium.Matrix3.multiplyByVector(result1, this.right, this.right);

      this._preCameraAngle = cameraAngle;
    }
  }, {
    key: "createIcon",
    value: function createIcon(position) {
      this.icon = this.viewer.entities.add({
        id: "mouseCursorIcon",
        position: position,
        billboard: {
          image: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0NiIgdmlld0JveD0iMCAwIDQwIDQ2Ij4NCiAgPGcgaWQ9IuWbvuWxgl80IiBkYXRhLW5hbWU9IuWbvuWxgiA0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzg4LjcyOSAtNDgwLjIxNCkiIG9wYWNpdHk9IjAuOSI+DQogICAgPHBhdGggaWQ9Iui3r+W+hF81MjYiIGRhdGEtbmFtZT0i6Lev5b6EIDUyNiIgZD0iTTQ2My4yNTcsNDg5LjNhNC41NzUsNC41NzUsMCwwLDEtNS4wNDEsMGwtMTMuNy03LjY5MWEyLjUzNywyLjUzNywwLDAsMC0zLjMsMy42OTEsMTAyLjk2LDEwMi45NiwwLDAsMSwxNi45LDM5LDMuMzUxLDMuMzUxLDAsMCwxLC4wNTEuNDA5LDIuNTQ5LDIuNTQ5LDAsMSwwLDUuMSwwLDMuMzc4LDMuMzc4LDAsMCwxLC4wNTEtLjQxNSwxMDMuNDc2LDEwMy40NzYsMCwwLDEsMTYuOTI2LTM4Ljk5MywyLjUzOCwyLjUzOCwwLDAsMC0zLjMtMy42OTFaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIgLTEuMDU0KSIgZmlsbD0iI2Y1ZjVmNSIvPg0KICA8L2c+DQo8L3N2Zz4NCg==",
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scale: 0.4
        }
      });
    }
  }, {
    key: "setCursor",
    value: function setCursor(actionName) {
      var str = "";
      switch (actionName) {
        case "CloseHand":
          str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAcElEQVR42u3VOw4AIQgEULn/oVkTKWxYPgHdTYaKhuGphTQuFwEAAAAAAABAYoa3Wa1vA/CsNUg0tD6SnQaogYIRiJmfegILsd1EOYBFcAXgOvknAN7lUYAb0QkwEZHlWcAr4higKveXfwEAAABQWg/OxzEh/2tENwAAAABJRU5ErkJggg==";
          break;
        case "CloseHandDragRotate":
          str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoElEQVR42u2VSxKAIAxDyf0PjbqQwULKZxBdpCucYvLaOhXh44AABCAAAQjAPMcNUA+P3CyeEQC82ZnCA3kiUfkQ90U4Z2puPWATDYh098qzM+tuzSORV+hcABY3jCmAekyNoAVBNOgIRgCKSlYB9EB0VU7ep9rujD2RFeZum3O90S7UPkCiN7VwXIjRRTa78SjENoBVur/7GwpAAALYHgdornUfxNnupAAAAABJRU5ErkJggg==";
          break;
        case "OpenHand":
          str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAiUlEQVR42u3W0Q6AIAgF0Pj/j6a2Xpzi5ArI3ODNZZdjloue5KICFKAAtwPYmoPe2Dbkr/4B0XYmMnlo2I67a+rcSABr8uEtmDWVcJqnEQJAtkMLEF8+MTAAMN37VbkD+hVam2sBA8Jr9QgARqQCkMNo+zPMAiwRkUexCnEM4JV7/Q9JAQpQAHO9VDxkIVP18bUAAAAASUVORK5CYII=";
          break;
        case "OpenHandDragRotate":
          str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAvElEQVR42u2WUQ7DIAxDm/sfmk2bKnWOvSQUtaoU/mjAfmAQte3mZg3QAA3wdIBxVqc68Wg43u3bMZvWrAx2hsc+1NK6OHD8mVwFUFo/3w0NghUMZcrgiJbzMBQOtjEFIOKgHoYFAUEPH81UxKE89qw2QucmY/ZRg/NAPTIRuFoGQOXPIogAXL24+hTAcojMAUSDUhQrzBnAZwLqVXdB3CDqOfOIhNewojv7ikmIywBW6T7+h6QBGqABTrcX7hSoH1Ml49YAAAAASUVORK5CYII=";
          break;
      }
      $(this.viewer.container).css({
        cursor: "url(" + str + ") 16 16, pointer"
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var handler = this.handler;
      //如果是右键旋转
      if (this.rotateKey == "right") {
        //右键按下
        handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_DOWN);
        //右键抬起
        handler.removeInputAction(Cesium.ScreenSpaceEventType.RIGHT_UP);
        //左键按下
        handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
        //左键抬起
        handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      } else if (this.rotateKey == "center") {
        //如果是中键旋转
        //中键按下
        handler.removeInputAction(Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
        //中键抬起
        handler.removeInputAction(Cesium.ScreenSpaceEventType.MIDDLE_UP);
        //左键按下
        handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
        //左键抬起
        handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      }

      this.viewer.scene.screenSpaceCameraController.maximumZoomDistance = this.maximumZoomDistance;
      this.viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.RIGHT_DRAG, Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
      this.viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
      this.viewer.scene.screenSpaceCameraController.enableZoom = true;
      this.viewer.scene.screenSpaceCameraController.enableTilt = true;
    }
  }, {
    key: "rotationLock",
    get: function get() {
      return this._rotationLock;
    },
    set: function set(val) {
      this._rotationLock = val;
    }
  }]);

  return MouseOperationController;
}();

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _AttackArrow = __webpack_require__(186);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var drawtype = "attackArrow";

var attackArrow = new _AttackArrow.AttackArrow();

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  //========== 构造方法 ==========
  function EditEx(entity, viewer) {
    _classCallCheck(this, EditEx);

    var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

    _this._hasMidPoint = true; //是否可以加点
    _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    return _this;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(EditEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 999; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttackArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(39);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var AttackArrow = exports.AttackArrow = function (_ArrowParent) {
  _inherits(AttackArrow, _ArrowParent);

  function AttackArrow(opt) {
    _classCallCheck(this, AttackArrow);

    var _this = _possibleConstructorReturn(this, (AttackArrow.__proto__ || Object.getPrototypeOf(AttackArrow)).call(this));

    if (!opt) opt = {};
    //影响因素
    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.headTailFactor = opt.headTailFactor || 0.8;
    _this.positions = null;
    _this.plotUtil = _PlotUtil.plotUtil;
    return _this;
  }

  _createClass(AttackArrow, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;
      var pnts = pointconvert.cartesians2mercators(positions);

      var _ref = [pnts[0], pnts[1]],
          tailLeft = _ref[0],
          tailRight = _ref[1];

      if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }
      var midTail = this.plotUtil.Mid(tailLeft, tailRight);
      var bonePnts = [midTail].concat(pnts.slice(2));
      var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
      var _ref2 = [headPnts[0], headPnts[4]],
          neckLeft = _ref2[0],
          neckRight = _ref2[1];

      var tailWidthFactor = this.plotUtil.MathDistance(tailLeft, tailRight) / this.plotUtil.getBaseLength(bonePnts);
      var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
      var count = bodyPnts.length;
      var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight);
      leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse());

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return AttackArrow;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _AttackArrowPW = __webpack_require__(188);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头(平尾)
var drawtype = "attackArrowPW";
var attackArrow = new _AttackArrowPW.AttackArrowPW();

//编辑

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  //========== 构造方法 ==========
  function EditEx(entity, viewer) {
    _classCallCheck(this, EditEx);

    var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

    _this._hasMidPoint = true; //是否可以加点
    _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    return _this;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(EditEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 999; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttackArrowPW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(39);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头（燕尾）
var AttackArrowPW = exports.AttackArrowPW = function (_ArrowParent) {
  _inherits(AttackArrowPW, _ArrowParent);

  function AttackArrowPW(opt) {
    _classCallCheck(this, AttackArrowPW);

    var _this = _possibleConstructorReturn(this, (AttackArrowPW.__proto__ || Object.getPrototypeOf(AttackArrowPW)).call(this));

    if (!opt) opt = {};
    //影响因素
    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;

    _this.positions = null;
    _this.plotUtil = _PlotUtil.plotUtil;
    return _this;
  }

  _createClass(AttackArrowPW, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;

      var pnts = pointconvert.cartesians2mercators(positions);

      var tailPnts = this.getTailPoints(pnts);
      var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
      var neckLeft = headPnts[0];
      var neckRight = headPnts[4];
      var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      var _count = bodyPnts.length;
      var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse());

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(points) {
      var allLen = this.plotUtil.getBaseLength(points);
      var tailWidth = allLen * this.tailWidthFactor;
      var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      return [tailLeft, tailRight];
    }
  }]);

  return AttackArrowPW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _AttackArrowYW = __webpack_require__(190);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头
var drawtype = "attackArrowYW";
var attackArrow = new _AttackArrowYW.AttackArrowYW();

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  //========== 构造方法 ==========
  function EditEx(entity, viewer) {
    _classCallCheck(this, EditEx);

    var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

    _this._hasMidPoint = true; //是否可以加点
    _this.hasClosure = false; //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    return _this;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(EditEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 999; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return attackArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);
//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttackArrowYW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(39);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//攻击箭头（燕尾）
var AttackArrowYW = exports.AttackArrowYW = function (_ArrowParent) {
  _inherits(AttackArrowYW, _ArrowParent);

  function AttackArrowYW(opt) {
    _classCallCheck(this, AttackArrowYW);

    var _this = _possibleConstructorReturn(this, (AttackArrowYW.__proto__ || Object.getPrototypeOf(AttackArrowYW)).call(this));

    if (!opt) opt = {};
    //影响因素
    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    _this.headTailFactor = opt.headTailFactor || 0.8;
    _this.swallowTailFactor = opt.swallowTailFactor || 1;
    _this.positions = null;
    _this.plotUtil = _PlotUtil.plotUtil;
    return _this;
  }

  _createClass(AttackArrowYW, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;

      var pnts = pointconvert.cartesians2mercators(positions);

      var _ref = [pnts[0], pnts[1]],
          tailLeft = _ref[0],
          tailRight = _ref[1];

      if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }
      var midTail = this.plotUtil.Mid(tailLeft, tailRight);
      var bonePnts = [midTail].concat(pnts.slice(2));
      var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
      var _ref2 = [headPnts[0], headPnts[4]],
          neckLeft = _ref2[0],
          neckRight = _ref2[1];

      var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
      var allLen = this.plotUtil.getBaseLength(bonePnts);
      var len = allLen * this.tailWidthFactor * this.swallowTailFactor;
      var swallowTailPnt = this.plotUtil.getThirdPoint(bonePnts[1], bonePnts[0], 0, len, true);
      var factor = tailWidth / allLen;
      var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, factor);
      var count = bodyPnts.length;
      var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight);
      leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [swallowTailPnt, leftPnts[0]]);

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return AttackArrowYW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _CloseCurve = __webpack_require__(192);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//闭合曲面(3个点)
var drawtype = "closeVurve";
var closeCurve = new _CloseCurve.CloseCurve();
//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  //========== 构造方法 ==========
  function EditEx(entity, viewer) {
    _classCallCheck(this, EditEx);

    var _this = _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).call(this, entity, viewer));

    _this._hasMidPoint = true; //是否可以加点
    return _this;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(EditEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return closeCurve.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 999; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return closeCurve.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CloseCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//闭合曲面
var CloseCurve = exports.CloseCurve = function () {
  function CloseCurve(opt) {
    _classCallCheck(this, CloseCurve);

    if (!opt) opt = {};
    //影响因素
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(CloseCurve, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = pointconvert.cartesians2mercators(positions);
      pnts.push(pnts[0], pnts[1]);

      var normals = [];
      var pList = [];
      for (var i = 0; i < pnts.length - 2; i++) {
        var normalPoints = this.plotUtil.getBisectorNormals(0.3, pnts[i], pnts[i + 1], pnts[i + 2]);
        normals = normals.concat(normalPoints);
      }
      var count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
      for (var _i = 0; _i < pnts.length - 2; _i++) {
        var pnt1 = pnts[_i];
        var pnt2 = pnts[_i + 1];
        pList.push(pnt1);
        for (var t = 0; t <= 100; t++) {
          var pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(pnt);
        }
        pList.push(pnt2);
      }

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return CloseCurve;
}();

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _DoubleArrow = __webpack_require__(194);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//双箭头（钳击）
var drawtype = "doubleArrow";
var doubleArrow = new _DoubleArrow.DoubleArrow();
//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return doubleArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 5; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return doubleArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoubleArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算钳击箭头坐标
var DoubleArrow = exports.DoubleArrow = function () {
  function DoubleArrow(opt) {
    _classCallCheck(this, DoubleArrow);

    if (!opt) opt = {};
    //影响因素
    this.headHeightFactor = opt.headHeightFactor || 0.25;
    this.headWidthFactor = opt.headWidthFactor || 0.3;
    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(DoubleArrow, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;

      var pnts = pointconvert.cartesians2mercators(positions);

      var _ref = [pnts[0], pnts[1], pnts[2]];
      var pnt1 = _ref[0];
      var pnt2 = _ref[1];
      var pnt3 = _ref[2];
      var count = this.positions.length;
      var tempPoint4;
      var connPoint;
      if (count === 3) {
        tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
        connPoint = this.plotUtil.Mid(pnt1, pnt2);
      } else if (count === 4) {
        tempPoint4 = pnts[3];
        connPoint = this.plotUtil.Mid(pnt1, pnt2);
      } else {
        tempPoint4 = pnts[3];
        connPoint = pnts[4];
      }
      var leftArrowPnts = undefined,
          rightArrowPnts = undefined;

      if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
        leftArrowPnts = this.getArrowPoints(pnt1, connPoint, tempPoint4, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt2, pnt3, true);
      } else {
        leftArrowPnts = this.getArrowPoints(pnt2, connPoint, pnt3, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt1, tempPoint4, true);
      }
      var m = leftArrowPnts.length;
      var t = (m - 5) / 2;
      var llBodyPnts = leftArrowPnts.slice(0, t);
      var lArrowPnts = leftArrowPnts.slice(t, t + 5);
      var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
      var rlBodyPnts = rightArrowPnts.slice(0, t);
      var rArrowPnts = rightArrowPnts.slice(t, t + 5);
      var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
      rlBodyPnts = this.plotUtil.getBezierPoints(rlBodyPnts);
      var bodyPnts = this.plotUtil.getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
      lrBodyPnts = this.plotUtil.getBezierPoints(lrBodyPnts);
      var newPnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);

      var returnArr = pointconvert.mercators2cartesians(newPnts);
      return returnArr;
    }
  }, {
    key: "getTempPoint4",
    value: function getTempPoint4(linePnt1, linePnt2, point) {
      var midPnt = this.plotUtil.Mid(linePnt1, linePnt2);
      var len = this.plotUtil.MathDistance(midPnt, point);
      var angle = this.plotUtil.getAngleOfThreePoints(linePnt1, midPnt, point);
      var symPnt = undefined,
          distance1 = undefined,
          distance2 = undefined,
          mid = undefined;

      if (angle < Math.PI / 2) {
        distance1 = len * Math.sin(angle);
        distance2 = len * Math.cos(angle);
        mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else if (angle >= Math.PI / 2 && angle < Math.PI) {
        distance1 = len * Math.sin(Math.PI - angle);
        distance2 = len * Math.cos(Math.PI - angle);
        mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      } else if (angle >= Math.PI && angle < Math.PI * 1.5) {
        distance1 = len * Math.sin(angle - Math.PI);
        distance2 = len * Math.cos(angle - Math.PI);
        mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else {
        distance1 = len * Math.sin(Math.PI * 2 - angle);
        distance2 = len * Math.cos(Math.PI * 2 - angle);
        mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      }
      return symPnt;
    }
  }, {
    key: "getArrowPoints",
    value: function getArrowPoints(pnt1, pnt2, pnt3, clockWise) {
      var midPnt = this.plotUtil.Mid(pnt1, pnt2);
      var len = this.plotUtil.MathDistance(midPnt, pnt3);
      var midPnt1 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
      var midPnt2 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
      midPnt1 = this.plotUtil.getThirdPoint(midPnt, midPnt1, Math.PI / 2, len / 5, clockWise);
      midPnt2 = this.plotUtil.getThirdPoint(midPnt, midPnt2, Math.PI / 2, len / 4, clockWise);
      var points = [midPnt, midPnt1, midPnt2, pnt3];
      var arrowPnts = this.getArrowHeadPoints(points);
      if (arrowPnts && Array.isArray(arrowPnts) && arrowPnts.length > 0) {
        var _ref2 = [arrowPnts[0], arrowPnts[4]],
            neckLeftPoint = _ref2[0],
            neckRightPoint = _ref2[1];

        var tailWidthFactor = this.plotUtil.MathDistance(pnt1, pnt2) / this.plotUtil.getBaseLength(points) / 2;
        var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
        if (bodyPnts) {
          var n = bodyPnts.length;
          var lPoints = bodyPnts.slice(0, n / 2);
          var rPoints = bodyPnts.slice(n / 2, n);
          lPoints.push(neckLeftPoint);
          rPoints.push(neckRightPoint);
          lPoints = lPoints.reverse();
          lPoints.push(pnt2);
          rPoints = rPoints.reverse();
          rPoints.push(pnt1);
          return lPoints.reverse().concat(arrowPnts, rPoints);
        }
      } else {
        throw new Error("插值出错");
      }
    }
  }, {
    key: "getArrowHeadPoints",
    value: function getArrowHeadPoints(points) {
      var len = this.plotUtil.getBaseLength(points);
      var headHeight = len * this.headHeightFactor;
      var headPnt = points[points.length - 1];
      var headWidth = headHeight * this.headWidthFactor;
      var neckWidth = headHeight * this.neckWidthFactor;
      var neckHeight = headHeight * this.neckHeightFactor;
      var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight];
    }
  }, {
    key: "getArrowBodyPoints",
    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      var allLen = this.plotUtil.wholeDistance(points);
      var len = this.plotUtil.getBaseLength(points);
      var tailWidth = len * tailWidthFactor;
      var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
      var widthDif = (tailWidth - neckWidth) / 2;
      var tempLen = 0,
          leftBodyPnts = [],
          rightBodyPnts = [];

      for (var i = 1; i < points.length - 1; i++) {
        var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
        var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
        var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts);
    }
  }]);

  return DoubleArrow;
}();

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _FineArrow = __webpack_require__(196);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(2个点)
var drawtype = "fineArrow";
var fineArrow = new _FineArrow.FineArrow();
//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return fineArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 2; //至少需要点的个数
    _this2._maxPointNum = 2; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return fineArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FineArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算粗单尖直箭头坐标
var FineArrow = exports.FineArrow = function () {
  function FineArrow(opt) {
    _classCallCheck(this, FineArrow);

    if (!opt) opt = {};
    //影响因素
    this.headAngle = opt.headAngle || Math.PI / 8.5;
    this.neckAngle = opt.neckAngle || Math.PI / 13;
    this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    this.neckWidthFactor = opt.neckWidthFactor || 0.2;
    this.headWidthFactor = opt.headWidthFactor || 0.25;
    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(FineArrow, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;

      var pnts = pointconvert.cartesians2mercators(positions);

      var _ref = [pnts[0], pnts[1]],
          pnt1 = _ref[0],
          pnt2 = _ref[1];
      var len = this.plotUtil.getBaseLength(pnts);
      var tailWidth = len * this.tailWidthFactor;
      var neckWidth = len * this.neckWidthFactor;
      var headWidth = len * this.headWidthFactor;
      var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return FineArrow;
}();

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _FineArrowYW = __webpack_require__(198);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(2个点)
var drawtype = "fineArrowYW";
var fineArrowYW = new _FineArrowYW.FineArrowYW();
//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return fineArrowYW.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 2; //至少需要点的个数
    _this2._maxPointNum = 2; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return fineArrowYW.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FineArrowYW = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _ArrowParent2 = __webpack_require__(39);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//计算粗单尖直箭头(带燕尾)坐标
var FineArrowYW = exports.FineArrowYW = function (_ArrowParent) {
  _inherits(FineArrowYW, _ArrowParent);

  function FineArrowYW(opt) {
    _classCallCheck(this, FineArrowYW);

    var _this = _possibleConstructorReturn(this, (FineArrowYW.__proto__ || Object.getPrototypeOf(FineArrowYW)).call(this, opt));

    if (!opt) opt = {};
    //影响因素
    _this.headHeightFactor = opt.headHeightFactor || 0.18;
    _this.headWidthFactor = opt.headWidthFactor || 0.3;
    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    _this.swallowTailFactor = opt.swallowTailFactor || 1;
    _this.positions = null;
    _this.plotUtil = _PlotUtil.plotUtil;
    return _this;
  }

  _createClass(FineArrowYW, [{
    key: "startCompute",
    value: function startCompute(positions) {
      if (!positions) return;
      this.positions = positions;

      var pnts = pointconvert.cartesians2mercators(positions);

      var tailPnts = this.getTailPoints(pnts);
      var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
      var neckLeft = headPnts[0];
      var neckRight = headPnts[4];
      var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      var _count = bodyPnts.length;
      var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
      var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }, {
    key: "getTailPoints",
    value: function getTailPoints(points) {
      var allLen = this.plotUtil.getBaseLength(points);
      var tailWidth = allLen * this.tailWidthFactor;
      var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      var len = tailWidth * this.swallowTailFactor;
      var swallowTailPnt = this.plotUtil.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight];
    }
  }]);

  return FineArrowYW;
}(_ArrowParent2.ArrowParent);

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _GatheringPlace = __webpack_require__(200);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//集结地(3个点)
var drawtype = "gatheringPlace";
var gatheringPlace = new _GatheringPlace.GatheringPlace();

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return gatheringPlace.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制

var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 3; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return gatheringPlace.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GatheringPlace = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//集结地
var GatheringPlace = exports.GatheringPlace = function () {
  function GatheringPlace(opt) {
    _classCallCheck(this, GatheringPlace);

    if (!opt) opt = {};
    //影响因素
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(GatheringPlace, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = pointconvert.cartesians2mercators(positions);

      var mid = this.plotUtil.Mid(pnts[0], pnts[2]);
      pnts.push(mid, pnts[0], pnts[1]);
      var normals = [],
          pnt1 = undefined,
          pnt2 = undefined,
          pnt3 = undefined,
          pList = [];
      for (var i = 0; i < pnts.length - 2; i++) {
        pnt1 = pnts[i];
        pnt2 = pnts[i + 1];
        pnt3 = pnts[i + 2];
        var normalPoints = this.plotUtil.getBisectorNormals(0.4, pnt1, pnt2, pnt3);
        normals = normals.concat(normalPoints);
      }
      var count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
      for (var _i = 0; _i < pnts.length - 2; _i++) {
        pnt1 = pnts[_i];
        pnt2 = pnts[_i + 1];
        pList.push(pnt1);
        for (var t = 0; t <= 100; t++) {
          var _pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(_pnt);
        }
        pList.push(pnt2);
      }

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return GatheringPlace;
}();

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _StraightArrow = __webpack_require__(202);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//直箭头(3个点)
var drawtype = "straightArrow";
var straightArrow = new _StraightArrow.StraightArrow();

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return straightArrow.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制

var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 2; //至少需要点的个数
    _this2._maxPointNum = 2; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return straightArrow.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StraightArrow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//计算粗直箭头坐标
var StraightArrow = exports.StraightArrow = function () {
  function StraightArrow(opt) {
    _classCallCheck(this, StraightArrow);

    if (!opt) opt = {};
    //影响因素
    this.tailWidthFactor = opt.tailWidthFactor || 0.05;
    this.neckWidthFactor = opt.neckWidthFactor || 0.1;
    this.headWidthFactor = opt.headWidthFactor || 0.15;
    this.headAngle = Math.PI / 4;
    this.neckAngle = Math.PI * 0.17741;
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(StraightArrow, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = pointconvert.cartesians2mercators(positions);
      var _ref = [pnts[0], pnts[1]],
          pnt1 = _ref[0],
          pnt2 = _ref[1];
      var len = this.plotUtil.getBaseLength(pnts);
      var tailWidth = len * this.tailWidthFactor;
      var neckWidth = len * this.neckWidthFactor;
      var headWidth = len * this.headWidthFactor;
      var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

      var returnArr = pointconvert.mercators2cartesians(pList);
      return returnArr;
    }
  }]);

  return StraightArrow;
}();

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _Lune = __webpack_require__(204);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//弓形面(3个点)
var drawtype = "lune";
var lune = new _Lune.Lune();

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return lune.startCompute(positions);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 3; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return lune.startCompute(positions);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Lune = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _PlotUtil = __webpack_require__(9);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//弓形面
var Lune = exports.Lune = function () {
  function Lune(opt) {
    _classCallCheck(this, Lune);

    if (!opt) opt = {};
    //影响因素
    this.positions = null;
    this.plotUtil = _PlotUtil.plotUtil;
  }

  _createClass(Lune, [{
    key: "startCompute",
    value: function startCompute(positions) {
      var pnts = pointconvert.cartesians2mercators(positions);
      var _ref = [pnts[0], pnts[1], pnts[2], undefined, undefined],
          pnt1 = _ref[0],
          pnt2 = _ref[1],
          pnt3 = _ref[2],
          startAngle = _ref[3],
          endAngle = _ref[4];

      var center = this.plotUtil.getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
      var radius = this.plotUtil.MathDistance(pnt1, center);
      var angle1 = this.plotUtil.getAzimuth(pnt1, center);
      var angle2 = this.plotUtil.getAzimuth(pnt2, center);
      if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
        startAngle = angle2;
        endAngle = angle1;
      } else {
        startAngle = angle1;
        endAngle = angle2;
      }
      pnts = this.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
      pnts.push(pnts[0]);

      var returnArr = pointconvert.mercators2cartesians(pnts);
      return returnArr;
    }
  }]);

  return Lune;
}();

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _pointconvert = __webpack_require__(4);

var pointconvert = _interopRequireWildcard(_pointconvert);

var _PlotUtil = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//扇形(3个点)
var drawtype = "sector";

function getPositions(positions, attribute) {
  var pnts = pointconvert.cartesians2mercators(positions);
  var center = pnts[0],
      pnt2 = pnts[1],
      pnt3 = pnts[2];
  var radius = _PlotUtil.plotUtil.MathDistance(pnt2, center);
  var startAngle = _PlotUtil.plotUtil.getAzimuth(pnt2, center);
  var endAngle = _PlotUtil.plotUtil.getAzimuth(pnt3, center);
  var pList = _PlotUtil.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
  pList.push(center, pList[0]);

  var returnArr = pointconvert.mercators2cartesians(pList);
  return returnArr;
}

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 3; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _matrix = __webpack_require__(16);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//正多边形  边数取决于config.border
var drawtype = "regular";

function getPositions(positions, attribute) {
  var center = positions[0];
  var point = positions[1];
  var num = attribute.config.border || 3; //边数量

  var addAngle = 360 / num;

  var pointArr = [];
  for (var i = 0; i < num; i++) {
    var thisAngle = addAngle * i;
    var newPoint = (0, _matrix.getRotateCenterPoint)(center, point, thisAngle);
    pointArr.push(newPoint);
  }
  return pointArr;
}

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 2; //至少需要点的个数
    _this2._maxPointNum = 2; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(11);

var _Edit = __webpack_require__(12);

var _Draw2 = __webpack_require__(6);

var _measure = __webpack_require__(18);

var _matrix = __webpack_require__(16);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//等腰三角形(3个点)
var drawtype = "triangleDY";

var midPoint = new Cesium.Cartesian3();

function getPositions(positions) {
  //p1 p2 用于控制腰的高度 p3用于控制夹角
  var p1 = positions[0];
  var p2 = positions[1];
  var p3 = positions[2];

  var midpoint = Cesium.Cartesian3.midpoint(p1, p2, midPoint);

  var angle1 = (0, _measure.getAngle)(midpoint, p2);
  var angle2 = (0, _measure.getAngle)(midpoint, p3);
  var angle = angle1 - angle2 - 90;
  var newPoint2 = (0, _matrix.getRotateCenterPoint)(midpoint, p3, angle);

  return [p1, p2, newPoint2];
}

//编辑

var EditEx = function (_EditPolygonEx) {
  _inherits(EditEx, _EditPolygonEx);

  function EditEx() {
    _classCallCheck(this, EditEx);

    return _possibleConstructorReturn(this, (EditEx.__proto__ || Object.getPrototypeOf(EditEx)).apply(this, arguments));
  }

  _createClass(EditEx, [{
    key: "getShowPositions",

    //根据标绘绘制的点，生成显示的边界点
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return EditEx;
}(_Edit.EditPolygonEx);

//绘制


var DrawEx = function (_DrawPolygonEx) {
  _inherits(DrawEx, _DrawPolygonEx);

  //========== 构造方法 ==========
  function DrawEx(opts) {
    _classCallCheck(this, DrawEx);

    var _this2 = _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).call(this, opts));

    _this2.type = drawtype;
    _this2.editClass = EditEx; //获取编辑对象

    _this2._minPointNum = 3; //至少需要点的个数
    _this2._maxPointNum = 3; //最多允许点的个数
    return _this2;
  }
  //根据标绘绘制的点，生成显示的边界点


  _createClass(DrawEx, [{
    key: "getShowPositions",
    value: function getShowPositions(positions, attribute) {
      return getPositions(positions, attribute);
    }
  }]);

  return DrawEx;
}(_Draw.DrawPolygonEx);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _zepto = __webpack_require__(7);

var _Draw = __webpack_require__(47);

var _Draw2 = __webpack_require__(6);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//div点（转图片）
var drawtype = "div-point-img";

var DrawEx = exports.DrawEx = function (_DrawBillboard) {
  _inherits(DrawEx, _DrawBillboard);

  function DrawEx() {
    _classCallCheck(this, DrawEx);

    return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
  }

  _createClass(DrawEx, [{
    key: "updateFeatureEx",

    //更新图标，子类用
    value: function updateFeatureEx(style, entity) {
      var that = this;

      var div = (0, _zepto.zepto)(style.html);
      div.appendTo(style.parent || "body");

      div = div.get(0);

      this._islosdImg = true;
      if (window.domtoimage) {
        //lib/dom2img/dom-to-image.js
        window.domtoimage.toPng(div).then(function (dataUrl) {
          entity.billboard.image = "" + dataUrl;

          div.remove();
          that._islosdImg = false;
        }).catch(function (error) {
          daslog.warn("未知原因，导出失败!", error);

          div.remove();
          that._islosdImg = false;
        });
      } else if (window.html2canvas) {
        //lib/dom2img/html2canvas.js
        window.html2canvas(div, {
          backgroundColor: null,
          allowTaint: true
        }).then(function (canvas) {
          entity.billboard.image = "" + canvas.toDataURL("image/png");

          div.remove();
          that._islosdImg = false;
        }).catch(function (error) {
          daslog.warn("未知原因，导出失败!", error);

          div.remove();
          that._islosdImg = false;
        });
      }
    }
  }]);

  return DrawEx;
}(_Draw.DrawBillboard);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Draw = __webpack_require__(47);

var _Draw2 = __webpack_require__(6);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//字体点（转图片）
var drawtype = "font-point";

var DrawEx = exports.DrawEx = function (_DrawBillboard) {
  _inherits(DrawEx, _DrawBillboard);

  function DrawEx() {
    _classCallCheck(this, DrawEx);

    return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
  }

  _createClass(DrawEx, [{
    key: "updateFeatureEx",

    //更新图标，子类用
    value: function updateFeatureEx(style, entity) {
      var that = this;

      var size = Cesium.defaultValue(style.iconSize, 50);

      var div = document.createElement("div"); //创建一个div
      div.setAttribute("style", "padding: 10px;text-align:center;max-width:" + (size + 10) + "px;max-height:" + (size + 10) + "px;");
      var jd = document.createElement("i");
      jd.setAttribute("class", Cesium.defaultValue(style.iconClass, "fa fa-automobile"));
      jd.setAttribute("style", "font-size:" + size + "px;color:" + style.color + ";");
      div.appendChild(jd);
      document.body.appendChild(div);

      this._islosdImg = true;
      if (window.domtoimage) {
        //lib/dom2img/dom-to-image.js
        window.domtoimage.toPng(div).then(function (dataUrl) {
          entity.billboard.image = "" + dataUrl;

          document.body.removeChild(div);
          that._islosdImg = false;
        }).catch(function (error) {
          daslog.warn("未知原因，导出失败!", error);

          document.body.removeChild(div);
          that._islosdImg = false;
        });
      } else if (window.html2canvas) {
        //lib/dom2img/html2canvas.js
        window.html2canvas(div, {
          backgroundColor: null,
          allowTaint: true
        }).then(function (canvas) {
          entity.billboard.image = "" + canvas.toDataURL("image/png");

          document.body.removeChild(div);
          that._islosdImg = false;
        }).catch(function (error) {
          daslog.warn("未知原因，导出失败!", error);

          document.body.removeChild(div);
          that._islosdImg = false;
        });
      }
    }
  }]);

  return DrawEx;
}(_Draw.DrawBillboard);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawEx = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

var _DivPoint = __webpack_require__(89);

var _Draw = __webpack_require__(25);

var _Draw2 = __webpack_require__(6);

var _Tooltip = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//div点
var drawtype = "div-point";

//与entity的联动矢量对象

var FeatureEx = function () {
  function FeatureEx(options) {
    _classCallCheck(this, FeatureEx);

    var viewer = options.viewer;
    var draw = options.draw;
    var entity = options.entity;
    var style = options.style;

    var divpoint;
    if (style.divpoint) {
      //外部构造好的divpoint
      divpoint = style.divpoint;
      divpoint.position = entity.position;
    } else {
      divpoint = new _DivPoint.DivPoint(viewer, _extends({
        position: entity.position
      }, (0, _DivPoint.style2Entity)(style)));
    }

    divpoint.enable = false;
    divpoint.on(_DasClass.eventType.click, function (e) {
      if (Cesium.defined(entity.hasDrawEdit) && !entity.hasDrawEdit()) return;

      divpoint.enable = false;

      draw.activate(entity);
      entity.draw_tooltip = _Tooltip.message.edit.end;
    });
    divpoint.on(_DasClass.eventType.mouseOver, function (e) {
      if (Cesium.defined(entity.hasDrawEdit) && !entity.hasDrawEdit()) return;
      draw.tooltip.showAt({ x: e.clientX, y: e.clientY }, "单击后 激活编辑");
    });
    divpoint.on(_DasClass.eventType.mouseOut, function (e) {
      if (Cesium.defined(entity.hasDrawEdit) && !entity.hasDrawEdit()) return;
      draw.tooltip.setVisible(false);
    });
    this.divpoint = divpoint;
  }

  _createClass(FeatureEx, [{
    key: "activate",
    value: function activate() {
      this.divpoint.enable = false;
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(style) {
      var newStyle = (0, _DivPoint.style2Entity)(style);
      for (var key in newStyle) {
        if (key == "html") continue;
        this.divpoint[key] = newStyle[key];
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      this.divpoint.enable = true;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.divpoint.destroy();
    }
  }, {
    key: "position",
    get: function get() {
      return this.divpoint.position;
    },
    set: function set(val) {
      this.divpoint.position = val;
    }
  }]);

  return FeatureEx;
}();

var DrawEx = exports.DrawEx = function (_DrawPoint) {
  _inherits(DrawEx, _DrawPoint);

  function DrawEx() {
    _classCallCheck(this, DrawEx);

    return _possibleConstructorReturn(this, (DrawEx.__proto__ || Object.getPrototypeOf(DrawEx)).apply(this, arguments));
  }

  _createClass(DrawEx, [{
    key: "createFeatureEx",
    value: function createFeatureEx(style, entity) {
      if (entity.featureEx) {
        entity.featureEx.activate();
      } else {
        entity.point.show = false;
        entity.featureEx = new FeatureEx({
          viewer: this.viewer,
          draw: this,
          entity: entity,
          style: style
        });
      }
    }
  }]);

  return DrawEx;
}(_Draw.DrawPoint);

//注册到Draw中


(0, _Draw2.register)(drawtype, DrawEx);

/***/ }),
/* 211 */
/***/ (function(module, exports) {

module.exports = "attribute vec4 position;\r\nattribute vec3 normal;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = czm_modelViewProjection * position;\r\n    v_position = vec3(position);\r\n    v_positionWC = (czm_model * position).xyz;\r\n    v_positionEC = (czm_modelView * position).xyz;\r\n    v_normalEC = czm_normal * normal;\r\n}"

/***/ }),
/* 212 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform float u_type;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    if(u_type == 1.0){\r\n        return getLineColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    //isOnEllipsoid = false;\r\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\r\n    /*if(false){\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    }else{\r\n        gl_FragColor = shade(isOnEllipsoid);\r\n    }\r\n*/\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)\n{\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n    vec3 D = czm_ellipsoidInverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n    vec3 q = D * coneVertexWC;\n    float qMagnitudeSquared = dot(q, q);\n    float test = qMagnitudeSquared - 1.0;\n    \n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n    vec3 temp = D * pointWC - q;\n    float d = dot(temp, q);\n    \n    // Behind silhouette plane and inside silhouette cone\n    return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvec4 getLineColor()\n{\n    return u_lineColor;\n}\n\nvec4 getIntersectionColor()\n{\n    return u_intersectionColor;\n}\n\nfloat getIntersectionWidth()\n{\n    return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\n    // (s, t) both in the range [0, 1]\n    float t = pointMC.z / sensorRadius;\n    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n    s = s - floor(s);\n    \n    return vec2(s, t);\n}\n"

/***/ }),
/* 214 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform vec4 u_color;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n\r\n    material.diffuse = u_color.rgb;\r\n    material.alpha = u_color.a;\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(vec3 point)\r\n{\r\n    vec3 scaled = czm_ellipsoidInverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle) - 0.0001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)- 0.0001){\r\n        discard;\r\n    }\r\n\r\n\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RectangularSensorVisualizer = undefined;
exports.removePrimitive = removePrimitive;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _RectangularSensorPrimitive = __webpack_require__(90);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var AssociativeArray = Cesium.AssociativeArray;
var Cartesian3 = Cesium.Cartesian3;
var Color = Cesium.Color;
var defined = Cesium.defined;
var DeveloperError = Cesium.DeveloperError;
var Matrix3 = Cesium.Matrix3;
var Matrix4 = Cesium.Matrix4;
var Quaternion = Cesium.Quaternion;
var MaterialProperty = Cesium.MaterialProperty;
var Property = Cesium.Property;

var matrix3Scratch = new Matrix3();
// var matrix4Scratch = new Matrix4();
var cachedPosition = new Cartesian3();
var cachedGazePosition = new Cartesian3();
var cachedOrientation = new Quaternion();
var diffVectorScratch = new Cartesian3();
var orientationScratch = new Quaternion();

function removePrimitive(entity, hash, primitives) {
  var data = hash[entity.id];
  if (Cesium.defined(data)) {
    var primitive = data.primitive;
    try {
      primitives.remove(primitive);
    } catch (e) {
      //
    }
    if (primitive.isDestroyed && !primitive.isDestroyed()) {
      primitive.destroy();
    }
    delete hash[entity.id];
  }
}

var RectangularSensorVisualizer = function RectangularSensorVisualizer(scene, entityCollection) {
  // >>includeStart('debug', pragmas.debug);
  if (!defined(scene)) {
    throw new DeveloperError("scene is required.");
  }
  if (!defined(entityCollection)) {
    throw new DeveloperError("entityCollection is required.");
  }
  // >>includeEnd('debug');

  entityCollection.collectionChanged.addEventListener(RectangularSensorVisualizer.prototype._onCollectionChanged, this);

  this._scene = scene;
  this._primitives = scene.primitives;
  this._entityCollection = entityCollection;
  this._hash = {};
  this._entitiesToVisualize = new AssociativeArray();

  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
};

/**
 * Updates the primitives created by this visualizer to match their
 * Entity counterpart at the given time.
 *
 * @param {JulianDate} time The time to update to.
 * @returns {Boolean} This function always returns true.
 */
RectangularSensorVisualizer.prototype.update = function (time) {
  // >>includeStart('debug', pragmas.debug);
  if (!defined(time)) {
    throw new DeveloperError("time is required.");
  }
  // >>includeEnd('debug');

  var entities = this._entitiesToVisualize.values;
  var hash = this._hash;
  var primitives = this._primitives;

  for (var i = 0, len = entities.length; i < len; i++) {
    var entity = entities[i];
    var rectangularSensorGraphics = entity._rectangularSensor;

    var position;
    var orientation;
    var radius;
    var xHalfAngle;
    var yHalfAngle;
    var data = hash[entity.id];
    var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(rectangularSensorGraphics._show, time, true);

    if (show) {
      position = Property.getValueOrUndefined(entity._position, time, cachedPosition);
      orientation = Property.getValueOrUndefined(entity._orientation, time, cachedOrientation);
      radius = Property.getValueOrUndefined(rectangularSensorGraphics._radius, time);
      xHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._xHalfAngle, time);
      yHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._yHalfAngle, time);
      show = defined(position) && defined(xHalfAngle) && defined(yHalfAngle);
    }

    if (!show) {
      // don't bother creating or updating anything else
      if (defined(data)) {
        data.primitive.show = false;
      }
      continue;
    }

    var primitive = defined(data) ? data.primitive : undefined;
    if (!defined(primitive)) {
      primitive = new _RectangularSensorPrimitive.RectangularSensorPrimitive();
      primitive.id = entity;
      primitives.add(primitive);

      data = {
        primitive: primitive,
        position: undefined,
        orientation: undefined
      };
      hash[entity.id] = data;
    }

    var gaze = Property.getValueOrUndefined(rectangularSensorGraphics._gaze, time);
    if (defined(gaze)) {
      var targetPosition = Property.getValueOrUndefined(gaze._position, time, cachedGazePosition);

      if (!defined(position) || !defined(targetPosition)) {
        continue;
      }

      var diffVector = Cartesian3.subtract(position, targetPosition, diffVectorScratch);
      var rotate = Cartesian3.angleBetween(Cesium.Cartesian3.UNIT_Z, diffVector);
      var cross = Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, diffVector, diffVectorScratch);
      orientation = Quaternion.fromAxisAngle(cross, rotate - Math.PI, orientationScratch);

      //replace original radius
      radius = Cartesian3.distance(position, targetPosition);
      primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
    } else {
      if (!Cartesian3.equals(position, data.position) || !Quaternion.equals(orientation, data.orientation)) {
        if (defined(orientation)) {
          primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
          data.position = Cartesian3.clone(position, data.position);
          data.orientation = Quaternion.clone(orientation, data.orientation);
        } else {
          primitive.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
          data.position = Cartesian3.clone(position, data.position);
        }
      }
    }

    primitive.show = true;
    primitive.gaze = gaze;
    primitive.radius = radius;
    primitive.xHalfAngle = xHalfAngle;
    primitive.yHalfAngle = yHalfAngle;
    primitive.lineColor = Property.getValueOrDefault(rectangularSensorGraphics._lineColor, time, Color.WHITE);
    primitive.showSectorLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorLines, time, true);
    primitive.showSectorSegmentLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorSegmentLines, time, true);
    primitive.showLateralSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showLateralSurfaces, time, true);
    primitive.material = MaterialProperty.getValue(time, rectangularSensorGraphics._material, primitive.material);
    primitive.showDomeSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showDomeSurfaces, time, true);
    primitive.showDomeLines = Property.getValueOrDefault(rectangularSensorGraphics._showDomeLines, time, true);
    primitive.showIntersection = Property.getValueOrDefault(rectangularSensorGraphics._showIntersection, time, true);
    primitive.intersectionColor = Property.getValueOrDefault(rectangularSensorGraphics._intersectionColor, time, Color.WHITE);
    primitive.intersectionWidth = Property.getValueOrDefault(rectangularSensorGraphics._intersectionWidth, time, 1);
    primitive.showThroughEllipsoid = Property.getValueOrDefault(rectangularSensorGraphics._showThroughEllipsoid, time, true);
    primitive.scanPlaneMode = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneMode, time);
    primitive.scanPlaneColor = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneColor, time, Color.WHITE);
    primitive.showScanPlane = Property.getValueOrDefault(rectangularSensorGraphics._showScanPlane, time, true);
    primitive.scanPlaneRate = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneRate, time, 1);
  }
  return true;
};

/**
 * Returns true if this object was destroyed; otherwise, false.
 *
 * @returns {Boolean} True if this object was destroyed; otherwise, false.
 */
RectangularSensorVisualizer.prototype.isDestroyed = function () {
  return false;
};

/**
 * Removes and destroys all primitives created by this instance.
 */
RectangularSensorVisualizer.prototype.destroy = function () {
  var entities = this._entitiesToVisualize.values;
  var hash = this._hash;
  var primitives = this._primitives;
  for (var i = entities.length - 1; i > -1; i--) {
    removePrimitive(entities[i], hash, primitives);
  }

  //删除所有绑定的数据
  for (var _i in this) {
    delete this[_i];
  }

  return Cesium.destroyObject(this);
};

/**
 * @private
 */
RectangularSensorVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
  var entities = this._entitiesToVisualize;
  if (!entities) return;

  var hash = this._hash;
  var primitives = this._primitives;

  var i;
  var entity;
  for (i = added.length - 1; i > -1; i--) {
    entity = added[i];
    if (defined(entity._rectangularSensor) && defined(entity._position)) {
      entities.set(entity.id, entity);
    }
  }

  for (i = changed.length - 1; i > -1; i--) {
    entity = changed[i];
    if (defined(entity._rectangularSensor) && defined(entity._position)) {
      entities.set(entity.id, entity);
    } else {
      removePrimitive(entity, hash, primitives);
      entities.remove(entity.id);
    }
  }

  for (i = removed.length - 1; i > -1; i--) {
    entity = removed[i];
    removePrimitive(entity, hash, primitives);
    entities.remove(entity.id);
  }
};

var originalDefaultVisualizersCallback = Cesium.DataSourceDisplay.defaultVisualizersCallback;
Cesium.DataSourceDisplay.defaultVisualizersCallback = function (scene, entityCluster, dataSource) {
  var entities = dataSource.entities;
  var array = originalDefaultVisualizersCallback(scene, entityCluster, dataSource);
  return array.concat([new RectangularSensorVisualizer(scene, entities)]);
};

exports.RectangularSensorVisualizer = RectangularSensorVisualizer;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DynamicRiver = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.Lines2Plane = Lines2Plane;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _util = __webpack_require__(3);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _Draw = __webpack_require__(6);

var _DynamicRiverFS = __webpack_require__(217);

var _DynamicRiverFS2 = _interopRequireDefault(_DynamicRiverFS);

var _DynamicRiverVS = __webpack_require__(218);

var _DynamicRiverVS2 = _interopRequireDefault(_DynamicRiverVS);

var _DynamicRiverMaterial = __webpack_require__(219);

var _DynamicRiverMaterial2 = _interopRequireDefault(_DynamicRiverMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//动态河流、公路
var DynamicRiver = exports.DynamicRiver = function (_DasClass) {
  _inherits(DynamicRiver, _DasClass);

  //========== 构造方法 ==========
  function DynamicRiver(viewer, options) {
    _classCallCheck(this, DynamicRiver);

    var _this = _possibleConstructorReturn(this, (DynamicRiver.__proto__ || Object.getPrototypeOf(DynamicRiver)).call(this, options));

    _this.viewer = viewer;

    options = options || {};
    _this.options = options;

    _this._positions = Cesium.defaultValue(options.positions, null);

    _this._image = Cesium.defaultValue(options.image, null); //贴图路径
    _this._flipY = Cesium.defaultValue(options.flipY, false); //uv交换（图片横竖切换）
    _this._width = Cesium.defaultValue(options.width, 10); //宽度
    _this._height = Cesium.defaultValue(options.height, 0); //拔高数值
    _this._alpha = Cesium.defaultValue(options.alpha, 0.5); //透明度
    _this._speed = Cesium.defaultValue(options.speed, 1.0); //流动速度

    _this._move = Cesium.defaultValue(options.move, true); //是否开启流动效果
    _this._moveDir = Cesium.defaultValue(options.moveDir, true); //设置流动方向
    _this._moveVar = Cesium.defaultValue(options.moveVar, new Cesium.Cartesian3(50, 1, 100)); //流动动画参数，不建议调整该参数

    _this.resetPos();
    return _this;
  }

  //========== 对外属性 ==========


  _createClass(DynamicRiver, [{
    key: "resetPos",


    //========== 方法 ==========

    value: function resetPos() {
      if (this.riverPrimitive) {
        this.viewer.scene.primitives.remove(this.riverPrimitive);
        delete this.riverPrimitive;
      }

      if (!(0, _util.isArray)(this._positions) || !this._positions.length) return;

      this.sideRes = Lines2Plane(this._positions, this.width, this.height);
      if (!this.sideRes) return;

      this.material = this.prepareMaterial();
      this.riverPrimitive = this.createPrimitive();
      this.viewer.scene.primitives.add(this.riverPrimitive);
    }
  }, {
    key: "drawLines",
    value: function drawLines(style) {
      if (!this.drawControl) {
        this.drawControl = new _Draw.Draw(this.viewer, {
          hasEdit: false,
          removeScreenSpaceEvent: true
        });
      }
      var control = this.drawControl;

      var that = this;
      control.startDraw({
        type: "polyline",
        style: style || {
          color: "#55ff33",
          width: 3,
          clampToGround: true
        },
        success: function success(entity) {
          var positions = that.drawControl.getPositions(entity);
          that.setPositions(positions);
          that.drawControl.deleteAll();
        }
      });
    }
  }, {
    key: "setPositions",
    value: function setPositions(positions) {
      this._positions = positions;
      this.resetPos();
    }
  }, {
    key: "prepareMaterial",
    value: function prepareMaterial() {
      var material;
      if (this.image) {
        material = new Cesium.Material({
          fabric: {
            uniforms: {
              image: this.image,
              alpha: this.alpha,
              moveVar: this.moveVar,
              reflux: this.moveDir ? -1 : 1,
              speed: this.speed,
              move: this.move,
              flipY: this.flipY
            },
            source: _DynamicRiverMaterial2.default
          }
        });
      } else {
        material = Cesium.Material.fromType("Color");
        material.uniforms.color = new Cesium.Color(0.0, 1.0, 0.0, this.alpha);
      }
      return material;
    }
  }, {
    key: "createPrimitive",
    value: function createPrimitive() {
      //创建图元
      var sides = this.sideRes;
      var positions = new Float64Array(sides.vertexs);
      var attributes = new Cesium.GeometryAttributes();
      attributes.position = new Cesium.GeometryAttribute({
        componentDatatype: Cesium.ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
      });
      attributes.st = new Cesium.GeometryAttribute({
        componentDatatype: Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 2,
        values: sides.uvs
      });
      var geometry = new Cesium.Geometry({
        attributes: attributes,
        indices: sides.indexs,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
      });
      // geometry._workerName = ""

      var instance = new Cesium.GeometryInstance({
        geometry: geometry
      });
      var renderState = new Cesium.RenderState();
      renderState.depthTest.enabled = true;

      var primitive = new Cesium.Primitive({
        geometryInstances: instance,
        appearance: new Cesium.Appearance({
          material: this.material,
          renderState: renderState,
          vertexShaderSource: _DynamicRiverVS2.default,
          fragmentShaderSource: _DynamicRiverFS2.default //czm_lightDirectionEC在cesium1.66开始加入的
        })
      });
      primitive.eventTarget = this;
      primitive.popup = this.options.popup;
      primitive.tooltip = this.options.tooltip;
      return primitive;
    }
  }, {
    key: "offsetHeight",
    value: function offsetHeight(height, time) {
      if (!height || !time || !this.riverPrimitive) return;
      var that = this;
      var currH = 0;
      var avgF = 20; //平均每帧20毫秒，即每秒50帧；
      var avgH = height / (time * avgF);

      var selfV = this.sideRes.self;
      var totalN = new Cesium.Cartesian3();
      for (var i = 0, len = selfV.length; i < len; i++) {
        //求平均的法线
        var currN = Cesium.Cartesian3.normalize(selfV[i], new Cesium.Cartesian3());
        Cesium.Cartesian3.add(totalN, currN, totalN);
      }
      Cesium.Cartesian3.normalize(totalN, totalN);

      var initM = Cesium.clone(this.riverPrimitive.modelMatrix);

      this.dhEvent = function () {
        if (Math.abs(currH) <= Math.abs(height)) {
          //可以升高，可以降低，height可以为负值
          var currNor = Cesium.Cartesian3.multiplyByScalar(totalN, currH, new Cesium.Cartesian3());
          that.riverPrimitive.modelMatrix = Cesium.Matrix4.multiplyByTranslation(initM, currNor, new Cesium.Matrix4());
        } else {
          that.viewer.clock.onTick.removeEventListener(that.dhEvent);
        }
        currH += avgH;
      };
      this.viewer.clock.onTick.addEventListener(this.dhEvent);
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.primitives.remove(this.riverPrimitive);

      if (this.drawControl) {
        this.drawControl.destroy();
        delete this.drawControl;
      }
      this.material.destroy();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "positions",
    get: function get() {
      return this._positions;
    },
    set: function set(val) {
      this.setPositions(val);
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    },
    set: function set(val) {
      this._width = Number(val) || 1;
      this.resetPos();
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(val) {
      this._height = Number(val);
      this.resetPos();
    }
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = Number(val);
      this.material.uniforms.alpha = this._alpha;
    }
  }, {
    key: "moveDir",
    get: function get() {
      return this._moveDir;
    },
    set: function set(val) {
      this._moveDir = Boolean(val);
      this.material.uniforms.reflux = this._moveDir ? -1 : 1;
    }
  }, {
    key: "speed",
    get: function get() {
      return this._speed;
    },
    set: function set(val) {
      this._speed = Number(val) || 1;
      this.material.uniforms.speed = this._speed;
    }
  }, {
    key: "image",
    get: function get() {
      return this._image;
    },
    set: function set(str) {
      this._image = str;
      this.material.uniforms.image = this._image;
    }
  }, {
    key: "move",
    get: function get() {
      return this._move;
    },
    set: function set(val) {
      this._move = Boolean(val);
      this.material.uniforms.move = this._move;
    }
  }, {
    key: "flipY",
    get: function get() {
      return this._flipY;
    },
    set: function set(val) {
      this._flipY = Boolean(val);
      this.material.uniforms.flipY = this._flipY;
    }
  }, {
    key: "moveVar",
    get: function get() {
      return this._moveVar;
    },
    set: function set(val) {
      this._moveVar = val;
      this.material.uniforms.moveVar = this._moveVar;
    }
  }]);

  return DynamicRiver;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


DynamicRiver.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

function Lines2Plane(lineArr, width, height) {
  if (!lineArr || lineArr.length <= 1 || !width || width == 0) {
    daslog.warn("请确认参数符合规则：数组长度大于1，宽高不能为0！", lineArr);
    return;
  }
  var len = lineArr.length;
  var leftPots = [];
  var rightPots = [];
  var halfW = width / 2.0;
  for (var i = 0; i < len; i++) {
    var prevP = void 0;
    var currP = void 0;
    var nextP = void 0;
    var leftPot = void 0;
    var rightPot = void 0;
    if (i == 0) {
      prevP = lineArr[i];
      currP = lineArr[i];
      nextP = lineArr[i + 1];
    } else if (i == len - 1) {
      prevP = lineArr[i - 1];
      currP = lineArr[i];
      nextP = lineArr[i - 1];
    } else {
      prevP = lineArr[i - 1];
      currP = lineArr[i];
      nextP = lineArr[i + 1];
    }

    if (height != 0) {
      prevP = RaisePoint(prevP, height);
      currP = RaisePoint(currP, height);
      nextP = RaisePoint(nextP, height);
    }

    if (prevP && currP && nextP) {
      var sides = GetSides(currP, nextP, halfW);
      leftPot = sides.left;
      rightPot = sides.right;

      if (i == 0) {
        leftPots.push(leftPot);
        rightPots.push(rightPot);
        leftPots.push(leftPot);
        rightPots.push(rightPot);
        continue;
      } else {
        if (i < len - 1) {
          leftPots.push(leftPot);
          rightPots.push(rightPot);
        } else {
          leftPots.push(rightPot);
          rightPots.push(leftPot);
          leftPots.push(rightPot);
          rightPots.push(leftPot);
          continue;
        }
      }

      sides = GetSides(currP, prevP, halfW);
      leftPot = sides.left;
      rightPot = sides.right;
      leftPots.push(rightPot);
      rightPots.push(leftPot);
    }
  }
  // return {
  //     left:leftPots,
  //     right:rightPots,
  //     self:lineArr
  // }

  var leftPotsRes = [];
  var rightPotsRes = [];
  if (leftPots.length == len * 2) {
    for (var _i = 0; _i < len; _i++) {
      var CurrP = lineArr[_i];

      var lf1 = leftPots[_i * 2 + 0];
      var lf2 = leftPots[_i * 2 + 1];
      var dir1 = Cesium.Cartesian3.subtract(lf1, CurrP, new Cesium.Cartesian3());
      var dir2 = Cesium.Cartesian3.subtract(lf2, CurrP, new Cesium.Cartesian3());
      var avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
      var avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
      leftPotsRes.push(Cesium.clone(avgPot));

      var rg1 = rightPots[_i * 2 + 0];
      var rg2 = rightPots[_i * 2 + 1];
      dir1 = Cesium.Cartesian3.subtract(rg1, CurrP, new Cesium.Cartesian3());
      dir2 = Cesium.Cartesian3.subtract(rg2, CurrP, new Cesium.Cartesian3());
      avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
      avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
      rightPotsRes.push(Cesium.clone(avgPot));
    }
  } else {
    daslog.warn("计算左右侧点出问题！");
    return;
  }

  var uvs = [];
  var vertexs = [];
  var vertexsH = [];
  var vertexsL = [];
  var indexs = [];

  //先记录右边点，后记录左边点、记录2遍为了分离UV
  for (var _i2 = 0; _i2 < len; _i2++) {
    var encodeRes = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i2]);
    vertexs.push(rightPotsRes[_i2].x);
    vertexs.push(rightPotsRes[_i2].y);
    vertexs.push(rightPotsRes[_i2].z);

    vertexsH.push(encodeRes.high.x);
    vertexsH.push(encodeRes.high.y);
    vertexsH.push(encodeRes.high.z);

    vertexsL.push(encodeRes.low.x);
    vertexsL.push(encodeRes.low.y);
    vertexsL.push(encodeRes.low.z);

    uvs.push(1, 1);

    //记录索引以及UV
    if (_i2 < len - 1) {
      indexs.push(_i2 + len * 2);
      indexs.push(_i2 + 1);
      indexs.push(_i2 + 1 + len);

      indexs.push(_i2 + len * 2);
      indexs.push(_i2 + 1 + len);
      indexs.push(len + _i2 + len * 2);
    }
  }
  for (var _i3 = 0; _i3 < len; _i3++) {
    var _encodeRes = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i3]);
    vertexs.push(leftPotsRes[_i3].x);
    vertexs.push(leftPotsRes[_i3].y);
    vertexs.push(leftPotsRes[_i3].z);

    vertexsH.push(_encodeRes.high.x);
    vertexsH.push(_encodeRes.high.y);
    vertexsH.push(_encodeRes.high.z);

    vertexsL.push(_encodeRes.low.x);
    vertexsL.push(_encodeRes.low.y);
    vertexsL.push(_encodeRes.low.z);

    uvs.push(1, 0);
  }

  for (var _i4 = 0; _i4 < len; _i4++) {
    var _encodeRes2 = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i4]);
    vertexs.push(rightPotsRes[_i4].x);
    vertexs.push(rightPotsRes[_i4].y);
    vertexs.push(rightPotsRes[_i4].z);

    vertexsH.push(_encodeRes2.high.x);
    vertexsH.push(_encodeRes2.high.y);
    vertexsH.push(_encodeRes2.high.z);

    vertexsL.push(_encodeRes2.low.x);
    vertexsL.push(_encodeRes2.low.y);
    vertexsL.push(_encodeRes2.low.z);

    uvs.push(0, 1);

    // if(i<len-1){
    //     // indexs.push(i + len*2);
    //     // indexs.push(i+1 + len*2);
    //     // indexs.push(i+1+len + len*2);

    //     // indexs.push(i + len*2);
    //     // indexs.push(i+1+len + len*2);
    //     // indexs.push(len+i + len*2);
    // }
  }
  for (var _i5 = 0; _i5 < len; _i5++) {
    var _encodeRes3 = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i5]);
    vertexs.push(leftPotsRes[_i5].x);
    vertexs.push(leftPotsRes[_i5].y);
    vertexs.push(leftPotsRes[_i5].z);

    vertexsH.push(_encodeRes3.high.x);
    vertexsH.push(_encodeRes3.high.y);
    vertexsH.push(_encodeRes3.high.z);

    vertexsL.push(_encodeRes3.low.x);
    vertexsL.push(_encodeRes3.low.y);
    vertexsL.push(_encodeRes3.low.z);

    uvs.push(0, 0);
  }

  return {
    left: leftPotsRes,
    right: rightPotsRes,
    self: lineArr,
    vertexs: new Float32Array(vertexs),
    vertexsH: new Float32Array(vertexsH),
    vertexsL: new Float32Array(vertexsL),
    indexs: new Uint16Array(indexs),
    uvs: new Float32Array(uvs)
  };
}

function RaisePoint(pot, height) {
  if (!(pot instanceof Cesium.Cartesian3)) {
    daslog.warn("请确认点是Cartesian3类型！");
    return;
  }
  if (!height || height == 0) {
    daslog.warn("请确认高度是非零数值！");
    return;
  }
  var dir = Cesium.Cartesian3.normalize(pot, new Cesium.Cartesian3());
  var ray = new Cesium.Ray(pot, dir);
  return Cesium.Ray.getPoint(ray, height);
}

function GetSides(firstP, sceondP, halfW) {
  var dir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(sceondP, firstP, new Cesium.Cartesian3()), new Cesium.Cartesian3());
  var nor = Cesium.Cartesian3.normalize(firstP, new Cesium.Cartesian3());
  var leftDir = Cesium.Cartesian3.cross(nor, dir, new Cesium.Cartesian3());
  var rightDir = Cesium.Cartesian3.cross(dir, nor, new Cesium.Cartesian3());
  var leftray = new Cesium.Ray(firstP, leftDir);
  var rightray = new Cesium.Ray(firstP, rightDir);
  var leftPot = Cesium.Ray.getPoint(leftray, halfW);
  var rightPot = Cesium.Ray.getPoint(rightray, halfW);
  return {
    left: leftPot,
    right: rightPot
  };
}

/***/ }),
/* 217 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n        gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput) { \n    czm_material material = czm_getDefaultMaterial(materialInput); \n    vec2 st = materialInput.st;\n    if(move){\n        float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n        float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n        float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n        st += sqrt(z*z+z2*z2);\n        st.s += reflux * czm_frameNumber/1000.0 * speed;\n        st.s = mod(st.s,1.0);\n    }\n    if(flipY){\n        st = vec2(st.t,st.s);\n    }\n    vec4 colorImage = texture2D(image, st);\n    material.alpha = alpha;\n    material.diffuse = colorImage.rgb; \n    return material; \n}"

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DasWater = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _TextureChangedWater = __webpack_require__(221);

var _TextureChangedWater2 = _interopRequireDefault(_TextureChangedWater);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 镜面反射水
//
var DasWater = exports.DasWater = function () {
  //========== 构造方法 ==========

  function DasWater(options) {
    _classCallCheck(this, DasWater);

    if (!Cesium.defined(options.viewer)) {
      throw new Cesium.DeveloperError("options.viewer is required.");
    }
    if (!Cesium.defined(options.viewer.scene)) {
      throw new Cesium.DeveloperError("viewer.scene is required.");
    }
    this._scene = options.viewer.scene;
    this._wrfbo = new _TextureChangedWater2.default();
    this._opacity = Cesium.defaultValue(options.opacity, 1);
    this._color = Cesium.defaultValue(options.color, 1);
    this._waterColor = Cesium.Color.fromCssColorString(this._color || "#3388ff").withAlpha(this._opacity);
    this._frequency = Cesium.defaultValue(options.frequency, 1000);
    this._animationSpeed = Cesium.defaultValue(options.animationSpeed, 0.05);
    this._amplitude = Cesium.defaultValue(options.amplitude, 6);
    this._specularIntensity = Cesium.defaultValue(options.specularIntensity, 0.5);
    this._fadeFactor = Cesium.defaultValue(options.fadeFactor, 1);
    this._positions = Cesium.defaultValue(options.positions, []);
    this._trackedPrimitives = [];
    this._isVisible = Cesium.defaultValue(options.isVisible, true);
    this.waterPolygon = this.createWaterPolygonPrimitive(this._positions);
    this.waterHeight = 0;
    this.requestID = 0;
    this.updateReflectTexture();
  }
  //========== 方法 ==========


  _createClass(DasWater, [{
    key: "createWaterPolygonPrimitive",
    value: function createWaterPolygonPrimitive(positions) {
      var _scene = this._scene;
      var Primitive = void 0;
      var fromPositions = void 0;
      var that = this;
      fromPositions = Cesium.CoplanarPolygonGeometry.fromPositions({
        vertexFormat: Cesium.MaterialAppearance.MaterialSupport.ALL.vertexFormat,
        positions: positions
      });
      var RenderState = new Cesium.RenderState();
      RenderState.depthTest.enabled = true;
      Primitive = _scene.primitives.add(new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: fromPositions
        }),
        appearance: new Cesium.Appearance({
          materialSupport: Cesium.MaterialAppearance.MaterialSupport.ALL,
          material: that._createWaterMaterial(),
          renderState: RenderState,
          vertexShaderSource: "attribute vec3 position3DHigh;\n          attribute vec3 position3DLow;\n          attribute vec3 normal;\n          attribute vec3 tangent;\n          attribute vec3 bitangent;\n          attribute vec2 st;\n          attribute float batchId;\n          varying vec3 v_positionEC;\n          varying vec3 v_normalEC;\n          varying vec3 v_tangentEC;\n          varying vec3 v_bitangentEC;\n          varying vec2 v_st;\n          void main()\n          {\n          vec4 p = czm_computePosition();\n          v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n          v_normalEC = czm_normal * normal;\n          v_tangentEC = czm_normal * tangent;\n          v_bitangentEC = czm_normal * bitangent;\n          v_st = st;\n          gl_Position = czm_modelViewProjectionRelativeToEye * p;\n          }",
          fragmentShaderSource: "varying vec3 v_positionEC;\n          varying vec3 v_normalEC;\n          varying vec3 v_tangentEC;\n          varying vec3 v_bitangentEC;\n          varying vec2 v_st;\n          void main()\n          {\n          vec3 positionToEyeEC = -v_positionEC;\n          mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\n          vec3 normalEC = normalize(v_normalEC);\n          #ifdef FACE_FORWARD\n          normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n          #endif\n          czm_materialInput materialInput;\n          materialInput.normalEC = normalEC;\n          materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n          materialInput.positionToEyeEC = positionToEyeEC;\n          materialInput.st = v_st;\n          czm_material material = czm_getMaterial(materialInput);\n          #ifdef FLAT\n          gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n          #else\n          gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n          #endif\n          }\n          "
        })
      }));
      var o = new Cesium.Cartesian3();
      var a = new Cesium.Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      var s = new Cesium.Cartesian3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      positions.forEach(function (e) {
        Cesium.Cartesian3.add(o, e, o);
        a.x = a.x > e.x ? e.x : a.x;
        a.y = a.y > e.y ? e.y : a.y;
        a.z = a.z > e.z ? e.z : a.z;
        s.x = s.x < e.x ? e.x : s.x;
        s.y = s.y < e.y ? e.y : s.y;
        s.z = s.z < e.z ? e.z : s.z;
      });
      var l = s.x - a.x;
      var u = s.y - a.y;
      var h = s.z - a.z;
      var radius = 0.5 * Math.max(l, u, h);
      var centerPos = Cesium.Cartesian3.multiplyByScalar(o, 1 / positions.length, o);
      Primitive.centerPos = centerPos;
      Primitive.radius = radius;
      var getWaterHeight = Cesium.Cartographic.fromCartesian(centerPos);
      Primitive.waterHeight = getWaterHeight.height;
      this._trackPrimitive(Primitive);
      return Primitive;
    }
  }, {
    key: "_createWaterMaterial",
    value: function _createWaterMaterial() {
      var that = this;
      var material = new Cesium.Material({
        fabric: {
          type: "WaterMaterial",
          uniforms: {
            color: this._waterColor,
            image: Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
            normalMap: Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
            frequency: 1000,
            animationSpeed: 0.05,
            amplitude: 2,
            specularIntensity: 0.5,
            fadeFactor: 1
          },
          source: "uniform sampler2D image;\n                uniform sampler2D normalMap;\n                uniform vec4 color;\n                uniform float frequency;\n                uniform float animationSpeed;\n                uniform float amplitude;\n                uniform float specularIntensity;\n                uniform float fadeFactor;\n                czm_material czm_getMaterial(czm_materialInput materialInput)\n                {\n                    czm_material material = czm_getDefaultMaterial(materialInput);\n                    float time = czm_frameNumber * animationSpeed;\n                    // fade is a function of the distance from the fragment and the frequency of the waves\n                    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n                    float specularMapValue = texture2D(image, materialInput.st).r;\n                    specularMapValue = 1.0;\n                    // note: not using directional motion at this time, just set the angle to 0.0;\n                    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n                    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n                    // fade out the normal perturbation as we move further from the water surface\n                    normalTangentSpace.xy /= fade;\n                    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n                    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n                    normalTangentSpace = normalize(normalTangentSpace);\n                    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n                    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n                    // fade out water effect as specular map value decreases\n                    material.alpha = specularMapValue;\n                    // base color is a blend of the water and non-water color based on the value from the specular map\n                    // may need a uniform blend factor to better control this\n                    // material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n                    vec2 v = gl_FragCoord.xy / czm_viewport.zw; \n                    v.y = 1.0 - v.y;\n                    // material.diffuse = texture2D(image, v).rgb; \n                    material.diffuse = texture2D(image, v + noise.xy*0.03).rgb; \n                    // diffuse highlights are based on how perturbed the normal is\n                    material.diffuse += (0.1 * tsPerturbationRatio);\n                    // material.diffuse += (0.1 * tsPerturbationRatio);\n                    material.diffuse = material.diffuse;\n                    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n                    material.specular = specularIntensity;\n                    material.shininess = 10.0;\n                    material.diffuse = color.rgb * material.diffuse;\n                    // material.diffuse = mix(material.diffuse,color.rgb, color.a);\n                    material.alpha = color.a;\n                    return material;\n                }"

        }
      });
      material._uniforms.image_1 = function () {
        return that._wrfbo._colorTexture || that._scene.context.defaultTexture;
      };
      material._uniforms.color_0 = function () {
        return that._waterColor;
      };
      material._uniforms.amplitude_5 = function () {
        return that._amplitude;
      };
      material._uniforms.animationSpeed_4 = function () {
        return that._animationSpeed;
      };
      material._uniforms.frequency_3 = function () {
        return that._frequency;
      };
      material._uniforms.specularIntensity_6 = function () {
        return that._specularIntensity;
      };
      material._uniforms.fadeFactor_7 = function () {
        return that._fadeFactor;
      };
      return material;
    }
  }, {
    key: "_trackPrimitive",
    value: function _trackPrimitive(pri) {
      ~this._trackedPrimitives.indexOf(pri) || this._trackedPrimitives.push(pri);
    }
  }, {
    key: "updateReflectTexture",
    value: function updateReflectTexture() {
      var that = this;
      this._disposeListener = function () {
        var sceneCamera = that._scene.camera,
            sceneCameraVol = sceneCamera.frustum.computeCullingVolume(sceneCamera.positionWC, sceneCamera.directionWC, sceneCamera.upWC);
        if (that._trackedPrimitives.some(function (primitiveItem) {
          if (!primitiveItem.show) return false;
          var bounding = primitiveItem._boundingSphereWC || primitiveItem._boundingVolumes;
          return bounding && bounding.some(function (e) {
            return sceneCameraVol.computeVisibility(e) !== Cesium.Intersect.OUTSIDE;
          });
        })) {
          var i = Number.MAX_VALUE,
              selectPrimitive = void 0;
          that._trackedPrimitives.forEach(function (primitiveItem) {
            if (primitiveItem.show) {
              var bounding = primitiveItem._boundingSphereWC || primitiveItem._boundingVolumes;
              if (bounding && bounding.some(function (e) {
                return sceneCameraVol.computeVisibility(e) !== Cesium.Intersect.OUTSIDE;
              })) {
                var a = Cesium.Cartesian3.distanceSquared(primitiveItem.centerPos, sceneCamera.positionWC) - primitiveItem.radius;
                i > a && (i = a, selectPrimitive = primitiveItem);
              }
            }
          }), selectPrimitive && that.doWork(that._scene, selectPrimitive.waterHeight, that._wrfbo);
        }
        that.requestID = window.requestAnimationFrame(function () {
          that._disposeListener();
        });
      };
      that.requestID = window.requestAnimationFrame(function () {
        that._disposeListener();
      });
    }
  }, {
    key: "doWork",
    value: function doWork(scene, waterHeight, wrfbo) {
      var that = this;
      var newFrustum1 = new Cesium.PerspectiveFrustum();
      var newOffCenterFrustum1 = new Cesium.PerspectiveOffCenterFrustum();
      var newFrustum2 = new Cesium.OrthographicFrustum();
      var newOffCenterFrustum2 = new Cesium.OrthographicOffCenterFrustum();
      var PassState = Cesium.Cesium3DTilePassState && new Cesium.Cesium3DTilePassState({
        pass: Cesium.Cesium3DTilePass.RENDER
      });
      var tempCamera;
      if (tempCamera || (tempCamera = new Cesium.Camera(scene)), scene.mode === Cesium.SceneMode.SCENE3D) {
        var sceneContext = scene.context;
        var passState = scene._view.passState;
        var cameraClone = Cesium.Camera.clone(scene.camera, tempCamera);
        var cloneCameraPosition = cameraClone.positionCartographic;
        var cloneCameraPitch = cameraClone.pitch;
        var cloneCameraHeading = cameraClone.heading;
        var cloneCameraRoll = cameraClone.roll;
        cameraClone.setView({
          destination: Cesium.Cartesian3.fromRadians(cloneCameraPosition.longitude, cloneCameraPosition.latitude, waterHeight + waterHeight - cloneCameraPosition.height),
          orientation: {
            heading: cloneCameraHeading,
            pitch: -cloneCameraPitch,
            roll: cloneCameraRoll
          }
        });
        var BufferWidth = 0.5 * scene.context.drawingBufferWidth;
        var BufferHeight = 0.5 * scene.context.drawingBufferHeight;
        passState.viewport.x = 0;
        passState.viewport.y = 0;
        passState.viewport.width = BufferWidth;
        passState.viewport.height = BufferHeight;
        passState.framebuffer = wrfbo._framebuffer;
        var clearColorCommand = scene._clearColorCommand;
        Cesium.Color.multiplyByScalar(Cesium.Color.DEEPSKYBLUE, 0.1, clearColorCommand.color);
        clearColorCommand.color.alpha = 1;
        // clearColorCommand.execute(sceneContext, passState);
        if (scene._frameState.useLogDepth) {
          clearColorCommand.execute(sceneContext, passState);
        } else {
          return;
        }
        wrfbo._colorTexture;
        wrfbo.update(sceneContext, BufferWidth, BufferHeight);
        wrfbo._colorTexture;
        var ClearCommand = scene._depthClearCommand;
        var uniformState = sceneContext.uniformState;
        uniformState.updateCamera(cameraClone);
        var cameraCloneMartix;
        if (Cesium.defined(cameraClone.frustum.fov)) {
          cameraCloneMartix = cameraClone.frustum.clone(newFrustum1);
        } else if (Cesium.defined(cameraClone.frustum.infiniteProjectionMatrix)) {
          cameraCloneMartix = cameraClone.frustum.clone(newOffCenterFrustum1);
        } else if (Cesium.defined(cameraClone.frustum.width)) {
          cameraCloneMartix = cameraClone.frustum.clone(newFrustum2);
        } else {
          cameraCloneMartix = cameraClone.frustum.clone(newOffCenterFrustum2);
        }
        cameraCloneMartix.near = cameraClone.frustum.near;
        cameraCloneMartix.far = cameraClone.frustum.far;
        uniformState.updateFrustum(cameraCloneMartix);
        var frameState = scene._frameState;
        frameState.passes.render = true;
        frameState.tilesetPassState = PassState;
        scene.frameState.commandList.length = 0;
        scene._primitives.update(frameState);
        scene._view.createPotentiallyVisibleSet(scene);
        for (var M, S, T, E = scene._view.frustumCommandsList, A = E.length, P = [Cesium.Pass.ENVIRONMENT, Cesium.Pass.GLOBE, Cesium.Pass.TERRAIN_CLASSIFICATION, Cesium.Pass.CESIUM_3D_TILE, Cesium.Pass.TRANSLUCENT], L = 0; L < A; ++L) {
          var D = A - L - 1;
          var I = E[D];
          if (D != 0) {
            cameraCloneMartix.near = I.near * scene.opaqueFrustumNearOffset;
          } else {
            cameraCloneMartix.near = I.near;
          }
          cameraCloneMartix.far = I.far;
          uniformState.updateFrustum(cameraCloneMartix);
          ClearCommand.execute(sceneContext, passState);
          for (var R = 0; R < P.length; R++) {
            // for ( M = I.commands[P[R]], S = I.indices[P[R]], T = 0; T < S; ++T) {
            // M[T].execute(sceneContext, passState);
            for (uniformState.updatePass(P[R]), M = I.commands[P[R]], S = I.indices[P[R]], T = 0; T < S; ++T) {
              !function (e, t, n, i) {
                var r = t._frameState;
                if (!Cesium.defined(t.debugCommandFilter) || t.debugCommandFilter(e)) {
                  if (e instanceof Cesium.ClearCommand) {
                    return e.execute(n, i);
                  };
                  if (r.useLogDepth && Cesium.defined(e.derivedCommands.logDepth)) {
                    e = e.derivedCommands.logDepth.command;
                  }
                  r = r.passes;
                  !r.pick && t._hdr && Cesium.defined(e.derivedCommands) && Cesium.defined(e.derivedCommands.hdr) && (e = e.derivedCommands.hdr.command);
                  r.pick || r.depth || t.debugShowCommands || t.debugShowFrustums || e.execute(n, i);
                }
              }(M[T], scene, sceneContext, passState);
            }
          }
        }
        passState.framebuffer = null;
        uniformState.das3dWaterHeight = -500000;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._scene.primitives.remove(this.waterPolygon);
      window.cancelAnimationFrame(this.requestID);
      Cesium.destroyObject(this);
    }
    //========== 对外属性 ==========

  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(val) {
      this._color = val;
      this._waterColor = Cesium.Color.fromCssColorString(this._color).withAlpha(this._opacity);
    }
  }, {
    key: "opacity",
    get: function get() {
      return this._opacity;
    },
    set: function set(val) {
      this._opacity = val;
      this._waterColor = Cesium.Color.fromCssColorString(this._color).withAlpha(this._opacity);
    }
  }, {
    key: "frequency",
    get: function get() {
      return this._frequency;
    },
    set: function set(val) {
      this._frequency = val;
    }
  }, {
    key: "animationSpeed",
    get: function get() {
      return this._animationSpeed;
    },
    set: function set(val) {
      this._animationSpeed = val;
    }
  }, {
    key: "specularIntensity",
    get: function get() {
      return this._specularIntensity;
    },
    set: function set(val) {
      this._specularIntensity = val;
    }
  }, {
    key: "amplitude",
    get: function get() {
      return this._amplitude;
    },
    set: function set(val) {
      this._amplitude = val;
    }
  }, {
    key: "fadeFactor",
    get: function get() {
      return this._fadeFactor;
    },
    set: function set(val) {
      this._fadeFactor = val;
    }
  }, {
    key: "isVisible",
    get: function get() {
      return this._isVisible;
    },
    set: function set(val) {
      this._isVisible = val;
      if (this.waterPolygon) {
        this.waterPolygon.show = this._isVisible;
      }
    }
  }]);

  return DasWater;
}();

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextureChangedWater = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //纹理变化对象


var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TextureChangedWater = exports.TextureChangedWater = function () {
  function TextureChangedWater() {
    _classCallCheck(this, TextureChangedWater);

    this._framebuffer = null;
    this._colorTexture = null;
    this._textureChangedEvent = new Cesium.Event();
  }

  _createClass(TextureChangedWater, [{
    key: "getTextureChangedEvent",
    value: function getTextureChangedEvent() {
      return this._textureChangedEvent;
    }
  }, {
    key: "update",
    value: function update(context, width, height) {
      var colorTexture = this._colorTexture;
      if (!Cesium.defined(this._framebuffer)) {
        if (!Cesium.defined(colorTexture) || colorTexture.width !== width || colorTexture.height !== height) {
          this.setNewTexture(this, context, width, height);
          this._textureChangedEvent.raiseEvent(this._colorTexture);
        }
      }
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyDepthStencilTexture(this);
      this.framebufferDestroy(this);
      Cesium.destroyObject(this);
    }
  }, {
    key: "destroyDepthStencilTexture",
    value: function destroyDepthStencilTexture(texture) {
      texture._colorTexture && !texture._colorTexture.isDestroyed() && texture._colorTexture.destroy() || !texture._colorTexture || (texture._colorTexture.destroy = function () {}, texture._colorTexture = void 0), texture._depthStencilTexture = texture._depthStencilTexture && !texture._depthStencilTexture.isDestroyed() && texture._depthStencilTexture.destroy();
    }
  }, {
    key: "framebufferDestroy",
    value: function framebufferDestroy(texture) {
      if (texture._framebuffer && !texture._framebuffer.isDestroyed()) {
        texture._framebuffer.destroy();
      }
    }
  }, {
    key: "setNewTexture",
    value: function setNewTexture(texture, context, width, height) {
      this.destroyDepthStencilTexture(texture);
      this.framebufferDestroy(texture);
      texture._colorTexture = new Cesium.Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
      });
      texture._depthStencilTexture = new Cesium.Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      });
      texture._framebuffer = new Cesium.Framebuffer({
        context: context,
        colorTextures: [texture._colorTexture],
        depthStencilTexture: texture._depthStencilTexture,
        destroyAttachments: false
      });
    }
  }]);

  return TextureChangedWater;
}();

exports.default = TextureChangedWater;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DasWater2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _reflectRender = __webpack_require__(223);

var _reflectRender2 = _interopRequireDefault(_reflectRender);

var _refractRender = __webpack_require__(224);

var _refractRender2 = _interopRequireDefault(_refractRender);

var _wrfboReflect = __webpack_require__(225);

var _wrfboReflect2 = _interopRequireDefault(_wrfboReflect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 镜面反射水(全反射)
//
var DasWater2 = exports.DasWater2 = function () {
  //========== 构造方法 ==========

  function DasWater2(options) {
    _classCallCheck(this, DasWater2);

    if (!Cesium.defined(options.viewer)) {
      throw new Cesium.DeveloperError("options.viewer is required.");
    }
    if (!Cesium.defined(options.viewer.scene)) {
      throw new Cesium.DeveloperError("viewer.scene is required.");
    }
    this._layers = options.layers;
    this._scene = options.viewer.scene;
    this._rColor = Cesium.defaultValue(options.rColor, new Cesium.Color(0.439, 0.564, 0.788, 0.5));
    this._normal = Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg");
    this._brightness = Cesium.defaultValue(options.brightness, 1);
    this._animateSpeed = Cesium.defaultValue(options.animateSpeed, 0.06);
    this._frequency = Cesium.defaultValue(options.frequency, 10);
    this._amplitude = Cesium.defaultValue(options.amplitude, 1);
    this._specularIntensity = Cesium.defaultValue(options.specularIntensity, 0.9);
    this.rPolygon = null;
    this._normalMap = null;
    var that = this;
    Cesium.Resource.fetchImage({
      url: that._normal
    }).then(function (e) {
      that._normalMap = new Cesium.Texture({
        context: that._scene.frameState.context,
        source: e
      }), that._normalMap.sampler = new Cesium.Sampler({
        wrapS: Cesium.TextureWrap.REPEAT,
        wrapT: Cesium.TextureWrap.REPEAT,
        maximumAnisotropy: 16
      });
    });
    this._wrfboReflect = new _wrfboReflect2.default();
    this._reflectRender = new _reflectRender2.default();
    this._wrfboRefract = new _wrfboReflect2.default();
    this._refractRender = new _refractRender2.default();
    this._positions = Cesium.defaultValue(options.positions, []);
    this._trackedPrimitives = [];
    this._isVisible = Cesium.defaultValue(options.isVisible, true);
    this.createPolygonPrimitive(this._positions, false);
    this.updateReflectTexture();
  }
  //========== 方法 ==========

  _createClass(DasWater2, [{
    key: "createPolygonPrimitive",
    value: function createPolygonPrimitive(positions, t) {
      var scene = this._scene;
      var primitive = null;
      var geometry = Cesium.CoplanarPolygonGeometry.fromPositions({
        vertexFormat: Cesium.MaterialAppearance.MaterialSupport.ALL.vertexFormat,
        positions: positions
      });
      primitive = scene.primitives.add(new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geometry
        }),
        appearance: new Cesium.MaterialAppearance({
          materialSupport: Cesium.MaterialAppearance.MaterialSupport.ALL,
          closed: true
        })
      }));
      primitive.appearance.material = this._createMaterial();
      var val = new Cesium.Cartesian3(),
          maxVal = new Cesium.Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
          minVal = new Cesium.Cartesian3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      positions.forEach(function (position) {
        Cesium.Cartesian3.add(val, position, val), maxVal.x = (maxVal.x > position.x ? position : maxVal).x, maxVal.y = (maxVal.y > position.y ? position : maxVal).y, maxVal.z = (maxVal.z > position.z ? position : maxVal).z, minVal.x = (minVal.x < position.x ? position : minVal).x, minVal.y = (minVal.y < position.y ? position : minVal).y, minVal.z = (minVal.z < position.z ? position : minVal).z;
      });
      var xminVal = minVal.x - maxVal.x;
      var yminVal = minVal.y - maxVal.y;
      var zminVal = minVal.z - maxVal.z;
      xminVal = 0.5 * Math.max(xminVal, yminVal, zminVal);
      yminVal = Cesium.Cartesian3.multiplyByScalar(val, 1 / positions.length, val);
      zminVal = Cesium.Cartesian3.subtract(positions[0], yminVal, new Cesium.Cartesian3());
      positions = Cesium.Cartesian3.subtract(positions[1], yminVal, new Cesium.Cartesian3());
      positions = Cesium.Cartesian3.cross(zminVal, positions, new Cesium.Cartesian3());
      positions = Cesium.Cartesian3.normalize(positions, new Cesium.Cartesian3());
      primitive.centerPos = yminVal;
      primitive.radius = xminVal;
      primitive.normal = positions;
      this._normal = positions;
      Cesium.Cartographic.fromCartesian(yminVal);
      for (var planeTmp = Cesium.Plane.fromPointNormal(yminVal, positions), layerIndex = 0; layerIndex < this._layers.length; layerIndex++) {
        var transform;
        var tileset = this._layers[layerIndex];
        if (tileset.clippingPlanes) {
          transform = tileset.root.transform;
          transform = Cesium.Matrix4.inverse(transform, new Cesium.Matrix4());
          transform = Cesium.Plane.transform(planeTmp, transform);
          tileset.clippingPlanes.get(0).normal = transform.normal;
          tileset.clippingPlanes.get(0).distance = transform.distance;
        }
      }
      this._trackPrimitive(primitive);
      this.rPolygon = primitive;
      this.rPolygon.show = this._isVisible;
      return primitive;
    }
  }, {
    key: "_createMaterial",
    value: function _createMaterial() {
      var WaterMaterial = new Cesium.Material({
        fabric: {
          type: "DasWater2Material",
          uniforms: {
            color: this._rColor,
            reflect: Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
            refract: Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
            normalMap: Cesium.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
            brightness: this._brightness,
            animateSpeed: this._animateSpeed,
            frequency: this._frequency,
            amplitude: this._amplitude,
            specularIntensity: this._specularIntensity
          },
          source: "\n        uniform vec4 color;\n        uniform sampler2D reflect;\n        uniform sampler2D refract;\n        uniform sampler2D normalMap;\n        uniform float brightness;\n        uniform float frequency;\n        uniform float animateSpeed;\n        uniform float amplitude;\n        uniform float specularIntensity;\n        czm_material czm_getMaterial(czm_materialInput materialInput)\n        {\n            czm_material material = czm_getDefaultMaterial(materialInput);\n            float specularMapValue = 1.0; \n            float fadeFactor = 1.0;\n            float time = czm_frameNumber * animateSpeed;\n            // fade is a function of the distance from the fragment and the frequency of the waves\n            float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n            vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n            vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n            // fade out the normal perturbation as we move further from the water surface\n            normalTangentSpace.xy /= fade;\n            // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n            normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n            normalTangentSpace = normalize(normalTangentSpace);\n            // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n            float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n            vec2 uv = gl_FragCoord.xy / czm_viewport.zw; \n            vec3 refract = texture2D(refract, uv + noise.xy*0.03).rgb;\n            refract += (0.1 * tsPerturbationRatio);\n            uv.x = 1.0 - uv.x;\n            vec3 reflect = texture2D(reflect, uv + noise.xy*0.03).rgb;\n            reflect += (0.1 * tsPerturbationRatio);\n            float reflectance = specularIntensity;\n            material.diffuse = mix( refract, reflect, reflectance ); \n            material.diffuse = brightness * color.rgb * material.diffuse;\n            material.specular = 0.99;\n            material.shininess = 20.0;\n            material.alpha = color.a;\n            material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n            if ( materialInput.normalEC.z < 0.0 ) {\n                material.diffuse.rgb = vec3(0, 0, 0); // back\n                material.shininess = 0.0;\n                material.specular = 0.0;\n                material.alpha = color.a;\n            }  \n            return material;\n        }"
        }
      });
      var that = this;
      return WaterMaterial._uniforms.color_0 = function () {
        return that._rColor;
      }, WaterMaterial._uniforms.reflect_1 = function () {
        return that._wrfboReflect._colorTexture || that._scene.context.defaultTexture;
      }, WaterMaterial._uniforms.refract_2 = function () {
        return that._wrfboRefract._colorTexture || that._scene.context.defaultTexture;
      }, WaterMaterial._uniforms.normalMap_3 = function () {
        return that._normalMap;
      }, WaterMaterial._uniforms.brightness_4 = function () {
        return that._brightness;
      }, WaterMaterial._uniforms.animateSpeed_5 = function () {
        return that._animateSpeed;
      }, WaterMaterial._uniforms.frequency_6 = function () {
        return that._frequency;
      }, WaterMaterial._uniforms.amplitude_7 = function () {
        return that._amplitude;
      }, WaterMaterial._uniforms.specularIntensity_8 = function () {
        return that._specularIntensity;
      }, WaterMaterial;
    }
  }, {
    key: "_trackPrimitive",
    value: function _trackPrimitive(e) {
      ~this._trackedPrimitives.indexOf(e) || this._trackedPrimitives.push(e);
    }
  }, {
    key: "updateReflectTexture",
    value: function updateReflectTexture() {
      var scene = this._scene;
      var that = this;
      this._disposeListener = scene.preRender.addEventListener(function () {
        that._reflectRender.render(that._scene, that.rPolygon, that._wrfboReflect, that._layers);
        that._refractRender.render(that._scene, that.rPolygon, that._wrfboRefract, that._layers);
      });
    }
  }, {
    key: "release",
    value: function release() {
      this._initialized = false;
      this._rPolygon = null;
      this._drawCommand = null;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._scene.primitives.remove(this.rPolygon);
      if (this._disposeListener != null) {
        this._disposeListener();
        this._disposeListener = null;
      }
      Cesium.destroyObject(this);
    }
  }, {
    key: "rColor",
    get: function get() {
      return this._rColor;
    },
    set: function set(value) {
      this._rColor = value;
    }
  }, {
    key: "brightness",
    get: function get() {
      return this._brightness;
    },
    set: function set(value) {
      this._brightness = value;
    }
  }, {
    key: "frequency",
    get: function get() {
      return this._frequency;
    },
    set: function set(value) {
      this._frequency = value;
    }
  }, {
    key: "amplitude",
    get: function get() {
      return this._amplitude;
    },
    set: function set(value) {
      this._amplitude = value;
    }
  }, {
    key: "specularIntensity",
    get: function get() {
      return this._specularIntensity;
    },
    set: function set(value) {
      this._specularIntensity = value;
    }
  }, {
    key: "isVisible",
    get: function get() {
      return this._isVisible;
    },
    set: function set(value) {
      this._isVisible = value;
      if (this.rPolygon) {
        this.rPolygon.show = this._isVisible;
      }
    }
  }]);

  return DasWater2;
}();

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reflectRender = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //纹理变化对象


var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var reflectRender = exports.reflectRender = function () {
  function reflectRender() {
    _classCallCheck(this, reflectRender);

    this._reflectCam = null;
    this.scratchColorZero = new Cesium.Color(0, 0, 0, 0);
    this.renderTilesetPassState = new Cesium.Cesium3DTilePassState({
      pass: Cesium.Cesium3DTilePass.RENDER
    });
  }

  _createClass(reflectRender, [{
    key: "executeCommand",
    value: function executeCommand(e, t, n, i, r) {
      var frameState = t._frameState;
      Cesium.defined(t.debugCommandFilter) && !t.debugCommandFilter(e) || (e instanceof Cesium.ClearCommand ? e.execute(n, i) : (frameState.useLogDepth && Cesium.defined(e.derivedCommands.logDepth) && (e = e.derivedCommands.logDepth.command), !(frameState = frameState.passes).pick && t._hdr && Cesium.defined(e.derivedCommands) && Cesium.defined(e.derivedCommands.hdr) && (e = e.derivedCommands.hdr.command), frameState.pick || frameState.depth || t.debugShowCommands || t.debugShowFrustums || e.execute(n, i)));
    }
  }, {
    key: "reflect",
    value: function reflect(e, t) {
      var n = Cesium.Cartesian3.dot(t, e),
          n = Cesium.Cartesian3.multiplyByScalar(t, 2 * n, new Cesium.Cartesian3());
      return Cesium.Cartesian3.subtract(e, n, new Cesium.Cartesian3());
    }
  }, {
    key: "getCenter",
    value: function getCenter(camera) {
      var position = Cesium.Cartesian3.clone(camera.position);
      var direction = Cesium.Cartesian3.clone(camera.direction);
      var pitch = camera.pitch + Math.PI / 2;
      var position1 = Cesium.Cartesian3.magnitude(position);
      if (pitch == 0) {
        return Cesium.Cartesian3.multiplyByScalar(position, 6378137 / position1, new Cesium.Cartesian3());
      }
      camera = new Cesium.Cartesian3(-direction.x, -direction.y, -direction.z);
      pitch = Math.PI - pitch;
      camera = Cesium.Cartesian3.angleBetween(position, camera);
      camera = Math.PI - pitch - camera;
      camera = Math.sqrt(position1 * position1 + 40680631590769 - 2 * position1 * 6378137 * Math.cos(camera));
      camera = Cesium.Cartesian3.multiplyByScalar(direction, camera, new Cesium.Cartesian3());
      return Cesium.Cartesian3.add(position, camera, new Cesium.Cartesian3());
    }
  }, {
    key: "applyMat4",
    value: function applyMat4(e, t) {
      var n = e.x,
          i = e.y,
          r = e.z,
          a = t,
          e = 1 / (a[3] * n + a[7] * i + a[11] * r + a[15]),
          t = new Cesium.Cartesian3();
      return t.x = (a[0] * n + a[4] * i + a[8] * r + a[12]) * e, t.y = (a[1] * n + a[5] * i + a[9] * r + a[13]) * e, t.z = (a[2] * n + a[6] * i + a[10] * r + a[14]) * e, t;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(e, t) {
      var n = Cesium.Matrix4.getMatrix3(t, new Cesium.Matrix3()),
          n = Cesium.Matrix3.inverse(n, new Cesium.Matrix3()),
          i = Cesium.Matrix3.transpose(n, new Cesium.Matrix3()),
          n = Cesium.Cartesian3.clone(e.normal),
          n = Cesium.Cartesian3.multiplyByScalar(n, -e.distance, new Cesium.Cartesian3()),
          t = this.applyMat4(n, t),
          i = Cesium.Matrix3.multiplyByVector(i, e.normal, new Cesium.Cartesian3()),
          e = new Cesium.Plane(e.normal, e.distance);
      return e.normal = Cesium.Cartesian3.normalize(i, new Cesium.Cartesian3()), e.distance = -Cesium.Cartesian3.dot(t, e.normal), e;
    }
  }, {
    key: "render",
    value: function render(scene, rPolygon, wrfboReflect, layers) {
      var passState, camera, CloneCamera, curNormal, curAxis, CloneCameraPosition, viewMatrix, PolygonNormal, context;
      if (!this._reflectCam) {
        this._reflectCam = new Cesium.Camera(scene);
      }
      if (scene.mode === Cesium.SceneMode.SCENE3D && rPolygon.show) {
        rPolygon.show = false;
        context = scene.context;
        passState = scene._view.passState;
        camera = scene.camera;
        CloneCamera = Cesium.Camera.clone(scene.camera, this._reflectCam);
        CloneCameraPosition = CloneCamera.position;
        viewMatrix = CloneCamera.viewMatrix;
        Cesium.Matrix4.getMatrix3(viewMatrix, new Cesium.Matrix3());
        PolygonNormal = rPolygon.normal;
        curAxis = Cesium.Cartesian3.subtract(rPolygon.centerPos, CloneCameraPosition, new Cesium.Cartesian3());
        curNormal = this.reflect(curAxis, PolygonNormal);
        viewMatrix = Cesium.Cartesian3.negate(curNormal, new Cesium.Cartesian3());
        viewMatrix = Cesium.Cartesian3.add(rPolygon.centerPos, viewMatrix, new Cesium.Cartesian3());
        CloneCameraPosition = this.getCenter(scene.camera);
        curAxis = Cesium.Cartesian3.subtract(rPolygon.centerPos, CloneCameraPosition, new Cesium.Cartesian3());
        curNormal = this.reflect(curAxis, PolygonNormal);
        CloneCameraPosition = Cesium.Cartesian3.negate(curNormal, new Cesium.Cartesian3());
        CloneCameraPosition = Cesium.Cartesian3.add(rPolygon.centerPos, CloneCameraPosition, new Cesium.Cartesian3());
        curAxis = Cesium.Cartesian3.clone(CloneCamera.up, new Cesium.Cartesian3());
        curAxis = this.reflect(curAxis, PolygonNormal);
        curNormal = Cesium.Cartesian3.subtract(CloneCameraPosition, viewMatrix, new Cesium.Cartesian3());
        curNormal = Cesium.Cartesian3.normalize(curNormal, new Cesium.Cartesian3());
        CloneCameraPosition = Cesium.Cartesian3.cross(curNormal, curAxis, new Cesium.Cartesian3());
        CloneCameraPosition = Cesium.Cartesian3.normalize(CloneCameraPosition, new Cesium.Cartesian3());
        CloneCamera.position = viewMatrix;
        CloneCamera.direction = curNormal;
        CloneCamera.up = curAxis;
        CloneCamera.right = CloneCameraPosition;
        CloneCamera.update(scene.mode);
        scene.camera = CloneCamera;
        curAxis = 0.5 * scene.context.drawingBufferWidth;
        CloneCameraPosition = 0.5 * scene.context.drawingBufferHeight;
        passState.viewport.x = 0;
        passState.viewport.y = 0;
        passState.viewport.width = curAxis;
        passState.viewport.height = CloneCameraPosition;
        wrfboReflect.update(context, curAxis, CloneCameraPosition);
        passState.framebuffer = wrfboReflect._framebuffer;
        wrfboReflect = scene._clearColorCommand;
        Cesium.Color.multiplyByScalar(Cesium.Color.DEEPSKYBLUE, 0.1, wrfboReflect.color);
        wrfboReflect.color.alpha = 1;
        wrfboReflect.execute(context, passState);
        scene._depthClearCommand;
        wrfboReflect = context.uniformState;
        context = Cesium.Plane.fromPointNormal(rPolygon.centerPos, PolygonNormal);
        Math.abs(Cesium.Plane.getPointDistance(context, viewMatrix));
        viewMatrix = Cesium.Plane.transform(context, CloneCamera.viewMatrix);
        context = new Cesium.Cartesian4(viewMatrix.normal.x, viewMatrix.normal.y, viewMatrix.normal.z, viewMatrix.distance);
        CloneCamera.frustum.fov;
        Cesium.Cartesian3.angleBetween(PolygonNormal, CloneCamera.direction);
        CloneCamera.frustum._offCenterFrustum.clipPlane = context;
        wrfboReflect.updateCamera(CloneCamera);
        scene.updateFrameState();
        viewMatrix = scene.globe.show;
        context = (PolygonNormal = scene._frameState).useLogDepth;
        PolygonNormal.invertClassification = false;
        PolygonNormal.passes.render = true;
        PolygonNormal.tilesetPassState = this.renderTilesetPassState;
        PolygonNormal.camera = CloneCamera;
        PolygonNormal.useLogDepth = false;
        scene.globe.show = false;
        wrfboReflect.update(PolygonNormal);
        scene.updateEnvironment();
        scene.updateAndExecuteCommands(passState, this.scratchColorZero);
        scene.resolveFramebuffers(passState);
        passState.framebuffer = null;
        PolygonNormal.camera = camera;
        PolygonNormal.useLogDepth = context;
        scene.camera = camera;
        rPolygon.show = true;
        scene.globe.show = viewMatrix;
      }
    }
  }]);

  return reflectRender;
}();

exports.default = reflectRender;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refractRender = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var refractRender = exports.refractRender = function () {
  function refractRender() {
    _classCallCheck(this, refractRender);

    this._refractCam = null;
    this.scratchColorZero = new Cesium.Color(0, 0, 0, 0);
    this.renderTilesetPassState = new Cesium.Cesium3DTilePassState({
      pass: Cesium.Cesium3DTilePass.RENDER
    });
  }

  _createClass(refractRender, [{
    key: "reflect",
    value: function reflect(e, t) {
      var n = Cesium.Cartesian3.dot(t, e);
      n = Cesium.Cartesian3.multiplyByScalar(t, 2 * n, new Cesium.Cartesian3());
      return Cesium.Cartesian3.subtract(e, n, new Cesium.Cartesian3());
    }
  }, {
    key: "render",
    value: function render(scene, rPolygon, wrfboRefract, layers) {
      var passState;
      var camera;
      var CloneCamera;
      var BufferWidth;
      var CloneCameraViewMatrix;
      var rPolygonNormal;
      var CloneCameraPosition;
      var context;
      if (!this._refractCam) {
        this._refractCam = new Cesium.Camera(scene);
      }
      if (scene.mode === Cesium.SceneMode.SCENE3D && rPolygon.show) {
        rPolygon.show = false;
        context = scene.context;
        passState = scene._view.passState;
        camera = scene.camera;
        CloneCamera = Cesium.Camera.clone(scene.camera, this._refractCam);
        CloneCameraPosition = CloneCamera.position;
        CloneCameraViewMatrix = CloneCamera.viewMatrix;
        Cesium.Matrix4.getMatrix3(CloneCameraViewMatrix, new Cesium.Matrix3());
        rPolygonNormal = rPolygon.normal;
        scene.camera = CloneCamera;
        BufferWidth = scene.context.drawingBufferWidth;
        CloneCameraViewMatrix = scene.context.drawingBufferHeight;
        passState.viewport.x = 0;
        passState.viewport.y = 0;
        passState.viewport.width = BufferWidth;
        passState.viewport.height = CloneCameraViewMatrix;
        wrfboRefract.update(context, BufferWidth, CloneCameraViewMatrix);
        passState.framebuffer = wrfboRefract._framebuffer;
        wrfboRefract = scene._clearColorCommand;
        Cesium.Color.multiplyByScalar(Cesium.Color.DEEPSKYBLUE, 0.1, wrfboRefract.color);
        wrfboRefract.color.alpha = 1;
        wrfboRefract.execute(context, passState);
        scene._depthClearCommand;
        wrfboRefract = context.uniformState;
        context = Cesium.Cartesian3.clone(CloneCameraPosition, new Cesium.Cartesian3());
        CloneCameraPosition = Cesium.Cartesian3.negate(rPolygonNormal, new Cesium.Cartesian3());
        rPolygonNormal = Cesium.Plane.fromPointNormal(rPolygon.centerPos, CloneCameraPosition);
        Math.abs(Cesium.Plane.getPointDistance(rPolygonNormal, context));
        CloneCameraPosition = Cesium.Plane.transform(rPolygonNormal, CloneCamera.viewMatrix);
        context = new Cesium.Cartesian4(CloneCameraPosition.normal.x, CloneCameraPosition.normal.y, CloneCameraPosition.normal.z, CloneCameraPosition.distance);
        CloneCamera.frustum._offCenterFrustum.clipPlane = context;
        wrfboRefract.updateCamera(CloneCamera);
        scene.updateFrameState();
        rPolygonNormal = scene.globe.show;
        context = (CloneCameraPosition = scene._frameState).useLogDepth;
        CloneCameraPosition.invertClassification = false;
        CloneCameraPosition.passes.render = true;
        CloneCameraPosition.tilesetPassState = this.renderTilesetPassState;
        CloneCameraPosition.camera = CloneCamera;
        CloneCameraPosition.useLogDepth = false;
        scene.globe.show = false;
        wrfboRefract.update(CloneCameraPosition);
        scene.updateEnvironment();
        scene.updateAndExecuteCommands(passState, this.scratchColorZero);
        scene.resolveFramebuffers(passState);
        passState.framebuffer = void 0;
        CloneCameraPosition.camera = camera;
        CloneCameraPosition.useLogDepth = context;
        scene.camera = camera;
        rPolygon.show = true;
        scene.globe.show = rPolygonNormal;
      }
    }
  }]);

  return refractRender;
}();

exports.default = refractRender;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrfboReflect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var wrfboReflect = exports.wrfboReflect = function () {
  function wrfboReflect() {
    _classCallCheck(this, wrfboReflect);

    this._framebuffer = null;
    this._colorTexture = null;
    this._textureChangedEvent = new Cesium.Event();
  }

  _createClass(wrfboReflect, [{
    key: "destroyDepthStencilTexture",
    value: function destroyDepthStencilTexture(texture) {
      texture._colorTexture && !texture._colorTexture.isDestroyed() && texture._colorTexture.destroy() || !texture._colorTexture || (texture._colorTexture.destroy = function () {
        console.log("pb");
      }, texture._colorTexture = void 0), texture._depthStencilTexture = texture._depthStencilTexture && !texture._depthStencilTexture.isDestroyed() && texture._depthStencilTexture.destroy();
    }
  }, {
    key: "framebufferDestroy",
    value: function framebufferDestroy(texture) {
      if (texture._framebuffer && !texture._framebuffer.isDestroyed()) {
        texture._framebuffer.destroy();
      }
    }
  }, {
    key: "getTextureChangedEvent",
    value: function getTextureChangedEvent() {
      return this._textureChangedEvent;
    }
  }, {
    key: "update",
    value: function update(height1, t, context) {
      var i, r, context1, width1;
      r = height1, context1 = t, width1 = context, height1 = (i = this)._colorTexture, t = !Cesium.defined(height1) || height1.width !== context1 || height1.height !== width1, Cesium.defined(i._framebuffer) && !t || (context = r, height1 = context1, t = width1, this.destroyDepthStencilTexture(r = i), this.framebufferDestroy(r), context1 = context, width1 = height1, height1 = t, (t = r)._colorTexture = new Cesium.Texture({
        context: context1,
        width: width1,
        height: height1,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
      }), t._depthStencilTexture = new Cesium.Texture({
        context: context1,
        width: width1,
        height: height1,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      }), r._framebuffer = new Cesium.Framebuffer({
        context: context,
        colorTextures: [r._colorTexture],
        depthStencilTexture: r._depthStencilTexture,
        destroyAttachments: !1
      }), i._textureChangedEvent.raiseEvent(i._colorTexture));
    }
  }, {
    key: "isDestroyed",
    value: function isDestroyed() {
      return false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyDepthStencilTexture(this);
      this.framebufferDestroy(this);
    }
  }]);

  return wrfboReflect;
}();

exports.default = wrfboReflect;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParticleSystemEx = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//粒子效果封装，方便控制。
var ParticleSystemEx = exports.ParticleSystemEx = function () {
  //========== 构造方法 ==========

  function ParticleSystemEx(viewer, options) {
    _classCallCheck(this, ParticleSystemEx);

    if (!viewer) return;

    this.viewer = viewer;
    this.options = options;

    this.viewer.clock.shouldAnimate = true;

    //一些临时数据
    this.emitterModelMatrix = new Cesium.Matrix4();
    this.translation = new Cesium.Cartesian3();
    this.rotation = new Cesium.Quaternion();
    this.hpr = new Cesium.HeadingPitchRoll();
    this.trs = new Cesium.TranslationRotationScale();

    //内部属性
    this.position = options.position; //中心点位置
    this._show = Cesium.defaultValue(options.show, true);
    this._maxHeight = Cesium.defaultValue(options.maxHeight, 5000);
    this.gravity = Cesium.defaultValue(options.gravity, 0); //重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）

    this.transX = Cesium.defaultValue(options.transX, 0);
    this.transY = Cesium.defaultValue(options.transY, 0);
    this.transZ = Cesium.defaultValue(options.transZ, 0);

    this.target = Cesium.defaultValue(options.target, new Cesium.Cartesian3(0, 0, 0)); //粒子的方向

    this._init(options);
  }

  //========== 对外属性 ==========
  //显示隐藏


  _createClass(ParticleSystemEx, [{
    key: "_init",


    //========== 方法 ==========
    value: function _init(options) {
      //默认值
      var viewModel = {
        startColor: Cesium.Color.LIGHTCYAN.withAlpha(0.3), //粒子出生时的颜色
        endColor: Cesium.Color.WHITE.withAlpha(0.0), //当粒子死亡时的颜色

        imageSize: new Cesium.Cartesian2(25, 25), //粒子图片的Size大小（单位：像素）
        // scale:1.0,//粒子的比例
        startScale: 2.0, //粒子在出生时的比例（单位：相对于imageSize大小的倍数）
        endScale: 4.0, //粒子在死亡时的比例（单位：相对于imageSize大小的倍数）

        // particleLife:1.1, //粒子存在的时间（单位：秒）
        minimumParticleLife: 1.1, //粒子可能存在的最短寿命时间，实际寿命将随机生成（单位：秒）
        maximumParticleLife: 3.1, //粒子可能存在的最长寿命时间，实际寿命将随机生成（单位：秒）

        // speed:1.0,//粒子初速度
        minimumSpeed: 1.0, //粒子初速度的最小界限，超过该最小界限，随机选择粒子的实际速度。（单位：米/秒）
        maximumSpeed: 2.0, //粒子初速度的最大界限，超过该最大界限，随机选择粒子的实际速度。（单位：米/秒）

        emissionRate: 100, //粒子发射器的发射速率 （单位：次/秒）

        loop: true, //是否循环
        lifetime: 16.0, //生命周期（单位：秒）

        // bursts: [//而粒子会在5s、10s、15s时分别进行一次粒子大爆发
        //     new Cesium.ParticleBurst({ time: 5.0, minimum: 10, maximum: 100 }),  // 当在5秒时，发射的数量为10-100
        //     new Cesium.ParticleBurst({ time: 10.0, minimum: 50, maximum: 100 }), // 当在10秒时，发射的数量为50-100
        //     new Cesium.ParticleBurst({ time: 15.0, minimum: 200, maximum: 300 })  // 当在15秒时，发射的数量为200-300
        // ],
        emitter: new Cesium.CircleEmitter(2.0), //此系统的粒子发射器(指定方向)，  共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类

        modelMatrix: this._computeModelMatrix(this.viewer.clock.currentTime), // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标
        emitterModelMatrix: this._computeEmitterModelMatrix(this), // 4x4转换矩阵，用于在粒子系统本地坐标系中转换粒子系统发射器
        show: this._show
      };

      if (Cesium.defaultValue(options.hasDefUpdate, true)) {
        //回调函数，参数是(particle,dt)，分别是单个粒子的属性和两次发射之间的时间间隔(单位:s)
        // eslint-disable-next-line no-inner-declarations
        var applyGravity = function applyGravity(particle, dt) {
          var translatCar3 = that.target.clone();

          var position = particle.position;
          Cesium.Cartesian3.add(particle.position, translatCar3, particle.position);

          var gravityScratch = new Cesium.Cartesian3();

          Cesium.Cartesian3.normalize(position, gravityScratch);
          Cesium.Cartesian3.multiplyByScalar(gravityScratch, that.gravity * dt, gravityScratch);
          particle.velocity = Cesium.Cartesian3.add(particle.velocity, gravityScratch, particle.velocity);
        };

        var that = this;
        viewModel.updateCallback = applyGravity;
      }

      for (var key in options) {
        var value = options[key];
        switch (key) {
          default:
            //直接赋值
            viewModel[key] = value;
            break;
          case "position": //跳过扩展其他属性的参数
          case "modelMatrix":
          case "gravity":
            break;
          case "particleSize":
            viewModel.imageSize = new Cesium.Cartesian2(value, value);
            break;
        }
      }

      //构造粒子对象
      this.particleSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem(viewModel));

      this.viewer.scene.preUpdate.addEventListener(this._scene_preUpdateHandler, this);

      //加控制，只在相机高度低于一定高度时才开启本效果
      this.viewer.scene.camera.changed.addEventListener(this._camera_changedHandler, this);
    }
  }, {
    key: "_scene_preUpdateHandler",
    value: function _scene_preUpdateHandler(scene, time) {
      if (!this.particleSystem) return;

      this.particleSystem.modelMatrix = this._computeModelMatrix(time);
      this.particleSystem.emitterModelMatrix = this._computeEmitterModelMatrix(this);
    }
  }, {
    key: "_computeModelMatrix",
    value: function _computeModelMatrix(time) {
      if (this.position) {
        var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);
        // var hprRotation = Cesium.Matrix3.fromHeadingPitchRoll(new Cesium.HeadingPitchRoll(2.619729, 0.0, 0.0));
        // var hpr = Cesium.Matrix4.fromRotationTranslation(hprRotation, new Cesium.Cartesian3(0.0, 0.0, -2.0));
        // Cesium.Matrix4.multiply(modelMatrix, hpr, modelMatrix);
        return modelMatrix;
      } else if (this.options.modelMatrix) {
        return this.options.modelMatrix(time);
      }
    }
  }, {
    key: "_computeEmitterModelMatrix",
    value: function _computeEmitterModelMatrix(that) {
      that.hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, that.hpr);
      that.trs.translation = Cesium.Cartesian3.fromElements(that.transX, that.transY, that.transZ, that.translation);
      that.trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(that.hpr, that.rotation);

      Cesium.Matrix4.fromTranslationRotationScale(that.trs, that.emitterModelMatrix);

      // var translatCar3 = new Cesium.Cartesian3(-2, -2, 2);
      // Cesium.Matrix4.multiplyByTranslation(that.emitterModelMatrix, translatCar3, that.emitterModelMatrix);
      return that.emitterModelMatrix;
    }
  }, {
    key: "_camera_changedHandler",
    value: function _camera_changedHandler(event) {
      if (this.viewer.camera.positionCartographic.height < this._maxHeight) {
        if (this.particleSystem.show != this._show) this.particleSystem.show = this._show;
      } else {
        if (this.particleSystem.show) this.particleSystem.show = false;
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.preUpdate.removeEventListener(this._scene_preUpdateHandler, this);
      this.viewer.scene.camera.changed.removeEventListener(this._camera_changedHandler, this);

      this.viewer.scene.primitives.remove(this.particleSystem);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (this.particleSystem) this.particleSystem.show = this._show;
    }

    //修改Image大小

  }, {
    key: "particleSize",
    get: function get() {
      return this.particleSize || 25;
    },
    set: function set(particleSize) {
      if (!this.particleSystem) return;

      this.particleSystem.minimumImageSize.x = particleSize;
      this.particleSystem.minimumImageSize.y = particleSize;
      this.particleSystem.maximumImageSize.x = particleSize;
      this.particleSystem.maximumImageSize.y = particleSize;
    }
  }]);

  return ParticleSystemEx;
}();

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*点光源*/


//点光源
var PointLight = exports.PointLight = function (_DasClass) {
  _inherits(PointLight, _DasClass);

  function PointLight(viewer, options) {
    _classCallCheck(this, PointLight);

    var _this = _possibleConstructorReturn(this, (PointLight.__proto__ || Object.getPrototypeOf(PointLight)).call(this, options));

    _this.viewer = viewer;
    _this.options = options;
    _this._pointPosition = options.pointPosition;
    _this._lightEnabled = Cesium.defaultValue(options.lightEnabled, true);
    _this._color = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.color, '#ffffff'));
    _this._cutoffDistance = Cesium.defaultValue(options.cutoffDistance, 50);
    _this._decay = Cesium.defaultValue(options.decay, 0.03);
    _this._lightIntensity = Cesium.defaultValue(options.lightIntensity, 3);
    _this.initialize(_this.viewer);
    return _this;
  }

  _createClass(PointLight, [{
    key: "initialize",
    value: function initialize(viewer) {
      var that = this;
      var newPoint = new Cesium.Cartesian3();
      this._postProcessStage = new Cesium.PostProcessStage({
        fragmentShader: "precision highp float;\n            uniform sampler2D colorTexture;\n            varying vec2 v_textureCoordinates;\n            uniform float cutoffDistance;\n            uniform float decay;\n            uniform float lightIntensity;\n            uniform vec3 lightPositionEC;\n            uniform vec3 color;\n            uniform bool u_enable;\n            float pow2( const in float x ) { return x*x; }\n          float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\n          float saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\n          \n          void main()\n          {\n            gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n            if (u_enable == true) {\n              float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n              vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n              eyeCoordinate /= eyeCoordinate.w;\n              float dis = distance(eyeCoordinate.xyz, lightPositionEC);\n              if (dis < cutoffDistance) {\n                vec3 lightAdd = color * lightIntensity;\n                \n                // if PHYSICALLY_CORRECT_LIGHTS\n                // float distanceFalloff = 1.0 / max( pow( dis, 2.0 ), 1.0 );\n                // distanceFalloff *= pow2( saturate( 1.0 - pow2( dis / cutoffDistance ) ) );\n                \n                float distanceFalloff = 1.0;\n                if( cutoffDistance > 0.0 && decay > 0.0 ) {\n\t\t            if (cutoffDistance <= 1.0) {\n\t\t                float a = 1.0 / (1.0 + decay * dis * dis);\n                        distanceFalloff = distanceFalloff * a / dis;\n\t\t            } else {\n\t\t                distanceFalloff = pow( saturate( -dis / cutoffDistance + 1.0 ), decay );\n\t\t            }\n\t            }\n\t            \n                lightAdd = lightAdd * distanceFalloff;\n                gl_FragColor += vec4(lightAdd, 1.0);\n              }\n            };\n          } ",
        uniforms: {
          lightPositionEC: function lightPositionEC() {
            return Cesium.Matrix4.multiplyByPoint(viewer.camera.viewMatrix, that._pointPosition, newPoint);
          },
          lightEnabled: function lightEnabled() {
            return that._lightEnabled;
          },
          color: function color() {
            return that._color;
          },
          cutoffDistance: function cutoffDistance() {
            return that._cutoffDistance;
          },
          decay: function decay() {
            return that._decay;
          },
          lightIntensity: function lightIntensity() {
            return that._lightIntensity;
          },
          u_enable: function u_enable() {
            return that._lightEnabled;
          }
        }
      });
      viewer.scene.postProcessStages.add(this._postProcessStage);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      viewer.scene.postProcessStages.remove(this._postProcessStage);
    }

    //========== 对外属性 ==========

  }, {
    key: "pointPosition",
    get: function get() {
      return this._pointPosition;
    },
    set: function set(value) {
      this._pointPosition = value;
    }
  }, {
    key: "lightEnabled",
    get: function get() {
      return this._lightEnabled;
    },
    set: function set(value) {
      this._lightEnabled = value;
    }
  }, {
    key: "color",
    get: function get() {
      return this._color;
    },
    set: function set(value) {
      this._color = Cesium.Color.fromCssColorString(value);
    }
  }, {
    key: "cutoffDistance",
    get: function get() {
      return this._cutoffDistance;
    },
    set: function set(value) {
      this._cutoffDistance = value;
    }
  }, {
    key: "decay",
    get: function get() {
      return this._decay;
    },
    set: function set(value) {
      this._decay = value;
    }
  }, {
    key: "lightIntensity",
    get: function get() {
      return this._lightIntensity;
    },
    set: function set(value) {
      this._lightIntensity = value;
    }
  }]);

  return PointLight;
}(_DasClass2.DasClass);

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpotLight = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _EffectCollection = __webpack_require__(91);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //聚光灯


//聚光灯
var SpotLight = exports.SpotLight = function (_DasClass) {
    _inherits(SpotLight, _DasClass);

    function SpotLight(viewer, options) {
        _classCallCheck(this, SpotLight);

        var _this = _possibleConstructorReturn(this, (SpotLight.__proto__ || Object.getPrototypeOf(SpotLight)).call(this, options));

        viewer.effects || (viewer.effects = new _EffectCollection.EffectCollection(options));
        _this._viewer = viewer;
        var defaultLights = [{
            name: "默认点位",
            coords: [113.39086, 49.90735],
            heading: 0,
            modelMatrix: new Cesium.Matrix4()
        }];
        _this._lights = Cesium.defaultValue(options.lights, defaultLights);
        _this._lightEnabled = Cesium.defaultValue(options.lightEnabled, true);
        _this._selectedName = Cesium.defaultValue(options.selectedName, "全部");
        _this._enabled = Cesium.defaultValue(options.enabled, true);
        _this._color = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.color, '#ffffff'));
        _this._angle = Cesium.defaultValue(options.angle, 100);
        _this._cutoffDistance = Cesium.defaultValue(options.cutoffDistance, 50);
        _this._decay = Cesium.defaultValue(options.decay, 2);
        _this._lightIntensity = Cesium.defaultValue(options.lightIntensity, 3);
        _this.init();
        return _this;
    }

    _createClass(SpotLight, [{
        key: "init",
        value: function init() {
            this.createStage(this._lights);
            this._updatePostProcess();
        }
    }, {
        key: "createStage",
        value: function createStage(lights) {
            var that = this;
            var glStr = "\n              precision highp float;\n              uniform sampler2D colorTexture;\n              uniform sampler2D depthTexture;\n              varying vec2 v_textureCoordinates;\n            ";
            lights.forEach(function (e, value) {
                glStr += "uniform bool enabled" + value + ";\n            uniform vec3 color" + value + ";\n            uniform float cutoffDistance" + value + ";\n            uniform float decay" + value + ";\n            uniform float lightIntensity" + value + ";\n            uniform float angle" + value + ";\n            uniform vec3 lightPositionEC" + value + ";\n            uniform vec3 lightDirEC" + value + ";\n            ";
            });
            glStr += "\n        uniform mat4 inverseViewMatrix;\n        uniform mat4 viewMatrix1;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n            vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n            vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n            posInCamera =posInCamera / posInCamera.w;\n            return posInCamera;\n        }\n        float getDepth(in vec4 depth)\n        {\n            float z_window = czm_unpackDepth(depth);\n            z_window = czm_reverseLogDepth(z_window);\n            float n_range = czm_depthRange.near;\n            float f_range = czm_depthRange.far;\n            return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        float saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\n        void main()\n        {        \n            gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n            float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n            vec4 viewPos = toEye(v_textureCoordinates, depth);\n            viewPos /= viewPos.w;\n            vec4 worldPos = inverseViewMatrix*viewPos;\n            float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\n            vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n            eyeCoordinate /=eyeCoordinate.w; \n            vec3 pos; vec3 dir;\n         ";
            lights.forEach(function (e, value) {
                glStr += "if (enabled" + value + ") {pos=lightPositionEC" + value + ";\n                dir=lightDirEC" + value + ";\n                vec3 vecToPos = eyeCoordinate.xyz - pos;\n                vec3 pointDir = normalize(vecToPos);\n                float range = cutoffDistance" + value + ";\n                float dis = dot(vecToPos, dir);\n                if (dot(dir, pointDir) >= cos(angle" + value + "*0.5) && dis < range) {\n                    vec3 lightAdd = color" + value + " * lightIntensity" + value + (";\n                    \n                    float b = pow( saturate( -dis / range + 1.0 ), decay" + value + " );\n                    if (range <= 1.0) {\n\t\t                float a = 1.0 / (1.0 + decay" + value + " * dis * dis);\n                        b = b * a / dis;\n\t\t            } \n\t\t            \n\t\t            lightAdd = lightAdd *  b;\n\t\t            gl_FragColor += vec4(lightAdd, 1.0);\n                }};");
            });
            glStr += "}\n";
            var uniforms = {};
            lights.forEach(function (lightItem, t) {
                var n = (new Cesium.JulianDate(), new Cesium.Matrix4(), new Cesium.Cartesian3()),
                    i = new Cesium.Cartesian3(),
                    r = new Cesium.Cartesian3();
                lightItem.offset, lightItem.modelMatrix, new Cesium.Cartesian3(1, 0, -0.5), uniforms["lightPositionEC" + t] = function () {
                    return Cesium.Matrix4.multiplyByPoint(that._lights[t].modelMatrix, that._lights[t].offset, n), Cesium.Matrix4.multiplyByPoint(that._viewer.camera.viewMatrix, n, n), n;
                }, uniforms["lightDirEC" + t] = function () {
                    var e = Cesium.Cartesian3.add(that._lights[t].offset, that._lights[t].direction, new Cesium.Cartesian3());
                    return Cesium.Matrix4.multiplyByPoint(that._lights[t].modelMatrix, that._lights[t].offset, n), Cesium.Matrix4.multiplyByPoint(that._viewer.camera.viewMatrix, n, n), Cesium.Matrix4.multiplyByPoint(that._lights[t].modelMatrix, e, i), Cesium.Matrix4.multiplyByPoint(that._viewer.camera.viewMatrix, i, i), Cesium.Cartesian3.subtract(i, n, r), Cesium.Cartesian3.normalize(r, r);
                };
            });
            lights = new Cesium.PostProcessStage({
                fragmentShader: glStr,
                uniforms: uniforms
            });
            this._postProcessStage = lights;
        }
    }, {
        key: "_add",
        value: function _add() {
            return this._viewer.scene.postProcessStages.add(this._postProcessStage);
        }
    }, {
        key: "_remove",
        value: function _remove() {
            return this._viewer.scene.postProcessStages.remove(this._postProcessStage);
        }
    }, {
        key: "getkey",
        value: function getkey(obj) {
            var list = [];
            $.each(obj, function (key, value) {
                list.push(key);
            });
            return list;
        }
    }, {
        key: "_updatePostProcess",
        value: function _updatePostProcess() {
            var that = this;
            var t = this.getkey(that._lights);
            var n = this.getkey(t);
            t.unshift("全部"), n.unshift(null), that._postProcessStage.enabled = that._lightEnabled;
            for (var i = n[t.indexOf(that._selectedName)], r = 0; r < t.length; r++) {
                null !== i && r != i || (that._postProcessStage.uniforms["enabled" + r] = that._enabled, that._postProcessStage.uniforms["color" + r] = that._color, that._postProcessStage.uniforms["angle" + r] = that._angle / 180 * Math.PI, that._postProcessStage.uniforms["cutoffDistance" + r] = that._cutoffDistance, that._postProcessStage.uniforms["decay" + r] = that._decay, that._postProcessStage.uniforms["lightIntensity" + r] = that._lightIntensity);
            }
        }
    }, {
        key: "_update",
        value: function _update() {
            var ellipsoid = this._viewer.scene.globe.ellipsoid;
            var positionItem = this._positions[0];
            this._cartographic = ellipsoid.cartesianToCartographic(positionItem);
            this._minH = Cesium.Cartesian3.fromRadians(this._cartographic.longitude, this._cartographic.latitude, Number(this._minHeight));
            this._maxH = Cesium.Cartesian3.fromRadians(this._cartographic.longitude, this._cartographic.latitude, Number(this._maxHeight));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._viewer.scene.postProcessStages.remove(this._postProcessStage);
        }
        //对外方法

    }, {
        key: "viewer",
        get: function get() {
            return this._viewer;
        },
        set: function set(e) {
            this._viewer = e;
        }
    }, {
        key: "lights",
        get: function get() {
            return this._lights;
        },
        set: function set(e) {
            e !== this._lights && (this._lights = e, this._updatePostProcess());
        }
    }, {
        key: "lightEnabled",
        get: function get() {
            return this._lightEnabled;
        },
        set: function set(e) {
            e !== this._lightEnabled && (this._lightEnabled = e, this._updatePostProcess());
        }
    }, {
        key: "selectedName",
        get: function get() {
            return this._selectedName;
        },
        set: function set(e) {
            e !== this._selectedName && (this._selectedName = e, this._updatePostProcess());
        }
    }, {
        key: "enabled",
        get: function get() {
            return this._enabled;
        },
        set: function set(e) {
            e !== this._enabled && (this._enabled = e, this._updatePostProcess());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(e) {
            e = Cesium.Color.fromCssColorString(e);
            e !== this._color && (this._color = e, this._updatePostProcess());
        }
    }, {
        key: "angle",
        get: function get() {
            return this._angle;
        },
        set: function set(e) {
            e !== this._angle && (this._angle = e, this._updatePostProcess());
        }
    }, {
        key: "cutoffDistance",
        get: function get() {
            return this._cutoffDistance;
        },
        set: function set(e) {
            e !== this._cutoffDistance && (this._cutoffDistance = e, this._updatePostProcess());
        }
    }, {
        key: "decay",
        get: function get() {
            return this._decay;
        },
        set: function set(e) {
            e !== this._decay && (this._decay = e, this._updatePostProcess());
        }
    }, {
        key: "lightIntensity",
        get: function get() {
            return this._lightIntensity;
        },
        set: function set(e) {
            e !== this._lightIntensity && (this._lightIntensity = e, this._updatePostProcess());
        }
    }]);

    return SpotLight;
}(_DasClass2.DasClass);

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlatBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _FlatBillboardFS = __webpack_require__(230);

var _FlatBillboardFS2 = _interopRequireDefault(_FlatBillboardFS);

var _FlatBillboardVS = __webpack_require__(231);

var _FlatBillboardVS2 = _interopRequireDefault(_FlatBillboardVS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//平放的图标
//目前DrawCommand单向渲染的，无法鼠标单击拾取对象
var FlatBillboard = exports.FlatBillboard = function (_DasClass) {
  _inherits(FlatBillboard, _DasClass);

  //========== 构造方法 ==========
  function FlatBillboard(viewer, options) {
    _classCallCheck(this, FlatBillboard);

    var _this = _possibleConstructorReturn(this, (FlatBillboard.__proto__ || Object.getPrototypeOf(FlatBillboard)).call(this, options));

    _this.viewer = viewer;
    _this.options = options || {};

    _this.width = options.width || options.size || 50;
    _this.height = Cesium.defaultValue(options.height, _this.width);
    _this.scale3d = Cesium.defaultValue(options.scale3d, 0.6);
    _this._show = Cesium.defaultValue(options.show, true);

    var oldVal = Cesium.defaultValue(options.distanceDisplayCondition, new Cesium.DistanceDisplayCondition(0, 5000000));
    _this.distanceDisplayCondition = new Cesium.Cartesian2(oldVal.near, oldVal.far);

    _this.textures = {};
    _this.textureDef = new Cesium.Texture({
      context: _this.viewer.scene.context,
      width: 500,
      height: 500
    });
    _this._pickId = _this.viewer.scene.context.createPickId({
      id: "FlatBillboard",
      primitive: _this
    });

    if (options.data) _this.init(options.data);

    //切换场景后事件
    _this.viewer.scene.morphComplete.addEventListener(_this.onMorphComplete, _this);

    _this.viewer.scene.primitives.add(_this);
    return _this;
  }

  //========== 对外属性 ==========
  //数据


  _createClass(FlatBillboard, [{
    key: "init",


    //========== 方法 ==========
    value: function init(arrdata) {
      this.clear();

      this.options.data = arrdata;
      this.draw();
    }
    //渲染数据

  }, {
    key: "draw",
    value: function draw() {
      this._removeCollectionBy3D();
      this._removeCollectionBy2D();

      if (this.viewer.scene.mode === Cesium.SceneMode.SCENE3D) {
        this._initCollectionBy3D();
      } else {
        this._initCollectionBy2D();
      }
    }
  }, {
    key: "onMorphComplete",
    value: function onMorphComplete(e) {
      this.draw();
    }
  }, {
    key: "update",
    value: function update(frameState) {
      if (!this.show) {
        if (this.billboardCollection) {
          this._removeCollectionBy2D();
        }
        return;
      }

      //三维模式下
      if (frameState.mode === Cesium.SceneMode.SCENE3D) {
        var commandList = frameState.commandList;
        if (commandList && this.commands) {
          commandList.push.apply(commandList, _toConsumableArray(this.commands));
        }
      } else {
        if (!this.billboardCollection) {
          this._initCollectionBy2D();
        }
      }
    }

    //二维模式下的处理

  }, {
    key: "isInit2D",
    value: function isInit2D() {
      return this.billboardCollection;
    }
  }, {
    key: "_initCollectionBy2D",
    value: function _initCollectionBy2D() {
      var arrdata = this.data;
      if (!arrdata) return;

      this.billboardCollection = new Cesium.BillboardCollection({ scene: this.viewer.scene });
      this.viewer.scene.primitives.add(this.billboardCollection);

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];

        var primitive = this.billboardCollection.add({
          position: item.position,
          image: item.image,
          rotation: Cesium.Math.toRadians(item.angle),
          scale: 1,
          width: this.width,
          height: this.height
        });

        primitive.data = item.data || item;
        primitive.eventTarget = this;
        primitive.tooltip = this.options.tooltip;
        primitive.popup = this.options.popup;
      }
    }
  }, {
    key: "_removeCollectionBy2D",
    value: function _removeCollectionBy2D() {
      if (!this.billboardCollection) return;

      this.viewer.scene.primitives.remove(this.billboardCollection);
      delete this.billboardCollection;
    }

    //三维模式下的处理

  }, {
    key: "isInit3D",
    value: function isInit3D() {
      return this.commands;
    }
  }, {
    key: "_initCollectionBy3D",
    value: function _initCollectionBy3D() {
      var arrdata = this.data;
      if (!arrdata) return;

      //按图片分组
      var imaObj = {};
      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];

        if (!imaObj[item.image]) imaObj[item.image] = [];

        imaObj[item.image].push(item);
      }

      var commands = [];
      for (var key in imaObj) {
        var arr = imaObj[key];
        var image = key;

        //加载图片
        this.prepareTexture(image);

        //生成Command
        var VAO = this.prepareVAO(arr);
        var command = this.prepareCommand(VAO, image);
        commands.push(command);
      }
      this.commands = commands;
    }
  }, {
    key: "_removeCollectionBy3D",
    value: function _removeCollectionBy3D() {
      if (this.commands) {
        delete this.commands;
      }

      for (var key in this.textures) {
        if (this.textures[key]) {
          this.textures[key].destroy();
        }
      }
      this.textures = {};
    }
  }, {
    key: "prepareTexture",
    value: function prepareTexture(imgUrl) {
      var _this2 = this;

      var image = new Image();
      image.onload = function (e) {
        var texture = new Cesium.Texture({
          context: _this2.viewer.scene.context,
          source: image
        });
        _this2.textures[imgUrl] = texture;
      };
      image.src = imgUrl;
    }
  }, {
    key: "prepareVAO",
    value: function prepareVAO(points) {
      var vertexs_H = [];
      var vertexs_L = [];
      var indexs = [];
      var uvs = [];
      var colors = [];
      for (var i = 0, len = points.length; i < len; i++) {
        var currP = points[i];
        var currCar = currP.position;
        var angle = currP.angle;

        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 2);
        indexs.push(i * 4 + 1);
        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 3);
        indexs.push(i * 4 + 2);

        // 伪造双精度数据
        var currDF = new Float32Array(6);
        currDF[0] = currCar.x;
        currDF[1] = currCar.x - currDF[0];
        currDF[2] = currCar.y;
        currDF[3] = currCar.y - currDF[2];
        currDF[4] = currCar.z;
        currDF[5] = currCar.z - currDF[4];

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        uvs.push(0, 0);
        uvs.push(0, 1);
        uvs.push(1, 1);
        uvs.push(1, 0);
        var trans = Cesium.Transforms.eastNorthUpToFixedFrame(currCar);
        var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle));
        var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
        var currMat = Cesium.Matrix4.multiply(trans, rotationZ, new Cesium.Matrix4());

        var heightScale = this.height / this.width;

        var zxj = new Cesium.Cartesian3(-1, -heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, zxj, zxj);
        Cesium.Cartesian3.normalize(zxj, zxj);
        colors.push(zxj.x, zxj.y, zxj.z);

        var zsj = new Cesium.Cartesian3(-1, heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, zsj, zsj);
        Cesium.Cartesian3.normalize(zsj, zsj);
        colors.push(zsj.x, zsj.y, zsj.z);

        var ysj = new Cesium.Cartesian3(1, heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, ysj, ysj);
        Cesium.Cartesian3.normalize(ysj, ysj);
        colors.push(ysj.x, ysj.y, ysj.z);

        var yxj = new Cesium.Cartesian3(1, -heightScale, 0);
        Cesium.Matrix4.multiplyByPointAsVector(currMat, yxj, yxj);
        Cesium.Cartesian3.normalize(yxj, yxj);
        colors.push(yxj.x, yxj.y, yxj.z);
      }

      return {
        index: new Uint16Array(indexs),
        vertex_H: {
          values: new Float32Array(vertexs_H),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        vertex_L: {
          values: new Float32Array(vertexs_L),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        uv: {
          values: new Float32Array(uvs),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 2
        },
        color: {
          values: new Float32Array(colors),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 3
        }
      };
    }
  }, {
    key: "prepareCommand",
    value: function prepareCommand(VAO, imgUrl) {
      var context = this.viewer.scene.context;

      var width = context.drawingBufferWidth;
      var height = context.drawingBufferHeight;
      var sp = Cesium.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: _FlatBillboardVS2.default,
        fragmentShaderSource: _FlatBillboardFS2.default,
        attributeLocations: {
          position3DHigh: 0,
          position3DLow: 1,
          color: 2,
          st: 3
        }
      });

      var indexBuffer = Cesium.Buffer.createIndexBuffer({
        context: context,
        typedArray: VAO.index,
        usage: Cesium.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium.IndexDatatype.UNSIGNED_SHORT
      });

      var va = new Cesium.VertexArray({
        context: context,
        attributes: [{
          index: 0,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_H.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 1,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.vertex_L.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 2,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.color.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 3
        }, {
          index: 3,
          vertexBuffer: Cesium.Buffer.createVertexBuffer({
            context: context,
            typedArray: VAO.uv.values,
            usage: Cesium.BufferUsage.STATIC_DRAW
          }),
          componentsPerAttribute: 2
        }],
        indexBuffer: indexBuffer
      });

      var rs = Cesium.RenderState.fromCache();
      var that = this;
      var bs = Cesium.BoundingSphere.fromVertices(VAO.vertex_H.values);
      bs.radius = 1000000;
      // rs.depthMask = true;

      var command = new Cesium.DrawCommand({
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        shaderProgram: sp,
        vertexArray: va,
        modelMatrix: Cesium.Matrix4.IDENTITY,
        pickOnly: true,
        renderState: rs,
        boundingVolume: bs,
        uniformMap: {
          mm: function mm() {
            // return that.viewer.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;
            if (that.viewer.scene.camera.frustum._offCenterFrustum) return that.viewer.scene.camera.frustum._offCenterFrustum._perspectiveMatrix;else return that.viewer.scene.camera.frustum._orthographicMatrix;
          },
          vv: function vv() {
            return that.viewer.scene.camera._viewMatrix;
          },
          resolution: function resolution() {
            return new Cesium.Cartesian2(width, height);
          },
          billWidth: function billWidth() {
            return that.width * that.scale3d * 2;
          },
          billImg: function billImg() {
            return that.textures[imgUrl] || that.textureDef;
          },
          u_distanceDisplayCondition: function u_distanceDisplayCondition() {
            return that.distanceDisplayCondition;
          },
          u_eyePos: function u_eyePos() {
            return that.viewer.scene.camera.positionWC;
          }
        },
        castShadows: false,
        receiveShadows: false,
        pass: Cesium.Pass.TRANSLUCENT,
        pickCommand: new Cesium.DrawCommand({
          owner: this,
          pickOnly: true
        })
      });
      return command;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.options && this.options.data) this.options.data = null;

      if (this.billboardCollection) {
        this.billboardCollection.removeAll();
      }
      this._removeCollectionBy3D();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      //切换场景后事件
      this.viewer.scene.morphComplete.removeEventListener(this.onMorphComplete, this);
      this.viewer.scene.primitives.remove(this);
      if (!this.viewer) return;

      this.clear();
      this._removeCollectionBy2D();

      this.textureDef.destroy();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "data",
    get: function get() {
      return this.options.data;
    },
    set: function set(val) {
      this.init(val);
    }

    //是否显示

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
    }
  }]);

  return FlatBillboard;
}(_DasClass2.DasClass);

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec2 u_distanceDisplayCondition;\nuniform vec3 u_eyePos;\nvarying vec3 v_worldPos;\nuniform sampler2D billImg;\nvarying vec2 v_st;\nvoid main() {\n    float dis = distance(u_eyePos, v_worldPos);\n    if (dis < u_distanceDisplayCondition.x || dis > u_distanceDisplayCondition.y) {\n        discard;\n    } else {\n        gl_FragColor = texture2D(billImg,v_st);\n    }\n}"

/***/ }),
/* 231 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 color;\nattribute vec2 st;\nattribute float batchId;\nuniform mat4 mm;\nuniform mat4 vv;\nuniform vec2 resolution;\nuniform float billWidth;\nvarying vec2 v_st;\nvarying vec3 v_worldPos;\nvec4 transform(mat4 m,mat4 v,vec3 coord) {\n    return m * v * vec4(coord, 1.0);\n}\nvec2 project(vec4 device) {\n    vec3 device_normal = device.xyz / device.w;\n    vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;\n    return clip_pos * resolution;\n}\nvec4 unproject(vec2 screen, float z, float w) {\n    vec2 clip_pos = screen / resolution;\n    vec2 device_normal = clip_pos * 2.0 - 1.0;\n    return vec4(device_normal * w, z, w);\n}\nvoid main() { \n    v_st = st;\n    vec3 currP = position3DHigh.xyz + position3DLow.xyz;\n    v_worldPos = currP;\n    vec4 eyeCurrP = transform(mm,vv,currP);\n    vec2 winCurrP = project(eyeCurrP);\n    vec3 dirEye = czm_viewRotation * color;\n    dirEye = normalize(dirEye);\n    vec2 newWinCurrP = winCurrP + dirEye.xy * billWidth;\n    gl_Position = unproject(newWinCurrP, eyeCurrP.z, eyeCurrP.w);\n    gl_PointSize = billWidth;\n}"

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlatImage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _FlatImageMaterial = __webpack_require__(233);

var _FlatImageMaterial2 = _interopRequireDefault(_FlatImageMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//平放的图片（图片随地图缩放）
var FlatImage = exports.FlatImage = function (_DasClass) {
  _inherits(FlatImage, _DasClass);

  //========== 构造方法 ==========
  function FlatImage(viewer, options) {
    _classCallCheck(this, FlatImage);

    var _this = _possibleConstructorReturn(this, (FlatImage.__proto__ || Object.getPrototypeOf(FlatImage)).call(this, options));

    _this.viewer = viewer;
    _this.options = options || {};

    _this.size = Cesium.defaultValue(options.size, 50);
    _this._show = Cesium.defaultValue(options.show, true);

    //
    var primitiveCollection = new Cesium.PrimitiveCollection();
    primitiveCollection.show = _this._show;
    _this.viewer.scene.primitives.add(primitiveCollection);

    _this.primitiveCollection = primitiveCollection;

    if (options.data) _this.init(options.data);
    return _this;
  }

  //========== 对外属性 ==========
  //数据


  _createClass(FlatImage, [{
    key: "init",


    //========== 方法 ==========
    value: function init(arrdata) {
      this.clear();

      for (var i = 0, len = arrdata.length; i < len; i++) {
        var item = arrdata[i];
        var primitive = this.createPrimitive(item, item.size || this.size);
        this.primitiveCollection.add(primitive);
      }
    }
  }, {
    key: "createPrimitive",
    value: function createPrimitive(item, size) {
      var mat4 = Cesium.Transforms.eastNorthUpToFixedFrame(item.position);

      var mz = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(item.angle));
      var rotationZ = Cesium.Matrix4.fromRotationTranslation(mz);
      Cesium.Matrix4.multiply(mat4, rotationZ, mat4);

      var vertices = new Float64Array([
      //顶点坐标
      -size, -size, 0, size, -size, 0, size, size, 0, -size, size, 0]);
      var st = new Float32Array([
      //纹理坐标
      0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]);
      //let positions=new Float64Array;
      var attributes = new Cesium.GeometryAttributes();
      var indices = new Uint16Array(6); //顶点索引
      indices[0] = 0;
      indices[1] = 1;
      indices[2] = 2;
      indices[3] = 0;
      indices[4] = 2;
      indices[5] = 3;
      attributes.position = new Cesium.GeometryAttribute({
        //顶点attributes
        componentDatatype: Cesium.ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: vertices
      });
      attributes.st = new Cesium.GeometryAttribute({
        componentDatatype: Cesium.ComponentDatatype.FLOAT,
        componentsPerAttribute: 2,
        values: st
      });
      //自定义几何图形时，使用图片纹理，需要自己设置st,normal属性
      var rect = new Cesium.Geometry({
        attributes: attributes,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        indices: indices,
        boundingSphere: Cesium.BoundingSphere.fromVertices(vertices)
      });
      Cesium.GeometryPipeline.computeNormal(rect);
      var instance = new Cesium.GeometryInstance({
        geometry: rect,
        modelMatrix: mat4,
        id: "flatImage"
      });

      var primitive = new Cesium.Primitive({
        geometryInstances: [instance],
        appearance: new Cesium.MaterialAppearance({
          flat: true,
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                image: item.image,
                speed: 0.0
              },
              source: _FlatImageMaterial2.default
            }
          }),
          materialSupport: Cesium.MaterialAppearance.MaterialSupport.TEXTURED
        }),
        compressVertices: false,
        asynchronous: false
      });

      primitive.tooltip = item.tooltip;
      primitive.popup = item.popup;
      primitive.eventTarget = this;

      // let speed = 0.0;
      // const setIntervalID = setInterval(function () {//如果使用scene.preUpdate等帧刷新，则图片不显示
      //     if (speed <= 1.0) {
      //         speed += 0.05;
      //     } else {
      //         clearInterval(setIntervalID);
      //         speed = 0.0
      //     }
      //     primitive.appearance.material.uniforms.speed = speed;
      // }, 500)

      return primitive;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.primitiveCollection.removeAll();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.clear();
      this.viewer.scene.primitives.remove(this.primitiveCollection);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "data",
    get: function get() {
      return this.options.data;
    },
    set: function set(val) {
      this.options.data = val;
      this.init(val);
    }

    //数据

  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = val;
      if (this.primitiveCollection) this.primitiveCollection.show = this._show;
    }
  }]);

  return FlatImage;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


FlatImage.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    float isRed=step(speed,materialInput.st.x);\n    vec3 red;\n    if(isRed==0.0){\n        red = vec3(1.0,0.0,0.1);\n    }\n    else{\n        red = vec3(1.0,1.0,1.0);\n    }\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = czm_gammaCorrect(texture2D(image, fract(materialInput.st)).rgb *red); \n    \n    material.alpha = texture2D(image, fract(materialInput.st)).a;\n    return material;\n} "

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConeGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.getCirclePosition = getCirclePosition;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _ConeGlowCircleOuterMaterial = __webpack_require__(235);

var _ConeGlowCircleOuterMaterial2 = _interopRequireDefault(_ConeGlowCircleOuterMaterial);

var _ConeGlowCylinderGaussMaterial = __webpack_require__(236);

var _ConeGlowCylinderGaussMaterial2 = _interopRequireDefault(_ConeGlowCylinderGaussMaterial);

var _ConeGlowGradientMaterial = __webpack_require__(237);

var _ConeGlowGradientMaterial2 = _interopRequireDefault(_ConeGlowGradientMaterial);

var _ConeGlowRingScanMaterial = __webpack_require__(238);

var _ConeGlowRingScanMaterial2 = _interopRequireDefault(_ConeGlowRingScanMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//光柱
var ConeGlow = exports.ConeGlow = function (_DasClass) {
  _inherits(ConeGlow, _DasClass);

  function ConeGlow(viewer, options) {
    _classCallCheck(this, ConeGlow);

    var _this = _possibleConstructorReturn(this, (ConeGlow.__proto__ || Object.getPrototypeOf(ConeGlow)).call(this, options));

    _this.viewer = viewer;
    _this.options = options;

    _this.position = options.position; //中心点
    _this.extrudedHeight = Cesium.defaultValue(options.height, 1000);
    _this.u_color = Cesium.defaultValue(options.color, Cesium.Color.fromCssColorString("#00ffff"));
    _this._show = Cesium.defaultValue(options.show, true);
    _this._distanceDisplayCondition = Cesium.defaultValue(options.distanceDisplayCondition, new Cesium.DistanceDisplayConditionGeometryInstanceAttribute());

    var radius = Cesium.defaultValue(options.radius, 100);

    _this.topRadius = radius / 100.0;
    _this.topRadius = _this.topRadius > 1.0 ? 1.0 : _this.topRadius;
    _this.inner_controlPoints = getCirclePosition(_this.position, radius * 0.7);
    _this.outer_controlPoints = getCirclePosition(_this.position, radius); //计算底部外圈
    _this.circular_clone_topPoints = getCirclePosition(_this.position, _this.topRadius); //计算顶部
    _this.circlePoints_2 = getCirclePosition(_this.position, radius * 2); //计算顶部

    _this.primitive1 = null; //外圈
    _this.primitive2 = null; //内圈
    _this.primitive3 = null; //底部圆
    _this.primitive4 = null; //底部放大钰圆环

    _this.ringCanvas = _this.drawRingCanvas();
    _this.gradientCircleCanvas = _this.cirdrawGradientCircleCanvas();

    //兼容直接传入单击回调方法，适合简单场景下使用。
    if (options.click) {
      _this.on(_DasClass2.eventType.click, options.click);
    }

    _this.draw();
    return _this;
  }

  //========== 对外属性 ==========


  _createClass(ConeGlow, [{
    key: "draw",


    //========== 方法 ==========

    value: function draw() {
      var _this2 = this;

      this.getParticleImage(function () {
        _this2.addOuter(); //外圈
      });

      this.addInner(); //内圈
      this.addCircle(); //底部圆
      this.addRing(); //底部放大钰圆环
    }

    //添加绘制外圈粒子效果

  }, {
    key: "addOuter",
    value: function addOuter() {
      var side_instances = createCylinderInstance(this.outer_controlPoints, this.circular_clone_topPoints, {
        height: this.extrudedHeight,
        distanceDisplayCondition: this._distanceDisplayCondition
      });
      this.primitive1 = new Cesium.Primitive({
        geometryInstances: side_instances,
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                u_color: this.u_color,
                image: this.image
              },
              source: _ConeGlowCircleOuterMaterial2.default
            }
          })
        }),
        asynchronous: false
      });
      this.primitive1.tooltip = this.options.tooltip;
      this.primitive1.popup = this.options.popup;
      this.primitive1.eventTarget = this;
      this.viewer.scene.primitives.add(this.primitive1);
    }

    //添加绘制内圈圆柱闪烁效果

  }, {
    key: "addInner",
    value: function addInner() {
      var side_instances = createCylinderInstance(this.inner_controlPoints, this.circular_clone_topPoints, {
        height: this.extrudedHeight,
        color: this.v_color,
        distanceDisplayCondition: this._distanceDisplayCondition
      });
      var a = new Cesium.EllipsoidSurfaceAppearance({
        material: new Cesium.Material({
          //translucent:false,
          fabric: {
            uniforms: {
              u_color: this.u_color
            },
            source: _ConeGlowCylinderGaussMaterial2.default
          }
        })
      });
      this.primitive2 = new Cesium.Primitive({
        geometryInstances: side_instances,
        appearance: a,
        asynchronous: false
      });
      this.primitive2.tooltip = this.options.tooltip;
      this.primitive2.popup = this.options.popup;
      this.primitive2.eventTarget = this;
      this.primitive2.show = this._show;
      this.viewer.scene.primitives.add(this.primitive2);
    }

    //绘制底部圆

  }, {
    key: "addCircle",
    value: function addCircle() {
      var carto = Cesium.Cartographic.fromCartesian(this.position);
      var instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: carto.height >= 1,
        distanceDisplayCondition: this._distanceDisplayCondition
      });
      this.primitive3 = new Cesium.Primitive({
        geometryInstances: instance,
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                u_color: this.u_color,
                image: this.gradientCircleCanvas
              },
              source: _ConeGlowGradientMaterial2.default
            }
          })
        }),
        asynchronous: false
      });

      this.primitive3.tooltip = this.options.tooltip;
      this.primitive3.popup = this.options.popup;
      this.primitive3.eventTarget = this;
      this.primitive3.show = this._show;
      this.viewer.scene.primitives.add(this.primitive3);
    }

    //添加绘制底部扩散圆环

  }, {
    key: "addRing",
    value: function addRing() {
      var carto = Cesium.Cartographic.fromCartesian(this.position);
      var instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: carto.height >= 1,
        distanceDisplayCondition: this._distanceDisplayCondition
      });
      this.primitive4 = new Cesium.Primitive({
        geometryInstances: instance,
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                u_color: this.u_color,
                image: this.ringCanvas
              },
              source: _ConeGlowRingScanMaterial2.default
            }
          })
        }),
        asynchronous: false
      });

      this.primitive4.tooltip = this.options.tooltip;
      this.primitive4.popup = this.options.popup;
      this.primitive4.eventTarget = this;
      this.primitive4.show = this._show;
      this.viewer.scene.primitives.add(this.primitive4);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.primitive1) {
        this.viewer.scene.primitives.remove(this.primitive1);
      }
      if (this.primitive2) {
        this.viewer.scene.primitives.remove(this.primitive2);
      }
      if (this.primitive3) {
        this.viewer.scene.primitives.remove(this.primitive3);
      }
      if (this.primitive4) {
        this.viewer.scene.primitives.remove(this.primitive4);
      }
      _get(ConeGlow.prototype.__proto__ || Object.getPrototypeOf(ConeGlow.prototype), "destroy", this).call(this);
    }

    //================材质贴图Canvas ====================
    //画粒子图

  }, {
    key: "getParticleImage",
    value: function getParticleImage(callback) {
      var image = new Image();
      image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";
      image.onload = function () {
        this.image = this.drawCanvas(image);
        if (callback) callback();
      }.bind(this);
    }
  }, {
    key: "drawCanvas",
    value: function drawCanvas(image) {
      var canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 256;
      var ctx = canvas.getContext("2d");

      ctx.clearRect(0, 0, 64, 256);
      ctx.drawImage(image, 0, 0);
      ctx.drawImage(image, 33, 0);
      return canvas;
    }

    //画圆环图

  }, {
    key: "drawRingCanvas",
    value: function drawRingCanvas() {
      var canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      var ctx = canvas.getContext("2d");

      //ctx.clearRect(0,0,512,512);
      ctx.fillStyle = "rgba(255,255,255,0)";
      ctx.strokeStyle = "rgba(255, 255, 255,255)";
      ctx.setLineDash([50, 50]);
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.arc(256, 256, 150, 0, Math.PI * 2, true);
      ctx.stroke();
      ctx.restore();
      return canvas;
    }

    //画渐变圆

  }, {
    key: "cirdrawGradientCircleCanvas",
    value: function cirdrawGradientCircleCanvas() {
      var canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      var ctx = canvas.getContext("2d");

      var gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      gradient.addColorStop(0.1, "rgba(255, 255, 255, 1.0)");
      gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.3, "rgba(255, 255, 255, 0.9)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.9, "rgba(255, 255, 255, 0.2)");
      gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");

      ctx.clearRect(0, 0, 512, 512);
      ctx.beginPath();
      ctx.arc(256, 256, 256, 0, Math.PI * 2, true);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();

      return canvas;
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(value) {
      this._show = value;

      if (this.primitive1) {
        this.primitive1.show = value;
      }
      if (this.primitive2) {
        this.primitive2.show = value;
      }
      if (this.primitive3) {
        this.primitive3.show = value;
      }
      if (this.primitive4) {
        this.primitive4.show = value;
      }
    }
  }, {
    key: "popup",
    get: function get() {
      return this.options.popup;
    },
    set: function set(value) {
      this.options.popup = value;

      if (this.primitive1) {
        this.primitive1.popup = value;
      }
      if (this.primitive2) {
        this.primitive2.popup = value;
      }
      if (this.primitive3) {
        this.primitive3.popup = value;
      }
      if (this.primitive4) {
        this.primitive4.popup = value;
      }
    }
  }, {
    key: "tooltip",
    get: function get() {
      return this.options.tooltip;
    },
    set: function set(value) {
      this.options.tooltip = value;

      if (this.primitive1) {
        this.primitive1.tooltip = value;
      }
      if (this.primitive2) {
        this.primitive2.tooltip = value;
      }
      if (this.primitive3) {
        this.primitive3.tooltip = value;
      }
      if (this.primitive4) {
        this.primitive4.tooltip = value;
      }
    }
  }]);

  return ConeGlow;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


ConeGlow.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

//创建 圆 效果
function createCircleInstance(pos, options) {
  var polygon = new Cesium.PolygonGeometry({
    polygonHierarchy: new Cesium.PolygonHierarchy(pos),
    perPositionHeight: options.perPositionHeight
  });
  return new Cesium.GeometryInstance({
    geometry: polygon,
    attributes: {
      distanceDisplayCondition: options.distanceDisplayCondition
    }
  });
}

//创建 圆锥柱体 效果
function createCylinderInstance(pts, topPts, options) {
  var height = options.height,
      color = options.color || new Cesium.Color(0.5, 0.8, 1.0, 2);

  var newpts = pts.slice();

  var length = pts.length;
  var len_2 = 2 * length;
  var sts = [];
  var st_interval = 1.0 / (length - 1);
  var define_indices = [];

  var ep = [];
  for (var i = 0; i < length; i++) {
    ep.push((0, _point.addPositionsHeight)(topPts[i], height));
    sts.push(i * st_interval);
    sts.push(0);

    var i_1 = i + 1;
    var i_11 = (i + 1) % length;
    var len_2_i_1 = len_2 - i_1;
    define_indices.push.apply(define_indices, [len_2_i_1 - 1, len_2_i_1, i]); //用materialAppearance贴纹理正确
    define_indices.push.apply(define_indices, [i, i_11, len_2_i_1 - 1]);
  }

  for (var _i = 0; _i < ep.length; _i++) {
    newpts.push(ep[length - _i - 1]);

    sts.push(1 - _i * st_interval);
    sts.push(1);
  }

  var polygon = new Cesium.PolygonGeometry({
    polygonHierarchy: new Cesium.PolygonHierarchy(newpts),
    perPositionHeight: true
  });
  polygon = Cesium.PolygonGeometry.createGeometry(polygon);
  polygon.indices = define_indices;
  polygon.attributes.st.values = sts;

  return new Cesium.GeometryInstance({
    geometry: polygon,
    attributes: {
      color: Cesium.ColorGeometryInstanceAttribute.fromColor(color),
      distanceDisplayCondition: options.distanceDisplayCondition
    }
  });
}

//计算圆坐标
function getCirclePosition(center, radius) {
  var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120;

  var res = [];
  var mm = Cesium.Transforms.eastNorthUpToFixedFrame(center);

  var interval = 2 * Math.PI / length;
  var startPos = 2 * Math.PI * 270 / 360;

  for (var i = 0; i < length; i++) {
    var a = startPos - interval * i;
    var p = new Cesium.Cartesian3(Math.sin(a) * radius, Math.cos(a) * radius, 0);
    res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
  }
  res.push(res[0]);

  return res;
}

/***/ }),
/* 235 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}"

/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float powerRatio = 1./(fract(czm_frameNumber / 30.0) +  1.) ;\n    float alpha = pow(1. - st.t,powerRatio);\n    vec4 color = vec4(u_color.rgb, alpha*u_color.a);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}"

/***/ }),
/* 237 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n    float param = 1. - step(length, 0.6);//大于0.6模糊，rate = 0.6\n    float scale = param * length;// 0.6< length 返回0，反之返回1.\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length 返回0，反之返回1.\n\n    float param1 = step(length, 0.7);//小于0.5模糊\n    float scale1 = param1 * length;// 0.6< length 返回0，反之返回1.\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length 返回0，反之返回1.\n\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}"

/***/ }),
/* 238 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;//扫描速度1度\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);//color.r = 0 或1\n    return material;\n}"

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DiffuseWallGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _polygon = __webpack_require__(10);

var _DiffuseWallGlowVS = __webpack_require__(240);

var _DiffuseWallGlowVS2 = _interopRequireDefault(_DiffuseWallGlowVS);

var _DiffuseWallGlowFS = __webpack_require__(241);

var _DiffuseWallGlowFS2 = _interopRequireDefault(_DiffuseWallGlowFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//立体面(或圆)散射效果
var DiffuseWallGlow = exports.DiffuseWallGlow = function (_DasClass) {
  _inherits(DiffuseWallGlow, _DasClass);

  function DiffuseWallGlow(viewer, options) {
    _classCallCheck(this, DiffuseWallGlow);

    var _this = _possibleConstructorReturn(this, (DiffuseWallGlow.__proto__ || Object.getPrototypeOf(DiffuseWallGlow)).call(this, options));

    _this.viewer = viewer;
    _this.options = options;

    if (options.positions) {
      //多边形时
      _this.center = (0, _point.centerOfMass)(options.positions);
      _this.positions = options.positions;
    } else {
      //圆形时
      _this.center = options.position;
      _this.positions = (0, _polygon.getEllipseOuterPositions)({
        position: options.position,
        radius: Cesium.defaultValue(options.radius, 100), //半径
        count: Cesium.defaultValue(options.count, 50) //共返回(count*4)个点
      });
    }

    _this.translucent = Cesium.defaultValue(options.translucent, true);
    _this.height = Cesium.defaultValue(options.height, 1000);
    _this.direction = Cesium.defaultValue(options.direction, -1);
    _this.color = Cesium.defaultValue(options.color, new Cesium.Color(0.5, 0.8, 1));
    _this._show = Cesium.defaultValue(options.show, true);

    //缩放参数
    _this.speed = Cesium.defaultValue(options.speed, 1000);
    _this.mScale = Cesium.Matrix4.fromUniformScale(1.0);
    _this.xyScale = 2;
    // this.modelMatrix = Cesium.Matrix4.fromUniformScale(1.0);

    _this.draw();
    return _this;
  }

  //========== 对外属性 ==========


  _createClass(DiffuseWallGlow, [{
    key: "draw",


    //========== 方法 ==========
    value: function draw() {
      var cps = this.positions;
      var up = (0, _point.addPositionsHeight)(this.positions, this.height);

      //计算位置
      var pos = []; //坐标
      var sts = []; //纹理
      var indices = []; //索引
      var normal = []; //法向量
      for (var i = 0, count = cps.length; i < count; i++) {
        var ni = (i + 1) % count;
        pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
        pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
        pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);

        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);

        sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

        var ii = i * 4;
        var i1 = ii + 1;
        var i2 = ii + 2;
        var i3 = ii + 3;
        indices.push.apply(indices, [i2, i3, ii, ii, i1, i2]);
      }

      var positions = new Float64Array(pos);
      var gi = new Cesium.GeometryInstance({
        geometry: new Cesium.Geometry({
          attributes: {
            position: new Cesium.GeometryAttribute({
              // 使用double类型的position进行计算
              componentDatatype: Cesium.ComponentDatatype.DOUBLE,
              //componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new Cesium.GeometryAttribute({
              componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new Cesium.GeometryAttribute({
              componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: Cesium.PrimitiveType.TRIANGLES,
          boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
        })
      });
      this.primitive = new Cesium.Primitive({
        geometryInstances: gi,
        appearance: new Cesium.MaterialAppearance({
          material: new Cesium.Material({
            translucent: this.translucent,
            fabric: {
              uniforms: {
                u_color: this.color
              },
              source: this.getShader(this.translucent)
            }
          }),
          vertexShaderSource: _DiffuseWallGlowVS2.default,
          fragmentShaderSource: _DiffuseWallGlowFS2.default
        }),
        asynchronous: false
      });
      this.primitive.show = this._show;
      this.primitive.eventTarget = this;
      this.primitive.popup = this.options.popup;
      this.primitive.tooltip = this.options.tooltip;

      this.viewer.scene.primitives.add(this.primitive);

      this.viewer.scene.primitives.add(this);
    }
  }, {
    key: "update",
    value: function update(fs) {
      if (this.primitive && this._show) {
        var time = fs.frameNumber / this.speed;
        var tt = time - Math.floor(time);

        tt = tt < 0.01 ? 0.01 : tt;
        this.mScale[0] = this.mScale[5] = tt * this.xyScale;
        this.mScale[10] = 1.1 - tt;
        this.primitive.modelMatrix = scaleXYZ(this.center, this.mScale);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.primitives.remove(this);
      if (!this.viewer) return;

      if (this.primitive) {
        this.viewer.scene.primitives.remove(this.primitive);
        delete this.primitive;
      }

      for (var i in this) {
        delete this[i];
      }
    }

    //片源着色器

  }, {
    key: "getShader",
    value: function getShader(t) {
      var fs = "uniform vec4 u_color;\n" + "    vec4 xh_getMaterial(vec2 st){" + "    float alpha = pow(1. - st.t, 4.);\n";
      if (t) {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, alpha);";
      } else {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, 1.);";
      }
      fs += "    return color;\n" + "}\n";
      return fs;
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(value) {
      this._show = value;

      if (this.primitive) {
        this.primitive.show = value;
      }
    }
  }]);

  return DiffuseWallGlow;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


DiffuseWallGlow.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

function scaleXYZ(point, mScale) {
  var m = Cesium.Transforms.eastNorthUpToFixedFrame(point);
  var inverse = Cesium.Matrix4.inverse(m, new Cesium.Matrix4());

  var tt = Cesium.Matrix4.multiply(mScale, inverse, new Cesium.Matrix4());
  return Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4());
}

/***/ }),
/* 240 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"

/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main(){\n    gl_FragColor = xh_getMaterial(v_st);\n}"

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollWallGlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _point = __webpack_require__(2);

var _ScrollWallGlowVS = __webpack_require__(243);

var _ScrollWallGlowVS2 = _interopRequireDefault(_ScrollWallGlowVS);

var _ScrollWallGlowFS = __webpack_require__(244);

var _ScrollWallGlowFS2 = _interopRequireDefault(_ScrollWallGlowFS);

var _ScrollWallGlowMaterial = __webpack_require__(245);

var _ScrollWallGlowMaterial2 = _interopRequireDefault(_ScrollWallGlowMaterial);

var _ScrollWallGlowMaterial3 = __webpack_require__(246);

var _ScrollWallGlowMaterial4 = _interopRequireDefault(_ScrollWallGlowMaterial3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//走马灯围墙效果
var ScrollWallGlow = exports.ScrollWallGlow = function (_DasClass) {
  _inherits(ScrollWallGlow, _DasClass);

  function ScrollWallGlow(viewer, options) {
    _classCallCheck(this, ScrollWallGlow);

    var _this = _possibleConstructorReturn(this, (ScrollWallGlow.__proto__ || Object.getPrototypeOf(ScrollWallGlow)).call(this, options));

    _this.viewer = viewer;
    _this.options = options;

    _this.positions = options.positions;

    _this.height = Cesium.defaultValue(options.height, 500);
    _this.style = Cesium.defaultValue(options.style, 1);
    _this.color = Cesium.defaultValue(options.color, Cesium.Color.YELLOW);
    _this.speed = Cesium.defaultValue(options.speed, 600);
    _this.direction = Cesium.defaultValue(options.direction, -1); //方向：1往上、-1往下
    _this._show = Cesium.defaultValue(options.show, true);
    _this._transparent = Cesium.defaultValue(options.transparent, true);

    _this.draw();
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(ScrollWallGlow, [{
    key: "draw",


    //========== 方法 ==========
    value: function draw() {
      var cps = this.positions;
      var up = (0, _point.addPositionsHeight)(cps, this.height);

      //计算位置
      var pos = []; //坐标
      var sts = []; //纹理
      var indices = []; //索引
      var normal = []; //法向量

      for (var i = 0, len = cps.length; i < len; i++) {
        var ni = i + 1;
        if (ni == len) ni = 0;

        pos.push.apply(pos, [cps[i].x, cps[i].y, cps[i].z]);
        pos.push.apply(pos, [cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push.apply(pos, [up[ni].x, up[ni].y, up[ni].z]);
        pos.push.apply(pos, [up[i].x, up[i].y, up[i].z]);

        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);
        normal.push.apply(normal, [0, 0, 1]);

        sts.push.apply(sts, [0, 0, 1, 0, 1, 1, 0, 1]); //四个点的纹理一次存入

        var ii = i * 4;
        var i1 = ii + 1;
        var i2 = ii + 2;
        var i3 = ii + 3;
        indices.push.apply(indices, [ii, i1, i2, i2, i3, ii]);
      }

      var positions = new Float64Array(pos);
      var gi = new Cesium.GeometryInstance({
        geometry: new Cesium.Geometry({
          attributes: {
            position: new Cesium.GeometryAttribute({
              // 使用double类型的position进行计算
              componentDatatype: Cesium.ComponentDatatype.DOUBLE,
              //componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new Cesium.GeometryAttribute({
              componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new Cesium.GeometryAttribute({
              componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: Cesium.PrimitiveType.TRIANGLES,
          boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
        })
      });

      this.primitive = new Cesium.Primitive({
        geometryInstances: gi,
        appearance: new Cesium.MaterialAppearance({
          material: new Cesium.Material({
            translucent: this._transparent,
            fabric: {
              uniforms: {
                u_color: this.color,
                speed: this.speed,
                direction: this.direction
              },
              source: this.createShader()
            }
          }),
          vertexShaderSource: _ScrollWallGlowVS2.default,
          fragmentShaderSource: _ScrollWallGlowFS2.default
        }),
        asynchronous: false
      });
      this.primitive.show = this._show;
      this.primitive.eventTarget = this;
      this.primitive.popup = this.options.popup;
      this.primitive.tooltip = this.options.tooltip;

      this.viewer.scene.primitives.add(this.primitive);
    }
  }, {
    key: "createShader",
    value: function createShader() {
      if (this.style === 1) {
        return _ScrollWallGlowMaterial2.default;
      } else {
        return _ScrollWallGlowMaterial4.default;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.primitive) {
        this.viewer.scene.primitives.remove(this.primitive);
        delete this.primitive;
      }

      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(value) {
      this._show = value;

      if (this.primitive) {
        this.primitive.show = value;
      }
    }
  }]);

  return ScrollWallGlow;
}(_DasClass2.DasClass);

/***/ }),
/* 243 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\nvoid main()\n{\n    vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n    v_normalEC = czm_normal * normal;\n    v_st=st;\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}"

/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}"

/***/ }),
/* 245 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n    czm_material material = czm_getDefaultMaterial(cmi);\n    vec2 st = cmi.st;\n    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(st.s,fract(st.t - t));\n    vec4 color = vec4(0.,0.,0.,0.);\n    float tt = 0.5 - abs(0.5 - st1.t);\n    float ss = st1.s ;\n    float alpha = tt * 2.;\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}"

/***/ }),
/* 246 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n    czm_material material = czm_getDefaultMaterial(cmi);\n    vec2 st = cmi.st;\n    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(fract(st.s - t),st.t);\n    vec4 color = vec4(0.,0.,0.,0.);\n    float alpha = 1.-st.t;\n    float value = fract(st1.s/0.25);\n    alpha *= sin(value * 3.1415926);\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}"

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FogEffect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Fog = __webpack_require__(248);

var _Fog2 = _interopRequireDefault(_Fog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 场景雾效果
//原理：根据深度图的深度值，对片元进行不同程度的模糊
var FogEffect = exports.FogEffect = function () {
  //========== 构造方法 ==========
  function FogEffect(options) {
    _classCallCheck(this, FogEffect);

    this.viewer = options.viewer;

    this.fogByDistance = Cesium.defaultValue(options.fogByDistance, new Cesium.Cartesian4(10, 0.0, 1000, 0.9)); //雾强度
    this.color = Cesium.defaultValue(options.color, Cesium.Color.WHITE); //雾颜色

    this._show = Cesium.defaultValue(options.show, true);
    this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);

    this.init();
  }

  //========== 对外属性 ==========
  //是否开启效果


  _createClass(FogEffect, [{
    key: "init",


    //========== 方法 ==========

    value: function init() {
      var that = this;

      this.FogStage = new Cesium.PostProcessStage({
        fragmentShader: _Fog2.default,
        uniforms: {
          fogByDistance: function fogByDistance() {
            return that.fogByDistance;
          },
          fogColor: function fogColor() {
            return that.color;
          }
        },
        enabled: this._show
      });
      this.viewer.scene.postProcessStages.add(this.FogStage);

      //加控制，只在相机高度低于一定高度时才开启本效果
      this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }
  }, {
    key: "camera_changedHandler",
    value: function camera_changedHandler(event) {
      if (this.viewer.camera.positionCartographic.height < this._maxHeight) {
        this.FogStage.enabled = this._show;
      } else {
        this.FogStage.enabled = false;
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
      this.viewer.scene.postProcessStages.remove(this.FogStage);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = Boolean(val);
      this.FogStage.enabled = this._show;
    }
  }]);

  return FogEffect;
}();

/***/ }),
/* 248 */
/***/ (function(module, exports) {

module.exports = "float getDistance(sampler2D depthTexture, vec2 texCoords) \r\n{ \r\n    float depth = czm_unpackDepth(texture2D(depthTexture, texCoords)); \r\n    if (depth == 0.0) { \r\n        return czm_infinity; \r\n    } \r\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth); \r\n    return -eyeCoordinate.z / eyeCoordinate.w; \r\n} \r\nfloat interpolateByDistance(vec4 nearFarScalar, float distance) \r\n{ \r\n    float startDistance = nearFarScalar.x; \r\n    float startValue = nearFarScalar.y; \r\n    float endDistance = nearFarScalar.z; \r\n    float endValue = nearFarScalar.w; \r\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); \r\n    return mix(startValue, endValue, t); \r\n} \r\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) \r\n{ \r\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); \r\n} \r\nuniform sampler2D colorTexture; \r\nuniform sampler2D depthTexture; \r\nuniform vec4 fogByDistance; \r\nuniform vec4 fogColor; \r\nvarying vec2 v_textureCoordinates; \r\nvoid main(void) \r\n{ \r\n    float distance = getDistance(depthTexture, v_textureCoordinates); \r\n    vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates); \r\n    float blendAmount = interpolateByDistance(fogByDistance, distance); \r\n    vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount); \r\n    gl_FragColor = alphaBlend(finalFogColor, sceneColor); \r\n} "

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InvertedScene = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _InvertedScene = __webpack_require__(250);

var _InvertedScene2 = _interopRequireDefault(_InvertedScene);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//后处理实现倒影
//原理：利用空间镜面反射技术，计算倒影射线的UV进行采样
var InvertedScene = exports.InvertedScene = function () {
  //========== 构造方法 ==========

  function InvertedScene(options) {
    _classCallCheck(this, InvertedScene);

    this.viewer = options.viewer;
    this._show = Cesium.defaultValue(options.show, true);

    this.init();
  }

  //========== 对外属性 ==========

  //是否开启效果


  _createClass(InvertedScene, [{
    key: "init",


    //========== 方法 ==========

    value: function init() {
      this.postStage = new Cesium.PostProcessStage({
        name: "InvertedScene",
        fragmentShader: _InvertedScene2.default
      });
      this.postStage.enabled = this._show;
      this.viewer.scene.postProcessStages.add(this.postStage);
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.postProcessStages.remove(this.postStage);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = Boolean(val);
      this.postStage.enabled = this._show;
    }
  }]);

  return InvertedScene;
}();

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvec3 guussColor(vec2 uv){\r\n    vec2 pixelSize = 1.0 / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n    vec4 gc = (\r\n        texture2D(colorTexture, uv)+\r\n        texture2D(colorTexture, uv + vec2(dx0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy1))\r\n    ) * (1.0 / 9.0);\r\n    return gc.rgb;\r\n}\r\nvoid main(){\r\n    // mat4 dither = mat4(\r\n    //     0,       0.5,    0.125,  0.625,\r\n    //     0.75,    0.25,   0.875,  0.375,\r\n    //     0.1875,  0.6875, 0.0625, 0.5625,\r\n    //     0.9375,  0.4375, 0.8125, 0.3125\r\n    // );\r\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\r\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\r\n    float offset = 0.0;\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n\r\n    \r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * normal);\r\n    float fotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(fotNumWC<=0.5){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\r\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\r\n    // return;\r\n\r\n    vec3 viewDir = normalize(positionEC.xyz);\r\n    vec3 reflectDir = reflect(viewDir, normal);\r\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\r\n    vec3 viewReflectDir = reflectDir;\r\n\r\n    \r\n    float step = 0.05;\r\n    int stepNum = int(20.0 / step);\r\n    vec3 pos;\r\n    vec3 albedo;\r\n    bool jd = false;\r\n    for(int i = 1;i <= 400;i++)\r\n    {\r\n        float delta = step * float(i) + offset;\r\n        pos = positionEC.xyz + viewReflectDir * delta;\r\n        float d = -pos.z;\r\n\r\n        vec4 tmp = czm_projection * vec4(pos,1.0);\r\n        vec3 screenPos = tmp.xyz / tmp.w;\r\n        vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\r\n        \r\n        if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\r\n            float dd = getDepth(texture2D(depthTexture, uv));\r\n            vec4 jzc = toEye(uv, dd);\r\n            dd = -jzc.z;\r\n            if(d>dd){\r\n                if(abs(abs(d) - abs(dd)) <=step){\r\n                    jd = true;\r\n                    // albedo = texture2D(colorTexture, uv).rgb;\r\n                    albedo = guussColor(uv);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if(jd){\r\n        gl_FragColor = vec4(mix(color.xyz,albedo,0.5),1.0);\r\n    }else{\r\n        gl_FragColor = color;\r\n    }\r\n}"

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnowCover = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _SnowCover = __webpack_require__(252);

var _SnowCover2 = _interopRequireDefault(_SnowCover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 雪覆盖 效果
//原理：法线越垂直与地面越白
var SnowCover = exports.SnowCover = function () {
  //========== 构造方法 ==========

  function SnowCover(options) {
    _classCallCheck(this, SnowCover);

    this.viewer = options.viewer;

    this.alpha = Cesium.defaultValue(options.alpha, 1.0); //覆盖强度  0-1
    this._show = Cesium.defaultValue(options.show, true);
    this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);

    this.init();
  }

  //========== 对外属性 ==========
  //是否开启效果


  _createClass(SnowCover, [{
    key: "init",


    //========== 方法 ==========

    value: function init() {
      var that = this;
      this.postStage = new Cesium.PostProcessStage({
        name: "SnowCover",
        fragmentShader: _SnowCover2.default,
        uniforms: {
          alpha: function alpha() {
            return that.alpha;
          }
        }
      });
      this.postStage.enabled = this._show;
      this.viewer.scene.postProcessStages.add(this.postStage);

      //加控制，只在相机高度低于一定高度时才开启本效果
      this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }
  }, {
    key: "camera_changedHandler",
    value: function camera_changedHandler(event) {
      if (this.viewer.camera.positionCartographic.height < this._maxHeight) {
        this.postStage.enabled = this._show;
      } else {
        this.postStage.enabled = false;
      }
    }

    //销毁

  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
      this.viewer.scene.postProcessStages.remove(this.postStage);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    },
    set: function set(val) {
      this._show = Boolean(val);
      this.postStage.enabled = this._show;
    }
  }]);

  return SnowCover;
}();

/***/ }),
/* 252 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float alpha;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvoid main(){\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 nor = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\r\n    float dotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(dotNumWC<=0.3){\r\n        gl_FragColor = mix(color,vec4(1.0),alpha*0.3);\r\n        return;\r\n    }\r\n    gl_FragColor = mix(color,vec4(1.0),dotNumWC*alpha);\r\n}"

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColorCorrection = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _EffectCollection = __webpack_require__(91);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //颜色校正
//关于这些值的示例可参考https://www.freesion.com/article/96731097085/


var ColorCorrection = exports.ColorCorrection = function (_DasClass) {
    _inherits(ColorCorrection, _DasClass);

    function ColorCorrection(options, oldparam) {
        _classCallCheck(this, ColorCorrection);

        //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
        var _this = _possibleConstructorReturn(this, (ColorCorrection.__proto__ || Object.getPrototypeOf(ColorCorrection)).call(this, options));

        if (options instanceof Cesium.Viewer) {
            options = _extends({
                viewer: options
            }, oldparam);
        }
        //兼容v2.2之前旧版本处理,非升级用户可删除上面代码
        options.viewer.effects || (options.viewer.effects = new _EffectCollection.EffectCollection(options));
        _this._viewer = Cesium.defaultValue(options.viewer, viewer);
        _this._viewer.clock.shouldAnimate = true;
        _this._isBrightness = Cesium.defaultValue(options.isBrightness, void 0);
        _this._enabled = Cesium.defaultValue(options.enabled, _this._isBrightness);
        _this._enabled = Cesium.defaultValue(_this._enabled, true);
        _this._brightness = Cesium.defaultValue(options.brightness, 0.4);
        _this._contrast = Cesium.defaultValue(options.contrast, 0.4);
        _this._saturation = Cesium.defaultValue(options.saturation, 0.4);
        _this._hue = Cesium.defaultValue(options.hue, 0.4);
        _this._gamma = Cesium.defaultValue(options.gamma, 0.4);
        _this.initialize();
        return _this;
    }

    _createClass(ColorCorrection, [{
        key: "initialize",
        value: function initialize() {
            this._postProcessStage = new Cesium.PostProcessStage({
                fragmentShader: "\n        uniform sampler2D colorTexture;\n        uniform float u_brightness;\n        uniform float u_contrast;\n        uniform float u_saturation;\n        uniform float u_hue;\n        uniform float u_gamma;\n        \n        varying vec2 v_textureCoordinates;\n        \n        void main(void)\n        {\n            gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n            gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, u_brightness);\n            gl_FragColor.rgb = mix(vec3(0.5), gl_FragColor.rgb, u_contrast);\n            gl_FragColor.rgb = czm_hue(gl_FragColor.rgb, u_hue);\n            gl_FragColor.rgb = czm_saturation(gl_FragColor.rgb, u_saturation);\n            // gamma\n            //input\n            //float3 diffuseCol = pow(tex2D( diffTex, texCoord ), 2.2 );  \n            //output\n            //fragColor.rgb = pow(fragColor.rgb, 1.0/2.2);\n        }\n        ",
                uniforms: {
                    u_brightness: this._brightness,
                    u_contrast: this._contrast,
                    u_saturation: this._saturation,
                    u_hue: this._hue,
                    u_gamma: this._gamma
                }
            });
            this._postProcessStage.enabled = this._enabled;
        }
    }, {
        key: "_update",
        value: function _update() {
            this._postProcessStage.enabled = this._isBrightness, this._postProcessStage.enabled = Cesium.defaultValue(this._enabled, this._isBrightness), this._postProcessStage.uniforms.u_brightness = this._brightness, this._postProcessStage.uniforms.u_contrast = this._contrast, this._postProcessStage.uniforms.u_saturation = this._saturation, this._postProcessStage.uniforms.u_hue = this._hue, this._postProcessStage.uniforms.u_gamma = this._gamma;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this._postProcessStage) {
                this._postProcessStage.destroy();
                Cesium.destroyObject(this);
            }
        }
    }, {
        key: "_add",
        value: function _add() {
            return this._viewer.scene.postProcessStages.add(this._postProcessStage);
        }
    }, {
        key: "_remove",
        value: function _remove() {
            return this._viewer.scene.postProcessStages.remove(this._postProcessStage);
        }
    }, {
        key: "pause",
        value: function pause() {
            this.enabled = false;
        }
    }, {
        key: "resume",
        value: function resume() {
            this.enabled = true;
        }
        //暴露的方法

    }, {
        key: "viewer",
        get: function get() {
            return this._viewer;
        },
        set: function set(val) {
            this._viewer = val;
        }
        //是否可以修改亮度

    }, {
        key: "isBrightness",
        get: function get() {
            return this._isBrightness;
        },
        set: function set(val) {
            this._isBrightness = val;
            this._enabled = this._isBrightness;
            this._update();
        }

        //是否启用后处理

    }, {
        key: "enabled",
        get: function get() {
            return this._postProcessStage.enabled;
        },
        set: function set(val) {
            this._viewer = val;
        }

        //亮度

    }, {
        key: "brightness",
        get: function get() {
            return this._brightness;
        },
        set: function set(val) {
            this._brightness = Number(val);
            this._update();
        }

        //对比度

    }, {
        key: "contrast",
        get: function get() {
            return this._contrast;
        },
        set: function set(val) {
            this._contrast = Number(val);
            this._update();
        }

        //饱和度

    }, {
        key: "saturation",
        get: function get() {
            return this._saturation;
        },
        set: function set(val) {
            this._saturation = Number(val);
            this._update();
        }

        //色调

    }, {
        key: "hue",
        get: function get() {
            return this._hue;
        },
        set: function set(val) {
            this._hue = Number(val);
            this._update();
        }

        //伽马值

    }, {
        key: "gamma",
        get: function get() {
            return this._gamma;
        },
        set: function set(val) {
            this._gamma = Number(val);
            this._update();
        }
    }]);

    return ColorCorrection;
}(_DasClass2.DasClass);

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivMask = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DivMask = exports.DivMask = function (_DasClass) {
  _inherits(DivMask, _DasClass);

  function DivMask(options, oldparam) {
    _classCallCheck(this, DivMask);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (DivMask.__proto__ || Object.getPrototypeOf(DivMask)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    _this._viewer = Cesium.defaultValue(options.viewer, viewer);
    _this._color = Cesium.defaultValue(options.color, "#000000");
    _this._zIndex = Cesium.defaultValue(options.zIndex, 9999);
    _this.id = Cesium.defaultValue(options.id, "DasDivMask");
    _this.initialize();
    return _this;
  }

  _createClass(DivMask, [{
    key: "initialize",
    value: function initialize() {
      var basePanel = viewer._element.parentElement;
      var DivMask_Div = $("<div>");
      DivMask_Div.addClass(this.id);
      DivMask_Div.attr("id", this.id);
      DivMask_Div.css({
        'zIndex': this._zIndex,
        'position': 'absolute',
        'left': '0px',
        'top': '0px',
        'width': '100%',
        'height': '100%',
        'boxShadow': 'inset 1px 0px 500px 170px ' + this._color,
        'pointerEvents': 'none'
      });
      DivMask_Div.appendTo(basePanel);
    }
  }, {
    key: "remove",
    value: function remove() {
      $("." + this.id).remove();
    }
  }]);

  return DivMask;
}(_DasClass2.DasClass);

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HighlightBoundary = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//高亮边界
var HighlightBoundary = exports.HighlightBoundary = function (_DasClass) {
  _inherits(HighlightBoundary, _DasClass);

  function HighlightBoundary(options, oldparam) {
    _classCallCheck(this, HighlightBoundary);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (HighlightBoundary.__proto__ || Object.getPrototypeOf(HighlightBoundary)).call(this, options));

    if (options instanceof Cesium.Viewer) {
      options = _extends({
        viewer: options
      }, oldparam);
    }
    _this._viewer = Cesium.defaultValue(options.viewer, viewer);
    _this.feature = options.feature;
    _this.bufCount = Cesium.defaultValue(options.bufCount, 50);
    _this.bufDis = Cesium.defaultValue(options.bufDis, 20);
    _this.color = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.color, '#ffffff'));
    _this.dataSource = [];
    var multipleRingBuffer = _this.multipleRingBuffer(_this.feature, _this.bufCount, _this.bufDis);
    _this.addRegionData(multipleRingBuffer, _this.bufCount);
    return _this;
  }

  _createClass(HighlightBoundary, [{
    key: "multipleRingBuffer",
    value: function multipleRingBuffer(feature, bufCount, bufDis) {
      for (var featureList = [feature], o = 1; o <= bufCount; o++) {
        var turfBuffer = turf.buffer(feature, o * bufDis, {
          units: "meters"
        });
        turfBuffer.properties.opacity = (bufCount - o) / bufCount, featureList.push(turfBuffer);
      }
      for (var featureLength = featureList.length - 1; featureLength > 0; featureLength--) {
        var featureItem = featureList[featureLength];
        featureList[featureLength] = turf.difference(featureItem, featureList[featureLength - 1]), featureList[featureLength].properties.opt = featureItem.properties.opacity;
      }
      return featureList = featureList.slice(-(featureList.length - 1)), turf.featureCollection([].concat(featureList));
    }
  }, {
    key: "addRegionData",
    value: function addRegionData(multipleRingBuffer, bufCount) {
      var that = this;
      var alpha = 0;
      Cesium.GeoJsonDataSource.load(multipleRingBuffer).then(function (e) {
        that._viewer.dataSources.add(e);
        for (var entitiesValues = e.entities.values, r = 0; r < entitiesValues.length; r++) {
          var entitiesValue = entitiesValues[r];
          entitiesValue.polygon.outline = false;
          alpha = (bufCount - r) / bufCount * 0.8;
          entitiesValue.polygon.material = that.color.withAlpha(alpha);
          entitiesValue.alpha = alpha;
        }
        that.dataSource = e;
      }).otherwise(function (e) {});
    }
  }, {
    key: "changeBufCount",
    value: function changeBufCount(count) {
      this.remove();
      this.bufCount = count;
      var multipleRingBuffer = this.multipleRingBuffer(this.feature, this.bufCount, this.bufDis);
      this.addRegionData(multipleRingBuffer, this.bufCount);
    }
  }, {
    key: "changeBufDis",
    value: function changeBufDis(dis) {
      this.remove();
      this.bufDis = dis;
      var multipleRingBuffer = this.multipleRingBuffer(this.feature, this.bufCount, this.bufDis);
      this.addRegionData(multipleRingBuffer, this.bufCount);
    }
  }, {
    key: "changeColor",
    value: function changeColor(color) {
      this.color = Cesium.Color.fromCssColorString(color);
      for (var t = this.dataSource.entities.values, i = 0; i < t.length; i++) {
        var n = t[i];
        n.polygon.material = this.color.withAlpha(n.alpha);
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      this._viewer.dataSources.remove(this.dataSource);
    }
  }]);

  return HighlightBoundary;
}(_DasClass2.DasClass);

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Das3dWaterType = exports.PolyWoodType = exports.PolyGrassType = exports.PolyFacetType = exports.PolyBlobType = exports.PolyAsphaltType = exports.CircleWaveType = exports.CircleScanType = exports.ScanLineType = exports.ODLineType = exports.LineFlowType = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _cellular = __webpack_require__(257);

var _cellular2 = _interopRequireDefault(_cellular);

var _snoise = __webpack_require__(258);

var _snoise2 = _interopRequireDefault(_snoise);

var _LineFlowMaterial = __webpack_require__(259);

var _LineFlowMaterial2 = _interopRequireDefault(_LineFlowMaterial);

var _ODLineMaterial = __webpack_require__(260);

var _ODLineMaterial2 = _interopRequireDefault(_ODLineMaterial);

var _ScanLineMaterial = __webpack_require__(261);

var _ScanLineMaterial2 = _interopRequireDefault(_ScanLineMaterial);

var _CircleScanMaterial = __webpack_require__(262);

var _CircleScanMaterial2 = _interopRequireDefault(_CircleScanMaterial);

var _CircleWaveMaterial = __webpack_require__(263);

var _CircleWaveMaterial2 = _interopRequireDefault(_CircleWaveMaterial);

var _PolyAsphaltMaterial = __webpack_require__(264);

var _PolyAsphaltMaterial2 = _interopRequireDefault(_PolyAsphaltMaterial);

var _PolyBlobMaterial = __webpack_require__(265);

var _PolyBlobMaterial2 = _interopRequireDefault(_PolyBlobMaterial);

var _PolyFacetMaterial = __webpack_require__(266);

var _PolyFacetMaterial2 = _interopRequireDefault(_PolyFacetMaterial);

var _PolyGrassMaterial = __webpack_require__(267);

var _PolyGrassMaterial2 = _interopRequireDefault(_PolyGrassMaterial);

var _PolyWoodMaterial = __webpack_require__(268);

var _PolyWoodMaterial2 = _interopRequireDefault(_PolyWoodMaterial);

var _dasWaterMaterial = __webpack_require__(269);

var _dasWaterMaterial2 = _interopRequireDefault(_dasWaterMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

Cesium.ShaderSource._czmBuiltinsAndUniforms.czm_cellular = _cellular2.default;

Cesium.ShaderSource._czmBuiltinsAndUniforms.czm_snoise = _snoise2.default;

//线状: 流动效果 材质
var LineFlowType = exports.LineFlowType = "LineFlow";
Cesium.Material.LineFlowType = LineFlowType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.LineFlowType, {
  fabric: {
    type: Cesium.Material.LineFlowType,
    uniforms: {
      image: Cesium.Material.DefaultImageId,
      color: new Cesium.Color(1, 0, 0, 1.0),
      repeat: new Cesium.Cartesian2(1.0, 1.0),
      axisY: false,
      speed: 10.0,
      hasImage2: false,
      image2: Cesium.Material.DefaultImageId,
      color2: new Cesium.Color(1, 1, 1)
    },
    source: _LineFlowMaterial2.default
  },
  translucent: true
});

//线状: OD线效果 材质
var ODLineType = exports.ODLineType = "ODLine";
Cesium.Material.ODLineType = ODLineType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.ODLineType, {
  fabric: {
    type: Cesium.Material.ODLineType,
    uniforms: {
      color: new Cesium.Color(1.0, 1.0, 0.0, 0.7),
      startTime: 0,
      speed: 20
    },
    source: _ODLineMaterial2.default
  },
  translucent: true
});

//面状: 用于面状对象的 扫描线放大效果
var ScanLineType = exports.ScanLineType = "ScanLine";
Cesium.Material.ScanLineType = ScanLineType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.ScanLineType, {
  fabric: {
    type: Cesium.Material.ScanLineType,
    uniforms: {
      color: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
      speed: 10
    },
    source: _ScanLineMaterial2.default
  },
  translucent: true
});

//圆形: 扫描效果
var CircleScanType = exports.CircleScanType = "CircleScan";
Cesium.Material.CircleScanType = CircleScanType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleScanType, {
  fabric: {
    type: Cesium.Material.CircleScanType,
    uniforms: {
      color: new Cesium.Color(1.0, 0.0, 0.0, 1.0),
      scanImg: Cesium.Material.DefaultImageId
    },
    source: _CircleScanMaterial2.default
  },
  translucent: function translucent(material) {
    return material.uniforms.color.alpha < 1.0;
  }
});

//圆形: 扩散波纹效果
var CircleWaveType = exports.CircleWaveType = "CircleWave";
Cesium.Material.CircleWaveType = CircleWaveType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleWaveType, {
  fabric: {
    type: Cesium.Material.CircleWaveType,
    uniforms: {
      color: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
      speed: 10.0,
      count: 1.0,
      gradient: 0.1
    },
    source: _CircleWaveMaterial2.default
  },
  translucent: true
});

//面状： 柏油路面效果
var PolyAsphaltType = exports.PolyAsphaltType = "PolyAsphalt";
Cesium.Material.PolyAsphaltType = PolyAsphaltType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.PolyAsphaltType, {
  fabric: {
    type: Cesium.Material.PolyAsphaltType,
    uniforms: {
      asphaltColor: new Cesium.Color(0.15, 0.15, 0.15, 1.0),
      bumpSize: 0.02,
      roughness: 0.2
    },
    source: _PolyAsphaltMaterial2.default
  },
  translucent: function translucent(material) {
    return material.uniforms.asphaltColor.alpha < 1.0;
  }
});

//面状：混合效果
var PolyBlobType = exports.PolyBlobType = "PolyBlob";
Cesium.Material.PolyBlobType = PolyBlobType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.PolyBlobType, {
  fabric: {
    type: Cesium.Material.PolyBlobType,
    uniforms: {
      lightColor: new Cesium.Color(1.0, 1.0, 1.0, 0.5),
      darkColor: new Cesium.Color(0.0, 0.0, 1.0, 0.5),
      frequency: 10.0
    },
    source: _PolyBlobMaterial2.default
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 0.0;
  }
});

//面状：碎石面效果
var PolyFacetType = exports.PolyFacetType = "PolyFacet";
Cesium.Material.PolyFacetType = PolyFacetType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.PolyFacetType, {
  fabric: {
    type: Cesium.Material.PolyFacetType,
    uniforms: {
      lightColor: new Cesium.Color(0.25, 0.25, 0.25, 0.75),
      darkColor: new Cesium.Color(0.75, 0.75, 0.75, 0.75),
      frequency: 10.0
    },
    source: _PolyFacetMaterial2.default
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 0.0;
  }
});

//面状：草地面效果
var PolyGrassType = exports.PolyGrassType = "PolyGrass";
Cesium.Material.PolyGrassType = PolyGrassType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.PolyGrassType, {
  fabric: {
    type: Cesium.Material.PolyGrassType,
    uniforms: {
      grassColor: new Cesium.Color(0.25, 0.4, 0.1, 1.0),
      dirtColor: new Cesium.Color(0.1, 0.1, 0.1, 1.0),
      patchiness: 1.5
    },
    source: _PolyGrassMaterial2.default
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.grassColor.alpha < 1.0 || uniforms.dirtColor.alpha < 1.0;
  }
});

//面状：木材面效果
var PolyWoodType = exports.PolyWoodType = "PolyWood";
Cesium.Material.PolyWoodType = PolyWoodType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.PolyWoodType, {
  fabric: {
    type: Cesium.Material.PolyWoodType,
    uniforms: {
      lightWoodColor: new Cesium.Color(0.6, 0.3, 0.1, 1.0),
      darkWoodColor: new Cesium.Color(0.4, 0.2, 0.07, 1.0),
      ringFrequency: 3.0,
      noiseScale: new Cesium.Cartesian2(0.7, 0.5),
      grainFrequency: 27.0
    },
    source: _PolyWoodMaterial2.default
  },
  translucent: function translucent(material) {
    var uniforms = material.uniforms;
    return uniforms.lightWoodColor.alpha < 1.0 || uniforms.darkWoodColor.alpha < 1.0;
  }
});

var Das3dWaterType = exports.Das3dWaterType = "das3dWaterMaterial";
Cesium.Material.Das3dWaterType = Das3dWaterType;
Cesium.Material._materialCache.addMaterial(Cesium.Material.Das3dWaterType, {
  fabric: {
    type: "Das3dWaterType",
    uniforms: {
      color: Cesium.Color.BLUE,
      image: Cesium.DefaultImageId,
      normalMap: Cesium.Material.DefaultImageId,
      frequency: 10.0,
      animationSpeed: 0.01,
      amplitude: 1.0,
      specularIntensity: 0.5,
      fadeFactor: 1.0
    },
    source: _dasWaterMaterial2.default
  },
  translucent: function translucent(material) {
    return material.uniforms.color.alpha < 1;
  }
});

/***/ }),
/* 257 */
/***/ (function(module, exports) {

module.exports = "/**\n * @license\n * Cellular noise (\"Worley noise\") in 2D in GLSL.\n * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n * This code is released under the conditions of the MIT license.\n * See LICENSE file for details.\n */\n\n//#ifdef GL_OES_standard_derivatives\n//    #extension GL_OES_standard_derivatives : enable\n//#endif\n//\n//float aastep (float threshold , float value)\n//{\n//    float afwidth = 0.7 * length ( vec2 ( dFdx ( value ), dFdy ( value )));\n//    return smoothstep ( threshold - afwidth , threshold + afwidth , value );\n//}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 _czm_permute289(vec3 x)\n{\n    return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n/**\n * DOC_TBA\n *\n * Implemented by Stefan Gustavson, and distributed under the MIT License.  {@link http://openglinsights.git.sourceforge.net/git/gitweb.cgi?p=openglinsights/openglinsights;a=tree;f=proceduraltextures}\n *\n * @name czm_cellular\n * @glslFunction\n *\n * @see Stefan Gustavson's chapter, <i>Procedural Textures in GLSL</i>, in <a href=\"http://www.openglinsights.com/\">OpenGL Insights</a>.\n */\nvec2 czm_cellular(vec2 P)\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\n{\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n    vec2 Pi = mod(floor(P), 289.0);\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = _czm_permute289(Pi.x + oi);\n    vec3 p = _czm_permute289(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p*K) - Ko;\n    vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter*ox;\n    vec3 dy = Pf.y - of + jitter*oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = _czm_permute289(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p*K) - Ko;\n    oy = mod(floor(p*K),7.0)*K - Ko;\n    dx = Pf.x - 0.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = _czm_permute289(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p*K) - Ko;\n    oy = mod(floor(p*K),7.0)*K - Ko;\n    dx = Pf.x - 1.5 + jitter*ox;\n    dy = Pf.y - of + jitter*oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n"

/***/ }),
/* 258 */
/***/ (function(module, exports) {

module.exports = "/**\n * @license\n * Description : Array and textureless GLSL 2D/3D/4D simplex\n *               noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _czm_mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 _czm_mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 _czm_mod289(vec2 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat _czm_mod289(float x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 _czm_permute(vec4 x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 _czm_permute(vec3 x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nfloat _czm_permute(float x)\n{\n    return _czm_mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 _czm_taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat _czm_taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 _czm_grad4(float j, vec4 ip)\n{\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n\n/**\n * DOC_TBA\n *\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n *\n * @name czm_snoise\n * @glslFunction\n *\n * @see <a href=\"https://github.com/ashima/webgl-noise\">https://github.com/ashima/webgl-noise</a>\n * @see Stefan Gustavson's paper <a href=\"http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\">Simplex noise demystified</a>\n */\nfloat czm_snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = _czm_mod289(i); // Avoid truncation effects in permutation\n    vec3 p = _czm_permute( _czm_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat czm_snoise(vec3 v)\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = _czm_mod289(i);\n    vec4 p = _czm_permute( _czm_permute( _czm_permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat czm_snoise(vec4 v)\n{\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // (sqrt(5) - 1)/4 = F4, used once below\n    #define F4 0.309016994374947451\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = _czm_mod289(i);\n    float j0 = _czm_permute( _czm_permute( _czm_permute( _czm_permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = _czm_permute( _czm_permute( _czm_permute( _czm_permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = _czm_grad4(j0,   ip);\n    vec4 p1 = _czm_grad4(j1.x, ip);\n    vec4 p2 = _czm_grad4(j1.y, ip);\n    vec4 p3 = _czm_grad4(j1.z, ip);\n    vec4 p4 = _czm_grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= _czm_taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n"

/***/ }),
/* 259 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = repeat * materialInput.st;\r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - speed*czm_frameNumber/1000.0), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    \r\n    if(hasImage2)\r\n    {\r\n        vec4 colorBG = texture2D(image2,materialInput.st);\r\n        if(colorBG.a>0.5){\r\n            material.diffuse = color2.rgb;\r\n        }\r\n    }\r\n    return material;\r\n}"

/***/ }),
/* 260 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 color;\nuniform float speed;\nuniform float startTime;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float t = fract(startTime + czm_frameNumber * speed / 1000.0);\n    t *= 1.03;\n    float alpha = smoothstep(t- 0.03, t, st.s) * step(-t, -st.s);\n    alpha += 0.1;\n    material.diffuse = color.rgb;\n    material.alpha = alpha;\n    return material;\n}\n"

/***/ }),
/* 261 */
/***/ (function(module, exports) {

module.exports = "float circle(vec2 uv, float r, float blur) {\n    float d = length(uv) * 2.0;\n    float c = smoothstep(r+blur, r, d);\n    return c;\n}\n\nuniform vec4 color;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st - .5;\n    material.diffuse = color.rgb;\n    material.emission = vec3(0);\n\n    float t =fract(czm_frameNumber * speed / 1000.0);\n    float s = 0.3;\n    float radius1 = smoothstep(.0, s, t) * 0.5;\n    float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n    float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n    float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n    float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n\n    material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2*0.1 + alpha3*0.1);\n    material.alpha *= color.a;\n\n    return material;\n}\n"

/***/ }),
/* 262 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = materialInput.st;\r\n    vec4 imgC = texture2D(scanImg,st);\r\n    if(imgC.a>.0){\r\n        material.diffuse = color.rgb;\r\n    }\r\n    material.alpha = imgC.a;\r\n    return material;\r\n}"

/***/ }),
/* 263 */
/***/ (function(module, exports) {

module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    material.diffuse = 1.5 * color.rgb;\r\n    vec2 st = materialInput.st;\r\n\r\n    float dis = distance(st, vec2(0.5, 0.5));\r\n    float per = fract(speed*czm_frameNumber/1000.0);\r\n    if(count==1.0){\r\n        if(dis > per * 0.5){ \r\n            discard;\r\n        }else {\r\n            material.alpha = color.a  * dis / per / 2.0;\r\n        }\r\n    }\r\n    else{\r\n        vec3 str = materialInput.str;\r\n        if(abs(str.z)>0.001){\r\n            discard;\r\n        }\r\n        if(dis >0.5){\r\n            discard;\r\n        }\r\n        else {\r\n            float perDis = 0.5/count;\r\n            float disNum;\r\n            float bl = 0.0;\r\n            for(int i=0;i<=999;i++){\r\n                if(float(i)<=count){\r\n                    disNum = perDis*float(i) - dis + per/count;\r\n                    if(disNum>0.0){\r\n                        if(disNum<perDis){\r\n                            bl = 1.0-disNum/perDis;\r\n                        }\r\n                        else if(disNum-perDis<perDis){\r\n                            bl = 1.0 - abs(1.0-disNum/perDis);\r\n                        }\r\n                        material.alpha = pow(bl,(1.0 + 10.0 * (1.0 - gradient)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } \r\n    return material;\r\n}"

/***/ }),
/* 264 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 asphaltColor;\nuniform float bumpSize;\nuniform float roughness;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  //Main cellular pattern\n  vec4 color = asphaltColor;\n  vec2 st = materialInput.st;\n  vec2 F = czm_cellular(st / bumpSize);\n  color.rgb -= (F.x / F.y) * 0.1;\n\n  //Extra bumps for roughness\n  float noise = czm_snoise(st / bumpSize);\n  noise = pow(noise, 5.0) * roughness;\n  color.rgb += noise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 265 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 1.0 - F.x * F.x;\n\n  vec4 color = mix(lightColor, darkColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 0.1 + (F.y - F.x);\n\n  vec4 color = mix(lightColor, darkColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 267 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 grassColor;\nuniform vec4 dirtColor;\nuniform float patchiness;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  vec2 st = materialInput.st;\n  float noise1 = (czm_snoise(st * patchiness * 1.0)) * 1.0;\n  float noise2 = (czm_snoise(st * patchiness * 2.0)) * 0.5;\n  float noise3 = (czm_snoise(st * patchiness * 4.0)) * 0.25;\n  float noise = sin(noise1 + noise2 + noise3) * 0.1;\n\n  vec4 color = mix(grassColor, dirtColor, noise);\n\n  //Make thatch patterns\n  float verticalNoise = czm_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\n  float horizontalNoise = czm_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\n  float stripeNoise = min(verticalNoise, horizontalNoise);\n\n  color.rgb += stripeNoise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 268 */
/***/ (function(module, exports) {

module.exports = "uniform vec4 lightWoodColor;\nuniform vec4 darkWoodColor;\nuniform float ringFrequency;\nuniform vec2 noiseScale;\nuniform float grainFrequency;\n\nczm_material czm_getMaterial(czm_materialInput materialInput){\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  //Based on wood shader from OpenGL Shading Language (3rd edition) pg. 455\n  vec2 st = materialInput.st;\n\n  vec2 noisevec;\n  noisevec.x = czm_snoise(st * noiseScale.x);\n  noisevec.y = czm_snoise(st * noiseScale.y);\n\n  vec2 location = st + noisevec;\n  float dist = sqrt(location.x * location.x + location.y * location.y);\n  dist *= ringFrequency;\n\n  float r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\n  if(r > 1.0)\n      r = 2.0 - r;\n\n  vec4 color = mix(lightWoodColor, darkWoodColor, r);\n\n  //streaks\n  r = abs(czm_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\n  color.rgb += lightWoodColor.rgb * r;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a;\n\n  return material;\n}\n"

/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D image;\nuniform sampler2D normalMap;\nuniform vec4 color;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\n  czm_material czm_getMaterial(czm_materialInput materialInput)\n  {\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n\n    // 衰减是离碎片的距离和波的频率的函数\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n\n    float specularMapValue = texture2D(image, materialInput.st).r;\n    specularMapValue = 1.0; // vtxf 20190123\n\n    // note: 此时不使用方向运动，只需将角度设置为0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n\n    // 当我们离水面越来越远时，正常的扰动会逐渐消失\n    normalTangentSpace.xy /= fade;\n\n    // 当我们接近非水域时，尝试淡出正常扰动（低镜面反射贴图值）\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n\n    normalTangentSpace = normalize(normalTangentSpace);\n\n    // 获取新法向量与垂直于切平面的向量对齐的比率\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\n    // 当镜面反射贴图值减小时淡出水效果\n    material.alpha = specularMapValue;\n\n    // 基础颜色是基于镜面反射贴图的值的水和非水颜色的混合\n    // 可能需要一个均匀的混合因子来更好地控制这一点\n    // material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n    vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n    v.y = 1.0 - v.y;\n    // material.diffuse = texture2D(image, v).rgb;\n    material.diffuse = texture2D(image, v + noise.xy*0.03).rgb; \n\n    // 漫反射高光基于法线的扰动程度\n    material.diffuse += (0.1 * tsPerturbationRatio);\n    // material.diffuse += (0.1 * tsPerturbationRatio);\n\n    material.diffuse = material.diffuse;\n\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n\n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n    material.diffuse = color.rgb * material.diffuse;\n    // material.diffuse = mix(material.diffuse,color.rgb, color.a);\n    material.alpha = color.a;\n    return material;\n    }\n\n\r\n"

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextMaterial = undefined;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//文字贴图 primitive材质
var TextMaterial = exports.TextMaterial = function (_Cesium$Material) {
  _inherits(TextMaterial, _Cesium$Material);

  function TextMaterial(options) {
    _classCallCheck(this, TextMaterial);

    return _possibleConstructorReturn(this, (TextMaterial.__proto__ || Object.getPrototypeOf(TextMaterial)).call(this, conventOptions(options)));
  }

  return TextMaterial;
}(Cesium.Material);

function conventOptions(options) {
  var _text = options.text;
  var _textStyles = Cesium.defaultValue(options.textStyles, {
    font: "50px 楷体",
    fill: true,
    fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
    stroke: true,
    strokeWidth: 2,
    strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
    backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
    textBaseline: "top",
    padding: 10
  });

  var image = (0, _util.getTextImage)(_text, _textStyles);

  return {
    fabric: {
      uniforms: {
        image: image,
        repeat: options.repeat || new Cesium.Cartesian2(1.0, 1.0),
        color: options.color || new Cesium.Color(1.0, 1.0, 1.0, 1.0)
      },
      components: {
        diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb",
        alpha: "texture2D(image, fract(repeat * materialInput.st)).a * color.a"
      }
    },
    translucent: function translucent(material) {
      return material.uniforms.color.alpha < 1.0;
    }
  };
}

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CylinderWaveMaterial = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//圆锥 扩散效果 材质
var CylinderWaveMaterial = exports.CylinderWaveMaterial = function (_Cesium$Material) {
  _inherits(CylinderWaveMaterial, _Cesium$Material);

  function CylinderWaveMaterial(options) {
    _classCallCheck(this, CylinderWaveMaterial);

    //每秒刷新次数，因为requestAnimationFrame固定每秒60次的渲染，所以如果不想这么快，就把该数值调小一些
    var _this = _possibleConstructorReturn(this, (CylinderWaveMaterial.__proto__ || Object.getPrototypeOf(CylinderWaveMaterial)).call(this, conventOptions(options)));

    _this.frameTime = 1000 / (options.frameRate || 60);

    // 动态修改雷达材质中的offset变量，从而实现动态效果。
    var that = _this;
    var then = Date.now();
    (function frame() {
      that.animateFrame = window.requestAnimationFrame(frame);
      var now = Date.now();
      var delta = now - then;
      if (delta > that.frameTime) {
        then = now - delta % that.frameTime;
        that.updateOffset(); //按帧率执行
      }
    })();
    return _this;
  }

  // 动态修改雷达材质中的offset变量，从而实现动态效果。


  _createClass(CylinderWaveMaterial, [{
    key: "updateOffset",
    value: function updateOffset() {
      var offset = this.uniforms.offset;
      offset -= 0.001;
      if (offset > 1.0) {
        offset = 0.0;
      }
      this.uniforms.offset = offset;

      // viewer.scene.preUpdate.addEventListener(function () {
      //     var offset = radar.appearance.material.uniforms.offset;
      //     offset -= 0.001;
      //     if (offset > 1.0) {
      //         offset = 0.0;
      //     }
      //     radar.appearance.material.uniforms.offset = offset;
      // });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      window.cancelAnimationFrame(this.animateFrame);
      delete this.animateFrame;

      return _get(CylinderWaveMaterial.prototype.__proto__ || Object.getPrototypeOf(CylinderWaveMaterial.prototype), "destroy", this).call(this);
    }
  }]);

  return CylinderWaveMaterial;
}(Cesium.Material);

function conventOptions(options) {
  return {
    fabric: {
      uniforms: {
        color: Cesium.defaultValue(options.color, new Cesium.Color(2, 1, 0.0, 0.8)),
        repeat: Cesium.defaultValue(options.repeat, 30.0),
        offset: 0.0,
        thickness: 0.3
      },
      source: " uniform vec4 color;\n                uniform float repeat;\n                uniform float offset;\n                uniform float thickness;\n                czm_material czm_getMaterial(czm_materialInput materialInput)\n                {\n                    czm_material material = czm_getDefaultMaterial(materialInput);\n                    float sp = 1.0/repeat;\n                    vec2 st = materialInput.st;\n                    float dis = distance(st, vec2(0.5));\n                    float m = mod(dis + offset, sp);\n                    float a = step(sp*(1.0-thickness), m);\n                    material.diffuse = color.rgb;\n                    material.alpha = a * color.a;\n                    return material;\n                }  "
    },
    translucent: function translucent(material) {
      return material.uniforms.color.alpha < 1.0;
    }
  };
}

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleScanMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//圆形扫描效果 材质属性
var CircleScanMaterialProperty = exports.CircleScanMaterialProperty = function () {
  //========== 构造方法 ==========
  function CircleScanMaterialProperty(options) {
    _classCallCheck(this, CircleScanMaterialProperty);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    this._definitionChanged = new Cesium.Event();
    this._colorSubscription = undefined;

    //支持的属性
    this._color = Cesium.defaultValue(options.color, new Cesium.Color(1, 0, 0, 1.0)); //颜色
    this._scanImg = Cesium.defaultValue(options.url);
  }

  //========== 对外属性 ==========


  _createClass(CircleScanMaterialProperty, [{
    key: "getType",


    //========== 方法 ==========
    /**
     * Gets the {@link Cesium.Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    value: function getType(time) {
      return Cesium.Material.CircleScanType;
    }

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.color = this._color;
      result.scanImg = this._scanImg;
      return result;
    }

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param { Cesium.Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof CircleScanMaterialProperty && Cesium.Property.equals(this._color, other._color) && this._scanImg === other._scanImg;
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return CircleScanMaterialProperty;
}();

//属性


Object.defineProperties(CircleScanMaterialProperty.prototype, {
  /**
   * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
   * @memberof PolylineGlowMaterialProperty.prototype
   * @type { Cesium.Property}
   */
  color: Cesium.createPropertyDescriptor("color"),
  scanImg: Cesium.createPropertyDescriptor("scanImg")
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScanLineMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//面状: 用于面状对象的 扫描线放大效果 材质属性
var ScanLineMaterialProperty = exports.ScanLineMaterialProperty = function () {
  //========== 构造方法 ==========
  function ScanLineMaterialProperty(options) {
    _classCallCheck(this, ScanLineMaterialProperty);

    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

    this._definitionChanged = new Cesium.Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._time = undefined;

    //支持的属性
    this._color = Cesium.defaultValue(options.color, Cesium.Color.YELLOW); //颜色
    this._speed = Cesium.defaultValue(options.speed, 10); //速度，建议取值范围1-100
  }

  //========== 对外属性 ==========


  _createClass(ScanLineMaterialProperty, [{
    key: "getType",


    //========== 方法 ==========
    /**
     * Gets the {@link Cesium.Material} type at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    value: function getType(time) {
      return Cesium.Material.ScanLineType;
    }

    /**
     * Gets the value of the property at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */

  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.color = this._color;
      result.speed = this._speed;
      return result;
    }

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     *
     * @param { Cesium.Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof ScanLineMaterialProperty && Cesium.Property.equals(this._color, other._color) && this._speed === other._speed;
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return ScanLineMaterialProperty;
}();

Object.defineProperties(ScanLineMaterialProperty.prototype, {
  color: Cesium.createPropertyDescriptor("color"),
  speed: Cesium.createPropertyDescriptor("speed")
});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ODLineMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//线状 OD线效果 材质
var ODLineMaterialProperty = exports.ODLineMaterialProperty = function () {
  function ODLineMaterialProperty(options) {
    _classCallCheck(this, ODLineMaterialProperty);

    options = options || {};

    this._speed = undefined;
    this._speedSubscription = undefined;
    this._color = undefined;
    this._colorSubscription = undefined;
    this._startTime = undefined;
    this._definitionChanged = new Cesium.Event();

    //支持的属性
    this.color = Cesium.defaultValue(options.color, new Cesium.Color(Math.random() * 0.5 + 0.5, Math.random() * 0.8 + 0.2, 0.0, 1.0));
    this.speed = Cesium.defaultValue(options.speed, 20 + 10 * Math.random());
    this.startTime = Cesium.defaultValue(options.startTime, Math.random());
  }

  _createClass(ODLineMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return Cesium.Material.ODLineType;
    }
  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!result) {
        result = {};
      }
      result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, Cesium.Color.WHITE, result.color);
      result.speed = Cesium.Property.getValueOrClonedDefault(this._speed, time, 20, result.speed);
      result.startTime = Cesium.Property.getValueOrClonedDefault(this._startTime, time, 0, result.startTime);

      return result;
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof ODLineMaterialProperty && Cesium.Property.equals(this._color, other._color);
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return ODLineMaterialProperty;
}();

Object.defineProperties(ODLineMaterialProperty.prototype, {
  color: Cesium.createPropertyDescriptor("color"),
  speed: Cesium.createPropertyDescriptor("speed")
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//文字贴图 entity材质
var TextMaterialProperty = exports.TextMaterialProperty = function (_Cesium$ImageMaterial) {
  _inherits(TextMaterialProperty, _Cesium$ImageMaterial);

  //========== 构造方法 ==========
  function TextMaterialProperty(options) {
    _classCallCheck(this, TextMaterialProperty);

    var _this = _possibleConstructorReturn(this, (TextMaterialProperty.__proto__ || Object.getPrototypeOf(TextMaterialProperty)).call(this, options));

    _this.transparent = Cesium.defaultValue(options.transparent, true);

    _this._text = options.text;
    _this._textStyles = Cesium.defaultValue(options.textStyles, {
      font: "50px 楷体",
      fill: true,
      fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
      stroke: true,
      strokeWidth: 2,
      strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
      backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
      textBaseline: "top",
      padding: 40
    });

    _this.image = (0, _util.getTextImage)(_this._text, _this._textStyles);
    return _this;
  }
  //========== 对外属性 ==========


  _createClass(TextMaterialProperty, [{
    key: "text",
    get: function get() {
      return this._text;
    },
    set: function set(val) {
      this._text = val;
      this.image = (0, _util.getTextImage)(this._text, this._textStyles);
    }
  }, {
    key: "textStyles",
    get: function get() {
      return this._textStyles;
    },
    set: function set(val) {
      this._textStyles = val;
      this.image = (0, _util.getTextImage)(this._text, this._textStyles);
    }
  }]);

  return TextMaterialProperty;
}(Cesium.ImageMaterialProperty);

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterMaterialProperty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WaterMaterialProperty = exports.WaterMaterialProperty = function () {
  function WaterMaterialProperty(options) {
    _classCallCheck(this, WaterMaterialProperty);

    options = options || {};
    this._definitionChanged = new Cesium.Event();
    this._baseWaterColor = undefined;
    this._baseWaterColorSubscription = undefined;
    this.baseWaterColor = options.baseWaterColor || new Cesium.Color(0.2, 0.3, 0.6, 1.0);
    this._blendColor = undefined;
    this._blendColorSubscription = undefined;
    this.blendColor = options.blendColor || new Cesium.Color(0.0, 1.0, 0.699, 1.0);
    this._specularMap = undefined;
    this._specularMapSubscription = undefined;
    this.specularMap = options.specularMap || Cesium.Material.DefaultImageId;
    this._normalMap = undefined;
    this._normalMapSubscription = undefined;
    this.normalMap = options.normalMap || Cesium.Material.DefaultImageId;
    this.frequency = Cesium.defaultValue(options.frequency, 1000);
    this.animationSpeed = Cesium.defaultValue(options.animationSpeed, 0.01);
    this.amplitude = Cesium.defaultValue(options.amplitude, 10.0);
    this.specularIntensity = Cesium.defaultValue(options.specularIntensity, 0.5);
  }

  _createClass(WaterMaterialProperty, [{
    key: "getType",
    value: function getType(time) {
      return Cesium.Material.WaterType;
    }
  }, {
    key: "getValue",
    value: function getValue(time, result) {
      if (!result) {
        result = {};
      }
      result.baseWaterColor = Cesium.Property.getValueOrUndefined(this._baseWaterColor, time);
      result.blendColor = Cesium.Property.getValueOrUndefined(this._blendColor, time);
      result.specularMap = Cesium.Property.getValueOrUndefined(this._specularMap, time);
      result.normalMap = Cesium.Property.getValueOrUndefined(this._normalMap, time);
      result.frequency = this.frequency;
      result.animationSpeed = this.animationSpeed;
      result.amplitude = this.amplitude;
      result.specularIntensity = this.specularIntensity;
      return result;
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this === other || other instanceof WaterMaterialProperty && Cesium.Property.equals(this._baseWaterColor, other._baseWaterColor);
    }
  }, {
    key: "isConstant",
    get: function get() {
      return false;
    }
  }, {
    key: "definitionChanged",
    get: function get() {
      return this._definitionChanged;
    }
  }]);

  return WaterMaterialProperty;
}();

Object.defineProperties(WaterMaterialProperty.prototype, {
  baseWaterColor: Cesium.createPropertyDescriptor("baseWaterColor"),
  blendColor: Cesium.createPropertyDescriptor("blendColor"),
  specularMap: Cesium.createPropertyDescriptor("specularMap"),
  normalMap: Cesium.createPropertyDescriptor("normalMap")
});

/***/ }),
/* 277 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture;//输入的场景渲染照片\r\nvarying vec2 v_textureCoordinates;\r\n\r\nfloat hash(float x){\r\n    return fract(sin(x*133.3)*13.13);\r\n}\r\n\r\nvoid main(void){\r\n\r\n    float time = czm_frameNumber / 240.0;\r\n    vec2 resolution = czm_viewport.zw;\r\n\r\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\r\n    vec3 c=vec3(.6,.7,.8);\r\n\r\n    float a=-.4;\r\n    float si=sin(a),co=cos(a);\r\n    uv*=mat2(co,-si,si,co);\r\n    uv*=length(uv+vec2(0,4.9))*.3+1.;\r\n\r\n    float v=1.-sin(hash(floor(uv.x*100.))*2.);\r\n    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\r\n    c*=v*b; //屏幕上雨的颜色\r\n\r\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5); //将雨和三维场景融合\r\n}"

/***/ }),
/* 278 */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D colorTexture; //输入的场景渲染照片\nvarying vec2 v_textureCoordinates;\n\nfloat snow(vec2 uv,float scale){\n    float time = czm_frameNumber / 60.0;\n    float w=smoothstep(1.,0.,-uv.y*(scale/10.));\n    if(w<.1)return 0.;\n    uv+=time/scale;\n    uv.y+=time*2./scale;\n    uv.x+=sin(uv.y+time*.5)/scale;\n    uv*=scale;\n    vec2 s=floor(uv),f=fract(uv),p;\n    float k=3.,d;\n    p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\n    d=length(p);k=min(d,k);\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    return k*w;\n}\n\nvoid main(void){\n    vec2 resolution = czm_viewport.zw;\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n    vec3 finalColor=vec3(0);\n    float c = 0.0;\n    c+=snow(uv,10.);\n    c+=snow(uv,8.);\n    c+=snow(uv,6.);\n    c+=snow(uv,5.);\n    finalColor=(vec3(c)); //屏幕上雪的颜色\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5);  //将雪和三维场景融合\n\n}\n"

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZoomNavigation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var unprojectedScratch = new Cesium.Cartographic();
var rayScratch = new Cesium.Ray();
var cartesian3Scratch = new Cesium.Cartesian3();

/**
 * gets the focus point of the camera
 * @param {Viewer|Widget} viewer The viewer
 * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
 * @param {Cesium.Cartesian3} [result] The object in which the result will be stored.
 * @return {Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
 */
function getCameraFocus(viewer, inWorldCoordinates, result) {
  var scene = viewer.scene;
  var camera = scene.camera;

  if (scene.mode == Cesium.SceneMode.MORPHING) {
    return undefined;
  }

  if (!Cesium.defined(result)) {
    result = new Cesium.Cartesian3();
  }

  // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
  // TODO bug when tracking: reset should reset to default view of tracked entity

  if (Cesium.defined(viewer.trackedEntity)) {
    result = viewer.trackedEntity.position.getValue(viewer.clock.currentTime, result);
  } else {
    rayScratch.origin = camera.positionWC;
    rayScratch.direction = camera.directionWC;
    result = scene.globe.pick(rayScratch, scene, result);
  }

  if (!Cesium.defined(result)) {
    return undefined;
  }

  if (scene.mode == Cesium.SceneMode.SCENE2D || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
    result = camera.worldToCameraCoordinatesPoint(result, result);

    if (inWorldCoordinates) {
      result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);
    }
  } else {
    if (!inWorldCoordinates) {
      result = camera.worldToCameraCoordinatesPoint(result, result);
    }
  }

  return result;
}

var ZoomNavigation = exports.ZoomNavigation = function () {
  //========== 构造方法 ==========
  // is used for zooming in (true) or out (false)
  function ZoomNavigation(viewer, zoomIn) {
    _classCallCheck(this, ZoomNavigation);

    this.viewer = viewer;

    this.relativeAmount = 2;
    if (zoomIn) {
      // this ensures that zooming in is the inverse of zooming out and vice versa
      // e.g. the camera position remains when zooming in and out
      this.relativeAmount = 1 / this.relativeAmount;
    }
  }

  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control
   * @abstract
   * @protected
   */


  _createClass(ZoomNavigation, [{
    key: "activate",
    value: function activate() {
      this.zoom(this.relativeAmount);
    }
  }, {
    key: "zoom",
    value: function zoom(relativeAmount) {
      this.isActive = true;

      if (Cesium.defined(this.viewer)) {
        var scene = this.viewer.scene;

        var sscc = scene.screenSpaceCameraController;
        // do not zoom if it is disabled
        if (!sscc.enableInputs || !sscc.enableZoom) {
          return;
        }
        // TODO
        //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
        //                return;
        //            }

        var camera = scene.camera;
        var orientation;

        switch (scene.mode) {
          case Cesium.SceneMode.MORPHING:
            break;
          case Cesium.SceneMode.SCENE2D:
            camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
            break;
          default:
            var focus;

            if (Cesium.defined(this.viewer.trackedEntity)) {
              focus = new Cesium.Cartesian3();
            } else {
              focus = getCameraFocus(this.viewer, false);
            }

            if (!Cesium.defined(focus)) {
              // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
              // the focal point.
              var ray = new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
              focus = Cesium.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);

              orientation = {
                heading: camera.heading,
                pitch: camera.pitch,
                roll: camera.roll
              };
            } else {
              orientation = {
                direction: camera.direction,
                up: camera.up
              };
            }

            var direction = Cesium.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
            var movementVector = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
            var endPosition = Cesium.Cartesian3.add(focus, movementVector, focus);

            if (Cesium.defined(this.viewer.trackedEntity) || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
              // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
              // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
              camera.position = endPosition;
            } else {
              camera.flyTo({
                destination: endPosition,
                orientation: orientation,
                duration: 0.5,
                convert: false
              });
            }
        }
      }

      // this.viewer.notifyRepaintRequired();
      this.isActive = false;
    }
  }]);

  return ZoomNavigation;
}();

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rotate = undefined;
exports.move = move;
exports.getHeadingPitchRoll = getHeadingPitchRoll;

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _matrix = __webpack_require__(16);

var _util = __webpack_require__(3);

var _point = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//自旋转效果
//gltf模型
var rotate = exports.rotate = {
  isStart: false,
  viewer: null,
  start: function start(entity, opts) {
    this.entity = entity;
    this.viewer = opts.viewer || window.viewer;

    this.time = this.viewer.clock.currentTime.clone();

    this.hpr = (0, _matrix.getHeadingPitchRollByOrientation)(this.entity.position._value, this.entity.orientation && this.entity.orientation._value);
    this.angle = opts.step || 10; //步长

    this.viewer.clock.shouldAnimate = true;
    this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
    this.isStart = true;
  },
  clock_onTickHandler: function clock_onTickHandler(e) {
    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
    var heading = Cesium.Math.toRadians(delTime * this.angle) + this.hpr.heading;

    //角度控制
    var hpr = new Cesium.HeadingPitchRoll(heading, this.hpr.pitch, this.hpr.roll);
    this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.entity.position._value, hpr);
  },
  stop: function stop() {
    if (!this.isStart) return;

    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
    this.isStart = false;
  }
};

//移动模型
function move(entity, options) {
  var viewer = options.viewer || window.viewer;

  var property = new Cesium.SampledPositionProperty();
  var startTime = viewer.clock.currentTime; //飞行开始时间
  var stopTime; //飞行结束时间

  var pointStart = (0, _point.getPositionValue)(entity.position, startTime);
  property.addSample(startTime, pointStart);

  var pointEnd = options.position;
  var time = options.time || 3; //速度 秒
  stopTime = Cesium.JulianDate.addSeconds(startTime, time, new Cesium.JulianDate());
  property.addSample(stopTime, pointEnd);

  //为了保证到结束时间了，一直停留在那，所以加个很远的时间
  stopTime = Cesium.JulianDate.addDays(stopTime, 365, new Cesium.JulianDate());
  property.addSample(stopTime, pointEnd);

  entity.position = property;

  viewer.clock.shouldAnimate = true;
  var _bak_multiplier = viewer.clock.multiplier;
  viewer.clock.multiplier = options.speed || 1; //飞行速度
  // viewer.clock.currentTime = startTime.clone();

  setTimeout(function () {
    entity.position = pointEnd;

    viewer.clock.multiplier = _bak_multiplier;

    if (options.onEnd) options.onEnd();
  }, time * 1000);
}

//获取动态模型的当前hpr角度
function getHeadingPitchRoll(entity, time) {
  time = time || (0, _util.currentTime)();
  var position = Cesium.Property.getValueOrUndefined(entity.position, time, new Cesium.Cartesian3());
  var orientation = Cesium.Property.getValueOrUndefined(entity.orientation, time, new Cesium.Quaternion());
  var hpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, orientation);
  return hpr;
}

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Video3D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _Video3D = __webpack_require__(282);

var _Video3D2 = _interopRequireDefault(_Video3D);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ratateDirection = {
  LEFT: "Z",
  RIGHT: "-Z",
  TOP: "Y",
  BOTTOM: "-Y",
  ALONG: "X",
  INVERSE: "-X"
};

var textStyles = {
  font: "50px 楷体",
  fill: true,
  fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
  stroke: true,
  strokeWidth: 2,
  strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
  backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
  textBaseline: "top",
  padding: 40
};

var Video3DType = {
  Color: 1,
  Image: 2,
  Video: 3,
  Text: 4
};

//视频融合（投射3D，贴物体表面）
//原理：在可视域的基础上，着色器里传入纹理，再计算UV进行贴图

var Video3D = exports.Video3D = function () {
  //========== 构造方法 ==========
  function Video3D(viewer, options) {
    _classCallCheck(this, Video3D);

    this.viewer = viewer;

    options = options || {};

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    if (Cesium.defined(options.debugFrustum)) options.showFrustum = options.debugFrustum;
    this.debugFrustum = this.showFrustum;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    this._cameraPosition = options.cameraPosition; //相机位置
    this._position = options.position; //视点位置
    this.type = options.type; //投影类型
    this.alpha = options.alpha || 1.0; //透明度
    this.color = options.color; //投影的颜色
    this._debugFrustum = Cesium.defaultValue(options.showFrustum, true); //显示视椎体

    this._aspectRatio = options.aspectRatio || this._getWinWidHei(); //宽高比
    var fov = options.fov && Cesium.Math.toRadians(options.fov);
    this._camerafov = fov || this.viewer.scene.camera.frustum.fov; //相机水平张角
    this.videoTexture = this.texture = options.texture || new Cesium.Texture({
      //默认材质
      context: this.viewer.scene.context,
      source: {
        width: 1,
        height: 1,
        arrayBufferView: new Uint8Array([255, 255, 255, 255])
      },
      flipY: false
    });
    this._videoPlay = Cesium.defaultValue(options.videoPlay, true); //暂停播放
    this.defaultShow = Cesium.defaultValue(options.show, true); //显示和隐藏
    this.clearBlack = Cesium.defaultValue(options.clearBlack, false); //消除鱼眼视频的黑色
    this._rotateDeg = 1;
    this._dirObj = Cesium.defaultValue(options.dirObj, undefined);
    this.text = Cesium.defaultValue(options.text, undefined);
    this.textStyles = Cesium.defaultValue(options.textStyles, textStyles);
    this._disViewColor = Cesium.defaultValue(options.disViewColor, new Cesium.Color(0, 0, 0, 0.5));

    if (!this.cameraPosition || !this.position) {
      daslog.warn("初始化失败：请确认相机位置与视点位置正确！");
      return;
    }

    //传入了DOM
    if (options.dom) {
      this.dom = options.dom;
      if (this.dom instanceof HTMLElement) {
        this.dom = options.dom;
      }
      if (options.dom instanceof Object && options.dom.length) {
        this.dom = options.dom[0];
      }
    }
    //传入了URL
    this.url = options.url; //url

    switch (this.type) {
      default:
      case Video3DType.Video:
        this.activeVideo(this.url);
        break;
      case Video3DType.Image:
        this.activePicture(this.url);
        this.deActiveVideo();
        break;
      case Video3DType.Color:
        this.activeColor(this.color);
        this.deActiveVideo();
        break;
      case Video3DType.Text:
        this.activeText(this.text, this.textStyles);
        this.deActiveVideo();
        break;
    }

    this._createShadowMap();
    this._getOrientation();
    this._addCameraFrustum();
    this._addPostProcess();
    this.viewer.scene.primitives.add(this);
  }

  //========== 对外属性 ==========
  //混合系数0-1


  _createClass(Video3D, [{
    key: "rotateCamera",


    //旋转相机
    value: function rotateCamera(axis, deg) {
      var rotateDegree = Cesium.defaultValue(deg, this._rotateDeg);
      switch (axis) {
        case ratateDirection.LEFT:
          break;
        case ratateDirection.RIGHT:
          rotateDegree *= -1;
          break;
        case ratateDirection.TOP:
          break;
        case ratateDirection.BOTTOM:
          rotateDegree *= -1;
          break;
        case ratateDirection.ALONG:
          break;
        case ratateDirection.INVERSE:
          rotateDegree *= -1;
          break;
      }
      var newDir = this._computedNewViewDir(axis, rotateDegree);

      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);
      this.viewShadowMap.destroy();
      // this.cameraFrustum.destroy();
      this._resetCameraDir(newDir);
      this._getOrientation();
      this._addCameraFrustum();
      this._addPostProcess();
    }
  }, {
    key: "_resetCameraDir",
    value: function _resetCameraDir(dirObj) {
      if (!dirObj || !dirObj.up || !dirObj.right || !dirObj.direction) return;
      this._dirObj = dirObj;
      this._createShadowMap();
    }
    //计算新视点

  }, {
    key: "_computedNewViewDir",
    value: function _computedNewViewDir(axis, deg) {
      deg = Cesium.Math.toRadians(deg);
      var camera = this.viewShadowMap._lightCamera;
      var oldDir = Cesium.clone(camera.direction);
      var oldRight = Cesium.clone(camera.right);
      var oldTop = Cesium.clone(camera.up);
      var mat3 = new Cesium.Matrix3();

      switch (axis) {
        case ratateDirection.LEFT:
          Cesium.Matrix3.fromRotationZ(deg, mat3);
          break;
        case ratateDirection.RIGHT:
          Cesium.Matrix3.fromRotationZ(deg, mat3);
          break;
        case ratateDirection.TOP:
          Cesium.Matrix3.fromRotationY(deg, mat3);
          break;
        case ratateDirection.BOTTOM:
          Cesium.Matrix3.fromRotationY(deg, mat3);
          break;
        case ratateDirection.ALONG:
          Cesium.Matrix3.fromRotationX(deg, mat3);
          break;
        case ratateDirection.INVERSE:
          Cesium.Matrix3.fromRotationX(deg, mat3);
          break;
      }
      var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
      // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
      // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
      var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

      var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
      var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
      var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

      var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
      var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
      var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

      var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
      var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
      var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
      return {
        direction: newDir,
        right: newRight,
        up: newTop
      };
    }
  }, {
    key: "getPercentagePoint",
    value: function getPercentagePoint(cartesian) {
      if (!cartesian) return;
      var vm = this.viewShadowMap._lightCamera._viewMatrix;
      var pm = this.viewShadowMap._lightCamera.frustum.projectionMatrix;
      var c4 = new Cesium.Cartesian4(cartesian.x, cartesian.y, cartesian.z, 1.0);
      var pvm = Cesium.Matrix4.multiply(pm, vm, new Cesium.Matrix4());
      var epos1 = Cesium.Matrix4.multiplyByVector(pvm, c4, new Cesium.Cartesian4());
      var epos2 = new Cesium.Cartesian2(epos1.x / epos1.w, epos1.y / epos1.w);
      var epos3 = new Cesium.Cartesian2(epos2.x / 2 + 0.5, epos2.y / 2 + 0.5);
      return epos3;
    }

    /**
     * 改变相机的水平张角
     */

  }, {
    key: "_changeCameraFov",
    value: function _changeCameraFov() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);
      this._createShadowMap();
      this._getOrientation();
      this._addCameraFrustum();
      this._addPostProcess();
    }

    /**
     * 改变相机视野的宽高比例（垂直张角）
     */

  }, {
    key: "_changeVideoWidHei",
    value: function _changeVideoWidHei() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);
      this._createShadowMap();
      this._getOrientation();
      this._addCameraFrustum();
      this._addPostProcess();
    }

    /**
     * 改变相机的位置
     */

  }, {
    key: "_changeCameraPos",
    value: function _changeCameraPos() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);
      this.viewShadowMap.destroy();
      // this.cameraFrustum.destroy();
      this._createShadowMap(true);
      this._getOrientation();
      this._addCameraFrustum();
      this._addPostProcess();
    }

    /**
     * 改变相机视点的位置
     */

  }, {
    key: "_changeViewPos",
    value: function _changeViewPos() {
      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);
      this.viewShadowMap.destroy();
      // this.cameraFrustum.destroy();
      this._createShadowMap(true);
      this._getOrientation();
      this._addCameraFrustum();
      this._addPostProcess();
    }
  }, {
    key: "_switchShow",
    value: function _switchShow() {
      if (this.show) {
        !this.postProcess && this._addPostProcess();
      } else {
        this.viewer.scene.postProcessStages.remove(this.postProcess);
        delete this.postProcess;
        this.postProcess = null;
      }
      // this.cameraFrustum.show = this.show;
    }

    /**
     * 激活或重置视频URL
     * @param videoSrc
     * @returns
     */

  }, {
    key: "activeVideo",
    value: function activeVideo(videoSrc) {
      //在可视域添加视频
      var videoElement;
      if (this.dom) {
        videoElement = this.dom;
      } else {
        videoElement = this._createVideoEle(videoSrc);
      }

      var that = this;
      if (videoElement) {
        this.type = Video3DType.Video;
        this.videoElement = videoElement;
        videoElement.addEventListener("canplaythrough", function () {
          if (!that.viewer) return;
          that.viewer.clock.onTick.addEventListener(that.activeVideoListener, that);
        });
      }
    }
  }, {
    key: "activeVideoListener",
    value: function activeVideoListener() {
      try {
        if (this._videoPlay && this.videoElement.paused) this.videoElement.play();
      } catch (e) {
        //规避浏览器权限异常
      }

      if (!this.videoElement || !this.viewer) return;

      this.videoTexture && this.videoTexture.destroy();
      this.videoTexture = new Cesium.Texture({
        context: this.viewer.scene.context,
        source: this.videoElement,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
      });
    }

    //删除视频播放监听

  }, {
    key: "deActiveVideo",
    value: function deActiveVideo() {
      this.viewer.clock.onTick.removeEventListener(this.activeVideoListener, this);
      delete this.activeVideoListener;
    }

    /**
     * 激活或重置图片URL
     * @param videoSrc
     * @returns
     */

  }, {
    key: "activePicture",
    value: function activePicture(picSrc) {
      //在可视域添加图片
      this.videoTexture = this.texture;

      var that = this;
      var image = new Image();
      image.onload = function () {
        that.type = Video3DType.Image;
        that.videoTexture = new Cesium.Texture({
          context: that.viewer.scene.context,
          source: image
        });
      };
      image.onerror = function (e) {
        daslog.warn("图片加载失败：" + picSrc, e);
      };
      image.src = picSrc;
    }

    /**
     * 激活或重置颜色
     * @param color
     * @returns
     */

  }, {
    key: "activeColor",
    value: function activeColor(color) {
      //在可视域添加纯色
      var that = this;
      this.type = Video3DType.Color;
      var r, g, b, a;
      if (color) {
        r = color.red * 255;
        g = color.green * 255;
        b = color.blue * 255;
        a = color.alpha * 255;
      } else {
        r = Math.random() * 255;
        g = Math.random() * 255;
        b = Math.random() * 255;
        a = Math.random() * 255;
      }
      that.videoTexture = new Cesium.Texture({
        context: that.viewer.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([r, g, b, a])
        },
        flipY: false
      });
    }

    /**
     * 激活或重置文本
     * @param text
     * @param styles
     * @returns
     */
    // Name	               Type	          Default	                     Description
    // font	               String	      '10px sans-serif'	             optional The CSS font to use.
    // textBaseline	       String	      'bottom'	                     optional The baseline of the text.
    // fill	               Boolean	      true	                         optional Whether to fill the text.
    // stroke	           Boolean	      false	                         optional Whether to stroke the text.
    // fillColor	       Color	      Color.WHITE	                 optional The fill color.
    // strokeColor	       Color	      Color.BLACK	                 optional The stroke color.
    // strokeWidth	       Number	      1	                             optional The stroke width.
    // backgroundColor	   Color	      Color.TRANSPARENT	             optional The background color of the canvas.
    // padding	           Number	      0	                             optional The pixel size of the padding to add around the text.

  }, {
    key: "activeText",
    value: function activeText(text, styles) {
      //在可视域添加纯色
      var that = this;
      this.type = Video3DType.Text;
      if (!text) return;
      styles = styles || {};
      styles.textBaseline = "top";
      this.textCanvas = Cesium.writeTextToCanvas(text, styles);
      that.videoTexture = new Cesium.Texture({
        context: that.viewer.scene.context,
        source: this.textCanvas,
        flipY: true
      });
    }

    /**
     * 呈现投影相机的第一视角
     */

  }, {
    key: "locate",
    value: function locate() {
      var camera_pos = Cesium.clone(this.cameraPosition);
      var lookat_pos = Cesium.clone(this.position);
      this.viewer.camera.position = camera_pos;
      if (this._dirObj) {
        this.viewer.camera.direction = Cesium.clone(this._dirObj.direction);
        this.viewer.camera.right = Cesium.clone(this._dirObj.right);
        this.viewer.camera.up = Cesium.clone(this._dirObj.up);
        return;
      }
      this.viewer.camera.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
      this.viewer.camera.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
    }

    //获取四元数

  }, {
    key: "_getOrientation",
    value: function _getOrientation() {
      var cpos = this.cameraPosition;
      var position = this.position;
      var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(position, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
      var camera = new Cesium.Camera(this.viewer.scene);
      camera.position = cpos;
      camera.direction = direction;
      camera.up = up;
      direction = camera.directionWC;
      up = camera.upWC;
      var right = camera.rightWC;
      var scratchRight = new Cesium.Cartesian3();
      var scratchRotation = new Cesium.Matrix3();
      var scratchOrientation = new Cesium.Quaternion();

      // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
      right = Cesium.Cartesian3.negate(right, scratchRight);
      var rotation = scratchRotation;
      Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
      //计算视锥姿态
      var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
      this.orientation = orientation;
      return orientation;
    }
    //创建video元素

  }, {
    key: "_createVideoEle",
    value: function _createVideoEle(src) {
      //创建可视域video DOM  元素
      var source_map4 = document.createElement("SOURCE");
      source_map4.type = "video/mp4";
      source_map4.src = src;

      var source_mov = document.createElement("SOURCE");
      source_mov.type = "video/quicktime";
      source_mov.src = src;

      var videoEle = document.createElement("video");
      videoEle.setAttribute("autoplay", true);
      videoEle.setAttribute("loop", true);
      videoEle.setAttribute("crossorigin", true);
      videoEle.appendChild(source_map4);
      videoEle.appendChild(source_mov);
      videoEle.style.display = "none";
      document.body.appendChild(videoEle);
      return videoEle;
    }

    //获取canvas宽高

  }, {
    key: "_getWinWidHei",
    value: function _getWinWidHei() {
      var scene = this.viewer.scene;
      return scene.canvas.clientWidth / scene.canvas.clientHeight;
    }

    //创建ShadowMap

  }, {
    key: "_createShadowMap",
    value: function _createShadowMap(reset) {
      var camera_pos = this.cameraPosition;
      var lookat_pos = this.position;
      var scene = this.viewer.scene;
      var camera1 = new Cesium.Camera(scene);
      camera1.position = camera_pos;
      if (this._dirObj && !reset) {
        camera1.direction = this._dirObj.direction;
        camera1.right = this._dirObj.right;
        camera1.up = this._dirObj.up;
      } else {
        camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
        camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
        // this._dirObj = {
        //     direction:camera1.direction,
        //     right:camera1.right,
        //     up:camera1.up
        // }
      }

      var far = Cesium.Cartesian3.distance(lookat_pos, camera_pos);
      this.viewDis = far;
      camera1.frustum = new Cesium.PerspectiveFrustum({
        fov: this.fov,
        aspectRatio: this.aspectRatio,
        near: 0.1,
        far: far * 2
      });

      var isSpotLight = true;
      this.viewShadowMap = new Cesium.ShadowMap({
        lightCamera: camera1,
        enable: false,
        isPointLight: !isSpotLight,
        isSpotLight: isSpotLight,
        cascadesEnabled: false,
        context: scene.context,
        pointLightRadius: far
      });
    }

    //添加视椎体

  }, {
    key: "_addCameraFrustum",
    value: function _addCameraFrustum() {
      var that = this;
      this.cameraFrustum = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: new Cesium.FrustumOutlineGeometry({
            origin: that.cameraPosition,
            orientation: that.orientation,
            frustum: this.viewShadowMap._lightCamera.frustum,
            _drawNearPlane: true
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(0.0, 0.5, 0.5))
          }
        }),
        appearance: new Cesium.PerInstanceColorAppearance({
          translucent: false,
          flat: true
        }),
        asynchronous: false,
        show: this.showFrustum && this.show
      });
      this.viewer.scene.primitives.add(this.cameraFrustum);
    }
    //添加后处理

  }, {
    key: "_addPostProcess",
    value: function _addPostProcess() {
      var that = this;
      var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
      if (!this.show) return;
      this.postProcess = new Cesium.PostProcessStage({
        fragmentShader: _Video3D2.default,
        uniforms: {
          mixNum: function mixNum() {
            return that.alpha;
          },
          dasShadow: function dasShadow() {
            return that.viewShadowMap._shadowMapTexture;
          },
          videoTexture: function videoTexture() {
            return that.videoTexture;
          },
          _shadowMap_matrix: function _shadowMap_matrix() {
            return that.viewShadowMap._shadowMapMatrix;
          },
          shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
            return that.viewShadowMap._lightPositionEC;
          },
          shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
            var texelStepSize = new Cesium.Cartesian2();
            texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
            texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
            return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
          },
          shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
            return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
          },
          disViewColor: function disViewColor() {
            return that._disViewColor;
          },
          clearBlack: function clearBlack() {
            return that.clearBlack;
          }
        }
      });
      this.viewer.scene.postProcessStages.add(this.postProcess);
    }
  }, {
    key: "update",
    value: function update(frameState) {
      this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.primitives.remove(this);
      if (!this.viewer) return;

      this.viewer.scene.postProcessStages.remove(this.postProcess);
      this.viewer.scene.primitives.remove(this.cameraFrustum);

      if (this.videoElement) {
        this.videoElement.parentNode.removeChild(this.videoElement);
      }
      this.deActiveVideo();

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "alpha",
    get: function get() {
      return this._alpha;
    },
    set: function set(val) {
      this._alpha = val;
    }

    //相机宽高比例

  }, {
    key: "aspectRatio",
    get: function get() {
      return this._aspectRatio;
    },
    set: function set(val) {
      this._aspectRatio = val;
      this._changeVideoWidHei();
    }
    //视椎体显隐

  }, {
    key: "showFrustum",
    get: function get() {
      return this._debugFrustum;
    },
    set: function set(val) {
      this._debugFrustum = val;
      this.cameraFrustum.show = val;
    }
    //相机水平张角

  }, {
    key: "fov",
    get: function get() {
      return this._camerafov;
    },
    set: function set(val) {
      this._camerafov = Cesium.Math.toRadians(val);
      this._changeCameraFov();
    }
    //相机位置

  }, {
    key: "cameraPosition",
    get: function get() {
      return this._cameraPosition;
    },
    set: function set(pos) {
      if (!pos) return;
      this._cameraPosition = pos;
      this._changeCameraPos();
    }
    //视点位置

  }, {
    key: "position",
    get: function get() {
      return this._position;
    },
    set: function set(pos) {
      if (!pos) return;
      this._position = pos;
      this._changeViewPos();
    }
    //切换视频 播放/暂停

  }, {
    key: "videoPlay",
    get: function get() {
      return this._videoPlay;
    },
    set: function set(val) {
      this._videoPlay = Boolean(val);
      if (this.videoElement) {
        if (this.videoPlay) this.videoElement.play();else this.videoElement.pause();
      }
    }

    /** 所有相机的参数  */

  }, {
    key: "params",
    get: function get() {
      var viewJson = {};
      viewJson.type = this.type;
      if (this.type == Video3DType.Color) viewJson.color = this.color;else viewJson.url = this.url;

      viewJson.position = this.position;
      viewJson.cameraPosition = this.cameraPosition;
      viewJson.fov = Cesium.Math.toDegrees(this.fov);
      viewJson.aspectRatio = this.aspectRatio;
      viewJson.alpha = this.alpha;
      viewJson.showFrustum = this.showFrustum;
      viewJson.dirObj = this._dirObj;
      return viewJson;
    }

    //显示和隐藏

  }, {
    key: "show",
    get: function get() {
      return this.defaultShow;
    },
    set: function set(val) {
      this.defaultShow = Boolean(val);
      this._switchShow();
    }
  }, {
    key: "camera",
    get: function get() {
      return this.viewShadowMap._lightCamera;
    }
    //========== 方法 ==========

  }, {
    key: "disViewColor",
    get: function get() {
      return this._disViewColor;
    },
    set: function set(color) {
      if (!color) return;
      this._disViewColor = color;
      if (!color.a && color.a != 0) {
        this._disViewColor.a = 1.0;
      }
    }
  }]);

  return Video3D;
}();

Video3D.Type = Video3DType;

/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = "\r\n\r\n\r\n\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D dasShadow; \r\nuniform sampler2D videoTexture;\r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nuniform vec4 disViewColor;\r\nuniform bool clearBlack;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(dasShadow, shadowParameters); \r\n\r\n    vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);\r\n    if(clearBlack){\r\n        if(videoColor.r + videoColor.g + videoColor.b <0.01){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n    }\r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);\r\n    }else{\r\n        if(abs(shadowPosition.z-0.0)<0.01){\r\n            return;\r\n        }\r\n        if(clearBlack){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n        gl_FragColor = vec4(mix(color.rgb,disViewColor.rgb,disViewColor.a),disViewColor.a);\r\n    }\r\n} "

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Video2D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cesium = __webpack_require__(0);

var Cesium = _interopRequireWildcard(_cesium);

var _DasClass2 = __webpack_require__(1);

var _log = __webpack_require__(5);

var daslog = _interopRequireWildcard(_log);

var _util = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ratateDirection = {
  LEFT: "Z",
  RIGHT: "-Z",
  TOP: "Y",
  BOTTOM: "-Y",
  ALONG: "X",
  INVERSE: "-X"
};

//视频融合（投射2D平面）
//原理：根据相机位置，方向等参数，在相机前面生成一个平面，然后贴视频纹理

var Video2D = exports.Video2D = function (_DasClass) {
  _inherits(Video2D, _DasClass);

  //========== 构造方法 ==========
  function Video2D(viewer, options, oldparam) {
    _classCallCheck(this, Video2D);

    //兼容v2.2之前旧版本处理,非升级用户可删除下面代码
    var _this = _possibleConstructorReturn(this, (Video2D.__proto__ || Object.getPrototypeOf(Video2D)).call(this, options));

    if (oldparam) {
      oldparam.dom = options;
      options = oldparam;
    }
    if (Cesium.defined(options.frustumShow)) options.showFrustum = options.frustumShow;
    _this.frustumShow = _this.showFrustum;
    //兼容v2.2之前旧版本处理,非升级用户可删除上面代码

    _this.viewer = viewer;
    _this.options = options;

    _this._play = true;
    if (options.aspectRatio) {
      _this._aspectRatio = options.aspectRatio;
    } else {
      _this._aspectRatio = _this.viewer.scene.context.drawingBufferWidth / _this.viewer.scene.context.drawingBufferHeight;
    }

    _this._fov = Cesium.defaultValue(options.fov, _this.viewer.scene.camera.frustum.fov);
    _this._dis = Cesium.defaultValue(options.dis, 10);
    _this._stRotation = Cesium.defaultValue(options.stRotation, 0);
    _this._rotateCam = Cesium.defaultValue(options.rotateCam, 0.05);
    _this._frustumShow = Cesium.defaultValue(options.showFrustum, true);

    _this._camera = options.camera;

    //传入了DOM
    if (options.dom) {
      if (options.dom instanceof Object && options.dom.length) {
        _this.dom = options.dom[0];
      } else {
        _this.dom = options.dom;
      }
    }

    //兼容直接传入单击回调方法，适合简单场景下使用。
    if (options.click) {
      _this.on(_DasClass2.eventType.click, options.click);
    }

    _this.init();
    return _this;
  }

  //视频播放暂停


  _createClass(Video2D, [{
    key: "init",
    value: function init() {
      this.recordObj = this.record();
      this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
      var sys = this.getOrientation(this.recordObj);
      var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
      var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
      this.frustumPri = this.createFrustumPri(frustumGeo);
      this.addToScene();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.viewer.scene.primitives.remove(this.frustumPri);
      this.viewer.entities.remove(this.entity);

      this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
      var sys = this.getOrientation(this.recordObj);
      var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
      var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
      this.frustumPri = this.createFrustumPri(frustumGeo);
      this.addToScene();
    }
  }, {
    key: "record",
    value: function record() {
      var obj = {};
      var camera = this._camera || this.viewer.scene.camera;
      obj.direction = Cesium.clone(camera.direction);
      obj.up = Cesium.clone(camera.up);
      obj.right = Cesium.clone(camera.right);
      obj.position = Cesium.clone(camera.position);
      return obj;
    }
  }, {
    key: "addToScene",
    value: function addToScene() {
      this.viewer.scene.primitives.add(this.frustumPri);
      this.entity = this.viewer.entities.add(new Cesium.Entity({
        polygon: {
          hierarchy: this.rectPos,
          perPositionHeight: true,
          material: this.dom || this.options.material,
          stRotation: this.stRotation
        }
      }));

      //das3d扩展的属性
      this.entity.data = this.options;
      this.entity.eventTarget = this;
      this.entity.popup = this.options.popup;
      this.entity.tooltip = this.options.tooltip;
    }
  }, {
    key: "computedPos",
    value: function computedPos(dis, fov, kgb, camera) {
      var vpos = camera.position;
      var vdir = camera.direction;
      var vright = camera.right;
      var vup = camera.up;

      var vray = new Cesium.Ray(vpos, vdir);
      var vmbpos = Cesium.Ray.getPoint(vray, dis, new Cesium.Cartesian3());
      var halfFov = fov / 2.0;
      var tanres = Math.tan(halfFov);
      var horiDis = dis * tanres;
      var vertDis = horiDis / kgb;
      var xbDis = Math.sqrt(horiDis * horiDis + vertDis * vertDis);

      var ysj = new Cesium.Cartesian3();
      var rightRay = new Cesium.Ray(vmbpos, vright);
      var rightPos = Cesium.Ray.getPoint(rightRay, horiDis, new Cesium.Cartesian3());
      var upRay = new Cesium.Ray(rightPos, vup);
      Cesium.Ray.getPoint(upRay, vertDis, ysj);

      var yxj = new Cesium.Cartesian3();
      var fvup = Cesium.Cartesian3.negate(vup, new Cesium.Cartesian3());
      var fupRay = new Cesium.Ray(rightPos, fvup);
      Cesium.Ray.getPoint(fupRay, vertDis, yxj);

      var zxj = new Cesium.Cartesian3();
      var djdir1 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, ysj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var djRay1 = new Cesium.Ray(vmbpos, djdir1);
      Cesium.Ray.getPoint(djRay1, xbDis, zxj);

      var zsj = new Cesium.Cartesian3();
      var djdir2 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, yxj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      var djRay2 = new Cesium.Ray(vmbpos, djdir2);
      Cesium.Ray.getPoint(djRay2, xbDis, zsj);

      if (this.options.reverse) {
        return [zxj, zsj, ysj, yxj].reverse();
      }
      return [zxj, zsj, ysj, yxj];
    }
  }, {
    key: "createFrustum",
    value: function createFrustum(fov, kgb, dis) {
      return new Cesium.PerspectiveFrustum({
        fov: fov,
        aspectRatio: kgb,
        near: 0.1,
        far: dis
      });
    }
  }, {
    key: "getOrientation",
    value: function getOrientation(camera) {
      if (!camera) return;
      var direction = camera.direction;
      var up = camera.up;
      var right = camera.right;
      var scratchRight = new Cesium.Cartesian3();
      var scratchRotation = new Cesium.Matrix3();
      var scratchOrientation = new Cesium.Quaternion();

      // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
      right = Cesium.Cartesian3.negate(right, scratchRight);
      var rotation = scratchRotation;
      Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
      //计算视锥姿态
      var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
      return orientation;
    }
  }, {
    key: "createFrustumGeo",
    value: function createFrustumGeo(frustum, sys, origin) {
      return new Cesium.FrustumOutlineGeometry({
        frustum: frustum,
        orientation: sys,
        origin: origin
      });
    }
  }, {
    key: "createFrustumPri",
    value: function createFrustumPri(geo) {
      return new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: geo,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AZURE)
          }
        }),
        appearance: new Cesium.PerInstanceColorAppearance({
          flat: true
        }),
        show: this.showFrustum
      });
    }
    /**
     * 呈现投影相机的第一视角
     */

  }, {
    key: "locate",
    value: function locate() {
      this.viewer.camera.direction = Cesium.clone(this.recordObj.direction);
      this.viewer.camera.right = Cesium.clone(this.recordObj.right);
      this.viewer.camera.up = Cesium.clone(this.recordObj.up);
      this.viewer.camera.position = Cesium.clone(this.recordObj.position);
    }

    //旋转相机

  }, {
    key: "rotateCamera",
    value: function rotateCamera(axis, deg) {
      var rotateDegree = Cesium.defaultValue(deg, this._rotateCam);
      switch (axis) {
        case ratateDirection.LEFT:
          break;
        case ratateDirection.RIGHT:
          rotateDegree *= -1;
          break;
        case ratateDirection.TOP:
          break;
        case ratateDirection.BOTTOM:
          rotateDegree *= -1;
          break;
        case ratateDirection.ALONG:
          break;
        case ratateDirection.INVERSE:
          rotateDegree *= -1;
          break;
      }
      var newObj = this._computedNewViewDir(axis, rotateDegree);
      this.recordObj.direction = newObj.direction;
      this.recordObj.up = newObj.up;
      this.recordObj.right = newObj.right;
      this.reset();
    }

    //计算新视点

  }, {
    key: "_computedNewViewDir",
    value: function _computedNewViewDir(axis, deg) {
      deg = Cesium.Math.toRadians(deg);
      var camera = this.recordObj;
      var oldDir = Cesium.clone(camera.direction);
      var oldRight = Cesium.clone(camera.right);
      var oldTop = Cesium.clone(camera.up);
      var mat3 = new Cesium.Matrix3();

      switch (axis) {
        case ratateDirection.LEFT:
          Cesium.Matrix3.fromRotationZ(deg, mat3);
          break;
        case ratateDirection.RIGHT:
          Cesium.Matrix3.fromRotationZ(deg, mat3);
          break;
        case ratateDirection.TOP:
          Cesium.Matrix3.fromRotationY(deg, mat3);
          break;
        case ratateDirection.BOTTOM:
          Cesium.Matrix3.fromRotationY(deg, mat3);
          break;
        case ratateDirection.ALONG:
          Cesium.Matrix3.fromRotationX(deg, mat3);
          break;
        case ratateDirection.INVERSE:
          Cesium.Matrix3.fromRotationX(deg, mat3);
          break;
      }
      var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
      // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
      // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
      var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

      var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
      var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
      var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

      var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
      var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
      var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

      var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
      var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
      var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
      return {
        direction: newDir,
        right: newRight,
        up: newTop
      };
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.viewer.scene.primitives.remove(this.frustumPri);
      this.viewer.entities.remove(this.entity);

      //删除所有绑定的数据
      for (var i in this) {
        delete this[i];
      }
    }
  }, {
    key: "play",
    get: function get() {
      return this._play;
    },
    set: function set(val) {
      this._play = val;
      if (!this.dom) return;

      if (this._play) {
        this.dom.play();
      } else {
        this.dom.pause();
      }
    }
    //宽高比

  }, {
    key: "aspectRatio",
    get: function get() {
      return this._aspectRatio;
    },
    set: function set(val) {
      val = Number(val);
      if (!val || val < 0) return;
      if (val < 1.0) val = 1.0;
      this._aspectRatio = val;
      this.reset();
    }
    //张角

  }, {
    key: "fov",
    get: function get() {
      return this._fov;
    },
    set: function set(val) {
      val = Number(val);
      if (!val || val < 0) return;
      this._fov = val;
      this.reset();
    }
    //投射距离

  }, {
    key: "dis",
    get: function get() {
      return this._dis;
    },
    set: function set(val) {
      val = Number(val);
      if (!val || val < 0) return;
      this._dis = val;
      this.reset();
    }

    //UV旋转

  }, {
    key: "stRotation",
    get: function get() {
      return this._stRotation;
    },
    set: function set(val) {
      val = Number(val);
      if (!val || val < 0) return;
      this._stRotation = val;
      this.entity.polygon.stRotation = val;
    }

    //视椎体显示

  }, {
    key: "showFrustum",
    get: function get() {
      return this._frustumShow;
    },
    set: function set(val) {
      this._frustumShow = val;
      this.frustumPri.show = val;
    }

    /** 所有相机的参数  */

  }, {
    key: "params",
    get: function get() {
      var viewJson = {
        fov: this.fov,
        dis: this.dis,
        stRotation: this.stRotation,
        showFrustum: this.showFrustum,
        aspectRatio: this.aspectRatio,
        camera: {
          position: this.recordObj.position,
          direction: this.recordObj.direction,
          up: this.recordObj.up,
          right: this.recordObj.right
        }
      };
      return viewJson;
    }
  }]);

  return Video2D;
}(_DasClass2.DasClass);

//[静态属性]本类中支持的事件类型常量


Video2D.event = {
  click: _DasClass2.eventType.click,
  mouseOver: _DasClass2.eventType.mouseOver,
  mouseOut: _DasClass2.eventType.mouseOut
};

/***/ })
/******/ ]);
});
